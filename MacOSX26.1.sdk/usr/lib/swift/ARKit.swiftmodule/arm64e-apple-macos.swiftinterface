// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 effective-5.10 (swiftlang-6.2.1.4.7 clang-1700.4.4.1)
// swift-module-flags: -target arm64e-apple-macos26.1 -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftARKit -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-upcoming-feature StrictConcurrency -enable-upcoming-feature MemberImportVisibility -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 746.0.0.0.1 -module-name ARKit
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.1
@_exported import ARKit
import Foundation
import Network
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import simd
@available(visionOS 1.0, macOS 26.0, *)
public protocol Anchor : Swift.CustomStringConvertible, Swift.Identifiable, Swift.Sendable {
  var id: Foundation.UUID { get }
  var originFromAnchorTransform: simd.simd_float4x4 { get }
  @available(visionOS 2.0, *)
  var timestamp: Foundation.TimeInterval { get }
}
extension ARKit.Anchor {
  @available(visionOS 2.0, macOS 26.0, *)
  public var timestamp: Foundation.TimeInterval {
    get
  }
}
@available(visionOS 1.0, macOS 26.0, *)
public protocol TrackableAnchor : ARKit.Anchor {
  var isTracked: Swift.Bool { get }
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
public struct AnchorUpdate<AnchorType> : Swift.CustomStringConvertible, @unchecked Swift.Sendable where AnchorType : ARKit.Anchor {
  @frozen public enum Event : Swift.CustomStringConvertible, Swift.Sendable {
    case added
    case updated
    case removed
    public var description: Swift.String {
      get
    }
    public static func == (a: ARKit.AnchorUpdate<AnchorType>.Event, b: ARKit.AnchorUpdate<AnchorType>.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let event: ARKit.AnchorUpdate<AnchorType>.Event
  public let anchor: AnchorType
  public var timestamp: Foundation.TimeInterval {
    get
  }
  public var description: Swift.String {
    get
  }
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
public struct AnchorUpdateSequence<AnchorType> : _Concurrency.AsyncSequence where AnchorType : ARKit.Anchor {
  public typealias Element = ARKit.AnchorUpdate<AnchorType>
  public func makeAsyncIterator() -> ARKit.AnchorUpdateSequence<AnchorType>.Iterator<AnchorType>
  public struct Iterator<TypeOfAnchor> : _Concurrency.AsyncIteratorProtocol, @unchecked Swift.Sendable where TypeOfAnchor : ARKit.Anchor {
    public typealias Element = ARKit.AnchorUpdate<TypeOfAnchor>
    #if compiler(>=5.3) && $NonescapableTypes
    public mutating func next() async -> ARKit.AnchorUpdateSequence<AnchorType>.Iterator<TypeOfAnchor>.Element?
    #endif
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    @available(macOS, unavailable, introduced: 15.0)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
  }
  @available(visionOS 1.0, *)
  @available(macOS, unavailable)
  public typealias AsyncIterator = ARKit.AnchorUpdateSequence<AnchorType>.Iterator<AnchorType>
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @available(macOS, unavailable, introduced: 15.0)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
}
@available(visionOS 1.0, macOS 26.0, *)
final public class ARKitSession : Swift.CustomStringConvertible, @unchecked Swift.Sendable {
  public struct Error : Foundation.LocalizedError, Swift.CustomStringConvertible, @unchecked Swift.Sendable {
    public let dataProvider: (any ARKit.DataProvider)?
    public enum Code : Swift.CustomStringConvertible {
      @available(macOS, unavailable)
      case dataProviderNotAuthorized
      case dataProviderFailedToRun
      public var description: Swift.String {
        get
      }
      public static func == (a: ARKit.ARKitSession.Error.Code, b: ARKit.ARKitSession.Error.Code) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public var failureReason: Swift.String? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var recoverySuggestion: Swift.String? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var errorDescription: Swift.String? {
      get
    }
    #endif
    public var code: ARKit.ARKitSession.Error.Code {
      get
    }
    public var description: Swift.String {
      get
    }
  }
  @available(visionOS 26.0, macOS 26.0, *)
  final public var dataProviders: [any ARKit.DataProvider] {
    get
  }
  final public func run(_ dataProviders: [any ARKit.DataProvider]) async throws
  final public func stop()
  public enum Event : Swift.CustomStringConvertible, Swift.Sendable {
    @available(macOS, unavailable)
    case authorizationChanged(type: ARKit.ARKitSession.AuthorizationType, status: ARKit.ARKitSession.AuthorizationStatus)
    case dataProviderStateChanged(dataProviders: [any ARKit.DataProvider], newState: ARKit.DataProviderState, error: ARKit.ARKitSession.Error?)
    public var description: Swift.String {
      get
    }
  }
  final public var events: ARKit.ARKitSession.Events {
    get
  }
  public struct Events : _Concurrency.AsyncSequence {
    public typealias Element = ARKit.ARKitSession.Event
    public func makeAsyncIterator() -> ARKit.ARKitSession.Events.Iterator
    public struct Iterator : _Concurrency.AsyncIteratorProtocol {
      #if compiler(>=5.3) && $NonescapableTypes
      public mutating func next() async -> ARKit.ARKitSession.Events.Element?
      #endif
      @available(visionOS 1.0, macOS 26.0, *)
      public typealias Element = ARKit.ARKitSession.Events.Element
      @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 26.0, *)
      @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    }
    @available(visionOS 1.0, macOS 26.0, *)
    public typealias AsyncIterator = ARKit.ARKitSession.Events.Iterator
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 26.0, *)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  }
  @available(macOS, unavailable)
  convenience public init()
  @objc deinit
  @available(macOS, unavailable)
  final public func queryAuthorization(for authorizationTypes: [ARKit.ARKitSession.AuthorizationType]) async -> [ARKit.ARKitSession.AuthorizationType : ARKit.ARKitSession.AuthorizationStatus]
  @available(macOS, unavailable)
  final public func requestAuthorization(for authorizationTypes: [ARKit.ARKitSession.AuthorizationType]) async -> [ARKit.ARKitSession.AuthorizationType : ARKit.ARKitSession.AuthorizationStatus]
  public enum AuthorizationType : Swift.CustomStringConvertible, Swift.Sendable {
    case handTracking
    case worldSensing
    @available(visionOS 2.0, *)
    case cameraAccess
    public var description: Swift.String {
      get
    }
    public static func == (a: ARKit.ARKitSession.AuthorizationType, b: ARKit.ARKitSession.AuthorizationType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS, unavailable)
  public enum AuthorizationStatus : Swift.CustomStringConvertible, Swift.Sendable {
    case notDetermined
    case allowed
    case denied
    public var description: Swift.String {
      get
    }
    public static func == (a: ARKit.ARKitSession.AuthorizationStatus, b: ARKit.ARKitSession.AuthorizationStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public var description: Swift.String {
    get
  }
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
final public class BarcodeDetectionProvider : ARKit.DataProvider, @unchecked Swift.Sendable {
  public init(symbologies: [ARKit.BarcodeAnchor.Symbology])
  final public var anchorUpdates: ARKit.AnchorUpdateSequence<ARKit.BarcodeAnchor> {
    get
  }
  final public var state: ARKit.DataProviderState {
    get
  }
  public static var isSupported: Swift.Bool {
    get
  }
  public static var requiredAuthorizations: [ARKit.ARKitSession.AuthorizationType] {
    get
  }
  @objc deinit
  final public var description: Swift.String {
    get
  }
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
public struct BarcodeAnchor : ARKit.Anchor, @unchecked Swift.Sendable {
  public enum Symbology : Swift.CustomStringConvertible, Swift.Sendable {
    case aztec
    case codabar
    case code39
    case code39Checksum
    case code39FullAscii
    case code39FullAsciiChecksum
    case code93
    case code93i
    case code128
    case dataMatrix
    case ean8
    case ean13
    case gs1DataBar
    case gs1DataBarExpanded
    case gs1DataBarLimited
    case itf
    case itf14
    case itfChecksum
    case microPDF417
    case microQR
    case msiPlessey
    case pdf417
    case qr
    case upce
    public var description: Swift.String {
      get
    }
    public static func == (a: ARKit.BarcodeAnchor.Symbology, b: ARKit.BarcodeAnchor.Symbology) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var symbology: ARKit.BarcodeAnchor.Symbology {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var payloadString: Swift.String? {
    get
  }
  #endif
  public var payloadData: Foundation.Data {
    get
  }
  public var extent: Swift.SIMD3<Swift.Float> {
    get
  }
  public var id: Foundation.UUID {
    get
  }
  public var originFromAnchorTransform: simd.simd_float4x4 {
    get
  }
  public var description: Swift.String {
    get
  }
  @available(visionOS 2.0, *)
  @available(macOS, unavailable)
  public typealias ID = Foundation.UUID
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
final public class CameraFrameProvider : ARKit.DataProvider, @unchecked Swift.Sendable {
  public enum CameraType : Swift.CustomStringConvertible, Swift.Sendable {
    case main
    public var description: Swift.String {
      get
    }
    public static func == (a: ARKit.CameraFrameProvider.CameraType, b: ARKit.CameraFrameProvider.CameraType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum CameraPosition : Swift.CustomStringConvertible, Swift.Sendable {
    case left
    @available(visionOS 26.0, *)
    case right
    public var description: Swift.String {
      get
    }
    public static func == (a: ARKit.CameraFrameProvider.CameraPosition, b: ARKit.CameraFrameProvider.CameraPosition) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(visionOS 26.0, *)
  public enum CameraRectification : Swift.CustomStringConvertible, Swift.Sendable {
    case mono
    case stereoCorrected
    public var description: Swift.String {
      get
    }
    public static func == (a: ARKit.CameraFrameProvider.CameraRectification, b: ARKit.CameraFrameProvider.CameraRectification) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init()
  @objc deinit
  #if compiler(>=5.3) && $NonescapableTypes
  final public func cameraFrameUpdates(for cameraVideoFormat: ARKit.CameraVideoFormat) -> ARKit.CameraFrameProvider.CameraFrameUpdates?
  #endif
  public struct CameraFrameUpdates : _Concurrency.AsyncSequence {
    public typealias Element = ARKit.CameraFrame
    public func makeAsyncIterator() -> ARKit.CameraFrameProvider.CameraFrameUpdates.Iterator
    public struct Iterator : _Concurrency.AsyncIteratorProtocol {
      #if compiler(>=5.3) && $NonescapableTypes
      public mutating func next() async -> ARKit.CameraFrameProvider.CameraFrameUpdates.Element?
      #endif
      @available(visionOS 2.0, *)
      @available(macOS, unavailable)
      public typealias Element = ARKit.CameraFrameProvider.CameraFrameUpdates.Element
      @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
      @available(macOS, unavailable, introduced: 15.0)
      @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    }
    @available(visionOS 2.0, *)
    @available(macOS, unavailable)
    public typealias AsyncIterator = ARKit.CameraFrameProvider.CameraFrameUpdates.Iterator
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    @available(macOS, unavailable, introduced: 15.0)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  }
  public static var isSupported: Swift.Bool {
    get
  }
  public static var requiredAuthorizations: [ARKit.ARKitSession.AuthorizationType] {
    get
  }
  final public var state: ARKit.DataProviderState {
    get
  }
  final public var description: Swift.String {
    get
  }
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
public struct CameraVideoFormat : @unchecked Swift.Sendable, Swift.CustomStringConvertible, Swift.Equatable, Swift.Hashable {
  public var minFrameDuration: Swift.Float {
    get
  }
  public var maxFrameDuration: Swift.Float {
    get
  }
  public var frameSize: CoreFoundation.CGSize {
    get
  }
  public var pixelFormat: Darwin.OSType {
    get
  }
  public var cameraType: ARKit.CameraFrameProvider.CameraType {
    get
  }
  public var cameraPositions: [ARKit.CameraFrameProvider.CameraPosition] {
    get
  }
  @available(visionOS 26.0, *)
  public var cameraRectification: ARKit.CameraFrameProvider.CameraRectification {
    get
  }
  public var description: Swift.String {
    get
  }
  public static func == (lhs: ARKit.CameraVideoFormat, rhs: ARKit.CameraVideoFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func supportedVideoFormats(for cameraType: ARKit.CameraFrameProvider.CameraType, cameraPositions: [ARKit.CameraFrameProvider.CameraPosition]) -> [ARKit.CameraVideoFormat]
  public var hashValue: Swift.Int {
    get
  }
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
public struct CameraFrame : @unchecked Swift.Sendable, Swift.CustomStringConvertible, Swift.Equatable {
  public static func == (lhs: ARKit.CameraFrame, rhs: ARKit.CameraFrame) -> Swift.Bool
  public struct Sample : @unchecked Swift.Sendable, Swift.CustomStringConvertible, Swift.Equatable {
    public static func == (lhs: ARKit.CameraFrame.Sample, rhs: ARKit.CameraFrame.Sample) -> Swift.Bool
    public struct Parameters : @unchecked Swift.Sendable, Swift.CustomStringConvertible, Swift.Equatable {
      public static func == (lhs: ARKit.CameraFrame.Sample.Parameters, rhs: ARKit.CameraFrame.Sample.Parameters) -> Swift.Bool
      public var intrinsics: simd.simd_float3x3 {
        get
      }
      public var extrinsics: simd.simd_float4x4 {
        get
      }
      public var captureTimestamp: Foundation.TimeInterval {
        get
      }
      public var midExposureTimestamp: Foundation.TimeInterval {
        get
      }
      public var colorTemperature: Swift.Int {
        get
      }
      public var exposureDuration: Foundation.TimeInterval {
        get
      }
      public var cameraType: ARKit.CameraFrameProvider.CameraType {
        get
      }
      public var cameraPosition: ARKit.CameraFrameProvider.CameraPosition {
        get
      }
      public var description: Swift.String {
        get
      }
    }
    @available(visionOS, introduced: 2.0, deprecated: 26.0, renamed: "buffer")
    public var pixelBuffer: CoreVideo.CVPixelBuffer {
      get
    }
    @available(visionOS 26.0, *)
    public var buffer: CoreVideo.CVReadOnlyPixelBuffer {
      get
    }
    public var parameters: ARKit.CameraFrame.Sample.Parameters {
      get
    }
    public var description: Swift.String {
      get
    }
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public func sample(for position: ARKit.CameraFrameProvider.CameraPosition) -> ARKit.CameraFrame.Sample?
  #endif
  public var primarySample: ARKit.CameraFrame.Sample {
    get
  }
  @available(visionOS 26.0, *)
  public var samples: [ARKit.CameraFrame.Sample] {
    get
  }
  public var description: Swift.String {
    get
  }
}
@available(visionOS 1.0, macOS 26.0, *)
public protocol DataProvider : AnyObject, Swift.CustomStringConvertible, Swift.Sendable {
  static var isSupported: Swift.Bool { get }
  static var requiredAuthorizations: [ARKit.ARKitSession.AuthorizationType] { get }
  var state: ARKit.DataProviderState { get }
}
@available(visionOS 1.0, macOS 26.0, *)
public enum DataProviderState : Swift.CustomStringConvertible, Swift.Sendable {
  case initialized
  case paused
  case running
  case stopped
  public var description: Swift.String {
    get
  }
  public static func == (a: ARKit.DataProviderState, b: ARKit.DataProviderState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(visionOS 1.0, macOS 26.0, *)
public struct DeviceAnchor : ARKit.TrackableAnchor, @unchecked Swift.Sendable {
  public var id: Foundation.UUID {
    get
  }
  public var originFromAnchorTransform: simd.simd_float4x4 {
    get
  }
  public var isTracked: Swift.Bool {
    get
  }
  @available(visionOS 2.0, *)
  public var trackingState: ARKit.DeviceAnchor.TrackingState {
    get
  }
  public var description: Swift.String {
    get
  }
  @available(visionOS 2.0, *)
  public enum TrackingState : Swift.CustomStringConvertible, Swift.Sendable {
    case untracked
    case orientationTracked
    case tracked
    public var description: Swift.String {
      get
    }
    public static func == (a: ARKit.DeviceAnchor.TrackingState, b: ARKit.DeviceAnchor.TrackingState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(visionOS 1.0, macOS 26.0, *)
  public typealias ID = Foundation.UUID
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
public struct EnvironmentProbeAnchor : ARKit.Anchor, @unchecked Swift.Sendable, Swift.Equatable {
  @available(visionOS 2.0, *)
  public static func == (lhs: ARKit.EnvironmentProbeAnchor, rhs: ARKit.EnvironmentProbeAnchor) -> Swift.Bool
  public var id: Foundation.UUID {
    get
  }
  public var originFromAnchorTransform: simd.simd_float4x4 {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var environmentTexture: (any Metal.MTLTexture)? {
    get
  }
  #endif
  @available(visionOS 2.0, *)
  public var cameraScaleReference: Swift.Float {
    get
  }
  public var description: Swift.String {
    get
  }
  @available(visionOS 2.0, *)
  @available(macOS, unavailable)
  public typealias ID = Foundation.UUID
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
final public class EnvironmentLightEstimationProvider : ARKit.DataProvider, @unchecked Swift.Sendable {
  @available(visionOS 2.0, *)
  convenience public init()
  @objc deinit
  final public var state: ARKit.DataProviderState {
    get
  }
  public static var isSupported: Swift.Bool {
    get
  }
  public static var requiredAuthorizations: [ARKit.ARKitSession.AuthorizationType] {
    get
  }
  final public var anchorUpdates: ARKit.AnchorUpdateSequence<ARKit.EnvironmentProbeAnchor> {
    get
  }
  final public var description: Swift.String {
    get
  }
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
public struct GeometryElement : Swift.CustomStringConvertible, @unchecked Swift.Sendable {
  public enum Primitive : Swift.CustomStringConvertible, Swift.Sendable {
    case line
    case triangle
    public var indexCount: Swift.Int {
      get
    }
    public var description: Swift.String {
      get
    }
    public static func == (a: ARKit.GeometryElement.Primitive, b: ARKit.GeometryElement.Primitive) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var buffer: any Metal.MTLBuffer {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var bytesPerIndex: Swift.Int {
    get
  }
  public var primitive: ARKit.GeometryElement.Primitive {
    get
  }
  public var description: Swift.String {
    get
  }
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
public struct GeometrySource : Swift.CustomStringConvertible, @unchecked Swift.Sendable {
  public var buffer: any Metal.MTLBuffer {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var format: Metal.MTLVertexFormat {
    get
  }
  public var componentsPerVector: Swift.Int {
    get
  }
  public var offset: Swift.Int {
    get
  }
  public var stride: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.GeometrySource : Swift.Equatable {
  public static func == (lhs: ARKit.GeometrySource, rhs: ARKit.GeometrySource) -> Swift.Bool
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.GeometryElement : Swift.Equatable {
  public static func == (lhs: ARKit.GeometryElement, rhs: ARKit.GeometryElement) -> Swift.Bool
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
public struct HandSkeleton : Swift.CustomStringConvertible, @unchecked Swift.Sendable {
  public static var neutralPose: ARKit.HandSkeleton {
    get
  }
  public func joint(_ named: ARKit.HandSkeleton.JointName) -> ARKit.HandSkeleton.Joint
  public var description: Swift.String {
    get
  }
  public var allJoints: [ARKit.HandSkeleton.Joint] {
    get
  }
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.HandSkeleton : Swift.Equatable {
  public static func == (lhs: ARKit.HandSkeleton, rhs: ARKit.HandSkeleton) -> Swift.Bool
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.HandSkeleton {
  @available(visionOS 1.0, *)
  public struct Joint : Swift.CustomStringConvertible, @unchecked Swift.Sendable {
    #if compiler(>=5.3) && $NonescapableTypes
    public var parentJoint: ARKit.HandSkeleton.Joint? {
      get
    }
    #endif
    public var name: ARKit.HandSkeleton.JointName {
      get
    }
    public var parentFromJointTransform: simd.simd_float4x4 {
      get
    }
    public var anchorFromJointTransform: simd.simd_float4x4 {
      get
    }
    public var isTracked: Swift.Bool {
      get
    }
    public var description: Swift.String {
      get
    }
  }
  @available(visionOS 1.0, *)
  public enum JointName : Swift.CaseIterable, Swift.CustomStringConvertible, Swift.Hashable, @unchecked Swift.Sendable {
    case wrist
    case thumbKnuckle
    case thumbIntermediateBase
    case thumbIntermediateTip
    case thumbTip
    case indexFingerMetacarpal
    case indexFingerKnuckle
    case indexFingerIntermediateBase
    case indexFingerIntermediateTip
    case indexFingerTip
    case middleFingerMetacarpal
    case middleFingerKnuckle
    case middleFingerIntermediateBase
    case middleFingerIntermediateTip
    case middleFingerTip
    case ringFingerMetacarpal
    case ringFingerKnuckle
    case ringFingerIntermediateBase
    case ringFingerIntermediateTip
    case ringFingerTip
    case littleFingerMetacarpal
    case littleFingerKnuckle
    case littleFingerIntermediateBase
    case littleFingerIntermediateTip
    case littleFingerTip
    case forearmWrist
    case forearmArm
    public var description: Swift.String {
      get
    }
    public static func == (a: ARKit.HandSkeleton.JointName, b: ARKit.HandSkeleton.JointName) -> Swift.Bool
    @available(visionOS 1.0, *)
    @available(macOS, unavailable)
    public typealias AllCases = [ARKit.HandSkeleton.JointName]
    nonisolated public static var allCases: [ARKit.HandSkeleton.JointName] {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.HandSkeleton.Joint : Swift.Equatable {
  public static func == (lhs: ARKit.HandSkeleton.Joint, rhs: ARKit.HandSkeleton.Joint) -> Swift.Bool
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
final public class HandTrackingProvider : ARKit.DataProvider, @unchecked Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  final public var latestAnchors: (leftHand: ARKit.HandAnchor?, rightHand: ARKit.HandAnchor?) {
    get
  }
  #endif
  final public var state: ARKit.DataProviderState {
    get
  }
  public init()
  public static var isSupported: Swift.Bool {
    get
  }
  public static var requiredAuthorizations: [ARKit.ARKitSession.AuthorizationType] {
    get
  }
  @objc deinit
  final public var anchorUpdates: ARKit.AnchorUpdateSequence<ARKit.HandAnchor> {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(visionOS 2.0, *)
  final public func handAnchors(at timestamp: Foundation.TimeInterval) -> (leftHand: ARKit.HandAnchor?, rightHand: ARKit.HandAnchor?)
  #endif
  final public var description: Swift.String {
    get
  }
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
public struct HandAnchor : ARKit.TrackableAnchor, @unchecked Swift.Sendable {
  @frozen public enum Chirality : Swift.CustomStringConvertible, Swift.Sendable {
    case right
    case left
    public var description: Swift.String {
      get
    }
    public static func == (a: ARKit.HandAnchor.Chirality, b: ARKit.HandAnchor.Chirality) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(visionOS 26.0, *)
  public enum Fidelity : Swift.CustomStringConvertible, Swift.Sendable {
    case nominal
    case high
    public var description: Swift.String {
      get
    }
    public static func == (a: ARKit.HandAnchor.Fidelity, b: ARKit.HandAnchor.Fidelity) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var id: Foundation.UUID {
    get
  }
  public var originFromAnchorTransform: simd.simd_float4x4 {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var handSkeleton: ARKit.HandSkeleton? {
    get
  }
  #endif
  public var chirality: ARKit.HandAnchor.Chirality {
    get
  }
  @available(visionOS 26.0, *)
  public var fidelity: ARKit.HandAnchor.Fidelity {
    get
  }
  public var isTracked: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
  @available(visionOS 1.0, *)
  @available(macOS, unavailable)
  public typealias ID = Foundation.UUID
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.HandAnchor : Swift.Equatable {
  public static func == (lhs: ARKit.HandAnchor, rhs: ARKit.HandAnchor) -> Swift.Bool
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
final public class ImageTrackingProvider : ARKit.DataProvider, @unchecked Swift.Sendable {
  final public var state: ARKit.DataProviderState {
    get
  }
  public init(referenceImages: [ARKit.ReferenceImage])
  @available(visionOS 2.0, *)
  final public var allAnchors: [ARKit.ImageAnchor] {
    get
  }
  public static var isSupported: Swift.Bool {
    get
  }
  public static var requiredAuthorizations: [ARKit.ARKitSession.AuthorizationType] {
    get
  }
  @objc deinit
  final public var anchorUpdates: ARKit.AnchorUpdateSequence<ARKit.ImageAnchor> {
    get
  }
  final public var description: Swift.String {
    get
  }
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
public struct ImageAnchor : ARKit.TrackableAnchor, @unchecked Swift.Sendable {
  public var id: Foundation.UUID {
    get
  }
  public var originFromAnchorTransform: simd.simd_float4x4 {
    get
  }
  public var estimatedScaleFactor: Swift.Float {
    get
  }
  public var isTracked: Swift.Bool {
    get
  }
  public var referenceImage: ARKit.ReferenceImage {
    get
  }
  public var description: Swift.String {
    get
  }
  @available(visionOS 1.0, *)
  @available(macOS, unavailable)
  public typealias ID = Foundation.UUID
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.ImageAnchor : Swift.Equatable {
  public static func == (lhs: ARKit.ImageAnchor, rhs: ARKit.ImageAnchor) -> Swift.Bool
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
public struct MeshAnchor : ARKit.Anchor, @unchecked Swift.Sendable {
  @available(visionOS, introduced: 1.0, deprecated: 26.0, renamed: "SurfaceClassification")
  public enum MeshClassification : ObjectiveC.NSInteger, Swift.Sendable {
    case none
    case wall
    case floor
    case ceiling
    case table
    case seat
    case window
    case door
    case stairs
    case bed
    case cabinet
    case homeAppliance
    case tv
    case plant
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: ObjectiveC.NSInteger)
    #endif
    @available(visionOS, introduced: 1.0, deprecated: 26.0, renamed: "SurfaceClassification")
    @available(macOS, unavailable)
    public typealias RawValue = ObjectiveC.NSInteger
    public var rawValue: ObjectiveC.NSInteger {
      get
    }
  }
  public struct Geometry : Swift.CustomStringConvertible, @unchecked Swift.Sendable {
    public var vertices: ARKit.GeometrySource {
      get
    }
    public var normals: ARKit.GeometrySource {
      get
    }
    public var faces: ARKit.GeometryElement {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public var classifications: ARKit.GeometrySource? {
      get
    }
    #endif
    public var description: Swift.String {
      get
    }
  }
  public var id: Foundation.UUID {
    get
  }
  public var geometry: ARKit.MeshAnchor.Geometry {
    get
  }
  public var originFromAnchorTransform: simd.simd_float4x4 {
    get
  }
  public var description: Swift.String {
    get
  }
  @available(visionOS 1.0, *)
  @available(macOS, unavailable)
  public typealias ID = Foundation.UUID
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.MeshAnchor : Swift.Equatable {
  public static func == (lhs: ARKit.MeshAnchor, rhs: ARKit.MeshAnchor) -> Swift.Bool
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.MeshAnchor.Geometry : Swift.Equatable {
  public static func == (lhs: ARKit.MeshAnchor.Geometry, rhs: ARKit.MeshAnchor.Geometry) -> Swift.Bool
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
final public class ObjectTrackingProvider : ARKit.DataProvider, @unchecked Swift.Sendable {
  public struct Error : Foundation.LocalizedError, Swift.CustomStringConvertible, @unchecked Swift.Sendable {
    public let url: Foundation.URL?
    public let name: Swift.String?
    public let bundle: Foundation.Bundle?
    public enum Code : Swift.CustomStringConvertible {
      case referenceObjectLoadingFailed
      public var description: Swift.String {
        get
      }
      public static func == (a: ARKit.ObjectTrackingProvider.Error.Code, b: ARKit.ObjectTrackingProvider.Error.Code) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public var code: ARKit.ObjectTrackingProvider.Error.Code {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public var failureReason: Swift.String? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var recoverySuggestion: Swift.String? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var errorDescription: Swift.String? {
      get
    }
    #endif
    public var description: Swift.String {
      get
    }
  }
  public struct TrackingConfiguration : Swift.CustomStringConvertible {
    public var maximumTrackableInstances: Swift.Int
    public var maximumInstancesPerReferenceObject: Swift.Int
    public var detectionRate: Swift.Float
    public var stationaryObjectTrackingRate: Swift.Float
    public var movingObjectTrackingRate: Swift.Float
    public var description: Swift.String {
      get
    }
    public init()
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init(referenceObjects: [ARKit.ReferenceObject], trackingConfiguration: ARKit.ObjectTrackingProvider.TrackingConfiguration? = nil)
  #endif
  final public var trackingConfiguration: ARKit.ObjectTrackingProvider.TrackingConfiguration {
    get
  }
  final public var anchorUpdates: ARKit.AnchorUpdateSequence<ARKit.ObjectAnchor> {
    get
  }
  final public var state: ARKit.DataProviderState {
    get
  }
  final public var allAnchors: [ARKit.ObjectAnchor] {
    get
  }
  public static var isSupported: Swift.Bool {
    get
  }
  public static var requiredAuthorizations: [ARKit.ARKitSession.AuthorizationType] {
    get
  }
  @objc deinit
  final public var description: Swift.String {
    get
  }
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
public struct ObjectAnchor : ARKit.TrackableAnchor, @unchecked Swift.Sendable, Swift.Equatable {
  public static func == (lhs: ARKit.ObjectAnchor, rhs: ARKit.ObjectAnchor) -> Swift.Bool
  public var referenceObject: ARKit.ReferenceObject {
    get
  }
  public struct AxisAlignedBoundingBox : @unchecked Swift.Sendable, Swift.Equatable {
    public static func == (lhs: ARKit.ObjectAnchor.AxisAlignedBoundingBox, rhs: ARKit.ObjectAnchor.AxisAlignedBoundingBox) -> Swift.Bool
    public var min: Swift.SIMD3<Swift.Float> {
      get
    }
    public var max: Swift.SIMD3<Swift.Float> {
      get
    }
    public var center: Swift.SIMD3<Swift.Float> {
      get
    }
    public var extent: Swift.SIMD3<Swift.Float> {
      get
    }
  }
  public var boundingBox: ARKit.ObjectAnchor.AxisAlignedBoundingBox {
    get
  }
  public typealias ID = Foundation.UUID
  public var id: Foundation.UUID {
    get
  }
  public var originFromAnchorTransform: simd.simd_float4x4 {
    get
  }
  public var isTracked: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
@available(visionOS 26.0, *)
@available(macOS, unavailable)
public enum SurfaceClassification : Swift.Int, Swift.Sendable, Swift.CustomStringConvertible {
  case none
  case wall
  case floor
  case ceiling
  case table
  case seat
  case window
  case door
  case stairs
  case bed
  case cabinet
  case homeAppliance
  case tv
  case plant
  public var description: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  @available(visionOS 26.0, *)
  @available(macOS, unavailable)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
final public class PlaneDetectionProvider : ARKit.DataProvider, @unchecked Swift.Sendable {
  final public var alignments: [ARKit.PlaneAnchor.Alignment] {
    get
  }
  final public var state: ARKit.DataProviderState {
    get
  }
  public init(alignments: [ARKit.PlaneAnchor.Alignment] = [.horizontal, .vertical])
  @available(visionOS 2.0, *)
  final public var allAnchors: [ARKit.PlaneAnchor] {
    get
  }
  public static var isSupported: Swift.Bool {
    get
  }
  public static var requiredAuthorizations: [ARKit.ARKitSession.AuthorizationType] {
    get
  }
  @objc deinit
  final public var anchorUpdates: ARKit.AnchorUpdateSequence<ARKit.PlaneAnchor> {
    get
  }
  final public var description: Swift.String {
    get
  }
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
public struct PlaneAnchor : ARKit.Anchor, @unchecked Swift.Sendable {
  public struct Geometry : Swift.CustomStringConvertible, @unchecked Swift.Sendable {
    public struct Extent : Swift.CustomStringConvertible, @unchecked Swift.Sendable {
      public var width: Swift.Float {
        get
      }
      public var height: Swift.Float {
        get
      }
      public var anchorFromExtentTransform: simd.simd_float4x4 {
        get
      }
      public var description: Swift.String {
        get
      }
    }
    public var meshVertices: ARKit.GeometrySource {
      get
    }
    public var meshFaces: ARKit.GeometryElement {
      get
    }
    public var extent: ARKit.PlaneAnchor.Geometry.Extent {
      get
    }
    public var description: Swift.String {
      get
    }
  }
  public enum Alignment : Swift.CustomStringConvertible, Swift.Sendable {
    case horizontal
    case vertical
    @available(visionOS 2.0, *)
    case slanted
    public var description: Swift.String {
      get
    }
    public static func == (a: ARKit.PlaneAnchor.Alignment, b: ARKit.PlaneAnchor.Alignment) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(visionOS, introduced: 1.0, deprecated: 26.0, renamed: "SurfaceClassification")
  public enum Classification : Swift.CustomStringConvertible, Swift.Sendable {
    case notAvailable
    case undetermined
    case unknown
    case wall
    case floor
    case ceiling
    case table
    case seat
    case window
    case door
    public var description: Swift.String {
      get
    }
    public static func == (a: ARKit.PlaneAnchor.Classification, b: ARKit.PlaneAnchor.Classification) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var id: Foundation.UUID {
    get
  }
  public var originFromAnchorTransform: simd.simd_float4x4 {
    get
  }
  public var alignment: ARKit.PlaneAnchor.Alignment {
    get
  }
  @available(visionOS, introduced: 1.0, deprecated: 26.0, renamed: "surfaceClassification")
  public var classification: ARKit.PlaneAnchor.Classification {
    get
  }
  @available(visionOS 26.0, *)
  public var surfaceClassification: ARKit.SurfaceClassification {
    get
  }
  public var geometry: ARKit.PlaneAnchor.Geometry {
    get
  }
  public var description: Swift.String {
    get
  }
  @available(visionOS 1.0, *)
  @available(macOS, unavailable)
  public typealias ID = Foundation.UUID
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.PlaneAnchor : Swift.Equatable {
  public static func == (lhs: ARKit.PlaneAnchor, rhs: ARKit.PlaneAnchor) -> Swift.Bool
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.PlaneAnchor.Geometry : Swift.Equatable {
  public static func == (lhs: ARKit.PlaneAnchor.Geometry, rhs: ARKit.PlaneAnchor.Geometry) -> Swift.Bool
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.PlaneAnchor.Geometry.Extent : Swift.Equatable {
  public static func == (lhs: ARKit.PlaneAnchor.Geometry.Extent, rhs: ARKit.PlaneAnchor.Geometry.Extent) -> Swift.Bool
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
public struct ReferenceImage : Swift.CustomStringConvertible, @unchecked Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func loadReferenceImages(inGroupNamed groupName: Swift.String, bundle: Foundation.Bundle? = nil) -> [ARKit.ReferenceImage]
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var name: Swift.String? {
    get
    set
  }
  #endif
  public var physicalSize: CoreFoundation.CGSize {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(visionOS 2.0, *)
  public var resourceGroupName: Swift.String? {
    get
  }
  #endif
  public init(pixelBuffer: CoreVideo.CVPixelBuffer, physicalSize: CoreFoundation.CGSize, orientation: ImageIO.CGImagePropertyOrientation = .up)
  public init(cgimage: CoreGraphics.CGImage, physicalSize: CoreFoundation.CGSize, orientation: ImageIO.CGImagePropertyOrientation = .up)
  public var description: Swift.String {
    get
  }
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.ReferenceImage : Swift.Equatable {
  public static func == (lhs: ARKit.ReferenceImage, rhs: ARKit.ReferenceImage) -> Swift.Bool
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
public struct ReferenceObject : Swift.CustomStringConvertible, @unchecked Swift.Sendable, Swift.Equatable, Swift.Identifiable {
  @available(visionOS 2.0, *)
  public static func == (lhs: ARKit.ReferenceObject, rhs: ARKit.ReferenceObject) -> Swift.Bool
  public init(from url: Foundation.URL) async throws
  #if compiler(>=5.3) && $NonescapableTypes
  public init(named: Swift.String, from bundle: Foundation.Bundle? = nil) async throws
  #endif
  public typealias ID = Foundation.UUID
  public var id: Foundation.UUID {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var inputFile: Foundation.URL? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var usdzFile: Foundation.URL? {
    get
  }
  #endif
  public var name: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
final public class RoomTrackingProvider : ARKit.DataProvider, @unchecked Swift.Sendable {
  final public var state: ARKit.DataProviderState {
    get
  }
  public init()
  @available(visionOS 2.0, *)
  final public var allAnchors: [ARKit.RoomAnchor] {
    get
  }
  public static var isSupported: Swift.Bool {
    get
  }
  public static var requiredAuthorizations: [ARKit.ARKitSession.AuthorizationType] {
    get
  }
  @objc deinit
  final public var anchorUpdates: ARKit.AnchorUpdateSequence<ARKit.RoomAnchor> {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var currentRoomAnchor: ARKit.RoomAnchor? {
    get
  }
  #endif
  final public var description: Swift.String {
    get
  }
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
public struct RoomAnchor : ARKit.Anchor, @unchecked Swift.Sendable, Swift.Equatable {
  public static func == (lhs: ARKit.RoomAnchor, rhs: ARKit.RoomAnchor) -> Swift.Bool
  public var id: Foundation.UUID {
    get
  }
  public var originFromAnchorTransform: simd.simd_float4x4 {
    get
  }
  public var geometry: ARKit.MeshAnchor.Geometry {
    get
  }
  public var planeAnchorIDs: [Foundation.UUID] {
    get
  }
  public var meshAnchorIDs: [Foundation.UUID] {
    get
  }
  public var isCurrentRoom: Swift.Bool {
    get
  }
  @available(visionOS, introduced: 2.0, deprecated: 26.0, message: "Use geometries(classifiedAs: SurfaceClassification) instead.")
  public func geometries(of classification: ARKit.MeshAnchor.MeshClassification) -> [ARKit.MeshAnchor.Geometry]
  @available(visionOS 26.0, *)
  public func geometries(classifiedAs classification: ARKit.SurfaceClassification) -> [ARKit.MeshAnchor.Geometry]
  public func contains(_ point: Swift.SIMD3<Swift.Float>) -> Swift.Bool
  public var description: Swift.String {
    get
  }
  @available(visionOS 2.0, *)
  @available(macOS, unavailable)
  public typealias ID = Foundation.UUID
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
final public class SceneReconstructionProvider : ARKit.DataProvider, @unchecked Swift.Sendable {
  public enum Mode : Swift.CustomStringConvertible, Swift.Sendable {
    case classification
    public var description: Swift.String {
      get
    }
    public static func == (a: ARKit.SceneReconstructionProvider.Mode, b: ARKit.SceneReconstructionProvider.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let modes: [ARKit.SceneReconstructionProvider.Mode]
  final public var state: ARKit.DataProviderState {
    get
  }
  public init(modes: [ARKit.SceneReconstructionProvider.Mode] = [])
  @available(visionOS 2.0, *)
  final public var allAnchors: [ARKit.MeshAnchor] {
    get
  }
  public static var isSupported: Swift.Bool {
    get
  }
  public static var requiredAuthorizations: [ARKit.ARKitSession.AuthorizationType] {
    get
  }
  @objc deinit
  final public var anchorUpdates: ARKit.AnchorUpdateSequence<ARKit.MeshAnchor> {
    get
  }
  final public var description: Swift.String {
    get
  }
}
@available(visionOS 2.4, *)
@available(macOS, unavailable)
public struct ViewpointProperties : @unchecked Swift.Sendable, Swift.CustomStringConvertible {
  public var deviceFromLeftViewpointTransform: simd.simd_float4x4 {
    get
  }
  public var deviceFromRightViewpointTransform: simd.simd_float4x4 {
    get
  }
  public var description: Swift.String {
    get
  }
}
@available(visionOS 2.4, *)
@available(macOS, unavailable)
final public class StereoPropertiesProvider : ARKit.DataProvider, @unchecked Swift.Sendable {
  public init()
  #if compiler(>=5.3) && $NonescapableTypes
  final public var latestViewpointProperties: ARKit.ViewpointProperties? {
    get
  }
  #endif
  final public var state: ARKit.DataProviderState {
    get
  }
  public static var isSupported: Swift.Bool {
    get
  }
  public static var requiredAuthorizations: [ARKit.ARKitSession.AuthorizationType] {
    get
  }
  final public var description: Swift.String {
    get
  }
  @objc deinit
}
@available(visionOS 1.0, macOS 26.0, *)
final public class WorldTrackingProvider : ARKit.DataProvider, @unchecked Swift.Sendable {
  @available(macOS, unavailable)
  public struct Error : Foundation.LocalizedError, Swift.CustomStringConvertible, @unchecked Swift.Sendable {
    public let anchor: ARKit.WorldAnchor?
    public enum Code : Swift.CustomStringConvertible {
      case addWorldAnchorFailed
      case worldAnchorLimitReached
      case removeWorldAnchorFailed
      public var description: Swift.String {
        get
      }
      public static func == (a: ARKit.WorldTrackingProvider.Error.Code, b: ARKit.WorldTrackingProvider.Error.Code) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public var failureReason: Swift.String? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var recoverySuggestion: Swift.String? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var errorDescription: Swift.String? {
      get
    }
    #endif
    public var code: ARKit.WorldTrackingProvider.Error.Code {
      get
    }
    public var description: Swift.String {
      get
    }
  }
  final public var state: ARKit.DataProviderState {
    get
  }
  @available(macOS, unavailable)
  final public func addAnchor(_ worldAnchor: ARKit.WorldAnchor) async throws
  @available(macOS, unavailable)
  final public func removeAnchor(_ worldAnchor: ARKit.WorldAnchor) async throws
  @available(macOS, unavailable)
  final public func removeAnchor(forID id: Foundation.UUID) async throws
  @available(visionOS 26.0, *)
  @available(macOS, unavailable)
  final public func removeAllAnchors() async throws
  #if compiler(>=5.3) && $NonescapableTypes
  @available(visionOS 2.0, *)
  @available(macOS, unavailable)
  final public var allAnchors: [ARKit.WorldAnchor]? {
    get async
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func queryDeviceAnchor(atTimestamp timestamp: Foundation.TimeInterval) -> ARKit.DeviceAnchor?
  #endif
  public init()
  public static var isSupported: Swift.Bool {
    get
  }
  public static var requiredAuthorizations: [ARKit.ARKitSession.AuthorizationType] {
    get
  }
  @objc deinit
  @available(macOS, unavailable)
  final public var anchorUpdates: ARKit.AnchorUpdateSequence<ARKit.WorldAnchor> {
    get
  }
  final public var description: Swift.String {
    get
  }
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
public struct WorldAnchor : ARKit.TrackableAnchor, @unchecked Swift.Sendable {
  public var isTracked: Swift.Bool {
    get
  }
  public var id: Foundation.UUID {
    get
  }
  public var originFromAnchorTransform: simd.simd_float4x4 {
    get
  }
  public init(originFromAnchorTransform: simd.simd_float4x4)
  public var description: Swift.String {
    get
  }
  @available(visionOS 1.0, *)
  @available(macOS, unavailable)
  public typealias ID = Foundation.UUID
}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.WorldAnchor : Swift.Equatable {
  public static func == (lhs: ARKit.WorldAnchor, rhs: ARKit.WorldAnchor) -> Swift.Bool
}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.AnchorUpdate.Event : Swift.Equatable {}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.AnchorUpdate.Event : Swift.Hashable {}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.AnchorUpdate.Event : Swift.BitwiseCopyable {}
@available(visionOS 1.0, macOS 26.0, *)
extension ARKit.ARKitSession.Error.Code : Swift.Equatable {}
@available(visionOS 1.0, macOS 26.0, *)
extension ARKit.ARKitSession.Error.Code : Swift.Hashable {}
@available(visionOS 1.0, macOS 26.0, *)
extension ARKit.ARKitSession.AuthorizationType : Swift.Equatable {}
@available(visionOS 1.0, macOS 26.0, *)
extension ARKit.ARKitSession.AuthorizationType : Swift.Hashable {}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.ARKitSession.AuthorizationStatus : Swift.Equatable {}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.ARKitSession.AuthorizationStatus : Swift.Hashable {}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.BarcodeAnchor.Symbology : Swift.Equatable {}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.BarcodeAnchor.Symbology : Swift.Hashable {}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.CameraFrameProvider.CameraType : Swift.Equatable {}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.CameraFrameProvider.CameraType : Swift.Hashable {}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.CameraFrameProvider.CameraPosition : Swift.Equatable {}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.CameraFrameProvider.CameraPosition : Swift.Hashable {}
@available(visionOS 26.0, *)
@available(macOS, unavailable)
extension ARKit.CameraFrameProvider.CameraRectification : Swift.Equatable {}
@available(visionOS 26.0, *)
@available(macOS, unavailable)
extension ARKit.CameraFrameProvider.CameraRectification : Swift.Hashable {}
@available(visionOS 1.0, macOS 26.0, *)
extension ARKit.DataProviderState : Swift.Equatable {}
@available(visionOS 1.0, macOS 26.0, *)
extension ARKit.DataProviderState : Swift.Hashable {}
@available(macOS 26.0, visionOS 2.0, *)
extension ARKit.DeviceAnchor.TrackingState : Swift.Equatable {}
@available(macOS 26.0, visionOS 2.0, *)
extension ARKit.DeviceAnchor.TrackingState : Swift.Hashable {}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.GeometryElement.Primitive : Swift.Equatable {}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.GeometryElement.Primitive : Swift.Hashable {}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.HandAnchor.Chirality : Swift.Equatable {}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.HandAnchor.Chirality : Swift.Hashable {}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.HandAnchor.Chirality : Swift.BitwiseCopyable {}
@available(visionOS 26.0, *)
@available(macOS, unavailable)
extension ARKit.HandAnchor.Fidelity : Swift.Equatable {}
@available(visionOS 26.0, *)
@available(macOS, unavailable)
extension ARKit.HandAnchor.Fidelity : Swift.Hashable {}
@available(macOS, unavailable)
@available(visionOS, introduced: 1.0, deprecated: 26.0, renamed: "SurfaceClassification")
extension ARKit.MeshAnchor.MeshClassification : Swift.Equatable {}
@available(macOS, unavailable)
@available(visionOS, introduced: 1.0, deprecated: 26.0, renamed: "SurfaceClassification")
extension ARKit.MeshAnchor.MeshClassification : Swift.Hashable {}
@available(macOS, unavailable)
@available(visionOS, introduced: 1.0, deprecated: 26.0, renamed: "SurfaceClassification")
extension ARKit.MeshAnchor.MeshClassification : Swift.RawRepresentable {}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.ObjectTrackingProvider.Error.Code : Swift.Equatable {}
@available(visionOS 2.0, *)
@available(macOS, unavailable)
extension ARKit.ObjectTrackingProvider.Error.Code : Swift.Hashable {}
@available(visionOS 26.0, *)
@available(macOS, unavailable)
extension ARKit.SurfaceClassification : Swift.Equatable {}
@available(visionOS 26.0, *)
@available(macOS, unavailable)
extension ARKit.SurfaceClassification : Swift.Hashable {}
@available(visionOS 26.0, *)
@available(macOS, unavailable)
extension ARKit.SurfaceClassification : Swift.RawRepresentable {}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.PlaneAnchor.Alignment : Swift.Equatable {}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.PlaneAnchor.Alignment : Swift.Hashable {}
@available(macOS, unavailable)
@available(visionOS, introduced: 1.0, deprecated: 26.0, renamed: "SurfaceClassification")
extension ARKit.PlaneAnchor.Classification : Swift.Equatable {}
@available(macOS, unavailable)
@available(visionOS, introduced: 1.0, deprecated: 26.0, renamed: "SurfaceClassification")
extension ARKit.PlaneAnchor.Classification : Swift.Hashable {}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.SceneReconstructionProvider.Mode : Swift.Equatable {}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.SceneReconstructionProvider.Mode : Swift.Hashable {}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.WorldTrackingProvider.Error.Code : Swift.Equatable {}
@available(visionOS 1.0, *)
@available(macOS, unavailable)
extension ARKit.WorldTrackingProvider.Error.Code : Swift.Hashable {}
