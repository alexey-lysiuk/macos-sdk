// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 effective-5.10 (swiftlang-6.2.1.4.7 clang-1700.4.4.1)
// swift-module-flags: -target arm64e-apple-macos26.1 -target-variant arm64e-apple-ios26.1-macabi -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftSpatial -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 108 -module-name Spatial
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.1
@_exported import Spatial
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat : @unchecked Swift.Sendable {
  public static let right: Spatial.Vector3DFloat
  public static let up: Spatial.Vector3DFloat
  public static let forward: Spatial.Vector3DFloat
  @inlinable public init(x: Swift.Float = 0, y: Swift.Float = 0, z: Swift.Float = 0) {
        self = __SPVector3DFloatMake(x, y, z)
    }
  @inlinable public init(_ xyz: simd.simd_float3) {
        self = __SPVector3DFloatMakeWithVector(xyz)
    }
  @inlinable public init(_ size: Spatial.Size3DFloat) {
        self = __SPVector3DFloatMakeWithSize(size)
    }
  @inlinable public init(_ point: Spatial.Point3DFloat) {
        self = __SPVector3DFloatMakeWithPoint(point)
    }
  @inlinable public init(_ axis: Spatial.RotationAxis3DFloat) {
        self = __SPVector3DFloatMakeWithRotationAxis(axis)
    }
  @inlinable public func dot(_ other: Spatial.Vector3DFloat) -> Swift.Float {
        return __SPVector3DFloatDotProduct(self, other)
    }
  @inlinable public func cross(_ other: Spatial.Vector3DFloat) -> Spatial.Vector3DFloat {
        return __SPVector3DFloatCrossProduct(self, other)
    }
  @inlinable public var normalized: Spatial.Vector3DFloat {
    get {
        return __SPVector3DFloatNormalize(self)
    }
  }
  @inlinable public mutating func normalize() {
        self = __SPVector3DFloatNormalize(self)
    }
  @inlinable public func projected(_ other: Spatial.Vector3DFloat) -> Spatial.Vector3DFloat {
        return __SPVector3DFloatProject(self, other)
    }
  @inlinable public func reflected(_ normal: Spatial.Vector3DFloat) -> Spatial.Vector3DFloat {
        return __SPVector3DFloatReflect(self, normal)
    }
  @inlinable public var length: Swift.Float {
    get {
        return __SPVector3DFloatLength(self)
    }
  }
  @inlinable public var lengthSquared: Swift.Float {
    get {
        return __SPVector3DFloatLengthSquared(self)
    }
  }
  @inlinable public func applying(_ transform: Spatial.AffineTransform3DFloat) -> Spatial.Vector3DFloat {
        return __SPVector3DFloatApplyAffineTransform(self, transform)
    }
  @inlinable public func applying(_ transform: Spatial.ProjectiveTransform3DFloat) -> Spatial.Vector3DFloat {
        return __SPVector3DFloatApplyProjectiveTransform(self, transform)
    }
  @inlinable public func unapplying(_ transform: Spatial.AffineTransform3DFloat) -> Spatial.Vector3DFloat {
        return __SPVector3DFloatUnapplyAffineTransform(self, transform)
    }
  @inlinable public func unapplying(_ transform: Spatial.ProjectiveTransform3DFloat) -> Spatial.Vector3DFloat {
        return __SPVector3DFloatUnapplyProjectiveTransform(self, transform)
    }
  public func applying(_ pose: Spatial.Pose3DFloat) -> Spatial.Vector3DFloat
  public func unapplying(_ pose: Spatial.Pose3DFloat) -> Spatial.Vector3DFloat
  public func applying(_ scaledPose: Spatial.ScaledPose3DFloat) -> Spatial.Vector3DFloat
  public func unapplying(_ scaledPose: Spatial.ScaledPose3DFloat) -> Spatial.Vector3DFloat
  @inlinable public func rotated(by rotation: Spatial.Rotation3DFloat) -> Spatial.Vector3DFloat {
        return __SPVector3DFloatRotate(self, rotation)
    }
  @inlinable public func rotated(by quaternion: simd.simd_quatf) -> Spatial.Vector3DFloat {
        return __SPVector3DFloatRotateByQuaternion(self, quaternion)
    }
  @inlinable public func rotation(to other: Spatial.Vector3DFloat) -> Spatial.Rotation3DFloat {
        return __SPVector3DFloatRotationToVector(self, other)
    }
  @inlinable public func scaledBy(x: Swift.Float = 1, y: Swift.Float = 1, z: Swift.Float = 1) -> Spatial.Vector3DFloat {
        
        return __SPVector3DFloatScaleBy(self, x, y, z)
    }
  @inlinable public func scaled(by size: Spatial.Size3DFloat) -> Spatial.Vector3DFloat {
        
        return __SPVector3DFloatScaleBySize(self, size)
    }
  @inlinable public func uniformlyScaled(by scale: Swift.Float) -> Spatial.Vector3DFloat {
        return __SPVector3DFloatScaleUniform(self, scale)
    }
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.Vector3DFloat {
        
        return _shear(shearFunc: __SPVector3DFloatShear, shear: shear)
    }
  @usableFromInline
  internal func _shear(shearFunc: (Spatial.Vector3DFloat, Spatial.Axis3D, Swift.Float, Swift.Float) -> Spatial.Vector3DFloat, shear: Spatial.AxisWithFactors) -> Spatial.Vector3DFloat
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Vector3DFloat, rhs: Spatial.Vector3DFloat) -> Swift.Bool {
        
        return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat {
  public static func lerp(from: Spatial.Vector3DFloat, to: Spatial.Vector3DFloat, t: Spatial.Vector3DFloat) -> Spatial.Vector3DFloat
  public static func smoothstep(edge0: Spatial.Vector3DFloat, edge1: Spatial.Vector3DFloat, x: Spatial.Vector3DFloat) -> Spatial.Vector3DFloat
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
@available(*, deprecated, renamed: "Axis3D.x")
public let x: Spatial.Axis3D
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
@available(*, deprecated, renamed: "Axis3D.y")
public let y: Spatial.Axis3D
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
@available(*, deprecated, renamed: "Axis3D.z")
public let z: Spatial.Axis3D
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D {
  @available(*, deprecated, renamed: "Rotation3D.init(angle:axis:)")
  public init(axis: Spatial.RotationAxis3D, angle: Spatial.Angle2D)
  @available(*, deprecated, renamed: "Rotation3D.init()")
  public init(quaternion: simd.simd_quatf)
  @available(*, deprecated, renamed: "Rotation3D.init()")
  public init(quaternion: simd.simd_quatd)
  @available(*, deprecated, renamed: "Rotation3D.init(position:target:up:)")
  public init(eye: Spatial.Point3D, target: Spatial.Point3D, up: Spatial.Vector3D = Vector3D(x: 0, y: 1, z: 0))
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  @available(*, deprecated, renamed: "vector")
  @inlinable public var simd: simd.simd_double3 {
    get {
            return self.vector
        }
    set {
            self.vector = newValue
        }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @available(*, deprecated, renamed: "vector")
  @inlinable public var simd: simd.simd_double3 {
    get {
            return self.vector
        }
    set {
            self.vector = newValue
        }
  }
  @available(*, deprecated, message: "This property is deprecated")
  @inlinable public var origin: Spatial.Point3D {
    get {
        return self
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D {
  @available(*, deprecated, renamed: "vector")
  @inlinable public var simd: simd.simd_double3 {
    get {
            return self.vector
        }
    set {
            self.vector = newValue
        }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  @available(*, deprecated, renamed: "contains(anyOf:)")
  @inlinable public func containsAny(of points: [Spatial.Point3D]) -> Swift.Bool {
        return __SPSize3DContainsAnyPoint(self,
                                          points,
                                          Int32(points.count))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D {
  @available(*, deprecated, renamed: "contains(anyOf:)")
  @inlinable public func containsAny(of points: [Spatial.Point3D]) -> Swift.Bool {
        return __SPRect3DContainsAnyPoint(self,
                                          points,
                                          Int32(points.count))
    }
  @available(*, deprecated, message: "This function is deprecated")
  @inlinable public func distance(to other: Spatial.Rect3D) -> Swift.Double {
        return self.origin.distance(to: other.origin)
    }
  @available(*, deprecated, message: "This function is deprecated")
  @inlinable public func rotation(to other: Spatial.Rect3D) -> Spatial.Rotation3D {
        return self.origin.rotation(to: other.origin)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.Point3D {
        return self.translated(by: Vector3D(size))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.Rect3D {
        return self.translated(by: Vector3D(size))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.Ray3D {
        return self.translated(by: Vector3D(size))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.Pose3D {
        return self.translated(by: Vector3D(size))
    }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, renamed: "init(_:)")
  @inlinable public init?(matrix: simd.simd_double4x4) {
        
        self.init(matrix)
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, renamed: "init(_:)")
  @inlinable public init?(matrix: simd.simd_float4x4) {
        
        self.init(matrix)
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "Use `AffineTransform3D.init(truncating:)` instead.")
  @inlinable public init?(projectiveTransform transform: Spatial.ProjectiveTransform3D) {
        
        let affine = __SPAffineTransform3DMakeWithProjective(transform)
        
        if __SPAffineTransform3DIsValid(affine) {
            self = affine
        } else {
            return nil
        }
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "Use `AffineTransform3D.init(truncating:)` instead.")
  @inlinable public init?(_ matrix: simd.simd_double4x4) {

        let affine = __SPAffineTransform3DMakeWith4x4Matrix(matrix)

        if __SPAffineTransform3DIsValid(affine) {
            self = affine
        } else {
            return nil
        }
    }
  #endif
  @available(*, deprecated, renamed: "init(offset:)", message: "Use `Vector3D` variant.")
  @inlinable public init(translation: Spatial.Size3D) {
        self.init(translation: Vector3D(translation))
    }
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.AffineTransform3D {
        return self.translated(by: Vector3D(size))
    }
  @available(*, deprecated, renamed: "translation")
  @inlinable public var offset: Spatial.Vector3D {
    get {
            return __SPAffineTransform3DGetTranslation(self)
        }
    set {
            __SPAffineTransform3DSetTranslation(&self, newValue)
        }
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "Use `AffineTransform3D.getter:inverse` instead.")
  @inlinable public func inverted() -> Spatial.AffineTransform3D? {
        
        return inverse
    }
  #endif
  @available(*, deprecated, renamed: "init(_:)")
  @inlinable public init(matrix: simd.simd_float4x3) {
        self.init(matrix)
    }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, renamed: "init(_:)")
  @inlinable public init?(matrix: simd.simd_float4x4) {
        self.init(matrix)
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, renamed: "init(_:)")
  @inlinable public init?(matrix: simd.simd_double4x4) {
        
        self.init(matrix)
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "Use `AffineTransform3D.init(truncating:)` instead.")
  @inlinable public init?(_ matrix: simd.simd_float4x4) {

        let column0 = matrix.columns.0
        let column1 = matrix.columns.1
        let column2 = matrix.columns.2
        let column3 = matrix.columns.3
        
        let m = simd_double4x4([
            simd_double4(Double(column0.x), Double(column0.y),
                         Double(column0.z), Double(column0.w)),
            simd_double4(Double(column1.x), Double(column1.y),
                         Double(column1.z), Double(column1.w)),
            simd_double4(Double(column2.x), Double(column2.y),
                         Double(column2.z), Double(column2.w)),
            simd_double4(Double(column3.x), Double(column3.y),
                         Double(column3.z), Double(column3.w))
        ])
        
        let affine = __SPAffineTransform3DMakeWith4x4Matrix(m)

        if __SPAffineTransform3DIsValid(affine) {
            self = affine
        } else {
            return nil
        }
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D {
  @available(*, deprecated, renamed: "init(offset:)", message: "Use `Vector3D` variant.")
  @inlinable public init(translation: Spatial.Size3D) {
        self.init(translation: Vector3D(translation))
    }
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.ProjectiveTransform3D {
        return self.translated(by: Vector3D(size))
    }
  @available(*, deprecated, renamed: "translation")
  @inlinable public var offset: Spatial.Vector3D {
    get {
            return __SPProjectiveTransform3DGetTranslation(self)
        }
    set {
            __SPProjectiveTransform3DSetTranslation(&self, newValue)
        }
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "Use `ProjectiveTransform3D.getter:inverse` instead.")
  @inlinable public func inverted() -> Spatial.ProjectiveTransform3D? {
        
        return inverse
    }
  #endif
  @available(*, deprecated, renamed: "init(_:)")
  @inlinable public init(matrix: simd.simd_float4x4) {
        self.init(matrix)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.SIMD3 where Scalar == Swift.Float {
  @available(*, deprecated, renamed: "SIMD3.init(_:)")
  @inlinable public init(rotationAxis: Spatial.RotationAxis3D) {
        self.init(rotationAxis)
    }
  @available(*, deprecated, renamed: "SIMD3.init(_:)")
  @inlinable public init(point: Spatial.Point3D) {
        self.init(x: Float(point.x),
                  y: Float(point.y),
                  z: Float(point.z))
    }
  @available(*, deprecated, renamed: "SIMD3.init(_:)")
  @inlinable public init(vector: Spatial.Vector3D) {
        self.init(x: Float(vector.x),
                  y: Float(vector.y),
                  z: Float(vector.z))
    }
  @available(*, deprecated, renamed: "SIMD3.init(_:)")
  @inlinable public init(size: Spatial.Size3D) {
        self.init(x: Float(size.width),
                  y: Float(size.height),
                  z: Float(size.depth))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension simd.simd_quatf {
  @available(*, deprecated, renamed: "simd_quatf.init(_:)")
  @inlinable public init(rotation: Spatial.Rotation3D) {
        
        self.init(vector: simd_float(rotation.quaternion.vector))
        
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension simd.simd_float4x3 {
  @available(*, deprecated, renamed: "simd_float4x3.init(_:)")
  @inlinable public init(affineTransform: Spatial.AffineTransform3D) {
        
        self.init(affineTransform)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension simd.simd_float4x4 {
  @available(*, deprecated, renamed: "simd_float4x4.init(_:)")
  @inlinable public init(projectiveTransform: Spatial.ProjectiveTransform3D) {
        
        self.init(projectiveTransform)
    }
  @available(*, deprecated, renamed: "simd_float4x4.init(_:)")
  @inlinable public init(affineTransform: Spatial.AffineTransform3D) {
        
        self.init(affineTransform)
    }
  @available(*, deprecated, renamed: "simd_float4x4.init(_:)")
  @inlinable public init(pose: Spatial.Pose3D) {
        
        self.init(pose)
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.EulerAngles {
  @available(*, deprecated, renamed: "init(x:y:z:order:)")
  public init(_ x: Spatial.Angle2D, _ y: Spatial.Angle2D, _ z: Spatial.Angle2D, order: Spatial.EulerAngles.Order)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Rect3D {
  @available(*, deprecated, message: "Use `Rect3D.min.x`.")
  public var minX: Swift.Double {
    get
  }
  @available(*, deprecated, message: "Use `Rect3D.min.y`.")
  public var minY: Swift.Double {
    get
  }
  @available(*, deprecated, message: "Use `Rect3D.min.z`.")
  public var minZ: Swift.Double {
    get
  }
  @available(*, deprecated, message: "Use `Rect3D.center.x`.")
  public var midX: Swift.Double {
    get
  }
  @available(*, deprecated, message: "Use `Rect3D.center.y`.")
  public var midY: Swift.Double {
    get
  }
  @available(*, deprecated, message: "Use `Rect3D.center.z`.")
  public var midZ: Swift.Double {
    get
  }
  @available(*, deprecated, message: "Use `Rect3D.max.x`.")
  public var maxX: Swift.Double {
    get
  }
  @available(*, deprecated, message: "Use `Rect3D.max.y`.")
  public var maxY: Swift.Double {
    get
  }
  @available(*, deprecated, message: "Use `Rect3D.max.z`.")
  public var maxZ: Swift.Double {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat : @unchecked Swift.Sendable {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat {
  @inlinable public var translation: Spatial.Vector3DFloat {
    get {
            return __SPProjectiveTransform3DFloatGetTranslation(self)
        }
    set {
            __SPProjectiveTransform3DFloatSetTranslation(&self, newValue)
        }
  }
  @inlinable public init() {
         self.init(scale: Size3DFloat(width: 1, height: 1, depth: 1))
     }
  @inlinable public init(scale: Spatial.Size3DFloat = Size3DFloat(width: 1.0, height: 1, depth: 1), rotation: Spatial.Rotation3DFloat = .identity, translation: Spatial.Vector3DFloat = .zero) {
        
        
        self = __SPProjectiveTransform3DFloatMake(scale,
                                             rotation,
                                             translation)
    }
  @inlinable public init(pose: Spatial.Pose3DFloat) {
        
        self = __SPProjectiveTransform3DFloatMakeWithPose(pose)
    }
  @inlinable public init(scaledPose: Spatial.ScaledPose3DFloat) {
        
        self = __SPProjectiveTransform3DFloatMakeWithScaledPose(scaledPose)
    }
  @inlinable public func isApproximatelyEqual(to other: Spatial.ProjectiveTransform3DFloat, tolerance: Swift.Float = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPProjectiveTransform3DFloatAlmostEqualToTransform(self, other, tolerance)
    }
  public func flipped(along axis: Spatial.Axis3D) -> Spatial.ProjectiveTransform3DFloat
  public mutating func flip(along axis: Spatial.Axis3D)
  @inlinable public func scaledBy(x: Swift.Float, y: Swift.Float, z: Swift.Float) -> Spatial.ProjectiveTransform3DFloat {
        return __SPProjectiveTransform3DFloatScaleBy(self, x, y, z)
    }
  @inlinable public func isUniform(overDimensions: Spatial.Dimension3DSet) -> Swift.Bool {
        
        let axes = Axis3D(rawValue: UInt32(overDimensions.rawValue))
        
        return __SPProjectiveTransform3DFloatIsUniformOverDimensions(self,
                                                                axes)
    }
  @inlinable public init(shear: Spatial.AxisWithFactorsFloat) {
        switch shear {
            case .xAxis(let yShearFactor, let zShearFactor):
                self = __SPProjectiveTransform3DFloatMakeShear(.x, yShearFactor, zShearFactor)
            case .yAxis(let xShearFactor, let zShearFactor):
                self = __SPProjectiveTransform3DFloatMakeShear(.y, xShearFactor, zShearFactor)
            case .zAxis(let xShearFactor, let yShearFactor):
                self = __SPProjectiveTransform3DFloatMakeShear(.z, xShearFactor, yShearFactor)
            @unknown default:
                fatalError("Unsupported shear")
        }
    }
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactorsFloat) -> Spatial.ProjectiveTransform3DFloat {
        switch shear {
            case .xAxis(let yShearFactor, let zShearFactor):
                return __SPProjectiveTransform3DFloatShear(self, .x, Float(yShearFactor), Float(zShearFactor))
            case .yAxis(let xShearFactor, let zShearFactor):
                return __SPProjectiveTransform3DFloatShear(self, .y, Float(xShearFactor), Float(zShearFactor))
            case .zAxis(let xShearFactor, let yShearFactor):
                return __SPProjectiveTransform3DFloatShear(self, .z, Float(xShearFactor), Float(yShearFactor))
            @unknown default:
                fatalError("Unsupported shear")
        }
    }
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public var rotation: Spatial.Rotation3DFloat? {
    get {
        
        let r = __SPProjectiveTransform3DFloatGetRotation(self)
        
        if __SPRotation3DFloatIsValid(r) {
            return r
        } else {
            return nil
        }
    }
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public var inverse: Spatial.ProjectiveTransform3DFloat? {
    get {
        
        let t = __SPProjectiveTransform3DFloatInverted(self)
        
        if __SPProjectiveTransform3DFloatIsValid(t) {
            return t
        } else {
            return nil
        }
    }
  }
  #endif
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.ProjectiveTransform3DFloat, rhs: Spatial.ProjectiveTransform3DFloat) -> Swift.Bool {
        return lhs.matrix == rhs.matrix
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat {
  @inlinable public var scaleComponent: Spatial.Size3DFloat {
    get {
        
        return __SPProjectiveTransform3DFloatGetScale(self)
    }
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public enum AxisWithFactorsFloat {
  case xAxis(yShearFactor: Swift.Float, zShearFactor: Swift.Float)
  case yAxis(xShearFactor: Swift.Float, zShearFactor: Swift.Float)
  case zAxis(xShearFactor: Swift.Float, yShearFactor: Swift.Float)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public protocol ProjectiveTransformable3D {
  func applying(_ transform: Spatial.ProjectiveTransform3D) -> Self
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3D : Spatial.ProjectiveTransformable3D {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3D : Spatial.ProjectiveTransformable3D {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3D : Spatial.ProjectiveTransformable3D {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3D : Spatial.ProjectiveTransformable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public init(x: Swift.Double = 0, y: Swift.Double = 0, z: Swift.Double = 0) {
        self = __SPPoint3DMake(x, y, z)
    }
  @inlinable public init(_ xyz: simd.simd_double3) {
        self = __SPPoint3DMakeWithVector(xyz)
    }
  @inlinable public init(_ xyz: Spatial.Vector3D) {
        self = __SPPoint3DMakeWithVector(xyz)
    }
  @inlinable public init(_ size: Spatial.Size3D) {
        self = __SPPoint3DMakeWithSize(size)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public mutating func clamp(to rect: Spatial.Rect3D) {
        self = self.clamped(to: rect)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Spatial.Primitive3D {
  public func applying(_ pose: Spatial.Pose3D) -> Spatial.Point3D
  public func unapplying(_ pose: Spatial.Pose3D) -> Spatial.Point3D
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Point3D {
  public func applying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Point3D
  public func unapplying(_ pose: Spatial.ScaledPose3D) -> Spatial.Point3D
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Spatial.Rotatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Spatial.Translatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Point3D, rhs: Spatial.Point3D) -> Swift.Bool {
        return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z
    }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Point3D {
  @inlinable public func isApproximatelyEqual(to other: Spatial.Point3D, tolerance: Swift.Double = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPPoint3DAlmostEqualToPoint(self, other, tolerance)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Point3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public static func + (lhs: Spatial.Point3D, rhs: Spatial.Size3D) -> Spatial.Point3D {
       
        return Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func += (lhs: inout Spatial.Point3D, rhs: Spatial.Size3D) {
       
        lhs = Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func + (lhs: Spatial.Size3D, rhs: Spatial.Point3D) -> Spatial.Point3D {
       
        return Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Point3D, rhs: Spatial.Size3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Point3D, rhs: Spatial.Size3D) {
        
        lhs = Point3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Size3D, rhs: Spatial.Point3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector - rhs.vector)
    }
  @inlinable prefix public static func - (point: Spatial.Point3D) -> Spatial.Point3D {
        
        return Point3D(-point.vector)
    }
  @inlinable public static func * (lhs: Swift.Double, rhs: Spatial.Point3D) -> Spatial.Point3D {
        return Point3D(lhs * rhs.vector)
    }
  @inlinable public static func *= (lhs: inout Spatial.Point3D, rhs: Swift.Double) {
        lhs = Point3D(rhs * lhs.vector)
    }
  @inlinable public static func * (lhs: Spatial.Point3D, rhs: Swift.Double) -> Spatial.Point3D {
        return Point3D(lhs.vector * rhs)
    }
  @inlinable public static func / (lhs: Spatial.Point3D, rhs: Swift.Double) -> Spatial.Point3D {
        return Point3D(lhs.vector / rhs)
    }
  @inlinable public static func /= (lhs: inout Spatial.Point3D, rhs: Swift.Double) {
        lhs = Point3D(lhs.vector / rhs)
    }
  @inlinable public static func * (lhs: Spatial.AffineTransform3D, rhs: Spatial.Point3D) -> Spatial.Point3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.Point3D) -> Spatial.Point3D {

        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.Pose3D, rhs: Spatial.Point3D) -> Spatial.Point3D {

        return rhs.applying(lhs)
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Size3D : Swift.AdditiveArithmetic {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  @inlinable prefix public static func - (size: Spatial.Size3D) -> Spatial.Size3D {
        return Size3D(-size.vector)
    }
  @inlinable public static func + (lhs: Spatial.Size3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        return Size3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func += (lhs: inout Spatial.Size3D, rhs: Spatial.Size3D) {
        lhs = Size3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Size3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        return Size3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Size3D, rhs: Spatial.Size3D) {
        lhs = Size3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func * (lhs: Swift.Double, rhs: Spatial.Size3D) -> Spatial.Size3D {
        return Size3D(lhs * rhs.vector)
    }
  @inlinable public static func * (lhs: Spatial.Size3D, rhs: Swift.Double) -> Spatial.Size3D {
        return Size3D(lhs.vector * rhs)
    }
  @inlinable public static func *= (lhs: inout Spatial.Size3D, rhs: Swift.Double) {
        lhs = Size3D(lhs.vector * rhs)
    }
  @inlinable public static func / (lhs: Spatial.Size3D, rhs: Swift.Double) -> Spatial.Size3D {
        return Size3D(lhs.vector / rhs)
    }
  @inlinable public static func /= (lhs: inout Spatial.Size3D, rhs: Swift.Double) {
        lhs = Size3D(lhs.vector / rhs)
    }
  @inlinable public static func * (lhs: Spatial.AffineTransform3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.Pose3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        
        return rhs.applying(lhs)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D {
  @inlinable public static func * (lhs: Spatial.AffineTransform3D, rhs: Spatial.Rect3D) -> Spatial.Rect3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.Rect3D) -> Spatial.Rect3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.Pose3D, rhs: Spatial.Rect3D) -> Spatial.Rect3D {
        
        return rhs.applying(lhs)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D {
  @inlinable public static func * (lhs: Spatial.AffineTransform3D, rhs: Spatial.AffineTransform3D) -> Spatial.AffineTransform3D {
        
        let result = lhs.concatenating(rhs)
        
        return result
    }
  @inlinable public static func *= (lhs: inout Spatial.AffineTransform3D, rhs: Spatial.AffineTransform3D) {
        
        lhs = lhs.concatenating(rhs)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D {
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.ProjectiveTransform3D) -> Spatial.ProjectiveTransform3D {
        
        let result = lhs.concatenating(rhs)
        
        return result
    }
  @inlinable public static func *= (lhs: inout Spatial.ProjectiveTransform3D, rhs: Spatial.ProjectiveTransform3D) {
        
        lhs = lhs.concatenating(rhs)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
@inlinable public func * <T>(lhs: Spatial.Rotation3D, rhs: T) -> T where T : Spatial.Rotatable3D {
    
    let result = rhs.rotated(by: lhs)
    
    return result
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public static func - (lhs: Spatial.Point3D, rhs: Spatial.Point3D) -> Spatial.Vector3D {
        
        return Vector3D(lhs.vector - rhs.vector)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D {
  @inlinable public static func + (lhs: Spatial.Point3D, rhs: Spatial.Vector3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func + (lhs: Spatial.Vector3D, rhs: Spatial.Point3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Point3D, rhs: Spatial.Vector3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Vector3D, rhs: Spatial.Point3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector - rhs.vector)
    }
  @inlinable prefix public static func - (vector: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return Vector3D(-vector.vector)
    }
  @inlinable public static func + (lhs: Spatial.Vector3D, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return Vector3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func += (lhs: inout Spatial.Vector3D, rhs: Spatial.Vector3D) {
        
        lhs = Vector3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Vector3D, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return Vector3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Vector3D, rhs: Spatial.Vector3D) {
        
        lhs = Vector3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func * (lhs: Swift.Double, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return Vector3D(lhs * rhs.vector)
    }
  @inlinable public static func * (lhs: Spatial.Vector3D, rhs: Swift.Double) -> Spatial.Vector3D {
        
        return Vector3D(lhs.vector * rhs)
    }
  @inlinable public static func *= (lhs: inout Spatial.Vector3D, rhs: Swift.Double) {
        
        lhs = Vector3D(lhs.vector * rhs)
    }
  @inlinable public static func / (lhs: Spatial.Vector3D, rhs: Swift.Double) -> Spatial.Vector3D {
        
        return Vector3D(lhs.vector / rhs)
    }
  @inlinable public static func /= (lhs: inout Spatial.Vector3D, rhs: Swift.Double) {
        
        lhs = Vector3D(lhs.vector / rhs)
    }
  @inlinable public static func * (lhs: Spatial.AffineTransform3D, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.Pose3D, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func + (lhs: Spatial.Size3D, rhs: Spatial.Vector3D) -> Spatial.Size3D {
        
        return Size3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func + (lhs: Spatial.Vector3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        
        return Size3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Size3D, rhs: Spatial.Vector3D) -> Spatial.Size3D {
        
        return Size3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Vector3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        
        return Size3D(lhs.vector - rhs.vector)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D {
  @inlinable public static func * (lhs: Spatial.Pose3D, rhs: Spatial.Ray3D) -> Spatial.Ray3D {

        return rhs.applying(lhs)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public static func += (lhs: inout Spatial.Point3D, rhs: Spatial.Vector3D) {

        lhs = Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Point3D, rhs: Spatial.Vector3D) {

        lhs = Point3D(lhs.vector - rhs.vector)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  @inlinable public static func += (lhs: inout Spatial.Size3D, rhs: Spatial.Vector3D) {

        lhs = Size3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Size3D, rhs: Spatial.Vector3D) {

        lhs = Size3D(lhs.vector - rhs.vector)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D {
  @inlinable public static func * (lhs: Spatial.Pose3D, rhs: Spatial.Pose3D) -> Spatial.Pose3D {
        return __SPPose3DConcatenation(lhs, rhs)
    }
  @inlinable public static func *= (lhs: inout Spatial.Pose3D, rhs: Spatial.Pose3D) {
        
        lhs = lhs.concatenating(rhs)
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Rotation3D {
  @inlinable public static func * (lhs: Spatial.Rotation3D, rhs: Swift.Double) -> Spatial.Rotation3D {

            return Rotation3D.slerp(
                from: .identity,
                to: lhs,
                t: rhs,
                along: lhs.quaternion.real >= 0 ? .shortest : .longest)
    }
  @inlinable public static func * (lhs: Swift.Double, rhs: Spatial.Rotation3D) -> Spatial.Rotation3D {

        return rhs * lhs
    }
  @inlinable public static func * (lhs: Spatial.Rotation3D, rhs: Spatial.Rotation3D) -> Spatial.Rotation3D {

        return Rotation3D(lhs.quaternion * rhs.quaternion)
    }
  @inlinable public static func *= (lhs: inout Spatial.Rotation3D, rhs: Spatial.Rotation3D) {
        lhs = rhs.rotated(by: lhs)
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Angle2D : Swift.AdditiveArithmetic {
  @inlinable prefix public static func - (angle: Spatial.Angle2D) -> Spatial.Angle2D {
        return __SPAngleNegate(angle)
    }
  @inlinable prefix public static func + (angle: Spatial.Angle2D) -> Spatial.Angle2D {
        return angle
    }
  @inlinable public static func + (lhs: Spatial.Angle2D, rhs: Spatial.Angle2D) -> Spatial.Angle2D {
        return Angle2D(radians: lhs.radians + rhs.radians)
    }
  @inlinable public static func += (lhs: inout Spatial.Angle2D, rhs: Spatial.Angle2D) {
        lhs = lhs + rhs
    }
  @inlinable public static func - (lhs: Spatial.Angle2D, rhs: Spatial.Angle2D) -> Spatial.Angle2D {
        return Angle2D(radians: lhs.radians - rhs.radians)
    }
  @inlinable public static func -= (lhs: inout Spatial.Angle2D, rhs: Spatial.Angle2D) {
        lhs = lhs - rhs
    }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D {
  @inlinable public static func * (lhs: Spatial.ScaledPose3D, rhs: Spatial.Pose3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DConcatenation(lhs, rhs)
    }
  @inlinable public static func * (lhs: Spatial.ScaledPose3D, rhs: Spatial.ScaledPose3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DConcatenation(lhs, rhs)
    }
  @inlinable public static func * (lhs: Spatial.Pose3D, rhs: Spatial.ScaledPose3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DConcatenation(lhs, rhs)
    }
  @inlinable public static func *= (lhs: inout Spatial.ScaledPose3D, rhs: Spatial.ScaledPose3D) {
        
        lhs = lhs.concatenating(rhs)
    }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D {
  @inlinable public init(position: Spatial.Point3D = .zero, rotation: Spatial.Rotation3D, scale: Swift.Double = 1) {
        
        self = __SPScaledPose3DMake(position, rotation, scale)
    }
  @inlinable public init(position: simd.simd_double3 = .zero, rotation: simd.simd_quatd, scale: Swift.Double = 1) {
        
        self = __SPScaledPose3DMakeWithVector(position, rotation, scale)
    }
  @inlinable public init(position: simd.simd_float3 = .zero, rotation: simd.simd_quatf, scale: Swift.Float = 1) {
        
        let quaternion = simd_quatd(vector: simd_double(rotation.vector))
        
        self = __SPScaledPose3DMakeWithVector(simd_double(position),
                                              quaternion,
                                              Double(scale))
    }
  @inlinable public init(position: Spatial.Point3D = .zero, target: Spatial.Point3D, scale: Swift.Double = 1, up: Spatial.Vector3D = Vector3D(x: 0, y: 1, z: 0)) {
        
        self = __SPScaledPose3DMakeLookAt(position, target, scale, up)
    }
  @inlinable public init(forward: Spatial.Vector3D, scale: Swift.Double = 1, up: Spatial.Vector3D = Vector3D(x: 0, y: 1, z: 0)) {
        
        self = __SPScaledPose3DMakeLookAt(forward, scale, up)
    }
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public init?(transform: Spatial.AffineTransform3D) {
        
        let p = __SPScaledPose3DMakeWithAffineTransform(transform)
        
        if __SPScaledPose3DIsValid(p) {
            self = p
        } else {
            return nil
        }
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public init?(transform: Spatial.ProjectiveTransform3D) {
        
        let t = __SPScaledPose3DMakeWithProjectiveTransform(transform)
        
        if __SPScaledPose3DIsValid(t) {
            self = t
        } else {
            return nil
        }
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public init?(_ matrix: simd.simd_double4x4) {
        
        let p = __SPScaledPose3DMakeWith4x4Matrix(matrix)
        
        if __SPScaledPose3DIsValid(p) {
            self = p
        } else {
            return nil
        }
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public init?(_ matrix: simd.simd_float4x4) {
        
        let m = simd_double4x4(simd_double(matrix.columns.0),
                               simd_double(matrix.columns.1),
                               simd_double(matrix.columns.2),
                               simd_double(matrix.columns.3))
        
        let p = __SPScaledPose3DMakeWith4x4Matrix(m)
        
        if __SPScaledPose3DIsValid(p) {
            self = p
        } else {
            return nil
        }
    }
  #endif
  @inlinable public var matrix: simd.simd_double4x4 {
    get {
        return __SPScaledPose3DGet4x4Matrix(self)
    }
  }
  @inlinable public var inverse: Spatial.ScaledPose3D {
    get {
        return __SPScaledPose3DGetInverse(self)
    }
  }
  @inlinable public func concatenating(_ transform: Spatial.ScaledPose3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DConcatenation(self, transform)
    }
  @inlinable public func concatenating(_ transform: Spatial.Pose3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DConcatenation(self, transform)
    }
  @inlinable public static var identity: Spatial.ScaledPose3D {
    get {
        return __SPScaledPose3DIdentity
    }
  }
  @inlinable public func flipped(along axis: Spatial.Axis3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DFlip(self, axis)
    }
  public mutating func flip(along axis: Spatial.Axis3D)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D : Spatial.Translatable3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.ScaledPose3D {
        return self.translated(by: Vector3D(size))
    }
  @inlinable public func translated(by offset: Spatial.Vector3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DTranslate(self, offset)
    }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D : Spatial.Rotatable3D {
  @inlinable public func rotated(by rotation: Spatial.Rotation3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DRotate(self, rotation)
    }
  @inlinable public func rotated(by quaternion: simd.simd_quatd) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DRotateByQuaternion(self, quaternion)
    }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D : @unchecked Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.ScaledPose3D, rhs: Spatial.ScaledPose3D) -> Swift.Bool {
        return __SPScaledPose3DEqualToPose(lhs, rhs)
    }
  @inlinable public func isApproximatelyEqual(to other: Spatial.ScaledPose3D, tolerance: Swift.Double = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPScaledPose3DAlmostEqualToPose(self, other, tolerance)
    }
  @inlinable public var isIdentity: Swift.Bool {
    get {
        return __SPScaledPose3DIsIdentity(self)
    }
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Pose3D {
  @inlinable public func concatenating(_ transform: Spatial.ScaledPose3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DConcatenation(self, transform)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D {
  @inlinable public init(position: Spatial.Point3D = .zero, rotation: Spatial.Rotation3D) {
        
        self = __SPPose3DMake(position, rotation)
    }
  @inlinable public init(position: simd.simd_double3 = .zero, rotation: simd.simd_quatd) {
        
        self = __SPPose3DMakeWithVector(position, rotation)
    }
  @inlinable public init(position: simd.simd_float3 = .zero, rotation: simd.simd_quatf) {
        
        let quaternion = simd_quatd(vector: simd_double(rotation.vector))
        
        self = __SPPose3DMakeWithVector(simd_double(position),
                                        quaternion)
    }
  @inlinable public init(position: Spatial.Point3D = .zero, target: Spatial.Point3D, up: Spatial.Vector3D = Vector3D(x: 0, y: 1, z: 0)) {
        
        self = __SPPose3DMakeLookAt(position, target, up)
    }
  @inlinable public init(forward: Spatial.Vector3D, up: Spatial.Vector3D = Vector3D(x: 0, y: 1, z: 0)) {
        
        self = __SPPose3DMakeLookAt(forward, up)
    }
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public init?(transform: Spatial.AffineTransform3D) {
        
        let p = __SPPose3DMakeWithAffineTransform(transform)
        
        if __SPPose3DIsValid(p) {
            self = p
        } else {
            return nil
        }
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public init?(transform: Spatial.ProjectiveTransform3D) {
        
        let t = __SPPose3DMakeWithProjectiveTransform(transform)
        
        if __SPPose3DIsValid(t) {
            self = t
        } else {
            return nil
        }
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public init?(_ matrix: simd.simd_double4x4) {
        
        let p = __SPPose3DMakeWith4x4Matrix(matrix)
        
        if __SPPose3DIsValid(p) {
            self = p
        } else {
            return nil
        }
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public init?(_ matrix: simd.simd_float4x4) {
        
        let m = simd_double4x4(simd_double(matrix.columns.0),
                               simd_double(matrix.columns.1),
                               simd_double(matrix.columns.2),
                               simd_double(matrix.columns.3))
        
        let p = __SPPose3DMakeWith4x4Matrix(m)
        
        if __SPPose3DIsValid(p) {
            self = p
        } else {
            return nil
        }
    }
  #endif
  @inlinable public var matrix: simd.simd_double4x4 {
    get {
        return __SPPose3DGet4x4Matrix(self)
    }
  }
  @inlinable public var inverse: Spatial.Pose3D {
    get {
        return __SPPose3DGetInverse(self)
    }
  }
  @inlinable public func concatenating(_ transform: Spatial.Pose3D) -> Spatial.Pose3D {
        return __SPPose3DConcatenation(self, transform)
    }
  @inlinable public static var identity: Spatial.Pose3D {
    get {
        return __SPPose3DIdentity
    }
  }
  @inlinable public func flipped(along axis: Spatial.Axis3D) -> Spatial.Pose3D {
        return __SPPose3DFlip(self, axis)
    }
  public mutating func flip(along axis: Spatial.Axis3D)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D : Spatial.Translatable3D {
  @inlinable public func translated(by offset: Spatial.Vector3D) -> Spatial.Pose3D {
        return __SPPose3DTranslate(self, offset)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D : Spatial.Rotatable3D {
  @inlinable public func rotated(by rotation: Spatial.Rotation3D) -> Spatial.Pose3D {
        return __SPPose3DRotate(self, rotation)
    }
  @inlinable public func rotated(by quaternion: simd.simd_quatd) -> Spatial.Pose3D {
        return __SPPose3DRotateByQuaternion(self, quaternion)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Pose3D, rhs: Spatial.Pose3D) -> Swift.Bool {
        return __SPPose3DEqualToPose(lhs, rhs)
    }
  @inlinable public func isApproximatelyEqual(to other: Spatial.Pose3D, tolerance: Swift.Double = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPPose3DAlmostEqualToPose(self, other, tolerance)
    }
  @inlinable public var isIdentity: Swift.Bool {
    get {
        return __SPPose3DIsIdentity(self)
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Pose3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.SphericalCoordinates3D : @unchecked Swift.Sendable {
  public init(x: Swift.Double, y: Swift.Double, z: Swift.Double)
  public init(_ vector: simd.simd_double3)
  public init(_ point: Spatial.Point3D)
  public init(_ vector: Spatial.Vector3D)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Point3D {
  public init(_ coords: Spatial.SphericalCoordinates3D)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Vector3D {
  public init(_ coords: Spatial.SphericalCoordinates3D)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.SphericalCoordinates3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.SphericalCoordinates3D, rhs: Spatial.SphericalCoordinates3D) -> Swift.Bool {
        
        return lhs.radius == rhs.radius && lhs.inclination == rhs.inclination && lhs.azimuth == rhs.azimuth
    }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.SphericalCoordinates3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.SphericalCoordinates3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.SphericalCoordinates3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.SphericalCoordinates3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.SphericalCoordinates3DFloat : @unchecked Swift.Sendable {
  public init(x: Swift.Float, y: Swift.Float, z: Swift.Float)
  public init(_ vector: simd.simd_float3)
  public init(_ point: Spatial.Point3DFloat)
  public init(_ vector: Spatial.Vector3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat {
  public init(_ coords: Spatial.SphericalCoordinates3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat {
  public init(_ coords: Spatial.SphericalCoordinates3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.SphericalCoordinates3DFloat : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.SphericalCoordinates3DFloat, rhs: Spatial.SphericalCoordinates3DFloat) -> Swift.Bool {
        
        return lhs.radius == rhs.radius && lhs.inclination == rhs.inclination && lhs.azimuth == rhs.azimuth
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.SphericalCoordinates3DFloat : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.SphericalCoordinates3DFloat : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.SphericalCoordinates3DFloat : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.SphericalCoordinates3DFloat : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat {
  public init(_ source: simd.simd_packed_float4)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat {
  public init(_ source: simd.simd_packed_float4)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat {
  public init(_ source: simd.simd_packed_float4)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.SphericalCoordinates3DFloat {
  public init(_ source: simd.simd_packed_float4)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotation3DFloat {
  public init(_ source: simd.simd_packed_float4)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.RotationAxis3DFloat {
  public init(_ source: simd.simd_packed_float4)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Swift.SIMD4 where Scalar == Swift.Float {
  public init(_ point: Spatial.Point3DFloat)
  public init(_ vector: Spatial.Vector3DFloat)
  public init(_ size: Spatial.Size3DFloat)
  public init(_ point: Spatial.SphericalCoordinates3DFloat)
  public init(_ point: Spatial.Rotation3DFloat)
  public init(_ point: Spatial.RotationAxis3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3D {
  public init(_ source: simd.simd_packed_double4)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3D {
  public init(_ source: simd.simd_packed_double4)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3D {
  public init(_ source: simd.simd_packed_double4)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.SphericalCoordinates3D {
  public init(_ source: simd.simd_packed_double4)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotation3D {
  public init(_ source: simd.simd_packed_double4)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.RotationAxis3D {
  public init(_ source: simd.simd_packed_double4)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Swift.SIMD4 where Scalar == Swift.Double {
  public init(_ point: Spatial.Point3D)
  public init(_ vector: Spatial.Vector3D)
  public init(_ size: Spatial.Size3D)
  public init(_ point: Spatial.SphericalCoordinates3D)
  public init(_ point: Spatial.Rotation3D)
  public init(_ point: Spatial.RotationAxis3D)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat : @unchecked Swift.Sendable {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat {
  @inlinable public func unapplying(_ transform: Spatial.AffineTransform3DFloat) -> Spatial.Rect3DFloat {
        
        let unapplied = __SPRect3DFloatUnapplyAffineTransform(self, transform)
        
        if unapplied.isNull {
            return self
        } else {
            return unapplied
        }
    }
  @inlinable public func unapplying(_ transform: Spatial.ProjectiveTransform3DFloat) -> Spatial.Rect3DFloat {
        
        let unapplied = __SPRect3DFloatUnapplyProjectiveTransform(self, transform)
        
        if unapplied.isNull {
            return self
        } else {
            return unapplied
        }
    }
  public func applying(_ pose: Spatial.Pose3DFloat) -> Spatial.Rect3DFloat
  public func unapplying(_ pose: Spatial.Pose3DFloat) -> Spatial.Rect3DFloat
  public func applying(_ scaledPose: Spatial.ScaledPose3DFloat) -> Spatial.Rect3DFloat
  public func unapplying(_ scaledPose: Spatial.ScaledPose3DFloat) -> Spatial.Rect3DFloat
  @inlinable public func scaledBy(x: Swift.Float = 1, y: Swift.Float = 1, z: Swift.Float = 1) -> Spatial.Rect3DFloat {
        
        return __SPRect3DFloatScaleBy(self, x, y, z)
    }
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.Rect3DFloat {
        
        return _shear(shearFunc: __SPRect3DFloatShear,
                      shear: shear)
    }
  @usableFromInline
  internal func _shear(shearFunc: (Spatial.Rect3DFloat, Spatial.Axis3D, Swift.Float, Swift.Float) -> Spatial.Rect3DFloat, shear: Spatial.AxisWithFactors) -> Spatial.Rect3DFloat
  @inlinable public func contains(anyOf points: [Spatial.Point3DFloat]) -> Swift.Bool {
        return __SPRect3DFloatContainsAnyPoint(self,
                                          points,
                                          Int32(points.count))
    }
  @inlinable public mutating func formInset(by dXYZ: Spatial.Size3DFloat) {
        
        self = self.inset(by: dXYZ)
    }
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public func intersection(_ other: Spatial.Rect3DFloat) -> Spatial.Rect3DFloat? {
        let intersection = __SPRect3DFloatIntersection(self, other)
        
        if intersection.origin.isFinite {
            return intersection
        } else {
            return nil
        }
    }
  #endif
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Rect3DFloat, rhs: Spatial.Rect3DFloat) -> Swift.Bool {
        return lhs.origin == rhs.origin && lhs.size == rhs.size
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat {
  public init(origin: simd.simd_float3 = .zero, size: simd.simd_float3)
  public init(origin: Spatial.Vector3DFloat = .zero, size: Spatial.Vector3DFloat)
  public init(center: simd.simd_float3 = .zero, size: simd.simd_float3)
  public init(center: Spatial.Vector3DFloat = .zero, size: Spatial.Vector3DFloat)
  public init(points: [Spatial.Point3DFloat])
  public var cornerPoints: [Spatial.Point3DFloat] {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.RotationAxis3DFloat : @unchecked Swift.Sendable {
  public static let x: Spatial.RotationAxis3DFloat
  public static let y: Spatial.RotationAxis3DFloat
  public static let z: Spatial.RotationAxis3DFloat
  public static let xy: Spatial.RotationAxis3DFloat
  public static let yz: Spatial.RotationAxis3DFloat
  public static let xz: Spatial.RotationAxis3DFloat
  public static let xyz: Spatial.RotationAxis3DFloat
  @inlinable public init(x: Swift.Float = 0, y: Swift.Float = 0, z: Swift.Float = 0) {
        self = __SPRotationAxis3DFloatMake(x, y, z)
    }
  @inlinable public var x: Swift.Float {
    get {
            return self.__x
        }
    set {
            self.__x = newValue
        }
  }
  @inlinable public var y: Swift.Float {
    get {
            return self.__y
        }
    set {
            self.__y = newValue
        }
  }
  @inlinable public var z: Swift.Float {
    get {
            return self.__z
        }
    set {
            self.__z = newValue
        }
  }
  @inlinable public init(_ xyz: simd.simd_float3) {
        self = __SPRotationAxis3DFloatMakeWithVector(xyz)
    }
  @inlinable public init(_ xyz: Spatial.Vector3DFloat) {
        self = __SPRotationAxis3DFloatMakeWithVector(xyz)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.RotationAxis3DFloat : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.RotationAxis3DFloat, rhs: Spatial.RotationAxis3DFloat) -> Swift.Bool {
        return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.RotationAxis3DFloat : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.RotationAxis3DFloat : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.RotationAxis3DFloat : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.RotationAxis3DFloat : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Angle2DFloat {
  @inlinable public init<T>(radians: T) where T : Swift.BinaryFloatingPoint {
        self.init(radians: Float(radians))
    }
  @inlinable public init<T>(degrees: T) where T : Swift.BinaryFloatingPoint {
        self.init(degrees: Float(degrees))
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.RotationAxis3DFloat {
  @inlinable public init(_ xyz: simd.simd_double3) {
        self.init(simd_float3(Float(xyz.x),
                              Float(xyz.y),
                              Float(xyz.z)))
    }
  @inlinable public init<T>(x: T, y: T, z: T) where T : Swift.BinaryFloatingPoint {
        self.init(x: Float(x),
                  y: Float(y),
                  z: Float(z))
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Swift.SIMD3 where Scalar == Swift.Double {
  @inlinable public init(_ rotationAxis: Spatial.RotationAxis3DFloat) {
        self.init(x: Double(rotationAxis.x),
                  y: Double(rotationAxis.y),
                  z: Double(rotationAxis.z))
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotation3DFloat {
  @inlinable public init(_ quaternion: simd.simd_quatd) {
        
        let q = simd_quatf(vector: simd_float(quaternion.vector))
        
        self.init(q)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension simd.simd_quatd {
  @inlinable public init(_ rotation: Spatial.Rotation3DFloat) {
        
        self.init(vector: simd_double(rotation.quaternion.vector))
        
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat {
  @inlinable public init(_ xyz: simd.simd_double3) {
        self.init(simd_float3(Float(xyz.x),
                              Float(xyz.y),
                              Float(xyz.z)))
    }
  @inlinable public init<T>(x: T, y: T, z: T) where T : Swift.BinaryFloatingPoint {
        self.init(x: Float(x),
                  y: Float(y),
                  z: Float(z))
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Swift.SIMD3 where Scalar == Swift.Double {
  @inlinable public init(_ point: Spatial.Point3DFloat) {
        self.init(x: Double(point.x),
                  y: Double(point.y),
                  z: Double(point.z))
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat {
  @inlinable public init(_ xyz: simd.simd_double3) {
        self.init(simd_float3(Float(xyz.x),
                              Float(xyz.y),
                              Float(xyz.z)))
    }
  @inlinable public init<T>(x: T, y: T, z: T) where T : Swift.BinaryFloatingPoint {
        self.init(x: Float(x),
                  y: Float(y),
                  z: Float(z))
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Swift.SIMD3 where Scalar == Swift.Double {
  @inlinable public init(_ vector: Spatial.Vector3DFloat) {
        self.init(x: Double(vector.x),
                  y: Double(vector.y),
                  z: Double(vector.z))
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat {
  @inlinable public init(_ xyz: simd.simd_double3) {
        self.init(simd_float3(Float(xyz.x),
                              Float(xyz.y),
                              Float(xyz.z)))
    }
  @inlinable public init<T>(width: T, height: T, depth: T) where T : Swift.BinaryFloatingPoint {
        self.init(width: Float(width),
                  height: Float(height),
                  depth: Float(depth))
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Swift.SIMD3 where Scalar == Swift.Double {
  @inlinable public init(_ size: Spatial.Size3DFloat) {
        self.init(x: Double(size.width),
                  y: Double(size.height),
                  z: Double(size.depth))
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat {
  @inlinable public init(origin: simd.simd_double3 = .zero, size: simd.simd_double3) {
        
        let o = simd_float3(Float(origin.x),
                            Float(origin.y),
                            Float(origin.z))
        
        let s = simd_float3(Float(size.x),
                            Float(size.y),
                            Float(size.z))
        
        self = __SPRect3DFloatMakeAtOriginWithVector(o, s)
    }
  @inlinable public init(center: simd.simd_double3 = .zero, size: simd.simd_double3) {
        
        let c = simd_float3(Float(center.x),
                            Float(center.y),
                            Float(center.z))
        
        let s = simd_float3(Float(size.x),
                            Float(size.y),
                            Float(size.z))
        
        
        self = __SPRect3DFloatMakeAtCenterWithVector(c, s)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat {
  @inlinable public init(_ matrix: simd.simd_double4x3) {
        
        let column0 = matrix.columns.0
        let column1 = matrix.columns.1
        let column2 = matrix.columns.2
        let column3 = matrix.columns.3
        
        let m = simd_float4x3([
            simd_float3(Float(column0.x), Float(column0.y), Float(column0.z)),
            simd_float3(Float(column1.x), Float(column1.y), Float(column1.z)),
            simd_float3(Float(column2.x), Float(column2.y), Float(column2.z)),
            simd_float3(Float(column3.x), Float(column3.y), Float(column3.z))
        ])
        
        self.init(m)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat {
  @inlinable public init(truncating matrix: simd.simd_double4x4) {
        
        let m = simd_float4x4([
            simd_float(matrix.columns.0),
            simd_float(matrix.columns.1),
            simd_float(matrix.columns.2),
            simd_float(matrix.columns.3)])
        
        self = .init(truncating: m)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension simd.simd_double4x3 {
  @inlinable public init(_ affineTransform: Spatial.AffineTransform3DFloat) {
        
        let column0 = affineTransform.matrix.columns.0
        let column1 = affineTransform.matrix.columns.1
        let column2 = affineTransform.matrix.columns.2
        let column3 = affineTransform.matrix.columns.3
        
        self.init([
            simd_double3(Double(column0.x), Double(column0.y), Double(column0.z)),
            simd_double3(Double(column1.x), Double(column1.y), Double(column1.z)),
            simd_double3(Double(column2.x), Double(column2.y), Double(column2.z)),
            simd_double3(Double(column3.x), Double(column3.y), Double(column3.z))
        ])
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat {
  @inlinable public init(_ matrix: simd.simd_double4x4) {
        
        let column0 = matrix.columns.0
        let column1 = matrix.columns.1
        let column2 = matrix.columns.2
        let column3 = matrix.columns.3
        
        let m = simd_float4x4([
            simd_float4(Float(column0.x), Float(column0.y),
                        Float(column0.z), Float(column0.w)),
            
            simd_float4(Float(column1.x), Float(column1.y),
                        Float(column1.z), Float(column1.w)),
            
            simd_float4(Float(column2.x), Float(column2.y),
                        Float(column2.z), Float(column2.w)),
            
            simd_float4(Float(column3.x), Float(column3.y),
                        Float(column3.z), Float(column3.w))
        ])
        
        self.init(m)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension simd.simd_double4x4 {
  @inlinable public init(_ projectiveTransform: Spatial.ProjectiveTransform3DFloat) {
        
        self.init(simd_double(projectiveTransform.matrix.columns.0),
                  simd_double(projectiveTransform.matrix.columns.1),
                  simd_double(projectiveTransform.matrix.columns.2),
                  simd_double(projectiveTransform.matrix.columns.3))
    }
  @inlinable public init(_ affineTransform: Spatial.AffineTransform3DFloat) {
        let m = affineTransform.matrix4x4
        self.init(simd_double(m.columns.0),
                  simd_double(m.columns.1),
                  simd_double(m.columns.2),
                  simd_double(m.columns.3))
    }
  @inlinable public init(_ pose: Spatial.Pose3DFloat) {
        let m = pose.matrix
        self.init(simd_double(m.columns.0),
                  simd_double(m.columns.1),
                  simd_double(m.columns.2),
                  simd_double(m.columns.3))
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Angle2DFloat {
  public init(degrees: Swift.Float)
  public var degrees: Swift.Float {
    get
  }
  @inlinable public static func radians(_ radians: Swift.Float) -> Spatial.Angle2DFloat {
        return Angle2DFloat(radians: radians)
    }
  @inlinable public static func degrees(_ degrees: Swift.Float) -> Spatial.Angle2DFloat {
        return Angle2DFloat(degrees: degrees)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Angle2DFloat : @unchecked Swift.Sendable {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Angle2DFloat : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Angle2DFloat, rhs: Spatial.Angle2DFloat) -> Swift.Bool {
        return lhs.radians == rhs.radians
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Angle2DFloat : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Angle2DFloat : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Angle2DFloat : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Angle2DFloat : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Angle2DFloat {
  @inlinable public var normalized: Spatial.Angle2DFloat {
    get {
        return __SPAngleFloatNormalize(self)
    }
  }
  @inlinable public static func acos(_ x: Swift.Float) -> Spatial.Angle2DFloat {
        return __SPAngleFloatAcos(x)
    }
  @inlinable public static func asin(_ x: Swift.Float) -> Spatial.Angle2DFloat {
        return __SPAngleFloatAsin(x)
    }
  @inlinable public static func atan(_ x: Swift.Float) -> Spatial.Angle2DFloat {
        return __SPAngleFloatAtan(x)
    }
  @inlinable public static func acosh(_ x: Swift.Float) -> Spatial.Angle2DFloat {
        return __SPAngleFloatAcosh(x)
    }
  @inlinable public static func asinh(_ x: Swift.Float) -> Spatial.Angle2DFloat {
        return __SPAngleFloatAsinh(x)
    }
  @inlinable public static func atanh(_ x: Swift.Float) -> Spatial.Angle2DFloat {
        return __SPAngleFloatAtanh(x)
    }
  @inlinable public static func atan2(y: Swift.Float, x: Swift.Float) -> Spatial.Angle2DFloat {
        return __SPAngleFloatAtan2(y, x)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@inlinable public func cos(_ angle: Spatial.Angle2DFloat) -> Swift.Float {
    return __SPAngleFloatCos(angle)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@inlinable public func sin(_ angle: Spatial.Angle2DFloat) -> Swift.Float {
    return __SPAngleFloatSin(angle)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@inlinable public func tan(_ angle: Spatial.Angle2DFloat) -> Swift.Float {
    return __SPAngleFloatTan(angle)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@inlinable public func cosh(_ angle: Spatial.Angle2DFloat) -> Swift.Float {
    return __SPAngleFloatCosh(angle)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@inlinable public func sinh(_ angle: Spatial.Angle2DFloat) -> Swift.Float {
    return __SPAngleFloatSinh(angle)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@inlinable public func tanh(_ angle: Spatial.Angle2DFloat) -> Swift.Float {
    return __SPAngleFloatTanh(angle)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Angle2DFloat : Swift.Comparable {
  public static func < (lhs: Spatial.Angle2DFloat, rhs: Spatial.Angle2DFloat) -> Swift.Bool
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Angle2D {
  @inlinable public static func radians(_ radians: Swift.Double) -> Spatial.Angle2D {
        return Angle2D(radians: radians)
    }
  @inlinable public static func degrees(_ degrees: Swift.Double) -> Spatial.Angle2D {
        return Angle2D(degrees: degrees)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Angle2D, rhs: Spatial.Angle2D) -> Swift.Bool {
        return lhs.radians == rhs.radians
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Angle2D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Angle2D {
  @inlinable public var normalized: Spatial.Angle2D {
    get {
        return __SPAngleNormalize(self)
    }
  }
  @inlinable public static func acos(_ x: Swift.Double) -> Spatial.Angle2D {
        return __SPAngleAcos(x)
    }
  @inlinable public static func asin(_ x: Swift.Double) -> Spatial.Angle2D {
        return __SPAngleAsin(x)
    }
  @inlinable public static func atan(_ x: Swift.Double) -> Spatial.Angle2D {
        return __SPAngleAtan(x)
    }
  @inlinable public static func acosh(_ x: Swift.Double) -> Spatial.Angle2D {
        return __SPAngleAcosh(x)
    }
  @inlinable public static func asinh(_ x: Swift.Double) -> Spatial.Angle2D {
        return __SPAngleAsinh(x)
    }
  @inlinable public static func atanh(_ x: Swift.Double) -> Spatial.Angle2D {
        return __SPAngleAtanh(x)
    }
  @inlinable public static func atan2(y: Swift.Double, x: Swift.Double) -> Spatial.Angle2D {
        return __SPAngleAtan2(y, x)
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
@inlinable public func cos(_ angle: Spatial.Angle2D) -> Swift.Double {
    return __SPAngleCos(angle)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
@inlinable public func sin(_ angle: Spatial.Angle2D) -> Swift.Double {
    return __SPAngleSin(angle)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
@inlinable public func tan(_ angle: Spatial.Angle2D) -> Swift.Double {
    return __SPAngleTan(angle)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
@inlinable public func cosh(_ angle: Spatial.Angle2D) -> Swift.Double {
    return __SPAngleCosh(angle)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
@inlinable public func sinh(_ angle: Spatial.Angle2D) -> Swift.Double {
    return __SPAngleSinh(angle)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
@inlinable public func tanh(_ angle: Spatial.Angle2D) -> Swift.Double {
    return __SPAngleTanh(angle)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Angle2D : Swift.Comparable {
  public static func < (lhs: Spatial.Angle2D, rhs: Spatial.Angle2D) -> Swift.Bool
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.CoordinateSpace3D {
  public func transformSpace(_ baseFromMapTransform: @escaping (Self) -> Spatial.ProjectiveTransform3D) -> some Spatial.CoordinateSpace3D
  
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.CoordinateSpace3DFloat {
  public func transformSpace(_ baseFromMapTransform: @escaping (Self) -> Spatial.ProjectiveTransform3DFloat) -> some Spatial.CoordinateSpace3DFloat
  
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public protocol SpatialTypeProtocol<Scalar> : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  associatedtype Scalar : Swift.Numeric where Self.Scalar == Self.AffineTransform.Scalar, Self.AffineTransform.Scalar == Self.Point.Scalar, Self.Point.Scalar == Self.Pose.Scalar, Self.Pose.Scalar == Self.ProjectiveTransform.Scalar, Self.ProjectiveTransform.Scalar == Self.Rect.Scalar, Self.Rect.Scalar == Self.Rotation.Scalar, Self.Rotation.Scalar == Self.Size.Scalar, Self.Size.Scalar == Self.Vector.Scalar
  associatedtype AffineTransform : Spatial.Transform3DProtocol
  associatedtype ProjectiveTransform : Spatial.Transform3DProtocol
  associatedtype Pose : Spatial.Rotatable3DProtocol, Spatial.Translatable3DProtocol
  associatedtype Rect : Spatial.Primitive3DProtocol
  associatedtype Vector : Spatial.Primitive3DProtocol
  associatedtype Point : Spatial.Primitive3DProtocol
  associatedtype Size : Spatial.Primitive3DProtocol
  associatedtype Rotation : Spatial.Rotatable3DProtocol
  associatedtype Quaternion
  associatedtype AxisEnumeration
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Float
  public typealias AffineTransform = Spatial.AffineTransform3DFloat
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3DFloat
  public typealias Pose = Spatial.Pose3DFloat
  public typealias Rect = Spatial.Rect3DFloat
  public typealias Vector = Spatial.Vector3DFloat
  public typealias Point = Spatial.Point3DFloat
  public typealias Size = Spatial.Size3DFloat
  public typealias Rotation = Spatial.Rotation3DFloat
  public typealias Quaternion = simd.simd_quatf
  public typealias AxisEnumeration = Spatial.AxisWithFactorsFloat
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Float
  public typealias AffineTransform = Spatial.AffineTransform3DFloat
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3DFloat
  public typealias Pose = Spatial.Pose3DFloat
  public typealias Rect = Spatial.Rect3DFloat
  public typealias Vector = Spatial.Vector3DFloat
  public typealias Point = Spatial.Point3DFloat
  public typealias Size = Spatial.Size3DFloat
  public typealias Rotation = Spatial.Rotation3DFloat
  public typealias Quaternion = simd.simd_quatf
  public typealias AxisEnumeration = Spatial.AxisWithFactorsFloat
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3DFloat : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Float
  public typealias AffineTransform = Spatial.AffineTransform3DFloat
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3DFloat
  public typealias Pose = Spatial.Pose3DFloat
  public typealias Rect = Spatial.Rect3DFloat
  public typealias Vector = Spatial.Vector3DFloat
  public typealias Point = Spatial.Point3DFloat
  public typealias Size = Spatial.Size3DFloat
  public typealias Rotation = Spatial.Rotation3DFloat
  public typealias Quaternion = simd.simd_quatf
  public typealias AxisEnumeration = Spatial.AxisWithFactorsFloat
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Float
  public typealias AffineTransform = Spatial.AffineTransform3DFloat
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3DFloat
  public typealias Pose = Spatial.Pose3DFloat
  public typealias Rect = Spatial.Rect3DFloat
  public typealias Vector = Spatial.Vector3DFloat
  public typealias Point = Spatial.Point3DFloat
  public typealias Size = Spatial.Size3DFloat
  public typealias Rotation = Spatial.Rotation3DFloat
  public typealias Quaternion = simd.simd_quatf
  public typealias AxisEnumeration = Spatial.AxisWithFactorsFloat
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Float
  public typealias AffineTransform = Spatial.AffineTransform3DFloat
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3DFloat
  public typealias Pose = Spatial.Pose3DFloat
  public typealias Rect = Spatial.Rect3DFloat
  public typealias Vector = Spatial.Vector3DFloat
  public typealias Point = Spatial.Point3DFloat
  public typealias Size = Spatial.Size3DFloat
  public typealias Rotation = Spatial.Rotation3DFloat
  public typealias Quaternion = simd.simd_quatf
  public typealias AxisEnumeration = Spatial.AxisWithFactorsFloat
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Float
  public typealias AffineTransform = Spatial.AffineTransform3DFloat
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3DFloat
  public typealias Pose = Spatial.Pose3DFloat
  public typealias Rect = Spatial.Rect3DFloat
  public typealias Vector = Spatial.Vector3DFloat
  public typealias Point = Spatial.Point3DFloat
  public typealias Size = Spatial.Size3DFloat
  public typealias Rotation = Spatial.Rotation3DFloat
  public typealias Quaternion = simd.simd_quatf
  public typealias AxisEnumeration = Spatial.AxisWithFactorsFloat
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3DFloat : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Float
  public typealias AffineTransform = Spatial.AffineTransform3DFloat
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3DFloat
  public typealias Pose = Spatial.Pose3DFloat
  public typealias Rect = Spatial.Rect3DFloat
  public typealias Vector = Spatial.Vector3DFloat
  public typealias Point = Spatial.Point3DFloat
  public typealias Size = Spatial.Size3DFloat
  public typealias Rotation = Spatial.Rotation3DFloat
  public typealias Quaternion = simd.simd_quatf
  public typealias AxisEnumeration = Spatial.AxisWithFactorsFloat
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Float
  public typealias AffineTransform = Spatial.AffineTransform3DFloat
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3DFloat
  public typealias Pose = Spatial.Pose3DFloat
  public typealias Rect = Spatial.Rect3DFloat
  public typealias Vector = Spatial.Vector3DFloat
  public typealias Point = Spatial.Point3DFloat
  public typealias Size = Spatial.Size3DFloat
  public typealias Rotation = Spatial.Rotation3DFloat
  public typealias Quaternion = simd.simd_quatf
  public typealias AxisEnumeration = Spatial.AxisWithFactorsFloat
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ScaledPose3DFloat : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Float
  public typealias AffineTransform = Spatial.AffineTransform3DFloat
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3DFloat
  public typealias Pose = Spatial.Pose3DFloat
  public typealias Rect = Spatial.Rect3DFloat
  public typealias Vector = Spatial.Vector3DFloat
  public typealias Point = Spatial.Point3DFloat
  public typealias Size = Spatial.Size3DFloat
  public typealias Rotation = Spatial.Rotation3DFloat
  public typealias Quaternion = simd.simd_quatf
  public typealias AxisEnumeration = Spatial.AxisWithFactorsFloat
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotation3DFloat : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Float
  public typealias AffineTransform = Spatial.AffineTransform3DFloat
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3DFloat
  public typealias Pose = Spatial.Pose3DFloat
  public typealias Rect = Spatial.Rect3DFloat
  public typealias Vector = Spatial.Vector3DFloat
  public typealias Point = Spatial.Point3DFloat
  public typealias Size = Spatial.Size3DFloat
  public typealias Rotation = Spatial.Rotation3DFloat
  public typealias Quaternion = simd.simd_quatf
  public typealias AxisEnumeration = Spatial.AxisWithFactorsFloat
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3D : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Double
  public typealias AffineTransform = Spatial.AffineTransform3D
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3D
  public typealias Pose = Spatial.Pose3D
  public typealias Rect = Spatial.Rect3D
  public typealias Vector = Spatial.Vector3D
  public typealias Point = Spatial.Point3D
  public typealias Size = Spatial.Size3D
  public typealias Rotation = Spatial.Rotation3D
  public typealias Quaternion = simd.simd_quatd
  public typealias AxisEnumeration = Spatial.AxisWithFactors
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3D : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Double
  public typealias AffineTransform = Spatial.AffineTransform3D
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3D
  public typealias Pose = Spatial.Pose3D
  public typealias Rect = Spatial.Rect3D
  public typealias Vector = Spatial.Vector3D
  public typealias Point = Spatial.Point3D
  public typealias Size = Spatial.Size3D
  public typealias Rotation = Spatial.Rotation3D
  public typealias Quaternion = simd.simd_quatd
  public typealias AxisEnumeration = Spatial.AxisWithFactors
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3D : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Double
  public typealias AffineTransform = Spatial.AffineTransform3D
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3D
  public typealias Pose = Spatial.Pose3D
  public typealias Rect = Spatial.Rect3D
  public typealias Vector = Spatial.Vector3D
  public typealias Point = Spatial.Point3D
  public typealias Size = Spatial.Size3D
  public typealias Rotation = Spatial.Rotation3D
  public typealias Quaternion = simd.simd_quatd
  public typealias AxisEnumeration = Spatial.AxisWithFactors
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3D : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Double
  public typealias AffineTransform = Spatial.AffineTransform3D
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3D
  public typealias Pose = Spatial.Pose3D
  public typealias Rect = Spatial.Rect3D
  public typealias Vector = Spatial.Vector3D
  public typealias Point = Spatial.Point3D
  public typealias Size = Spatial.Size3D
  public typealias Rotation = Spatial.Rotation3D
  public typealias Quaternion = simd.simd_quatd
  public typealias AxisEnumeration = Spatial.AxisWithFactors
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3D : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Double
  public typealias AffineTransform = Spatial.AffineTransform3D
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3D
  public typealias Pose = Spatial.Pose3D
  public typealias Rect = Spatial.Rect3D
  public typealias Vector = Spatial.Vector3D
  public typealias Point = Spatial.Point3D
  public typealias Size = Spatial.Size3D
  public typealias Rotation = Spatial.Rotation3D
  public typealias Quaternion = simd.simd_quatd
  public typealias AxisEnumeration = Spatial.AxisWithFactors
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3D : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Double
  public typealias AffineTransform = Spatial.AffineTransform3D
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3D
  public typealias Pose = Spatial.Pose3D
  public typealias Rect = Spatial.Rect3D
  public typealias Vector = Spatial.Vector3D
  public typealias Point = Spatial.Point3D
  public typealias Size = Spatial.Size3D
  public typealias Rotation = Spatial.Rotation3D
  public typealias Quaternion = simd.simd_quatd
  public typealias AxisEnumeration = Spatial.AxisWithFactors
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3D : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Double
  public typealias AffineTransform = Spatial.AffineTransform3D
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3D
  public typealias Pose = Spatial.Pose3D
  public typealias Rect = Spatial.Rect3D
  public typealias Vector = Spatial.Vector3D
  public typealias Point = Spatial.Point3D
  public typealias Size = Spatial.Size3D
  public typealias Rotation = Spatial.Rotation3D
  public typealias Quaternion = simd.simd_quatd
  public typealias AxisEnumeration = Spatial.AxisWithFactors
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Double
  public typealias AffineTransform = Spatial.AffineTransform3D
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3D
  public typealias Pose = Spatial.Pose3D
  public typealias Rect = Spatial.Rect3D
  public typealias Vector = Spatial.Vector3D
  public typealias Point = Spatial.Point3D
  public typealias Size = Spatial.Size3D
  public typealias Rotation = Spatial.Rotation3D
  public typealias Quaternion = simd.simd_quatd
  public typealias AxisEnumeration = Spatial.AxisWithFactors
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ScaledPose3D : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Double
  public typealias AffineTransform = Spatial.AffineTransform3D
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3D
  public typealias Pose = Spatial.Pose3D
  public typealias Rect = Spatial.Rect3D
  public typealias Vector = Spatial.Vector3D
  public typealias Point = Spatial.Point3D
  public typealias Size = Spatial.Size3D
  public typealias Rotation = Spatial.Rotation3D
  public typealias Quaternion = simd.simd_quatd
  public typealias AxisEnumeration = Spatial.AxisWithFactors
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotation3D : Spatial.SpatialTypeProtocol {
  public typealias Scalar = Swift.Double
  public typealias AffineTransform = Spatial.AffineTransform3D
  public typealias ProjectiveTransform = Spatial.ProjectiveTransform3D
  public typealias Pose = Spatial.Pose3D
  public typealias Rect = Spatial.Rect3D
  public typealias Vector = Spatial.Vector3D
  public typealias Point = Spatial.Point3D
  public typealias Size = Spatial.Size3D
  public typealias Rotation = Spatial.Rotation3D
  public typealias Quaternion = simd.simd_quatd
  public typealias AxisEnumeration = Spatial.AxisWithFactors
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public protocol Primitive3DProtocol<Scalar> : Spatial.Rotatable3DProtocol {
  static var zero: Self { get }
  static var infinity: Self { get }
  var isZero: Swift.Bool { get }
  var isFinite: Swift.Bool { get }
  var isNaN: Swift.Bool { get }
  func applying(_ transform: Self.AffineTransform) -> Self
  func applying(_ transform: Self.ProjectiveTransform) -> Self
  func applying(_ pose: Self.Pose) -> Self
  mutating func apply(_ transform: Self.AffineTransform)
  mutating func apply(_ transform: Self.ProjectiveTransform)
  mutating func apply(_ pose: Self.Pose)
  func unapplying(_ transform: Self.AffineTransform) -> Self
  mutating func unapply(_ transform: Self.AffineTransform)
  func unapplying(_ transform: Self.ProjectiveTransform) -> Self
  func unapplying(_ pose: Self.Pose) -> Self
  mutating func unapply(_ transform: Self.ProjectiveTransform)
  mutating func unapply(_ pose: Self.Pose)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Primitive3DProtocol where Self.Scalar == Swift.Float {
  public mutating func apply(_ transform: Self.AffineTransform)
  public mutating func apply(_ transform: Self.ProjectiveTransform)
  public mutating func apply(_ pose: Self.Pose)
  public mutating func unapply(_ transform: Self.AffineTransform)
  public mutating func unapply(_ transform: Self.ProjectiveTransform)
  public mutating func unapply(_ pose: Self.Pose)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat : Spatial.Primitive3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3DFloat : Spatial.Primitive3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat : Spatial.Primitive3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat : Spatial.Primitive3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat : Spatial.Primitive3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3D : Spatial.Primitive3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3D : Spatial.Primitive3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3D : Spatial.Primitive3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3D : Spatial.Primitive3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3D : Spatial.Primitive3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public protocol ClampableWithinRectProtocol<Scalar> : Spatial.SpatialTypeProtocol {
  func clamped(to rect: Self.Rect) -> Self
  mutating func clamp(to rect: Self.Rect)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ClampableWithinRectProtocol where Self.Scalar == Swift.Float {
  @inlinable public mutating func clamp(to rect: Self.Rect) {
        self = self.clamped(to: rect)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat : Spatial.ClampableWithinRectProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3D : Spatial.ClampableWithinRectProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public protocol Translatable3DProtocol<Scalar> : Spatial.SpatialTypeProtocol {
  func translated(by vector: Self.Vector) -> Self
  mutating func translate(by vector: Self.Vector)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Translatable3DProtocol where Self.Scalar == Swift.Float {
  @inlinable public func translated(by vector: Self.Vector) -> Self {
        return self.translated(by: vector)
    }
  @inlinable public mutating func translate(by vector: Self.Vector) {
        self = self.translated(by: vector)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat : Spatial.Translatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3DFloat : Spatial.Translatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3DFloat : Spatial.Translatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat : Spatial.Translatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat : Spatial.Translatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat : Spatial.Translatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ScaledPose3DFloat : Spatial.Translatable3DProtocol {
  @inlinable public func translated(by offset: Spatial.Vector3DFloat) -> Spatial.ScaledPose3DFloat {
        return __SPScaledPose3DFloatTranslate(self, offset)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3D : Spatial.Translatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3D : Spatial.Translatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3D : Spatial.Translatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3D : Spatial.Translatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3D : Spatial.Translatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Translatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ScaledPose3D : Spatial.Translatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public protocol Scalable3DProtocol<Scalar> : Spatial.SpatialTypeProtocol {
  func scaledBy(x: Self.Scalar, y: Self.Scalar, z: Self.Scalar) -> Self
  mutating func scaleBy(x: Self.Scalar, y: Self.Scalar, z: Self.Scalar)
  func scaled(by size: Self.Size) -> Self
  mutating func scale(by size: Self.Size)
  func uniformlyScaled(by scale: Self.Scalar) -> Self
  mutating func uniformlyScale(by scale: Self.Scalar)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Scalable3DProtocol where Self.Scalar == Swift.Float {
  public mutating func scaleBy(x: Self.Scalar = 1, y: Self.Scalar = 1, z: Self.Scalar = 1)
  public mutating func scale(by scale: Self.Size)
  public mutating func uniformlyScale(by scale: Self.Scalar)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat : Spatial.Scalable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat : Spatial.Scalable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat : Spatial.Scalable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat : Spatial.Scalable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat : Spatial.Scalable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3D : Spatial.Scalable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3D : Spatial.Scalable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3D : Spatial.Scalable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3D : Spatial.Scalable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Scalable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public protocol Rotatable3DProtocol<Scalar> : Spatial.SpatialTypeProtocol {
  func rotated(by rotation: Self.Rotation) -> Self
  mutating func rotate(by rotation: Self.Rotation)
  func rotated(by quaternion: Self.Quaternion) -> Self
  mutating func rotate(by quaternion: Self.Quaternion)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotatable3DProtocol where Self.Scalar == Swift.Float {
  public mutating func rotate(by rotation: Self.Rotation)
  public mutating func rotate(by rotation: Self.Quaternion)
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
  @inlinable public static func * (lhs: Self.Rotation, rhs: Self) -> Self {
        
        let result = rhs.rotated(by: lhs)
        
        return result
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotation3DFloat : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3DFloat : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ScaledPose3DFloat : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3DFloat : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3D : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3D : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotation3D : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3D : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3D : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3D : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ScaledPose3D : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3D : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3D : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Rotatable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public protocol Shearable3DProtocol<Scalar> : Spatial.SpatialTypeProtocol {
  func sheared(_ shear: Self.AxisEnumeration) -> Self
  mutating func shear(_ shear: Self.AxisEnumeration)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Shearable3DProtocol where Self.Scalar == Swift.Float {
  public mutating func shear(_ shear: Self.AxisEnumeration)
  @usableFromInline
  internal func _shear(shearFunc: (Self, Spatial.Axis3D, Swift.Float, Swift.Float) -> Self, shear: Spatial.AxisWithFactorsFloat) -> Self
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat : Spatial.Shearable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat : Spatial.Shearable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3D : Spatial.Shearable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Shearable3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public protocol Transform3DProtocol : Spatial.SpatialTypeProtocol {
  init(shear: Self.AxisEnumeration)
  init(scale: Self.Size)
  init(rotation: Self.Rotation)
  init(translation: Self.Vector)
  init(scale: Self.Size, rotation: Self.Rotation, translation: Self.Vector)
  var isIdentity: Swift.Bool { get }
  static var identity: Self { get }
  var isTranslation: Swift.Bool { get }
  var isUniform: Swift.Bool { get }
  func isUniform(overDimensions: Spatial.Dimension3DSet) -> Swift.Bool
  var isRectilinear: Swift.Bool { get }
  func concatenating(_ transform: Self) -> Self
  #if compiler(>=5.3) && $NonescapableTypes
  var inverse: Self? { get }
  #endif
  func isApproximatelyEqual(to other: Self, tolerance: Self.Scalar) -> Swift.Bool
  var translation: Self.Vector { get set }
  #if compiler(>=5.3) && $NonescapableTypes
  var rotation: Self.Rotation? { get }
  #endif
  mutating func flip(along axis: Spatial.Axis3D)
  func flipped(along axis: Spatial.Axis3D) -> Self
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat : Spatial.Transform3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat : Spatial.Transform3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3D : Spatial.Transform3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Transform3DProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public protocol VolumetricProtocol<Scalar> : Spatial.SpatialTypeProtocol {
  var size: Self.Size { get }
  func contains(_ other: Self) -> Swift.Bool
  func contains(point: Self.Point) -> Swift.Bool
  func union(_ other: Self) -> Self
  #if compiler(>=5.3) && $NonescapableTypes
  func intersection(_ other: Self) -> Self?
  #endif
  mutating func formIntersection(_ other: Self)
  mutating func formUnion(_ other: Self)
  func contains(anyOf points: [Self.Point]) -> Swift.Bool
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.VolumetricProtocol where Self.Scalar == Swift.Float {
  public mutating func formIntersection(_ other: Self)
  public mutating func formUnion(_ other: Self)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat : Spatial.VolumetricProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat : Spatial.VolumetricProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3D : Spatial.VolumetricProtocol {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3D : Spatial.VolumetricProtocol {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D {
  @inlinable public var translation: Spatial.Vector3D {
    get {
            return __SPProjectiveTransform3DGetTranslation(self)
        }
    set {
            __SPProjectiveTransform3DSetTranslation(&self, newValue)
        }
  }
  @inlinable public init() {
         self.init(scale: Size3D(width: 1, height: 1, depth: 1))
     }
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public init(scale: Spatial.Size3D = Size3D(width: 1.0, height: 1, depth: 1), rotation: Spatial.Rotation3D = .zero, translation: Spatial.Size3D) {
        
        self = __SPProjectiveTransform3DMake(scale,
                                             rotation,
                                             Vector3D(translation))
    }
  @inlinable public init(scale: Spatial.Size3D = Size3D(width: 1.0, height: 1, depth: 1), rotation: Spatial.Rotation3D = .zero, translation: Spatial.Vector3D = .zero) {
        
        
        self = __SPProjectiveTransform3DMake(scale,
                                             rotation,
                                             translation)
    }
  @inlinable public init(pose: Spatial.Pose3D) {
        
        self = __SPProjectiveTransform3DMakeWithPose(pose)
    }
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
  @inlinable public init(scaledPose: Spatial.ScaledPose3D) {
        
        self = __SPProjectiveTransform3DMakeWithScaledPose(scaledPose)
    }
  @inlinable public func isApproximatelyEqual(to other: Spatial.ProjectiveTransform3D, tolerance: Swift.Double = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPProjectiveTransform3DAlmostEqualToTransform(self, other, tolerance)
    }
  public func flipped(along axis: Spatial.Axis3D) -> Spatial.ProjectiveTransform3D
  public mutating func flip(along axis: Spatial.Axis3D)
  @inlinable public func scaledBy(x: Swift.Double, y: Swift.Double, z: Swift.Double) -> Spatial.ProjectiveTransform3D {
        return __SPProjectiveTransform3DScaleBy(self, x, y, z)
    }
  @inlinable public func isUniform(overDimensions: Spatial.Dimension3DSet) -> Swift.Bool {
        
        let axes = Axis3D(rawValue: UInt32(overDimensions.rawValue))
        
        return __SPProjectiveTransform3DIsUniformOverDimensions(self,
                                                                axes)
    }
  @inlinable public init(shear: Spatial.AxisWithFactors) {
        switch shear {
            case .xAxis(let yShearFactor, let zShearFactor):
                self = __SPProjectiveTransform3DMakeShear(.x, yShearFactor, zShearFactor)
            case .yAxis(let xShearFactor, let zShearFactor):
                self = __SPProjectiveTransform3DMakeShear(.y, xShearFactor, zShearFactor)
            case .zAxis(let xShearFactor, let yShearFactor):
                self = __SPProjectiveTransform3DMakeShear(.z, xShearFactor, yShearFactor)
            @unknown default:
                fatalError("Unsupported shear")
        }
    }
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.ProjectiveTransform3D {
        switch shear {
            case .xAxis(let yShearFactor, let zShearFactor):
                return __SPProjectiveTransform3DShear(self, .x, yShearFactor, zShearFactor)
            case .yAxis(let xShearFactor, let zShearFactor):
                return __SPProjectiveTransform3DShear(self, .y, xShearFactor, zShearFactor)
            case .zAxis(let xShearFactor, let yShearFactor):
                return __SPProjectiveTransform3DShear(self, .z, xShearFactor, yShearFactor)
            @unknown default:
                fatalError("Unsupported shear")
        }
    }
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public var rotation: Spatial.Rotation3D? {
    get {
        
        let r = __SPProjectiveTransform3DGetRotation(self)
        
        if __SPRotation3DIsValid(r) {
            return r
        } else {
            return nil
        }
    }
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, renamed: "scaleComponent")
  @inlinable public var scale: Spatial.Size3D? {
    get {
        
        let s = __SPProjectiveTransform3DGetScale(self)
        
        if __SPSize3DIsValid(s) {
            return s
        } else {
            return nil
        }
    }
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public var inverse: Spatial.ProjectiveTransform3D? {
    get {
        
        let t = __SPProjectiveTransform3DInverted(self)
        
        if __SPProjectiveTransform3DIsValid(t) {
            return t
        } else {
            return nil
        }
    }
  }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.ProjectiveTransform3D) -> Swift.Bool {
        return lhs.matrix == rhs.matrix
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ProjectiveTransform3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.ProjectiveTransform3D {
  @inlinable public var scaleComponent: Spatial.Size3D {
    get {
        
        return __SPProjectiveTransform3DGetScale(self)
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Primitive3D {
  @inlinable public func unapplying(_ transform: Spatial.AffineTransform3D) -> Spatial.Rect3D {
        
        let unapplied = __SPRect3DUnapplyAffineTransform(self, transform)
        
        if __SPRect3DIsNull(unapplied) {
            return self
        } else {
            return unapplied
        }
    }
  @inlinable public func unapplying(_ transform: Spatial.ProjectiveTransform3D) -> Spatial.Rect3D {
        
        let unapplied = __SPRect3DUnapplyProjectiveTransform(self, transform)
        
        if __SPRect3DIsNull(unapplied) {
            return self
        } else {
            return unapplied
        }
    }
  public func applying(_ pose: Spatial.Pose3D) -> Spatial.Rect3D
  public func unapplying(_ pose: Spatial.Pose3D) -> Spatial.Rect3D
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Rect3D {
  public func applying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Rect3D
  public func unapplying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Rect3D
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Translatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Scalable3D {
  @inlinable public func scaledBy(x: Swift.Double = 1, y: Swift.Double = 1, z: Swift.Double = 1) -> Spatial.Rect3D {
        
        return __SPRect3DScaleBy(self, x, y, z)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Rotatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Shearable3D {
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.Rect3D {
        
        return _shear(shearFunc: __SPRect3DShear,
                      shear: shear)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Volumetric {
  @inlinable public func contains(anyOf points: [Spatial.Point3D]) -> Swift.Bool {
        return __SPRect3DContainsAnyPoint(self,
                                          points,
                                          Int32(points.count))
    }
  @inlinable public mutating func formInset(by dXYZ: Spatial.Size3D) {
        
        self = self.inset(by: dXYZ)
    }
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public func intersection(_ other: Spatial.Rect3D) -> Spatial.Rect3D? {
        let intersection = __SPRect3DIntersection(self, other)
        
        if intersection.origin.isFinite {
            return intersection
        } else {
            return nil
        }
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Rect3D, rhs: Spatial.Rect3D) -> Swift.Bool {
        return lhs.origin == rhs.origin && lhs.size == rhs.size
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D {
  public init(origin: simd.simd_double3 = .zero, size: simd.simd_double3)
  public init(origin: Spatial.Vector3D = .zero, size: Spatial.Vector3D)
  public init(center: simd.simd_double3 = .zero, size: simd.simd_double3)
  public init(center: Spatial.Vector3D = .zero, size: Spatial.Vector3D)
  public init(points: [Spatial.Point3D])
  public var cornerPoints: [Spatial.Point3D] {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Rect3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D {
  @inlinable public init<T>(radians: T) where T : Swift.BinaryFloatingPoint {
        self.init(radians: Double(radians))
    }
  @inlinable public init<T>(degrees: T) where T : Swift.BinaryFloatingPoint {
        self.init(degrees: Double(degrees))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D {
  @inlinable public init(_ xyz: simd.simd_float3) {
        self.init(simd_double3(Double(xyz.x),
                               Double(xyz.y),
                               Double(xyz.z)))
    }
  @inlinable public init<T>(x: T, y: T, z: T) where T : Swift.BinaryFloatingPoint {
        self.init(x: Double(x),
                  y: Double(y),
                  z: Double(z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.SIMD3 where Scalar == Swift.Float {
  @inlinable public init(_ rotationAxis: Spatial.RotationAxis3D) {
        self.init(x: Float(rotationAxis.x),
                  y: Float(rotationAxis.y),
                  z: Float(rotationAxis.z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D {
  @inlinable public init(_ quaternion: simd.simd_quatf) {
        
        let q = simd_quatd(vector: simd_double(quaternion.vector))
    
        self.init(q)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension simd.simd_quatf {
  @inlinable public init(_ rotation: Spatial.Rotation3D) {
        
        self.init(vector: simd_float(rotation.quaternion.vector))
        
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public init(_ xyz: simd.simd_float3) {
        self.init(simd_double3(Double(xyz.x),
                               Double(xyz.y),
                               Double(xyz.z)))
    }
  @inlinable public init<T>(x: T, y: T, z: T) where T : Swift.BinaryFloatingPoint {
        self.init(x: Double(x),
                  y: Double(y),
                  z: Double(z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.SIMD3 where Scalar == Swift.Float {
  @inlinable public init(_ point: Spatial.Point3D) {
        self.init(x: Float(point.x),
                  y: Float(point.y),
                  z: Float(point.z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D {
  @inlinable public init(_ xyz: simd.simd_float3) {
        self.init(simd_double3(Double(xyz.x),
                               Double(xyz.y),
                               Double(xyz.z)))
    }
  @inlinable public init<T>(x: T, y: T, z: T) where T : Swift.BinaryFloatingPoint {
        self.init(x: Double(x),
                  y: Double(y),
                  z: Double(z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.SIMD3 where Scalar == Swift.Float {
  @inlinable public init(_ vector: Spatial.Vector3D) {
        self.init(x: Float(vector.x),
                  y: Float(vector.y),
                  z: Float(vector.z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  @inlinable public init(_ xyz: simd.simd_float3) {
        self.init(simd_double3(Double(xyz.x),
                               Double(xyz.y),
                               Double(xyz.z)))
    }
  @inlinable public init<T>(width: T, height: T, depth: T) where T : Swift.BinaryFloatingPoint {
        self.init(width: Double(width),
                  height: Double(height),
                  depth: Double(depth))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.SIMD3 where Scalar == Swift.Float {
  @inlinable public init(_ size: Spatial.Size3D) {
        self.init(x: Float(size.width),
                  y: Float(size.height),
                  z: Float(size.depth))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D {
  @inlinable public init(origin: simd.simd_float3 = .zero, size: simd.simd_float3) {
        
        let o = simd_double3(Double(origin.x),
                             Double(origin.y),
                             Double(origin.z))
        
        let s = simd_double3(Double(size.x),
                             Double(size.y),
                             Double(size.z))
        
        self = __SPRect3DMakeAtOriginWithVector(o, s)
    }
  @inlinable public init(center: simd.simd_float3 = .zero, size: simd.simd_float3) {
        
        let c = simd_double3(Double(center.x),
                             Double(center.y),
                             Double(center.z))
        
        let s = simd_double3(Double(size.x),
                             Double(size.y),
                             Double(size.z))
        
        
        self = __SPRect3DMakeAtCenterWithVector(c, s)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D {
  @inlinable public init(_ matrix: simd.simd_float4x3) {
        
        let column0 = matrix.columns.0
        let column1 = matrix.columns.1
        let column2 = matrix.columns.2
        let column3 = matrix.columns.3
        
        let m = simd_double4x3([
            simd_double3(Double(column0.x), Double(column0.y), Double(column0.z)),
            simd_double3(Double(column1.x), Double(column1.y), Double(column1.z)),
            simd_double3(Double(column2.x), Double(column2.y), Double(column2.z)),
            simd_double3(Double(column3.x), Double(column3.y), Double(column3.z))
        ])
        
        self.init(m)
    }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.AffineTransform3D {
  @inlinable public init(truncating matrix: simd.simd_float4x4) {

        let m = simd_double4x4([
            simd_double(matrix.columns.0),
            simd_double(matrix.columns.1),
            simd_double(matrix.columns.2),
            simd_double(matrix.columns.3)])
        
        self = .init(truncating: m)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension simd.simd_float4x3 {
  @inlinable public init(_ affineTransform: Spatial.AffineTransform3D) {
        
        let column0 = affineTransform.matrix.columns.0
        let column1 = affineTransform.matrix.columns.1
        let column2 = affineTransform.matrix.columns.2
        let column3 = affineTransform.matrix.columns.3
        
        self.init([
            simd_float3(Float(column0.x), Float(column0.y), Float(column0.z)),
            simd_float3(Float(column1.x), Float(column1.y), Float(column1.z)),
            simd_float3(Float(column2.x), Float(column2.y), Float(column2.z)),
            simd_float3(Float(column3.x), Float(column3.y), Float(column3.z))
        ])
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D {
  @inlinable public init(_ matrix: simd.simd_float4x4) {
        
        let column0 = matrix.columns.0
        let column1 = matrix.columns.1
        let column2 = matrix.columns.2
        let column3 = matrix.columns.3
        
        let m = simd_double4x4([
            simd_double4(Double(column0.x), Double(column0.y),
                         Double(column0.z), Double(column0.w)),
            
            simd_double4(Double(column1.x), Double(column1.y),
                         Double(column1.z), Double(column1.w)),
            
            simd_double4(Double(column2.x), Double(column2.y),
                         Double(column2.z), Double(column2.w)),
            
            simd_double4(Double(column3.x), Double(column3.y),
                         Double(column3.z), Double(column3.w))
        ])
        
        self.init(m)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension simd.simd_float4x4 {
  @inlinable public init(_ projectiveTransform: Spatial.ProjectiveTransform3D) {
        
        self.init(simd_float(projectiveTransform.matrix.columns.0),
                  simd_float(projectiveTransform.matrix.columns.1),
                  simd_float(projectiveTransform.matrix.columns.2),
                  simd_float(projectiveTransform.matrix.columns.3))
    }
  @inlinable public init(_ affineTransform: Spatial.AffineTransform3D) {
        let m = affineTransform.matrix4x4
        self.init(simd_float(m.columns.0),
                  simd_float(m.columns.1),
                  simd_float(m.columns.2),
                  simd_float(m.columns.3))
    }
  @inlinable public init(_ pose: Spatial.Pose3D) {
        let m = pose.matrix
        self.init(simd_float(m.columns.0),
                  simd_float(m.columns.1),
                  simd_float(m.columns.2),
                  simd_float(m.columns.3))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D {
  public init(origin: Spatial.Point3D = .zero, direction: Spatial.Vector3D)
  public init(origin: simd.simd_double3 = .zero, direction: simd.simd_double3)
  public init(origin: simd.simd_float3 = .zero, direction: simd.simd_float3)
  public func intersects(_ rect: Spatial.Rect3D) -> Swift.Bool
  public func applying(_ pose: Spatial.Pose3D) -> Spatial.Ray3D
  public mutating func apply(_ pose: Spatial.Pose3D)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Ray3D {
  public func unapplying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Ray3D
  public func applying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Ray3D
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Ray3D : Spatial.Primitive3D {
  public func applying(_ transform: Spatial.AffineTransform3D) -> Spatial.Ray3D
  public func unapplying(_ transform: Spatial.AffineTransform3D) -> Spatial.Ray3D
  public func applying(_ transform: Spatial.ProjectiveTransform3D) -> Spatial.Ray3D
  public func unapplying(_ transform: Spatial.ProjectiveTransform3D) -> Spatial.Ray3D
  public func unapplying(_ pose: Spatial.Pose3D) -> Spatial.Ray3D
  public func rotated(by rotation: Spatial.Rotation3D, around pivot: Spatial.Point3D) -> Spatial.Ray3D
  public func rotated(by quaternion: simd.simd_quatd, around pivot: Spatial.Point3D) -> Spatial.Ray3D
  public var isNaN: Swift.Bool {
    get
  }
  public var isFinite: Swift.Bool {
    get
  }
  public var isZero: Swift.Bool {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Spatial.Translatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Spatial.Rotatable3D {
  public func rotated(by rotation: Spatial.Rotation3D) -> Spatial.Ray3D
  public func rotated(by quaternion: simd.simd_quatd) -> Spatial.Ray3D
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Ray3D, rhs: Spatial.Ray3D) -> Swift.Bool {
        return lhs.origin == rhs.origin && lhs.direction == rhs.direction
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Ray3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public protocol CoordinateSpaceValue3D<Value> {
  associatedtype Value : Spatial.ProjectiveTransformable3D
  func resolve<Space>(in otherSpace: Space) throws -> Self.Value where Space : Spatial.CoordinateSpace3D
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.CoordinateSpace3D {
  public func transform<Space>(from target: Space) throws -> Spatial.ProjectiveTransform3D where Space : Spatial.CoordinateSpace3D
  public func convert<T, Space>(value: T, to targetCoordinateSpace: Space) throws -> T where T : Spatial.ProjectiveTransformable3D, Space : Spatial.CoordinateSpace3D
  public func convert<T, Space>(value: T, from sourceCoordinateSpace: Space) throws -> T where T : Spatial.ProjectiveTransformable3D, Space : Spatial.CoordinateSpace3D
  public func convert<T>(value: T, to targetCoordinateSpace: Self) throws -> T where T : Spatial.ProjectiveTransformable3D
  public func convert<T>(value: T, from targetCoordinateSpace: Self) throws -> T where T : Spatial.ProjectiveTransformable3D
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : @unchecked Swift.Sendable {
  public static let right: Spatial.Vector3D
  public static let up: Spatial.Vector3D
  public static let forward: Spatial.Vector3D
  @inlinable public init(x: Swift.Double = 0, y: Swift.Double = 0, z: Swift.Double = 0) {
        self = __SPVector3DMake(x, y, z)
    }
  @inlinable public init(_ xyz: simd.simd_double3) {
        self = __SPVector3DMakeWithVector(xyz)
    }
  @inlinable public init(_ size: Spatial.Size3D) {
        self = __SPVector3DMakeWithSize(size)
    }
  @inlinable public init(_ point: Spatial.Point3D) {
        self = __SPVector3DMakeWithPoint(point)
    }
  @inlinable public init(_ axis: Spatial.RotationAxis3D) {
        self = __SPVector3DMakeWithRotationAxis(axis)
    }
  @inlinable public func dot(_ other: Spatial.Vector3D) -> Swift.Double {
        return __SPVector3DDotProduct(self, other)
    }
  @inlinable public func cross(_ other: Spatial.Vector3D) -> Spatial.Vector3D {
        return __SPVector3DCrossProduct(self, other)
    }
  @inlinable public var normalized: Spatial.Vector3D {
    get {
        return __SPVector3DNormalize(self)
    }
  }
  @inlinable public mutating func normalize() {
        self = __SPVector3DNormalize(self)
    }
  @inlinable public func projected(_ other: Spatial.Vector3D) -> Spatial.Vector3D {
        return __SPVector3DProject(self, other)
    }
  @inlinable public func reflected(_ normal: Spatial.Vector3D) -> Spatial.Vector3D {
        return __SPVector3DReflect(self, normal)
    }
  @inlinable public var length: Swift.Double {
    get {
        return __SPVector3DLength(self)
    }
  }
  @inlinable public var lengthSquared: Swift.Double {
    get {
        return __SPVector3DLengthSquared(self)
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Spatial.Primitive3D {
  @inlinable public func applying(_ transform: Spatial.AffineTransform3D) -> Spatial.Vector3D {
        return __SPVector3DApplyAffineTransform(self, transform)
    }
  @inlinable public func applying(_ transform: Spatial.ProjectiveTransform3D) -> Spatial.Vector3D {
        return __SPVector3DApplyProjectiveTransform(self, transform)
    }
  @inlinable public func unapplying(_ transform: Spatial.AffineTransform3D) -> Spatial.Vector3D {
        return __SPVector3DUnapplyAffineTransform(self, transform)
    }
  @inlinable public func unapplying(_ transform: Spatial.ProjectiveTransform3D) -> Spatial.Vector3D {
        return __SPVector3DUnapplyProjectiveTransform(self, transform)
    }
  public func applying(_ pose: Spatial.Pose3D) -> Spatial.Vector3D
  public func unapplying(_ pose: Spatial.Pose3D) -> Spatial.Vector3D
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Vector3D {
  public func applying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Vector3D
  public func unapplying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Vector3D
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Spatial.Rotatable3D {
  @inlinable public func rotated(by rotation: Spatial.Rotation3D) -> Spatial.Vector3D {
        return __SPVector3DRotate(self, rotation)
    }
  @inlinable public func rotated(by quaternion: simd.simd_quatd) -> Spatial.Vector3D {
        return __SPVector3DRotateByQuaternion(self, quaternion)
    }
  @inlinable public func rotation(to other: Spatial.Vector3D) -> Spatial.Rotation3D {
        return __SPVector3DRotationToVector(self, other)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Spatial.Scalable3D {
  @inlinable public func scaledBy(x: Swift.Double = 1, y: Swift.Double = 1, z: Swift.Double = 1) -> Spatial.Vector3D {
        
        return __SPVector3DScaleBy(self, x, y, z)
    }
  @inlinable public func scaled(by size: Spatial.Size3D) -> Spatial.Vector3D {
        
        return __SPVector3DScaleBySize(self, size)
    }
  @inlinable public func uniformlyScaled(by scale: Swift.Double) -> Spatial.Vector3D {
        return __SPVector3DScaleUniform(self, scale)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Spatial.Shearable3D {
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.Vector3D {
        
        return _shear(shearFunc: __SPVector3DShear, shear: shear)
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Vector3D : Swift.AdditiveArithmetic {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Vector3D, rhs: Spatial.Vector3D) -> Swift.Bool {
        
        return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Vector3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3D {
  public static func lerp(from: Spatial.Vector3D, to: Spatial.Vector3D, t: Spatial.Vector3D) -> Spatial.Vector3D
  public static func smoothstep(edge0: Spatial.Vector3D, edge1: Spatial.Vector3D, x: Spatial.Vector3D) -> Spatial.Vector3D
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat {
  @inlinable public static func + (lhs: Spatial.Point3DFloat, rhs: Spatial.Size3DFloat) -> Spatial.Point3DFloat {
       
        return Point3DFloat(lhs.vector + rhs.vector)
    }
  @inlinable public static func += (lhs: inout Spatial.Point3DFloat, rhs: Spatial.Size3DFloat) {
       
        lhs = Point3DFloat(lhs.vector + rhs.vector)
    }
  @inlinable public static func + (lhs: Spatial.Size3DFloat, rhs: Spatial.Point3DFloat) -> Spatial.Point3DFloat {
       
        return Point3DFloat(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Point3DFloat, rhs: Spatial.Size3DFloat) -> Spatial.Point3DFloat {
        
        return Point3DFloat(lhs.vector - rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Point3DFloat, rhs: Spatial.Size3DFloat) {
        
        lhs = Point3DFloat(lhs.vector - rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Size3DFloat, rhs: Spatial.Point3DFloat) -> Spatial.Point3DFloat {
        
        return Point3DFloat(lhs.vector - rhs.vector)
    }
  @inlinable prefix public static func - (point: Spatial.Point3DFloat) -> Spatial.Point3DFloat {
        
        return Point3DFloat(-point.vector)
    }
  @inlinable public static func * (lhs: Swift.Float, rhs: Spatial.Point3DFloat) -> Spatial.Point3DFloat {
        return Point3DFloat(lhs * rhs.vector)
    }
  @inlinable public static func *= (lhs: inout Spatial.Point3DFloat, rhs: Swift.Float) {
        lhs = Point3DFloat(rhs * lhs.vector)
    }
  @inlinable public static func * (lhs: Spatial.Point3DFloat, rhs: Swift.Float) -> Spatial.Point3DFloat {
        return Point3DFloat(lhs.vector * rhs)
    }
  @inlinable public static func / (lhs: Spatial.Point3DFloat, rhs: Swift.Float) -> Spatial.Point3DFloat {
        return Point3DFloat(lhs.vector / rhs)
    }
  @inlinable public static func /= (lhs: inout Spatial.Point3DFloat, rhs: Swift.Float) {
        lhs = Point3DFloat(lhs.vector / rhs)
    }
  @inlinable public static func * (lhs: Spatial.AffineTransform3DFloat, rhs: Spatial.Point3DFloat) -> Spatial.Point3DFloat {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3DFloat, rhs: Spatial.Point3DFloat) -> Spatial.Point3DFloat {

        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.Pose3DFloat, rhs: Spatial.Point3DFloat) -> Spatial.Point3DFloat {

        return rhs.applying(lhs)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat : Swift.AdditiveArithmetic {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat {
  @inlinable prefix public static func - (size: Spatial.Size3DFloat) -> Spatial.Size3DFloat {
        return Size3DFloat(-size.vector)
    }
  @inlinable public static func + (lhs: Spatial.Size3DFloat, rhs: Spatial.Size3DFloat) -> Spatial.Size3DFloat {
        return Size3DFloat(lhs.vector + rhs.vector)
    }
  @inlinable public static func += (lhs: inout Spatial.Size3DFloat, rhs: Spatial.Size3DFloat) {
        lhs = Size3DFloat(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Size3DFloat, rhs: Spatial.Size3DFloat) -> Spatial.Size3DFloat {
        return Size3DFloat(lhs.vector - rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Size3DFloat, rhs: Spatial.Size3DFloat) {
        lhs = Size3DFloat(lhs.vector - rhs.vector)
    }
  @inlinable public static func * (lhs: Swift.Float, rhs: Spatial.Size3DFloat) -> Spatial.Size3DFloat {
        return Size3DFloat(lhs * rhs.vector)
    }
  @inlinable public static func * (lhs: Spatial.Size3DFloat, rhs: Swift.Float) -> Spatial.Size3DFloat {
        return Size3DFloat(lhs.vector * rhs)
    }
  @inlinable public static func *= (lhs: inout Spatial.Size3DFloat, rhs: Swift.Float) {
        lhs = Size3DFloat(lhs.vector * rhs)
    }
  @inlinable public static func / (lhs: Spatial.Size3DFloat, rhs: Swift.Float) -> Spatial.Size3DFloat {
        return Size3DFloat(lhs.vector / rhs)
    }
  @inlinable public static func /= (lhs: inout Spatial.Size3DFloat, rhs: Swift.Float) {
        lhs = Size3DFloat(lhs.vector / rhs)
    }
  @inlinable public static func * (lhs: Spatial.AffineTransform3DFloat, rhs: Spatial.Size3DFloat) -> Spatial.Size3DFloat {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3DFloat, rhs: Spatial.Size3DFloat) -> Spatial.Size3DFloat {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.Pose3DFloat, rhs: Spatial.Size3DFloat) -> Spatial.Size3DFloat {
        
        return rhs.applying(lhs)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat {
  @inlinable public static func * (lhs: Spatial.AffineTransform3DFloat, rhs: Spatial.Rect3DFloat) -> Spatial.Rect3DFloat {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3DFloat, rhs: Spatial.Rect3DFloat) -> Spatial.Rect3DFloat {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.Pose3DFloat, rhs: Spatial.Rect3DFloat) -> Spatial.Rect3DFloat {
        
        return rhs.applying(lhs)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat {
  @inlinable public static func * (lhs: Spatial.AffineTransform3DFloat, rhs: Spatial.AffineTransform3DFloat) -> Spatial.AffineTransform3DFloat {
        
        let result = lhs.concatenating(rhs)
        
        return result
    }
  @inlinable public static func *= (lhs: inout Spatial.AffineTransform3DFloat, rhs: Spatial.AffineTransform3DFloat) {
        
        lhs = lhs.concatenating(rhs)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat {
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3DFloat, rhs: Spatial.ProjectiveTransform3DFloat) -> Spatial.ProjectiveTransform3DFloat {
        
        let result = lhs.concatenating(rhs)
        
        return result
    }
  @inlinable public static func *= (lhs: inout Spatial.ProjectiveTransform3DFloat, rhs: Spatial.ProjectiveTransform3DFloat) {
        
        lhs = lhs.concatenating(rhs)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat {
  @inlinable public static func - (lhs: Spatial.Point3DFloat, rhs: Spatial.Point3DFloat) -> Spatial.Vector3DFloat {
        
        return Vector3DFloat(lhs.vector - rhs.vector)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat {
  @inlinable public static func + (lhs: Spatial.Point3DFloat, rhs: Spatial.Vector3DFloat) -> Spatial.Point3DFloat {
        
        return Point3DFloat(lhs.vector + rhs.vector)
    }
  @inlinable public static func + (lhs: Spatial.Vector3DFloat, rhs: Spatial.Point3DFloat) -> Spatial.Point3DFloat {
        
        return Point3DFloat(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Point3DFloat, rhs: Spatial.Vector3DFloat) -> Spatial.Point3DFloat {
        
        return Point3DFloat(lhs.vector - rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Vector3DFloat, rhs: Spatial.Point3DFloat) -> Spatial.Point3DFloat {
        
        return Point3DFloat(lhs.vector - rhs.vector)
    }
  @inlinable prefix public static func - (vector: Spatial.Vector3DFloat) -> Spatial.Vector3DFloat {
        
        return Vector3DFloat(-vector.vector)
    }
  @inlinable public static func + (lhs: Spatial.Vector3DFloat, rhs: Spatial.Vector3DFloat) -> Spatial.Vector3DFloat {
        
        return Vector3DFloat(lhs.vector + rhs.vector)
    }
  @inlinable public static func += (lhs: inout Spatial.Vector3DFloat, rhs: Spatial.Vector3DFloat) {
        
        lhs = Vector3DFloat(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Vector3DFloat, rhs: Spatial.Vector3DFloat) -> Spatial.Vector3DFloat {
        
        return Vector3DFloat(lhs.vector - rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Vector3DFloat, rhs: Spatial.Vector3DFloat) {
        
        lhs = Vector3DFloat(lhs.vector - rhs.vector)
    }
  @inlinable public static func * (lhs: Swift.Float, rhs: Spatial.Vector3DFloat) -> Spatial.Vector3DFloat {
        
        return Vector3DFloat(lhs * rhs.vector)
    }
  @inlinable public static func * (lhs: Spatial.Vector3DFloat, rhs: Swift.Float) -> Spatial.Vector3DFloat {
        
        return Vector3DFloat(lhs.vector * rhs)
    }
  @inlinable public static func *= (lhs: inout Spatial.Vector3DFloat, rhs: Swift.Float) {
        
        lhs = Vector3DFloat(lhs.vector * rhs)
    }
  @inlinable public static func / (lhs: Spatial.Vector3DFloat, rhs: Swift.Float) -> Spatial.Vector3DFloat {
        
        return Vector3DFloat(lhs.vector / rhs)
    }
  @inlinable public static func /= (lhs: inout Spatial.Vector3DFloat, rhs: Swift.Float) {
        
        lhs = Vector3DFloat(lhs.vector / rhs)
    }
  @inlinable public static func * (lhs: Spatial.AffineTransform3DFloat, rhs: Spatial.Vector3DFloat) -> Spatial.Vector3DFloat {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3DFloat, rhs: Spatial.Vector3DFloat) -> Spatial.Vector3DFloat {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.Pose3DFloat, rhs: Spatial.Vector3DFloat) -> Spatial.Vector3DFloat {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func + (lhs: Spatial.Size3DFloat, rhs: Spatial.Vector3DFloat) -> Spatial.Size3DFloat {
        
        return Size3DFloat(lhs.vector + rhs.vector)
    }
  @inlinable public static func + (lhs: Spatial.Vector3DFloat, rhs: Spatial.Size3DFloat) -> Spatial.Size3DFloat {
        
        return Size3DFloat(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Size3DFloat, rhs: Spatial.Vector3DFloat) -> Spatial.Size3DFloat {
        
        return Size3DFloat(lhs.vector - rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Vector3DFloat, rhs: Spatial.Size3DFloat) -> Spatial.Size3DFloat {
        
        return Size3DFloat(lhs.vector - rhs.vector)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3DFloat {
  @inlinable public static func * (lhs: Spatial.Pose3DFloat, rhs: Spatial.Ray3DFloat) -> Spatial.Ray3DFloat {

        return rhs.applying(lhs)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat {
  @inlinable public static func += (lhs: inout Spatial.Point3DFloat, rhs: Spatial.Vector3DFloat) {

        lhs = Point3DFloat(lhs.vector + rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Point3DFloat, rhs: Spatial.Vector3DFloat) {

        lhs = Point3DFloat(lhs.vector - rhs.vector)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat {
  @inlinable public static func += (lhs: inout Spatial.Size3DFloat, rhs: Spatial.Vector3DFloat) {

        lhs = Size3DFloat(lhs.vector + rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Size3DFloat, rhs: Spatial.Vector3DFloat) {

        lhs = Size3DFloat(lhs.vector - rhs.vector)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3DFloat {
  @inlinable public static func * (lhs: Spatial.Pose3DFloat, rhs: Spatial.Pose3DFloat) -> Spatial.Pose3DFloat {
        return __SPPose3DFloatConcatenation(lhs, rhs)
    }
  @inlinable public static func *= (lhs: inout Spatial.Pose3DFloat, rhs: Spatial.Pose3DFloat) {
        
        lhs = lhs.concatenating(rhs)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ScaledPose3DFloat {
  @inlinable public static func * (lhs: Spatial.ScaledPose3DFloat, rhs: Spatial.Pose3DFloat) -> Spatial.ScaledPose3DFloat {
        return __SPScaledPose3DFloatConcatenation(lhs, rhs)
    }
  @inlinable public static func * (lhs: Spatial.ScaledPose3DFloat, rhs: Spatial.ScaledPose3DFloat) -> Spatial.ScaledPose3DFloat {
        return __SPScaledPose3DFloatConcatenation(lhs, rhs)
    }
  @inlinable public static func * (lhs: Spatial.Pose3DFloat, rhs: Spatial.ScaledPose3DFloat) -> Spatial.ScaledPose3DFloat {
        return __SPScaledPose3DFloatConcatenation(lhs, rhs)
    }
  @inlinable public static func *= (lhs: inout Spatial.ScaledPose3DFloat, rhs: Spatial.ScaledPose3DFloat) {
        
        lhs = lhs.concatenating(rhs)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotation3DFloat {
  @inlinable public static func * (lhs: Spatial.Rotation3DFloat, rhs: Swift.Float) -> Spatial.Rotation3DFloat {

            return Rotation3DFloat.slerp(
                from: .identity,
                to: lhs,
                t: rhs,
                along: lhs.quaternion.real >= 0 ? .shortest : .longest)
    }
  @inlinable public static func * (lhs: Swift.Float, rhs: Spatial.Rotation3DFloat) -> Spatial.Rotation3DFloat {

        return rhs * lhs
    }
  @inlinable public static func * (lhs: Spatial.Rotation3DFloat, rhs: Spatial.Rotation3DFloat) -> Spatial.Rotation3DFloat {

        return Rotation3DFloat(lhs.quaternion * rhs.quaternion)
    }
  @inlinable public static func *= (lhs: inout Spatial.Rotation3DFloat, rhs: Spatial.Rotation3DFloat) {
        lhs = rhs.rotated(by: lhs)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Angle2DFloat : Swift.AdditiveArithmetic {
  @inlinable prefix public static func - (angle: Spatial.Angle2DFloat) -> Spatial.Angle2DFloat {
        return __SPAngleFloatNegate(angle)
    }
  @inlinable prefix public static func + (angle: Spatial.Angle2DFloat) -> Spatial.Angle2DFloat {
        return angle
    }
  @inlinable public static func + (lhs: Spatial.Angle2DFloat, rhs: Spatial.Angle2DFloat) -> Spatial.Angle2DFloat {
        return Angle2DFloat(radians: lhs.radians + rhs.radians)
    }
  @inlinable public static func += (lhs: inout Spatial.Angle2DFloat, rhs: Spatial.Angle2DFloat) {
        lhs = lhs + rhs
    }
  @inlinable public static func - (lhs: Spatial.Angle2DFloat, rhs: Spatial.Angle2DFloat) -> Spatial.Angle2DFloat {
        return Angle2DFloat(radians: lhs.radians - rhs.radians)
    }
  @inlinable public static func -= (lhs: inout Spatial.Angle2DFloat, rhs: Spatial.Angle2DFloat) {
        lhs = lhs - rhs
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat : Swift.AdditiveArithmetic {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ScaledPose3DFloat {
  @inlinable public init(position: Spatial.Point3DFloat = .zero, rotation: Spatial.Rotation3DFloat, scale: Swift.Float = 1) {
        
        self = __SPScaledPose3DFloatMake(position, rotation, scale)
    }
  @inlinable public init(position: simd.simd_float3 = .zero, rotation: simd.simd_quatf, scale: Swift.Float = 1) {
        
        self = __SPScaledPose3DFloatMakeWithVector(position, rotation, scale)
    }
  @inlinable public init(position: Spatial.Point3DFloat = .zero, target: Spatial.Point3DFloat, scale: Swift.Float = 1, up: Spatial.Vector3DFloat = Vector3DFloat(x: 0, y: 1, z: 0)) {
        
        self = __SPScaledPose3DFloatMakeLookAt(position, target, scale, up)
    }
  @inlinable public init(forward: Spatial.Vector3DFloat, scale: Swift.Float = 1, up: Spatial.Vector3DFloat = Vector3DFloat(x: 0, y: 1, z: 0)) {
        
        self = __SPScaledPose3DFloatMakeLookAt(forward, scale, up)
    }
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public init?(transform: Spatial.AffineTransform3DFloat) {
        
        let p = __SPScaledPose3DFloatMakeWithAffineTransform(transform)
        
        if __SPScaledPose3DFloatIsValid(p) {
            self = p
        } else {
            return nil
        }
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public init?(transform: Spatial.ProjectiveTransform3DFloat) {
        
        let t = __SPScaledPose3DFloatMakeWithProjectiveTransform(transform)
        
        if __SPScaledPose3DFloatIsValid(t) {
            self = t
        } else {
            return nil
        }
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public init?(_ matrix: simd.simd_float4x4) {
        
        let p = __SPScaledPose3DFloatMakeWith4x4Matrix(matrix)
        
        if __SPScaledPose3DFloatIsValid(p) {
            self = p
        } else {
            return nil
        }
    }
  #endif
  @inlinable public var matrix: simd.simd_float4x4 {
    get {
        return __SPScaledPose3DFloatGet4x4Matrix(self)
    }
  }
  @inlinable public var inverse: Spatial.ScaledPose3DFloat {
    get {
        return __SPScaledPose3DFloatGetInverse(self)
    }
  }
  @inlinable public func concatenating(_ transform: Spatial.ScaledPose3DFloat) -> Spatial.ScaledPose3DFloat {
        return __SPScaledPose3DFloatConcatenation(self, transform)
    }
  @inlinable public func concatenating(_ transform: Spatial.Pose3DFloat) -> Spatial.ScaledPose3DFloat {
        return __SPScaledPose3DFloatConcatenation(self, transform)
    }
  @inlinable public static var identity: Spatial.ScaledPose3DFloat {
    get {
        return __SPScaledPose3DFloatIdentity
    }
  }
  @inlinable public func flipped(along axis: Spatial.Axis3D) -> Spatial.ScaledPose3DFloat {
        return __SPScaledPose3DFloatFlip(self, axis)
    }
  public mutating func flip(along axis: Spatial.Axis3D)
  @inlinable public func rotated(by rotation: Spatial.Rotation3DFloat) -> Spatial.ScaledPose3DFloat {
        return __SPScaledPose3DFloatRotate(self, rotation)
    }
  @inlinable public func rotated(by quaternion: simd.simd_quatf) -> Spatial.ScaledPose3DFloat {
        return __SPScaledPose3DFloatRotateByQuaternion(self, quaternion)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ScaledPose3DFloat : @unchecked Swift.Sendable {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ScaledPose3DFloat : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.ScaledPose3DFloat, rhs: Spatial.ScaledPose3DFloat) -> Swift.Bool {
        return __SPScaledPose3DFloatEqualToPose(lhs, rhs)
    }
  @inlinable public func isApproximatelyEqual(to other: Spatial.ScaledPose3DFloat, tolerance: Swift.Float = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPScaledPose3DFloatAlmostEqualToPose(self, other, tolerance)
    }
  @inlinable public var isIdentity: Swift.Bool {
    get {
        return __SPScaledPose3DFloatIsIdentity(self)
    }
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ScaledPose3DFloat : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ScaledPose3DFloat : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ScaledPose3DFloat : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ScaledPose3DFloat : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3DFloat {
  @inlinable public func concatenating(_ transform: Spatial.ScaledPose3DFloat) -> Spatial.ScaledPose3DFloat {
        return __SPScaledPose3DFloatConcatenation(self, transform)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public protocol CoordinateSpace3D {
  associatedtype AncestorCoordinateSpace : Spatial.CoordinateSpace3D
  #if compiler(>=5.3) && $NonescapableTypes
  var ancestorSpace: Self.AncestorCoordinateSpace? { get }
  #endif
  func ancestorFromSpaceTransform() throws -> Spatial.ProjectiveTransform3D
  func transform(from targetCoordinateSpace: Self) throws -> Spatial.ProjectiveTransform3D
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.CoordinateSpace3D {
  public func transform(from target: Self) throws -> Spatial.ProjectiveTransform3D
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat : @unchecked Swift.Sendable {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat {
  public static let one: Spatial.Size3DFloat
  @inlinable public init(width: Swift.Float = 0, height: Swift.Float = 0, depth: Swift.Float = 0) {
        self = __SPSize3DFloatMake(width, height, depth)
    }
  @inlinable public init(_ xyz: simd.simd_float3) {
        self = __SPSize3DFloatMakeWithVector(xyz)
    }
  @inlinable public init(_ point: Spatial.Point3DFloat) {
        self = __SPSize3DFloatMakeWithPoint(point)
    }
  @inlinable public init(_ xyz: Spatial.Vector3DFloat) {
        self = __SPSize3DFloatMakeWithVector(xyz)
    }
  @inlinable public func unapplying(_ transform: Spatial.AffineTransform3DFloat) -> Spatial.Size3DFloat {
        
        let unapplied = __SPSize3DFloatUnapplyAffineTransform(self, transform)
        
        if __SPSize3DFloatIsValid(unapplied) {
            return unapplied
        } else {
            return self
        }
    }
  @inlinable public func unapplying(_ transform: Spatial.ProjectiveTransform3DFloat) -> Spatial.Size3DFloat {
        
        let unapplied = __SPSize3DFloatUnapplyProjectiveTransform(self, transform)
        
        if __SPSize3DFloatIsValid(unapplied) {
            return unapplied
        } else {
            return self
        }
    }
  public func applying(_ pose: Spatial.Pose3DFloat) -> Spatial.Size3DFloat
  public func unapplying(_ pose: Spatial.Pose3DFloat) -> Spatial.Size3DFloat
  public func applying(_ scaledPose: Spatial.ScaledPose3DFloat) -> Spatial.Size3DFloat
  public func unapplying(_ scaledPose: Spatial.ScaledPose3DFloat) -> Spatial.Size3DFloat
  @inlinable public func scaledBy(x: Swift.Float = 1, y: Swift.Float = 1, z: Swift.Float = 1) -> Spatial.Size3DFloat {
        
        return __SPSize3DFloatScaleBy(self, x, y, z)
    }
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.Size3DFloat {
        
        return _shear(shearFunc: __SPSize3DFloatShear, shear: shear)
    }
  @usableFromInline
  internal func _shear(shearFunc: (Spatial.Size3DFloat, Spatial.Axis3D, Swift.Float, Swift.Float) -> Spatial.Size3DFloat, shear: Spatial.AxisWithFactors) -> Spatial.Size3DFloat
  public var size: Spatial.Size3DFloat {
    get
  }
  @inlinable public func contains(anyOf points: [Spatial.Point3DFloat]) -> Swift.Bool {
        return __SPSize3DFloatContainsAnyPoint(self,
                                               points,
                                               Int32(points.count))
    }
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public func intersection(_ other: Spatial.Size3DFloat) -> Spatial.Size3DFloat? {
        let intersection = __SPSize3DFloatIntersection(self, other)
        
        if intersection != Size3DFloat.zero {
            return intersection
        } else {
            return nil
        }
    }
  #endif
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Size3DFloat, rhs: Spatial.Size3DFloat) -> Swift.Bool {
        return lhs.width == rhs.width && lhs.height == rhs.height && lhs.depth == rhs.depth
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Primitive3D : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  static var zero: Self { get }
  static var infinity: Self { get }
  var isZero: Swift.Bool { get }
  var isFinite: Swift.Bool { get }
  var isNaN: Swift.Bool { get }
  func applying(_ transform: Spatial.AffineTransform3D) -> Self
  func applying(_ transform: Spatial.ProjectiveTransform3D) -> Self
  func applying(_ pose: Spatial.Pose3D) -> Self
  mutating func apply(_ transform: Spatial.AffineTransform3D)
  mutating func apply(_ transform: Spatial.ProjectiveTransform3D)
  mutating func apply(_ pose: Spatial.Pose3D)
  func unapplying(_ transform: Spatial.AffineTransform3D) -> Self
  mutating func unapply(_ transform: Spatial.AffineTransform3D)
  func unapplying(_ transform: Spatial.ProjectiveTransform3D) -> Self
  func unapplying(_ pose: Spatial.Pose3D) -> Self
  mutating func unapply(_ transform: Spatial.ProjectiveTransform3D)
  mutating func unapply(_ pose: Spatial.Pose3D)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Primitive3D {
  public mutating func apply(_ transform: Spatial.AffineTransform3D)
  public mutating func apply(_ transform: Spatial.ProjectiveTransform3D)
  public mutating func apply(_ pose: Spatial.Pose3D)
  public mutating func unapply(_ transform: Spatial.AffineTransform3D)
  public mutating func unapply(_ transform: Spatial.ProjectiveTransform3D)
  public mutating func unapply(_ pose: Spatial.Pose3D)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Translatable3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  func translated(by size: Spatial.Size3D) -> Self
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  mutating func translate(by size: Spatial.Size3D)
  func translated(by vector: Spatial.Vector3D) -> Self
  mutating func translate(by vector: Spatial.Vector3D)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Translatable3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public mutating func translate(by size: Spatial.Size3D) {
        self = self.translated(by: size)
    }
  @inlinable public func translated(by vector: Spatial.Vector3D) -> Self {
        return self.translated(by: vector)
    }
  @inlinable public mutating func translate(by vector: Spatial.Vector3D) {
        self = self.translated(by: vector)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Scalable3D {
  func scaledBy(x: Swift.Double, y: Swift.Double, z: Swift.Double) -> Self
  mutating func scaleBy(x: Swift.Double, y: Swift.Double, z: Swift.Double)
  func scaled(by size: Spatial.Size3D) -> Self
  mutating func scale(by size: Spatial.Size3D)
  func uniformlyScaled(by scale: Swift.Double) -> Self
  mutating func uniformlyScale(by scale: Swift.Double)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Scalable3D {
  public mutating func scaleBy(x: Swift.Double = 1, y: Swift.Double = 1, z: Swift.Double = 1)
  public mutating func scale(by scale: Spatial.Size3D)
  public mutating func uniformlyScale(by scale: Swift.Double)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Rotatable3D {
  func rotated(by rotation: Spatial.Rotation3D) -> Self
  mutating func rotate(by rotation: Spatial.Rotation3D)
  func rotated(by quaternion: simd.simd_quatd) -> Self
  mutating func rotate(by quaternion: simd.simd_quatd)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotatable3D {
  public mutating func rotate(by rotation: Spatial.Rotation3D)
  public mutating func rotate(by rotation: simd.simd_quatd)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public enum AxisWithFactors {
  case xAxis(yShearFactor: Swift.Double, zShearFactor: Swift.Double)
  case yAxis(xShearFactor: Swift.Double, zShearFactor: Swift.Double)
  case zAxis(xShearFactor: Swift.Double, yShearFactor: Swift.Double)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Shearable3D {
  func sheared(_ shear: Spatial.AxisWithFactors) -> Self
  mutating func shear(_ shear: Spatial.AxisWithFactors)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Shearable3D {
  public mutating func shear(_ shear: Spatial.AxisWithFactors)
  @usableFromInline
  internal func _shear(shearFunc: (Self, Spatial.Axis3D, Swift.Double, Swift.Double) -> Self, shear: Spatial.AxisWithFactors) -> Self
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Volumetric {
  var size: Spatial.Size3D { get }
  func contains(_ other: Self) -> Swift.Bool
  func contains(point: Spatial.Point3D) -> Swift.Bool
  func union(_ other: Self) -> Self
  #if compiler(>=5.3) && $NonescapableTypes
  func intersection(_ other: Self) -> Self?
  #endif
  mutating func formIntersection(_ other: Self)
  mutating func formUnion(_ other: Self)
  @available(*, deprecated, renamed: "contains(anyOf:)")
  func containsAny(of points: [Spatial.Point3D]) -> Swift.Bool
  func contains(anyOf points: [Spatial.Point3D]) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Volumetric {
  public mutating func formIntersection(_ other: Self)
  public mutating func formUnion(_ other: Self)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public struct Dimension3DSet : Swift.OptionSet {
  public let rawValue: Swift.Int
  public static let x: Spatial.Dimension3DSet
  public static let y: Spatial.Dimension3DSet
  public static let z: Spatial.Dimension3DSet
  public static let all: Spatial.Dimension3DSet
  public init(rawValue: Swift.Int)
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias ArrayLiteralElement = Spatial.Dimension3DSet
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Element = Spatial.Dimension3DSet
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias RawValue = Swift.Int
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  public static let one: Spatial.Size3D
  @inlinable public init(width: Swift.Double = 0, height: Swift.Double = 0, depth: Swift.Double = 0) {
        self = __SPSize3DMake(width, height, depth)
    }
  @inlinable public init(_ xyz: simd.simd_double3) {
        self = __SPSize3DMakeWithVector(xyz)
    }
  @inlinable public init(_ point: Spatial.Point3D) {
        self = __SPSize3DMakeWithPoint(point)
    }
  @inlinable public init(_ xyz: Spatial.Vector3D) {
        self = __SPSize3DMakeWithVector(xyz)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Spatial.Primitive3D {
  @inlinable public func unapplying(_ transform: Spatial.AffineTransform3D) -> Spatial.Size3D {
        
        let unapplied = __SPSize3DUnapplyAffineTransform(self, transform)
        
        if __SPSize3DIsValid(unapplied) {
            return unapplied
        } else {
            return self
        }
    }
  @inlinable public func unapplying(_ transform: Spatial.ProjectiveTransform3D) -> Spatial.Size3D {
        
        let unapplied = __SPSize3DUnapplyProjectiveTransform(self, transform)
        
        if __SPSize3DIsValid(unapplied) {
            return unapplied
        } else {
            return self
        }
    }
  public func applying(_ pose: Spatial.Pose3D) -> Spatial.Size3D
  public func unapplying(_ pose: Spatial.Pose3D) -> Spatial.Size3D
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Size3D {
  public func applying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Size3D
  public func unapplying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Size3D
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Spatial.Scalable3D {
  @inlinable public func scaledBy(x: Swift.Double = 1, y: Swift.Double = 1, z: Swift.Double = 1) -> Spatial.Size3D {
        
        return __SPSize3DScaleBy(self, x, y, z)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Spatial.Rotatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Spatial.Shearable3D {
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.Size3D {
        
        return _shear(shearFunc: __SPSize3DShear, shear: shear)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Spatial.Volumetric {
  public var size: Spatial.Size3D {
    get
  }
  @inlinable public func contains(anyOf points: [Spatial.Point3D]) -> Swift.Bool {
        return __SPSize3DContainsAnyPoint(self,
                                          points,
                                          Int32(points.count))
    }
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public func intersection(_ other: Spatial.Size3D) -> Spatial.Size3D? {
        let intersection = __SPSize3DIntersection(self, other)
        
        if intersection != Size3D.zero {
            return intersection
        } else {
            return nil
        }
    }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Size3D, rhs: Spatial.Size3D) -> Swift.Bool {
        return lhs.width == rhs.width && lhs.height == rhs.height && lhs.depth == rhs.depth
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Size3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D : @unchecked Swift.Sendable {
  public init(_ quaternion: simd.simd_quatd)
  public var angle: Spatial.Angle2D {
    get
    set
  }
  public var axis: Spatial.RotationAxis3D {
    get
    set
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D {
  public init(position: Spatial.Point3D = Point3D(x: 0, y: 0, z: 0), target: Spatial.Point3D, up: Spatial.Vector3D = Vector3D(x: 0, y: 1, z: 0))
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Rotation3D {
  public init(forward: Spatial.Vector3D)
}
extension Spatial.Rotation3D {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  @backDeployed(before: macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0)
  public init() {
        self = Rotation3D(simd_quaternion(simd_double4(x: 0, y: 0, z: 0, w: 1)))
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Rotation3D : Spatial.Rotatable3D {
  public func rotated(by rotation: Spatial.Rotation3D) -> Spatial.Rotation3D
  public func rotated(by quaternion: simd.simd_quatd) -> Spatial.Rotation3D
  public enum SlerpPath {
    case shortest
    case longest
    case automatic
    public static func == (a: Spatial.Rotation3D.SlerpPath, b: Spatial.Rotation3D.SlerpPath) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func slerp(from: Spatial.Rotation3D, to: Spatial.Rotation3D, t: Swift.Double, along path: Spatial.Rotation3D.SlerpPath = .shortest) -> Spatial.Rotation3D
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Rotation3D.SlerpPath : @unchecked Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Rotation3D {
  public static func spline(leftEndpoint r0: Spatial.Rotation3D, from r1: Spatial.Rotation3D, to r2: Spatial.Rotation3D, rightEndpoint r3: Spatial.Rotation3D, t: Swift.Double) -> Spatial.Rotation3D
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Rotation3D, rhs: Spatial.Rotation3D) -> Swift.Bool {
        __SPRotation3DEqualToRotation(lhs, rhs)
    }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Rotation3D {
  @inlinable public func isApproximatelyEqual(to other: Spatial.Rotation3D, tolerance: Swift.Double = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPRotation3DAlmostEqualToRotation(self, other, tolerance)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Rotation3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.EulerAngles {
  public typealias Order = Spatial.__SPEulerAngleOrder
  public init(angles: simd.simd_float3, order: Spatial.EulerAngles.Order)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.EulerAngles {
  public init(x: Spatial.Angle2D, y: Spatial.Angle2D, z: Spatial.Angle2D, order: Spatial.EulerAngles.Order)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Rotation3D {
  public func swingTwist(twistAxis: Spatial.RotationAxis3D) -> (swing: Spatial.Rotation3D, twist: Spatial.Rotation3D)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.__SPEulerAngleOrder {
  @available(*, deprecated, renamed: "EulerAngles.Order.xyz")
  public static let pitchYawRoll: Spatial.__SPEulerAngleOrder
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
  public static let xyz: Spatial.__SPEulerAngleOrder
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
  public static let zxy: Spatial.__SPEulerAngleOrder
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.__SPEulerAngleOrder : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat : @unchecked Swift.Sendable {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat {
  @inlinable public var translation: Spatial.Vector3DFloat {
    get {
            return __SPAffineTransform3DFloatGetTranslation(self)
        }
    set {
            __SPAffineTransform3DFloatSetTranslation(&self, newValue)
        }
  }
  @inlinable public func isApproximatelyEqual(to other: Spatial.AffineTransform3DFloat, tolerance: Swift.Float = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPAffineTransform3DFloatAlmostEqualToTransform(self, other, tolerance)
    }
  @inlinable public init() {
         self.init(scale: Size3DFloat(width: 1, height: 1, depth: 1))
     }
  @inlinable public init(scale: Spatial.Size3DFloat = Size3DFloat(width: 1.0, height: 1, depth: 1), rotation: Spatial.Rotation3DFloat = .identity, translation: Spatial.Vector3DFloat = .zero) {
        
        
        self = __SPAffineTransform3DFloatMake(scale,
                                         rotation,
                                         translation)
    }
  @inlinable public init(shear: Spatial.AxisWithFactorsFloat) {
        switch shear {
            case .xAxis(let yShearFactor, let zShearFactor):
                self = __SPAffineTransform3DFloatMakeShear(.x, yShearFactor, zShearFactor)
            case .yAxis(let xShearFactor, let zShearFactor):
                self = __SPAffineTransform3DFloatMakeShear(.y, xShearFactor, zShearFactor)
            case .zAxis(let xShearFactor, let yShearFactor):
                self = __SPAffineTransform3DFloatMakeShear(.z, xShearFactor, yShearFactor)
            @unknown default:
                fatalError("Unsupported shear")
        }
    }
  @inlinable public init(pose: Spatial.Pose3DFloat) {
        
        self = __SPAffineTransform3DFloatMakeWithPose(pose)
    }
  @inlinable public init(scaledPose: Spatial.ScaledPose3DFloat) {
        
        self = __SPAffineTransform3DFloatMakeWithScaledPose(scaledPose)
    }
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactorsFloat) -> Spatial.AffineTransform3DFloat {
        return _shear(shearFunc: __SPAffineTransform3DFloatShear, shear: shear)
    }
  @usableFromInline
  internal func _shear(shearFunc: (Spatial.AffineTransform3DFloat, Spatial.Axis3D, Swift.Float, Swift.Float) -> Spatial.AffineTransform3DFloat, shear: Spatial.AxisWithFactors) -> Spatial.AffineTransform3DFloat
  @inlinable public func scaledBy(x: Swift.Float = 1, y: Swift.Float = 1, z: Swift.Float = 1) -> Spatial.AffineTransform3DFloat {
        return __SPAffineTransform3DFloatScaleBy(self, x, y, z)
    }
  @inlinable public func isUniform(overDimensions: Spatial.Dimension3DSet) -> Swift.Bool {
        
        let axes = Axis3D(rawValue: UInt32(overDimensions.rawValue))
        
        return __SPAffineTransform3DFloatIsUniformOverDimensions(self,
                                                            axes)
    }
  @inlinable public func flipped(along axis: Spatial.Axis3D) -> Spatial.AffineTransform3DFloat {
        return __SPAffineTransform3DFloatFlip(self, axis)
    }
  public mutating func flip(along axis: Spatial.Axis3D)
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public var rotation: Spatial.Rotation3DFloat? {
    get {
        
        let r = __SPAffineTransform3DFloatGetRotation(self)
        
        if __SPRotation3DFloatIsValid(r) {
            return r
        } else {
            return nil
        }
    }
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public var inverse: Spatial.AffineTransform3DFloat? {
    get {
        
        let t = __SPAffineTransform3DFloatInverted(self)
        
        if __SPAffineTransform3DFloatIsValid(t) {
            return t
        } else {
            return nil
        }
    }
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func changeBasis(from: Spatial.AffineTransform3DFloat = .identity, to: Spatial.AffineTransform3DFloat) -> Spatial.AffineTransform3DFloat?
  #endif
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.AffineTransform3DFloat, rhs: Spatial.AffineTransform3DFloat) -> Swift.Bool {
        return lhs.matrix == rhs.matrix
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat {
  public var columns: (Spatial.Vector3DFloat, Spatial.Vector3DFloat, Spatial.Vector3DFloat, Spatial.Vector3DFloat) {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public struct WorldReferenceCoordinateSpace : Spatial.CoordinateSpace3D {
  #if compiler(>=5.3) && $NonescapableTypes
  public var ancestorSpace: Swift.Never? {
    get
  }
  #endif
  public func ancestorFromSpaceTransform() throws -> Spatial.ProjectiveTransform3D
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias AncestorCoordinateSpace = Swift.Never
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.WorldReferenceCoordinateSpace : Spatial.CoordinateSpace3DFloat {
  public func ancestorFromSpaceTransformFloat() throws -> Spatial.ProjectiveTransform3DFloat
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Swift.Never : Spatial.CoordinateSpace3D, Spatial.CoordinateSpace3DFloat {
  #if compiler(>=5.3) && $NonescapableTypes
  public var ancestorSpace: Swift.Never? {
    get
  }
  #endif
  public typealias AncestorCoordinateSpace = Swift.Never
  public func ancestorFromSpaceTransform() throws -> Spatial.ProjectiveTransform3D
  public func ancestorFromSpaceTransformFloat() throws -> Spatial.ProjectiveTransform3DFloat
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.CoordinateSpace3D where Self == Spatial.WorldReferenceCoordinateSpace {
  public static var worldReference: Spatial.WorldReferenceCoordinateSpace {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public protocol CoordinateSpace3DFloat : Spatial.CoordinateSpace3D where Self.AncestorCoordinateSpace : Spatial.CoordinateSpace3DFloat {
  func ancestorFromSpaceTransformFloat() throws -> Spatial.ProjectiveTransform3DFloat
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public protocol ProjectiveTransformable3DFloat : Spatial.ProjectiveTransformable3D {
  func applying(_ transform: Spatial.ProjectiveTransform3DFloat) -> Self
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransformable3DFloat {
  public func applying(_ transform: Spatial.ProjectiveTransform3D) -> Self
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.CoordinateSpace3DFloat {
  public func ancestorFromSpaceTransform() throws -> Spatial.ProjectiveTransform3D
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.CoordinateSpace3DFloat {
  public func transform<Space>(from target: Space) throws -> Spatial.ProjectiveTransform3DFloat where Space : Spatial.CoordinateSpace3DFloat
  public func convert<T, Space>(value: T, to targetCoordinateSpace: Space) throws -> T where T : Spatial.ProjectiveTransformable3DFloat, Space : Spatial.CoordinateSpace3DFloat
  public func convert<T, Space>(value: T, from sourceCoordinateSpace: Space) throws -> T where T : Spatial.ProjectiveTransformable3DFloat, Space : Spatial.CoordinateSpace3DFloat
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat : Spatial.ProjectiveTransformable3DFloat {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat : Spatial.ProjectiveTransformable3DFloat {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat : Spatial.ProjectiveTransformable3DFloat {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3DFloat : Spatial.ProjectiveTransformable3DFloat {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Angle2D {
  public init(_ angle: Spatial.Angle2DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Angle2DFloat {
  public init(_ angle: Spatial.Angle2D)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.RotationAxis3D {
  public init(_ axis: Spatial.RotationAxis3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.RotationAxis3DFloat {
  public init(_ axis: Spatial.RotationAxis3D)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotation3D {
  public init(_ rotation: Spatial.Rotation3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotation3DFloat {
  public init(_ rotation: Spatial.Rotation3D)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3D {
  public init(_ point: Spatial.Point3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat {
  public init(_ point: Spatial.Point3D)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3D {
  public init(_ vector: Spatial.Vector3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Vector3DFloat {
  public init(_ vector: Spatial.Vector3D)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3D {
  public init(_ size: Spatial.Size3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Size3DFloat {
  public init(_ size: Spatial.Size3D)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3D {
  public init(_ rect: Spatial.Rect3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rect3DFloat {
  public init(_ rect: Spatial.Rect3D)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3D {
  public init(_ ray: Spatial.Ray3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3DFloat {
  public init(_ ray: Spatial.Ray3D)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3D {
  public init(_ pose: Spatial.Pose3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3DFloat {
  public init(_ pose: Spatial.Pose3D)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ScaledPose3D {
  public init(_ pose: Spatial.ScaledPose3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ScaledPose3DFloat {
  public init(_ pose: Spatial.ScaledPose3D)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3D {
  public init(_ transform: Spatial.AffineTransform3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3DFloat {
  public init(_ transform: Spatial.AffineTransform3D)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3D {
  public init(_ transform: Spatial.ProjectiveTransform3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.ProjectiveTransform3DFloat {
  public init(_ transform: Spatial.ProjectiveTransform3D)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.SphericalCoordinates3D {
  public init(_ coords: Spatial.SphericalCoordinates3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.SphericalCoordinates3DFloat {
  public init(_ coords: Spatial.SphericalCoordinates3D)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D {
  @inlinable public var translation: Spatial.Vector3D {
    get {
            return __SPAffineTransform3DGetTranslation(self)
        }
    set {
            __SPAffineTransform3DSetTranslation(&self, newValue)
        }
  }
  @inlinable public func isApproximatelyEqual(to other: Spatial.AffineTransform3D, tolerance: Swift.Double = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPAffineTransform3DAlmostEqualToTransform(self, other, tolerance)
    }
  @inlinable public init() {
         self.init(scale: Size3D(width: 1, height: 1, depth: 1))
     }
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public init(scale: Spatial.Size3D = Size3D(width: 1.0, height: 1, depth: 1), rotation: Spatial.Rotation3D = .zero, translation: Spatial.Size3D) {
        
        
        self = __SPAffineTransform3DMake(scale,
                                         rotation,
                                         Vector3D(translation))
    }
  @inlinable public init(scale: Spatial.Size3D = Size3D(width: 1.0, height: 1, depth: 1), rotation: Spatial.Rotation3D = .zero, translation: Spatial.Vector3D = .zero) {
        
        
        self = __SPAffineTransform3DMake(scale,
                                         rotation,
                                         translation)
    }
  @inlinable public init(shear: Spatial.AxisWithFactors) {
        switch shear {
            case .xAxis(let yShearFactor, let zShearFactor):
                self = __SPAffineTransform3DMakeShear(.x, yShearFactor, zShearFactor)
            case .yAxis(let xShearFactor, let zShearFactor):
                self = __SPAffineTransform3DMakeShear(.y, xShearFactor, zShearFactor)
            case .zAxis(let xShearFactor, let yShearFactor):
                self = __SPAffineTransform3DMakeShear(.z, xShearFactor, yShearFactor)
            @unknown default:
                fatalError("Unsupported shear")
        }
    }
  @inlinable public init(pose: Spatial.Pose3D) {
        
        self = __SPAffineTransform3DMakeWithPose(pose)
    }
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
  @inlinable public init(scaledPose: Spatial.ScaledPose3D) {
        
        self = __SPAffineTransform3DMakeWithScaledPose(scaledPose)
    }
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.AffineTransform3D {
        return _shear(shearFunc: __SPAffineTransform3DShear, shear: shear)
    }
  @inlinable public func scaledBy(x: Swift.Double = 1, y: Swift.Double = 1, z: Swift.Double = 1) -> Spatial.AffineTransform3D {
        return __SPAffineTransform3DScaleBy(self, x, y, z)
    }
  @inlinable public func isUniform(overDimensions: Spatial.Dimension3DSet) -> Swift.Bool {
        
        let axes = Axis3D(rawValue: UInt32(overDimensions.rawValue))
        
        return __SPAffineTransform3DIsUniformOverDimensions(self,
                                                            axes)
    }
  @inlinable public func flipped(along axis: Spatial.Axis3D) -> Spatial.AffineTransform3D {
        return __SPAffineTransform3DFlip(self, axis)
    }
  public mutating func flip(along axis: Spatial.Axis3D)
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public var rotation: Spatial.Rotation3D? {
    get {
        
        let r = __SPAffineTransform3DGetRotation(self)
        
        if __SPRotation3DIsValid(r) {
            return r
        } else {
            return nil
        }
    }
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public var inverse: Spatial.AffineTransform3D? {
    get {
        
        let t = __SPAffineTransform3DInverted(self)
        
        if __SPAffineTransform3DIsValid(t) {
            return t
        } else {
            return nil
        }
    }
  }
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.AffineTransform3D, rhs: Spatial.AffineTransform3D) -> Swift.Bool {
        return lhs.matrix == rhs.matrix
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.AffineTransform3D {
  #if compiler(>=5.3) && $NonescapableTypes
  public func changeBasis(from: Spatial.AffineTransform3D = .identity, to: Spatial.AffineTransform3D) -> Spatial.AffineTransform3D?
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.AffineTransform3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Spatial.AffineTransform3D {
  @_alwaysEmitIntoClient public var columns: (Spatial.Vector3D, Spatial.Vector3D, Spatial.Vector3D, Spatial.Vector3D) {
    get {
        return (
            Vector3D(matrix.columns.0),
            Vector3D(matrix.columns.1),
            Vector3D(matrix.columns.2),
            Vector3D(matrix.columns.3)
        )
    }
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3DFloat {
  public init(origin: Spatial.Point3DFloat = .zero, direction: Spatial.Vector3DFloat)
  public init(origin: simd.simd_float3 = .zero, direction: simd.simd_float3)
  public func intersects(_ rect: Spatial.Rect3DFloat) -> Swift.Bool
  public func applying(_ pose: Spatial.Pose3DFloat) -> Spatial.Ray3DFloat
  public mutating func apply(_ pose: Spatial.Pose3DFloat)
  public func unapplying(_ scaledPose: Spatial.ScaledPose3DFloat) -> Spatial.Ray3DFloat
  public func applying(_ scaledPose: Spatial.ScaledPose3DFloat) -> Spatial.Ray3DFloat
  public func applying(_ transform: Spatial.AffineTransform3DFloat) -> Spatial.Ray3DFloat
  public func unapplying(_ transform: Spatial.AffineTransform3DFloat) -> Spatial.Ray3DFloat
  public func applying(_ transform: Spatial.ProjectiveTransform3DFloat) -> Spatial.Ray3DFloat
  public func unapplying(_ transform: Spatial.ProjectiveTransform3DFloat) -> Spatial.Ray3DFloat
  public func unapplying(_ pose: Spatial.Pose3DFloat) -> Spatial.Ray3DFloat
  public func rotated(by rotation: Spatial.Rotation3DFloat, around pivot: Spatial.Point3DFloat) -> Spatial.Ray3DFloat
  public func rotated(by quaternion: simd.simd_quatf, around pivot: Spatial.Point3DFloat) -> Spatial.Ray3DFloat
  public var isNaN: Swift.Bool {
    get
  }
  public var isFinite: Swift.Bool {
    get
  }
  public var isZero: Swift.Bool {
    get
  }
  public func rotated(by rotation: Spatial.Rotation3DFloat) -> Spatial.Ray3DFloat
  public func rotated(by quaternion: simd.simd_quatf) -> Spatial.Ray3DFloat
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3DFloat : @unchecked Swift.Sendable {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3DFloat : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Ray3DFloat, rhs: Spatial.Ray3DFloat) -> Swift.Bool {
        return lhs.origin == rhs.origin && lhs.direction == rhs.direction
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3DFloat : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3DFloat : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3DFloat : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Ray3DFloat : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3DFloat {
  @inlinable public init(position: Spatial.Point3DFloat = .zero, rotation: Spatial.Rotation3DFloat) {
        
        self = __SPPose3DFloatMake(position, rotation)
    }
  @inlinable public init(position: simd.simd_float3 = .zero, rotation: simd.simd_quatf) {
        
        self = __SPPose3DFloatMakeWithVector(position, rotation)
    }
  @inlinable public init(position: Spatial.Point3DFloat = .zero, target: Spatial.Point3DFloat, up: Spatial.Vector3DFloat = Vector3DFloat(x: 0, y: 1, z: 0)) {
        
        self = __SPPose3DFloatMakeLookAt(position, target, up)
    }
  @inlinable public init(forward: Spatial.Vector3DFloat, up: Spatial.Vector3DFloat = Vector3DFloat(x: 0, y: 1, z: 0)) {
        
        self = __SPPose3DFloatMakeLookAt(forward, up)
    }
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public init?(transform: Spatial.AffineTransform3DFloat) {
        
        let p = __SPPose3DFloatMakeWithAffineTransform(transform)
        
        if __SPPose3DFloatIsValid(p) {
            self = p
        } else {
            return nil
        }
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public init?(transform: Spatial.ProjectiveTransform3DFloat) {
        
        let t = __SPPose3DFloatMakeWithProjectiveTransform(transform)
        
        if __SPPose3DFloatIsValid(t) {
            self = t
        } else {
            return nil
        }
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public init?(_ matrix: simd.simd_float4x4) {
        
        let p = __SPPose3DFloatMakeWith4x4Matrix(matrix)
        
        if __SPPose3DFloatIsValid(p) {
            self = p
        } else {
            return nil
        }
    }
  #endif
  @inlinable public var matrix: simd.simd_float4x4 {
    get {
        return __SPPose3DFloatGet4x4Matrix(self)
    }
  }
  @inlinable public var inverse: Spatial.Pose3DFloat {
    get {
        return __SPPose3DFloatGetInverse(self)
    }
  }
  @inlinable public func concatenating(_ transform: Spatial.Pose3DFloat) -> Spatial.Pose3DFloat {
        return __SPPose3DFloatConcatenation(self, transform)
    }
  @inlinable public static var identity: Spatial.Pose3DFloat {
    get {
        return __SPPose3DFloatIdentity
    }
  }
  @inlinable public func flipped(along axis: Spatial.Axis3D) -> Spatial.Pose3DFloat {
        return __SPPose3DFloatFlip(self, axis)
    }
  public mutating func flip(along axis: Spatial.Axis3D)
  @inlinable public func translated(by offset: Spatial.Vector3DFloat) -> Spatial.Pose3DFloat {
        return __SPPose3DFloatTranslate(self, offset)
    }
  @inlinable public func rotated(by rotation: Spatial.Rotation3DFloat) -> Spatial.Pose3DFloat {
        return __SPPose3DFloatRotate(self, rotation)
    }
  @inlinable public func rotated(by quaternion: simd.simd_quatf) -> Spatial.Pose3DFloat {
        return __SPPose3DFloatRotateByQuaternion(self, quaternion)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3DFloat : @unchecked Swift.Sendable {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3DFloat : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Pose3DFloat, rhs: Spatial.Pose3DFloat) -> Swift.Bool {
        return __SPPose3DFloatEqualToPose(lhs, rhs)
    }
  @inlinable public func isApproximatelyEqual(to other: Spatial.Pose3DFloat, tolerance: Swift.Float = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPPose3DFloatAlmostEqualToPose(self, other, tolerance)
    }
  @inlinable public var isIdentity: Swift.Bool {
    get {
        return __SPPose3DFloatIsIdentity(self)
    }
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3DFloat : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3DFloat : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3DFloat : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Pose3DFloat : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotation3DFloat : @unchecked Swift.Sendable {
  public init(angle: Spatial.Angle2DFloat, axis: Spatial.RotationAxis3DFloat)
  public init(forward: Spatial.Vector3DFloat, up: Spatial.Vector3DFloat)
  public init(_ quaternion: simd.simd_quatf)
  public var angle: Spatial.Angle2DFloat {
    get
    set
  }
  public var axis: Spatial.RotationAxis3DFloat {
    get
    set
  }
  public init(position: Spatial.Point3DFloat = Point3DFloat(x: 0, y: 0, z: 0), target: Spatial.Point3DFloat, up: Spatial.Vector3DFloat = Vector3DFloat(x: 0, y: 1, z: 0))
  public init(forward: Spatial.Vector3DFloat)
  public init()
  public func rotated(by rotation: Spatial.Rotation3DFloat) -> Spatial.Rotation3DFloat
  public func rotated(by quaternion: simd.simd_quatf) -> Spatial.Rotation3DFloat
  public static func slerp(from: Spatial.Rotation3DFloat, to: Spatial.Rotation3DFloat, t: Swift.Float, along path: Spatial.Rotation3D.SlerpPath = .shortest) -> Spatial.Rotation3DFloat
  public static func spline(leftEndpoint r0: Spatial.Rotation3DFloat, from r1: Spatial.Rotation3DFloat, to r2: Spatial.Rotation3DFloat, rightEndpoint r3: Spatial.Rotation3DFloat, t: Swift.Float) -> Spatial.Rotation3DFloat
  public func swingTwist(twistAxis: Spatial.RotationAxis3DFloat) -> (swing: Spatial.Rotation3DFloat, twist: Spatial.Rotation3DFloat)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotation3DFloat : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Rotation3DFloat, rhs: Spatial.Rotation3DFloat) -> Swift.Bool {
        __SPRotation3DFloatEqualToRotation(lhs, rhs)
    }
  @inlinable public func isApproximatelyEqual(to other: Spatial.Rotation3DFloat, tolerance: Swift.Float = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPRotation3DFloatAlmostEqualToRotation(self, other, tolerance)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotation3DFloat : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotation3DFloat : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotation3DFloat : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Rotation3DFloat : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.EulerAnglesFloat {
  public init(x: Spatial.Angle2DFloat, y: Spatial.Angle2DFloat, z: Spatial.Angle2DFloat, order: Spatial.EulerAngles.Order)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat : @unchecked Swift.Sendable {
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat {
  @inlinable public init(x: Swift.Float = 0, y: Swift.Float = 0, z: Swift.Float = 0) {
        self = __SPPoint3DFloatMake(x, y, z)
    }
  @inlinable public init(_ xyz: simd.simd_float3) {
        self = __SPPoint3DFloatMakeWithVector(xyz)
    }
  @inlinable public init(_ xyz: Spatial.Vector3DFloat) {
        self = __SPPoint3DFloatMakeWithVector(xyz)
    }
  @inlinable public init(_ size: Spatial.Size3DFloat) {
        self = __SPPoint3DFloatMakeWithSize(size)
    }
  public func applying(_ pose: Spatial.Pose3DFloat) -> Spatial.Point3DFloat
  public func unapplying(_ pose: Spatial.Pose3DFloat) -> Spatial.Point3DFloat
  public func applying(_ scaledPose: Spatial.ScaledPose3DFloat) -> Spatial.Point3DFloat
  public func unapplying(_ pose: Spatial.ScaledPose3DFloat) -> Spatial.Point3DFloat
  @inlinable public func isApproximatelyEqual(to other: Spatial.Point3DFloat, tolerance: Swift.Float = sqrt(.ulpOfOne)) -> Swift.Bool {
      
        return __SPPoint3DFloatAlmostEqualToPoint(self, other, tolerance)
    }
  public func distance(to other: Spatial.Point3DFloat) -> Swift.Float
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Point3DFloat, rhs: Spatial.Point3DFloat) -> Swift.Bool {
        return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension Spatial.Point3DFloat : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Axis3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Axis3D {
  @inlinable public static var x: Spatial.Axis3D {
    get {
        return __SPAxisX
    }
  }
  @inlinable public static var y: Spatial.Axis3D {
    get {
        return __SPAxisY
    }
  }
  @inlinable public static var z: Spatial.Axis3D {
    get {
        return __SPAxisZ
    }
  }
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Spatial.Axis3D : Swift.Hashable, Swift.Codable {
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D {
  public static let x: Spatial.RotationAxis3D
  public static let y: Spatial.RotationAxis3D
  public static let z: Spatial.RotationAxis3D
  public static let xy: Spatial.RotationAxis3D
  public static let yz: Spatial.RotationAxis3D
  public static let xz: Spatial.RotationAxis3D
  public static let xyz: Spatial.RotationAxis3D
  @inlinable public init(x: Swift.Double = 0, y: Swift.Double = 0, z: Swift.Double = 0) {
        self = __SPRotationAxis3DMake(x, y, z)
    }
  @inlinable public var x: Swift.Double {
    get {
            return self.__x
        }
    set {
            self.__x = newValue
        }
  }
  @inlinable public var y: Swift.Double {
    get {
            return self.__y
        }
    set {
            self.__y = newValue
        }
  }
  @inlinable public var z: Swift.Double {
    get {
            return self.__z
        }
    set {
            self.__z = newValue
        }
  }
  @inlinable public init(_ xyz: simd.simd_double3) {
        self = __SPRotationAxis3DMakeWithVector(xyz)
    }
  @inlinable public init(_ xyz: Spatial.Vector3D) {
        self = __SPRotationAxis3DMakeWithVector(xyz)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.RotationAxis3D, rhs: Spatial.RotationAxis3D) -> Swift.Bool {
        return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.RotationAxis3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Spatial.Shearable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Spatial.Scalable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Spatial.Rotatable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Spatial.Translatable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Shearable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Scalable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Rotatable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Translatable3D {}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Rotation3D.SlerpPath : Swift.Equatable {}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Rotation3D.SlerpPath : Swift.Hashable {}
