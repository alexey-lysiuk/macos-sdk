// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 effective-5.10 (swiftlang-6.2.1.4.7 clang-1700.4.4.1)
// swift-module-flags: -target arm64e-apple-macos26.1 -target-variant arm64e-apple-ios26.1-macabi -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftMetal -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-upcoming-feature MemberImportVisibility -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 370.63.7 -module-name Metal
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.1
@_exported import Metal
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@available(macOS 10.15, iOS 13.0, tvOS 13.0, *)
@usableFromInline
@objc internal protocol __MTLObjCProxy : ObjectiveC.NSObjectProtocol {
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  @objc(__waitUntilScheduledAsync:) func __waitUntilScheduledAsync(_: @escaping (any Metal.MTLCommandBuffer) -> Swift.Void)
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  @objc(__waitUntilCompletedAsync:) func __waitUntilCompletedAsync(_: @escaping (any Metal.MTLCommandBuffer) -> Swift.Void)
  @objc(waitUntilScheduled) func __waitUntilScheduledSync()
  @objc(waitUntilCompleted) func __waitUntilCompletedSync()
}
@available(macOS 10.11, iOS 8.0, tvOS 8.0, *)
extension Metal.MTLBlitCommandEncoder {
  public func fill(buffer: any Metal.MTLBuffer, range: Swift.Range<Swift.Int>, value: Swift.UInt8)
  @available(macOS 10.14, iOS 12.0, tvOS 12.0, *)
  public func resetCommandsInBuffer(_ buffer: any Metal.MTLIndirectCommandBuffer, range: Swift.Range<Swift.Int>)
  @available(macOS 10.14, iOS 12.0, tvOS 12.0, *)
  public func copyIndirectCommandBuffer(_ buffer: any Metal.MTLIndirectCommandBuffer, sourceRange: Swift.Range<Swift.Int>, destination: any Metal.MTLIndirectCommandBuffer, destinationIndex: Swift.Int)
  @available(macOS 10.14, iOS 12.0, tvOS 12.0, *)
  public func optimizeIndirectCommandBuffer(_ buffer: any Metal.MTLIndirectCommandBuffer, range: Swift.Range<Swift.Int>)
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
  public func resolveCounters(_ sampleBuffer: any Metal.MTLCounterSampleBuffer, range: Swift.Range<Swift.Int>, destinationBuffer: any Metal.MTLBuffer, destinationOffset: Swift.Int)
}
@available(macOS 10.11, iOS 8.0, tvOS 8.0, *)
extension Metal.MTLBuffer {
  @available(macOS 10.11, macCatalyst 14.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  public func didModifyRange(_ range: Swift.Range<Swift.Int>)
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, *)
  public func addDebugMarker(_ marker: Swift.String, range: Swift.Range<Swift.Int>)
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
public struct MTLLogContainer : Swift.Sequence {
  public typealias Element = Metal.MTLFunctionLog
  public struct Iterator : Swift.IteratorProtocol {
    #if compiler(>=5.3) && $NonescapableTypes
    public mutating func next() -> (any Metal.MTLFunctionLog)?
    #endif
    @available(iOS 14.0, tvOS 14.0, macOS 11.0, *)
    public typealias Element = any Metal.MTLFunctionLog
  }
  public func makeIterator() -> Metal.MTLLogContainer.Iterator
}
@available(macOS 10.11, iOS 8.0, tvOS 8.0, *)
extension Metal.MTLCommandBuffer {
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
  public var logs: Metal.MTLLogContainer {
    get
  }
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, *)
  public func useResidencySets(_ residencySets: [any Metal.MTLResidencySet])
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, *)
  @backDeployed(before: macOS 16.0, iOS 19.0, tvOS 19.0, visionOS 3.0)
  public func scheduled() async {
        if #available(macOS 16.0, iOS 19.0, tvOS 19.0, visionOS 3.0, *) {
            await withUnsafeContinuation { continuation in
                let handler: MTLCommandBufferHandler = { _ in continuation.resume() }
                unsafeBitCast(self, to: __MTLObjCProxy.self).__waitUntilScheduledAsync(handler)
            }
        } else {
            unsafeBitCast(self, to: __MTLObjCProxy.self).__waitUntilScheduledSync()
        }
    }
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, *)
  @backDeployed(before: macOS 16.0, iOS 19.0, tvOS 19.0, visionOS 3.0)
  public func completed() async {
        if #available(macOS 16.0, iOS 19.0, tvOS 19.0, visionOS 3.0, *) {
            await withUnsafeContinuation { continuation in
                let handler: MTLCommandBufferHandler = { _ in continuation.resume() }
                unsafeBitCast(self, to: __MTLObjCProxy.self).__waitUntilCompletedAsync(handler)
            }
        } else {
            unsafeBitCast(self, to: __MTLObjCProxy.self).__waitUntilCompletedSync()
        }
    }
}
@available(macOS 11.0, iOS 14.0, tvOS 16.0, *)
extension Metal.MTLAccelerationStructureCommandEncoder {
  public func useResources(_ resources: [any Metal.MTLResource], usage: Metal.MTLResourceUsage)
  public func useHeaps(_ heaps: [any Metal.MTLHeap])
}
@available(macOS 11.0, iOS 14.0, tvOS 16.0, *)
extension Metal.MTLVisibleFunctionTable {
  #if compiler(>=5.3) && $NonescapableTypes
  public func setFunctions(_ functions: [(any Metal.MTLFunctionHandle)?], range: Swift.Range<Swift.Int>)
  #endif
}
@available(macOS 11.0, iOS 14.0, tvOS 16.0, *)
extension Metal.MTLIntersectionFunctionTable {
  #if compiler(>=5.3) && $NonescapableTypes
  public func setBuffers(_ buffers: [(any Metal.MTLBuffer)?], offsets: [Swift.Int], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func setFunctions(_ functions: [(any Metal.MTLFunctionHandle)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func setVisibleFunctionTables(_ functionTables: [(any Metal.MTLVisibleFunctionTable)?], bufferRange: Swift.Range<Swift.Int>)
  #endif
}
@available(macOS 10.11, iOS 8.0, tvOS 8.0, *)
extension Metal.MTLComputeCommandEncoder {
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, *)
  public func useResources(_ resources: [any Metal.MTLResource], usage: Metal.MTLResourceUsage)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, *)
  public func useHeaps(_ heaps: [any Metal.MTLHeap])
  #if compiler(>=5.3) && $NonescapableTypes
  public func setBuffers(_ buffers: [(any Metal.MTLBuffer)?], offsets: [Swift.Int], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
  public func setBuffers(_ buffers: [(any Metal.MTLBuffer)?], offsets: [Swift.Int], attributeStrides: [Swift.Int], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func setTextures(_ textures: [(any Metal.MTLTexture)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func setSamplerStates(_ samplers: [(any Metal.MTLSamplerState)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func setSamplerStates(_ samplers: [(any Metal.MTLSamplerState)?], lodMinClamps: [Swift.Float], lodMaxClamps: [Swift.Float], range: Swift.Range<Swift.Int>)
  #endif
  @available(macOS 10.14, iOS 12.0, tvOS 12.0, *)
  public func memoryBarrier(resources: [any Metal.MTLResource])
  @available(iOS 13.0, tvOS 13.0, macOS 11.0, macCatalyst 14.0, *)
  @_alwaysEmitIntoClient public func executeCommandsInBuffer(_ buffer: any Metal.MTLIndirectCommandBuffer, range: Swift.Range<Swift.Int>) {
        __executeCommands(in: buffer, with: NSRange(location: range.lowerBound, length: range.count))
    }
  @available(iOS 13.0, tvOS 13.0, macOS 11.0, macCatalyst 14.0, *)
  @_alwaysEmitIntoClient public func executeCommandsInBuffer(_ buffer: any Metal.MTLIndirectCommandBuffer, indirectBuffer indirectRangeBuffer: any Metal.MTLBuffer, offset: Swift.Int) {
        __executeCommands(in: buffer, indirectBuffer: indirectRangeBuffer, indirectBufferOffset: offset)
    }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 11.0, iOS 14.0, tvOS 16.0, *)
  public func setVisibleFunctionTables(_ visibleFunctionTables: [(any Metal.MTLVisibleFunctionTable)?], bufferRange: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 11.0, iOS 14.0, tvOS 16.0, *)
  public func setIntersectionFunctionTables(_ intersectionFunctionTables: [(any Metal.MTLIntersectionFunctionTable)?], bufferRange: Swift.Range<Swift.Int>)
  #endif
}
@available(macOS 10.11, iOS 8.0, tvOS 8.0, *)
extension Metal.MTLDevice {
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, *)
  public func getDefaultSamplePositions(sampleCount: Swift.Int) -> [Metal.MTLSamplePosition]
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
  public func sampleTimestamps() -> (cpu: Metal.MTLTimestamp, gpu: Metal.MTLTimestamp)
  @_alwaysEmitIntoClient public func makeLibrary(data: Dispatch.DispatchData) throws -> any Metal.MTLLibrary {
        return try makeLibrary(data: data as __DispatchData)
    }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.11, macCatalyst 13.0, iOS 9.0, tvOS 9.0, *)
  @_alwaysEmitIntoClient public func makeComputePipelineState(descriptor: Metal.MTLComputePipelineDescriptor, options: Metal.MTLPipelineOption) throws -> (any Metal.MTLComputePipelineState, Metal.MTLComputePipelineReflection?) {
        var reflection: MTLAutoreleasedComputePipelineReflection?
        let pipeline = try makeComputePipelineState(descriptor: descriptor, options: options, reflection: &reflection)
        return (pipeline, reflection)
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.11, macCatalyst 13.0, iOS 8.0, tvOS 9.0, *)
  @_alwaysEmitIntoClient public func makeRenderPipelineState(descriptor: Metal.MTLRenderPipelineDescriptor, options: Metal.MTLPipelineOption) throws -> (any Metal.MTLRenderPipelineState, Metal.MTLRenderPipelineReflection?) {
        var reflection: MTLAutoreleasedRenderPipelineReflection?
        let pipeline = try makeRenderPipelineState(descriptor: descriptor, options: options, reflection: &reflection)
        return (pipeline, reflection)
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 11.0, macCatalyst 14.0, iOS 11.0, tvOS 14.5, *)
  @_alwaysEmitIntoClient public func makeRenderPipelineState(tileDescriptor: Metal.MTLTileRenderPipelineDescriptor, options: Metal.MTLPipelineOption) throws -> (any Metal.MTLRenderPipelineState, Metal.MTLRenderPipelineReflection?) {
        var reflection: MTLAutoreleasedRenderPipelineReflection?
        let pipeline = try makeRenderPipelineState(tileDescriptor: tileDescriptor, options: options, reflection: &reflection)
        return (pipeline, reflection)
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 13.0, macCatalyst 16.0, iOS 16.0, tvOS 16.0, *)
  public func makeRenderPipelineState(descriptor: Metal.MTLMeshRenderPipelineDescriptor, options: Metal.MTLPipelineOption) throws -> (any Metal.MTLRenderPipelineState, Metal.MTLRenderPipelineReflection?)
  #endif
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
extension Metal.MTLCounterSampleBuffer {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
  public func resolveCounterRange(_ range: Swift.Range<Swift.Int>) throws -> Foundation.Data?
  #endif
}
@available(swift 4)
@available(macOS 10.13, *)
public func MTLCopyAllDevicesWithObserver(handler: @escaping (any Metal.MTLDevice, Metal.MTLDeviceNotificationName) -> Swift.Void) -> (devices: [any Metal.MTLDevice], observer: ObjectiveC.NSObject)
#if compiler(>=5.3) && $NonescapableTypes
@available(macOS 13.0, macCatalyst 16.0, iOS 16.0, tvOS 16.0, *)
public func MTLIOCreateCompressionContext(_ path: Swift.String, _ type: Metal.MTLIOCompressionMethod, _ chunkSize: Swift.Int) -> Metal.MTLIOCompressionContext?
#endif
@available(macOS 10.12, iOS 10.0, tvOS 10.0, *)
extension Metal.MTLFunctionConstantValues {
  public func setConstantValues(_ values: Swift.UnsafeRawPointer, type: Metal.MTLDataType, range: Swift.Range<Swift.Int>)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, *)
extension Metal.MTLResidencySet {
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, *)
  public func addAllocations(_ allocations: [any Metal.MTLAllocation])
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, *)
  public func removeAllocations(_ allocations: [any Metal.MTLAllocation])
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, *)
extension Metal.MTLCommandQueue {
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, *)
  public func addResidencySets(_ residencySets: [any Metal.MTLResidencySet])
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, *)
  public func removeResidencySets(_ residencySets: [any Metal.MTLResidencySet])
}
@available(macOS 10.13, iOS 11.0, tvOS 11.0, *)
extension Metal.MTLArgumentEncoder {
  #if compiler(>=5.3) && $NonescapableTypes
  public func setBuffers(_ buffers: [(any Metal.MTLBuffer)?], offsets: [Swift.Int], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func setTextures(_ textures: [(any Metal.MTLTexture)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func setSamplerStates(_ samplers: [(any Metal.MTLSamplerState)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.14, iOS 13.0, tvOS 13.0, *)
  public func setRenderPipelineStates(_ pipelines: [(any Metal.MTLRenderPipelineState)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 13.0, tvOS 13.0, macOS 11.0, macCatalyst 14.0, *)
  @_alwaysEmitIntoClient public func setComputePipelineStates(_ pipelines: [(any Metal.MTLComputePipelineState)?], range: Swift.Range<Swift.Int>) {
        __setComputePipelineStates(pipelines, with: NSRange(location: range.lowerBound, length: range.count))
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.14, iOS 12.0, tvOS 12.0, *)
  public func setIndirectCommandBuffers(_ buffers: [(any Metal.MTLIndirectCommandBuffer)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 11.0, iOS 14.0, tvOS 16.0, *)
  public func setVisibleFunctionTables(_ visibleFunctionTables: [(any Metal.MTLVisibleFunctionTable)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 11.0, iOS 14.0, tvOS 16.0, *)
  public func setIntersectionFunctionTables(_ intersectionFunctionTables: [(any Metal.MTLIntersectionFunctionTable)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func setDepthStencilStates(_ depthStencilStates: [(any Metal.MTLDepthStencilState)?], range: Swift.Range<Swift.Int>)
  #endif
}
@available(macOS 10.11, iOS 8.0, tvOS 8.0, *)
extension Metal.MTLRenderCommandEncoder {
  @available(macOS, introduced: 10.13, deprecated: 13.0, message: "Please specify stages with useResources(_:usage:stages:)")
  @available(iOS, introduced: 11.0, deprecated: 16.0, message: "Please specify stages with useResources(_:usage:stages:)")
  @available(tvOS, introduced: 11.0, deprecated: 16.0, message: "Please specify stages with useResources(_:usage:stages:)")
  public func useResources(_ resources: [any Metal.MTLResource], usage: Metal.MTLResourceUsage)
  @available(macOS, introduced: 10.13, deprecated: 13.0, message: "Please specify stages with useHeaps(_:stages:)")
  @available(iOS, introduced: 11.0, deprecated: 16.0, message: "Please specify stages with useHeaps(_:stages:)")
  @available(tvOS, introduced: 11.0, deprecated: 16.0, message: "Please specify stages with useHeaps(_:stages:)")
  public func useHeaps(_ heaps: [any Metal.MTLHeap])
  @available(macOS 10.15, macCatalyst 13.1, iOS 13.0, tvOS 13.0, *)
  @_alwaysEmitIntoClient public func useResources(_ resources: [any Metal.MTLResource], usage: Metal.MTLResourceUsage, stages: Metal.MTLRenderStages) {
        __use(resources, count: resources.count, usage: usage, stages: stages)
    }
  @available(macOS 10.15, macCatalyst 13.1, iOS 13.0, tvOS 13.0, *)
  @_alwaysEmitIntoClient public func useHeaps(_ heaps: [any Metal.MTLHeap], stages: Metal.MTLRenderStages) {
        __use(heaps, count: heaps.count, stages: stages)
    }
  @available(macOS, introduced: 10.15, deprecated: 13.0, renamed: "useResource(_:usage:stages:)")
  @available(macCatalyst, introduced: 13.1, deprecated: 16.0, renamed: "useResource(_:usage:stages:)")
  @available(iOS, introduced: 13.0, deprecated: 16.0, renamed: "useResource(_:usage:stages:)")
  @available(tvOS, introduced: 13.0, deprecated: 16.0, renamed: "useResource(_:usage:stages:)")
  @_alwaysEmitIntoClient public func use(_ resource: any Metal.MTLResource, usage: Metal.MTLResourceUsage, stages: Metal.MTLRenderStages) {
        useResource(resource, usage: usage, stages: stages)
    }
  @available(macOS, introduced: 10.15, deprecated: 13.0, renamed: "useResources(_:usage:stages:)")
  @available(macCatalyst, introduced: 13.1, deprecated: 16.0, renamed: "useResources(_:usage:stages:)")
  @available(iOS, introduced: 13.0, deprecated: 16.0, renamed: "useResources(_:usage:stages:)")
  @available(tvOS, introduced: 13.0, deprecated: 16.0, renamed: "useResources(_:usage:stages:)")
  @_alwaysEmitIntoClient public func use(_ resources: Swift.UnsafePointer<any Metal.MTLResource>, count: Swift.Int, usage: Metal.MTLResourceUsage, stages: Metal.MTLRenderStages) {
        __use(resources, count: count, usage: usage, stages: stages)
    }
  @available(macOS, introduced: 10.15, deprecated: 13.0, renamed: "useHeap(_:stages:)")
  @available(macCatalyst, introduced: 13.1, deprecated: 16.0, renamed: "useHeap(_:stages:)")
  @available(iOS, introduced: 13.0, deprecated: 16.0, renamed: "useHeap(_:stages:)")
  @available(tvOS, introduced: 13.0, deprecated: 16.0, renamed: "useHeap(_:stages:)")
  @_alwaysEmitIntoClient public func use(_ heap: any Metal.MTLHeap, stages: Metal.MTLRenderStages) {
        useHeap(heap, stages: stages)
    }
  @available(macOS, introduced: 10.15, deprecated: 13.0, renamed: "useHeaps(_:stages:)")
  @available(macCatalyst, introduced: 13.1, deprecated: 16.0, renamed: "useHeaps(_:stages:)")
  @available(iOS, introduced: 13.0, deprecated: 16.0, renamed: "useHeaps(_:stages:)")
  @available(tvOS, introduced: 13.0, deprecated: 16.0, renamed: "useHeaps(_:stages:)")
  @_alwaysEmitIntoClient public func use(_ heaps: Swift.UnsafePointer<any Metal.MTLHeap>, count: Swift.Int, stages: Metal.MTLRenderStages) {
        __use(heaps, count: count, stages: stages)
    }
  @available(macOS 10.13, iOS 12.0, tvOS 14.5, *)
  public func setViewports(_ viewports: [Metal.MTLViewport])
  @available(macOS 10.13, iOS 12.0, tvOS 14.5, *)
  public func setScissorRects(_ scissorRects: [Metal.MTLScissorRect])
  #if compiler(>=5.3) && $NonescapableTypes
  public func setVertexBuffers(_ buffers: [(any Metal.MTLBuffer)?], offsets: [Swift.Int], range: Swift.Range<Swift.Int>)
  #endif
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func setDepthTestBounds(_ bounds: Swift.ClosedRange<Swift.Float>)
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
  public func setVertexBuffers(_ buffers: [(any Metal.MTLBuffer)?], offsets: [Swift.Int], attributeStrides: [Swift.Int], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func setVertexTextures(_ textures: [(any Metal.MTLTexture)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func setVertexSamplerStates(_ samplers: [(any Metal.MTLSamplerState)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func setVertexSamplerStates(_ samplers: [(any Metal.MTLSamplerState)?], lodMinClamps: [Swift.Float], lodMaxClamps: [Swift.Float], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func setFragmentBuffers(_ buffers: [(any Metal.MTLBuffer)?], offsets: [Swift.Int], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func setFragmentTextures(_ textures: [(any Metal.MTLTexture)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func setFragmentSamplerStates(_ samplers: [(any Metal.MTLSamplerState)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func setFragmentSamplerStates(_ samplers: [(any Metal.MTLSamplerState)?], lodMinClamps: [Swift.Float], lodMaxClamps: [Swift.Float], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.0, macOS 11.0, tvOS 14.5, macCatalyst 14.0, *)
  @_alwaysEmitIntoClient public func setTileBuffers(_ buffers: [(any Metal.MTLBuffer)?], offsets: [Swift.Int], range: Swift.Range<Swift.Int>) {
        __setTileBuffers(buffers, offsets: offsets, with: NSRange(location: range.lowerBound, length: range.count))
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.0, macOS 11.0, tvOS 14.5, macCatalyst 14.0, *)
  @_alwaysEmitIntoClient public func setTileTextures(_ textures: [(any Metal.MTLTexture)?], range: Swift.Range<Swift.Int>) {
        __setTileTextures(textures, with: NSRange(location: range.lowerBound, length: range.count))
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.0, macOS 11.0, tvOS 14.5, macCatalyst 14.0, *)
  @_alwaysEmitIntoClient public func setTileSamplerStates(_ samplers: [(any Metal.MTLSamplerState)?], range: Swift.Range<Swift.Int>) {
        __setTileSamplerStates(samplers, with: NSRange(location: range.lowerBound, length: range.count))
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.0, macOS 11.0, tvOS 14.5, macCatalyst 14.0, *)
  @_alwaysEmitIntoClient public func setTileSamplerStates(_ samplers: [(any Metal.MTLSamplerState)?], lodMinClamps: [Swift.Float], lodMaxClamps: [Swift.Float], range: Swift.Range<Swift.Int>) {
        __setTileSamplerStates(samplers, lodMinClamps: lodMinClamps, lodMaxClamps: lodMaxClamps, with: NSRange(location: range.lowerBound, length: range.count))
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 13.0, macCatalyst 16.0, iOS 16.0, tvOS 16.0, *)
  public func setObjectBuffers(_ buffers: [(any Metal.MTLBuffer)?], offsets: [Swift.Int], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 13.0, macCatalyst 16.0, iOS 16.0, tvOS 16.0, *)
  public func setObjectTextures(_ textures: [(any Metal.MTLTexture)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 13.0, macCatalyst 16.0, iOS 16.0, tvOS 16.0, *)
  public func setObjectSamplerStates(_ samplers: [(any Metal.MTLSamplerState)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 13.0, macCatalyst 16.0, iOS 16.0, tvOS 16.0, *)
  public func setObjectSamplerStates(_ samplers: [(any Metal.MTLSamplerState)?], lodMinClamps: [Swift.Float], lodMaxClamps: [Swift.Float], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 13.0, macCatalyst 16.0, iOS 16.0, tvOS 16.0, *)
  public func setMeshBuffers(_ buffers: [(any Metal.MTLBuffer)?], offsets: [Swift.Int], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 13.0, macCatalyst 16.0, iOS 16.0, tvOS 16.0, *)
  public func setMeshTextures(_ textures: [(any Metal.MTLTexture)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 13.0, macCatalyst 16.0, iOS 16.0, tvOS 16.0, *)
  public func setMeshSamplerStates(_ samplers: [(any Metal.MTLSamplerState)?], range: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 13.0, macCatalyst 16.0, iOS 16.0, tvOS 16.0, *)
  public func setMeshSamplerStates(_ samplers: [(any Metal.MTLSamplerState)?], lodMinClamps: [Swift.Float], lodMaxClamps: [Swift.Float], range: Swift.Range<Swift.Int>)
  #endif
  @available(macOS 10.14, macCatalyst 14.0, iOS 16.0, tvOS 16.0, *)
  public func memoryBarrier(resources: [any Metal.MTLResource], after: Metal.MTLRenderStages, before: Metal.MTLRenderStages)
  @available(macOS 10.14, iOS 12.0, tvOS 12.0, *)
  public func executeCommandsInBuffer(_ buffer: any Metal.MTLIndirectCommandBuffer, range: Swift.Range<Swift.Int>)
  @available(macOS 10.14, iOS 13.0, tvOS 13.0, *)
  public func executeCommandsInBuffer(_ buffer: any Metal.MTLIndirectCommandBuffer, indirectBuffer indirectRangeBuffer: any Metal.MTLBuffer, offset: Swift.Int)
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 12.0, iOS 15.0, tvOS 16.0, *)
  public func setVertexVisibleFunctionTables(_ functionTables: [(any Metal.MTLVisibleFunctionTable)?], bufferRange: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 12.0, iOS 15.0, tvOS 16.0, *)
  public func setFragmentVisibleFunctionTables(_ functionTables: [(any Metal.MTLVisibleFunctionTable)?], bufferRange: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 12.0, iOS 15.0, tvOS 16.0, *)
  public func setTileVisibleFunctionTables(_ functionTables: [(any Metal.MTLVisibleFunctionTable)?], bufferRange: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 12.0, iOS 15.0, tvOS 16.0, *)
  public func setVertexIntersectionFunctionTables(_ functionTables: [(any Metal.MTLIntersectionFunctionTable)?], bufferRange: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 12.0, iOS 15.0, tvOS 16.0, *)
  public func setFragmentIntersectionFunctionTables(_ functionTables: [(any Metal.MTLIntersectionFunctionTable)?], bufferRange: Swift.Range<Swift.Int>)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 12.0, iOS 15.0, tvOS 16.0, *)
  public func setTileIntersectionFunctionTables(_ functionTables: [(any Metal.MTLIntersectionFunctionTable)?], bufferRange: Swift.Range<Swift.Int>)
  #endif
}
@available(macOS 10.14, iOS 12.0, tvOS 12.0, *)
extension Metal.MTLIndirectCommandBuffer {
  public func reset(_ range: Swift.Range<Swift.Int>)
  @available(macOS, unavailable)
  @available(macCatalyst, introduced: 14.0, deprecated: 14.0, renamed: "indirectComputeCommandAt")
  @available(iOS, introduced: 13.0, deprecated: 14.0, renamed: "indirectComputeCommandAt")
  @available(tvOS, introduced: 13.0, deprecated: 14.0, renamed: "indirectComputeCommandAt")
  @_alwaysEmitIntoClient public func indirectComputeCommand(at Index: Swift.Int) -> any Metal.MTLIndirectComputeCommand {
        indirectComputeCommandAt(Index)
    }
}
@available(macOS 11.0, iOS 13.0, tvOS 13.0, *)
extension Metal.MTLIndirectComputeCommand {
  @available(macOS, unavailable)
  @available(macCatalyst, introduced: 14.0, deprecated: 14.0, renamed: "setStageInRegion(_:)")
  @available(iOS, introduced: 13.0, deprecated: 14.0, renamed: "setStageInRegion(_:)")
  @available(tvOS, introduced: 13.0, deprecated: 14.0, renamed: "setStageInRegion(_:)")
  @_alwaysEmitIntoClient public func setStageIn(_ region: Metal.MTLRegion) {
        setStageInRegion(region)
    }
  @available(macOS, unavailable)
  @available(macCatalyst, introduced: 14.0, deprecated: 14.0, renamed: "setThreadgroupMemoryLength(_:index:)")
  @available(iOS, introduced: 13.0, deprecated: 14.0, renamed: "setThreadgroupMemoryLength(_:index:)")
  @available(tvOS, introduced: 13.0, deprecated: 14.0, renamed: "setThreadgroupMemoryLength(_:index:)")
  @_alwaysEmitIntoClient public func setThreadgroupMemoryLength(_ length: Swift.Int, at index: Swift.Int) {
        setThreadgroupMemoryLength(length, index: index)
    }
}
@available(macOS 10.11, iOS 8.0, tvOS 8.0, *)
extension Metal.MTLRenderPassDescriptor {
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, *)
  public func setSamplePositions(_ positions: [Metal.MTLSamplePosition])
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, *)
  public func getSamplePositions() -> [Metal.MTLSamplePosition]
}
@available(macOS 10.11, iOS 8.0, tvOS 8.0, *)
extension Metal.MTLTexture {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.11, iOS 9.0, tvOS 9.0, *)
  public func makeTextureView(pixelFormat: Metal.MTLPixelFormat, textureType: Metal.MTLTextureType, levels levelRange: Swift.Range<Swift.Int>, slices sliceRange: Swift.Range<Swift.Int>) -> (any Metal.MTLTexture)?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, *)
  public func makeTextureView(pixelFormat: Metal.MTLPixelFormat, textureType: Metal.MTLTextureType, levels levelRange: Swift.Range<Swift.Int>, slices sliceRange: Swift.Range<Swift.Int>, swizzle: Metal.MTLTextureSwizzleChannels) -> (any Metal.MTLTexture)?
  #endif
}
@available(macOS 10.15.4, macCatalyst 13.4, iOS 13.0, tvOS 16.0, *)
extension Metal.MTLRasterizationRateSampleArray {
  public subscript(index: Swift.Int) -> Swift.Float {
    get
    set
  }
}
@available(macOS 10.15.4, macCatalyst 13.4, iOS 13.0, tvOS 16.0, *)
extension Metal.MTLRasterizationRateLayerDescriptor {
  convenience public init(horizontal: [Swift.Float], vertical: [Swift.Float])
}
@available(macOS 10.15.4, macCatalyst 13.4, iOS 13.0, tvOS 16.0, *)
extension Metal.MTLRasterizationRateMapDescriptor {
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(screenSize: Metal.MTLSize, label: Swift.String? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(screenSize: Metal.MTLSize, layer: Metal.MTLRasterizationRateLayerDescriptor, label: Swift.String? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(screenSize: Metal.MTLSize, layers: [Metal.MTLRasterizationRateLayerDescriptor], label: Swift.String? = nil)
  #endif
}
@available(macOS 10.14, iOS 12.0, tvOS 12.0, *)
extension Metal.MTLSharedEvent {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, *)
  @backDeployed(before: macOS 16.0, iOS 19.0, tvOS 19.0, visionOS 3.0)
  public func valueSignaled(_ value: Swift.UInt64) async {
        await withUnsafeContinuation { continuation in
            var listener: MTLSharedEventListener
            if #available(macOS 16.0, iOS 19.0, tvOS 19.0, visionOS 3.0, *) {
                listener = MTLSharedEventListener.shared()
            } else {
                listener = MTLSharedEventListener()
            }
            notify(listener, atValue: value) { _, _ in
                continuation.resume()
            }
        }
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Metal.MTL4RenderCommandEncoder {
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func setViewports(_ viewports: [Metal.MTLViewport])
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func setScissorRects(_ scissorRects: [Metal.MTLScissorRect])
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func setVertexAmplificationCount(_ count: Swift.Int)
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func setVertexAmplificationCount(_ viewMappings: [Metal.MTLVertexAmplificationViewMapping])
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func setDepthTestBounds(_ bounds: Swift.ClosedRange<Swift.Float>)
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func executeCommands(buffer: any Metal.MTLIndirectCommandBuffer, range: Swift.Range<Swift.Int>)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Metal.MTL4ComputeCommandEncoder {
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func executeCommands(buffer: any Metal.MTLIndirectCommandBuffer, range: Swift.Range<Swift.Int>)
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func copy(sourceTexture: any Metal.MTLTexture, sourceSlice: Swift.Int, sourceLevel: Swift.Int, sourceOrigin: Metal.MTLOrigin, sourceSize: Metal.MTLSize, destinationBuffer: any Metal.MTLBuffer, destinationOffset: Swift.Int, destinationBytesPerRow: Swift.Int, destinationBytesPerImage: Swift.Int, options: Metal.MTLBlitOption = [])
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func copy(sourceBuffer: any Metal.MTLBuffer, sourceOffset: Swift.Int, sourceBytesPerRow: Swift.Int, sourceBytesPerImage: Swift.Int, sourceSize: Metal.MTLSize, destinationTexture: any Metal.MTLTexture, destinationSlice: Swift.Int, destinationLevel: Swift.Int, destinationOrigin: Metal.MTLOrigin, options: Metal.MTLBlitOption = [])
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func fill(buffer: any Metal.MTLBuffer, range: Swift.Range<Swift.Int>, value: Swift.UInt8)
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func copyCommands(sourceBuffer: any Metal.MTLIndirectCommandBuffer, sourceRange: Swift.Range<Swift.Int>, destinationBuffer: any Metal.MTLIndirectCommandBuffer, destinationIndex: Swift.Int)
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func resetCommands(buffer: any Metal.MTLIndirectCommandBuffer, range: Swift.Range<Swift.Int>)
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func optimizeCommands(buffer: any Metal.MTLIndirectCommandBuffer, range: Swift.Range<Swift.Int>)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Metal.MTL4CommandQueue {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func commit(_ commandBuffers: [any Metal.MTL4CommandBuffer], options: Metal.MTL4CommitOptions? = nil)
  #endif
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func addResidencySets(_ residencySets: [any Metal.MTLResidencySet])
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func removeResidencySets(_ residencySets: [any Metal.MTLResidencySet])
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func updateMappings(texture: any Metal.MTLTexture, heap: (any Metal.MTLHeap)?, operations: [Metal.MTL4UpdateSparseTextureMappingOperation])
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func updateMappings(buffer: any Metal.MTLBuffer, heap: (any Metal.MTLHeap)?, operations: [Metal.MTL4UpdateSparseBufferMappingOperation])
  #endif
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func copyMappings(sourceTexture: any Metal.MTLTexture, destinationTexture: any Metal.MTLTexture, operations: [Metal.MTL4CopySparseTextureMappingOperation])
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func copyMappings(sourceBuffer: any Metal.MTLBuffer, destinationBuffer: any Metal.MTLBuffer, operations: [Metal.MTL4CopySparseBufferMappingOperation])
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Metal.MTL4CommandBuffer {
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func useResidencySets(_ residencySets: [any Metal.MTLResidencySet])
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func resolveCounterHeap(_ counterHeap: any Metal.MTL4CounterHeap, range: Swift.Range<Swift.Int>, buffer: Metal.MTL4BufferRange, fenceToWait: (any Metal.MTLFence)? = nil, fenceToUpdate: (any Metal.MTLFence)? = nil)
  #endif
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Metal.MTL4CommandEncoder {
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func barrier(afterQueueStages: Metal.MTLStages, beforeStages: Metal.MTLStages, visibilityOptions: Metal.MTL4VisibilityOptions = [ .device ])
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func barrier(afterStages: Metal.MTLStages, beforeQueueStages: Metal.MTLStages, visibilityOptions: Metal.MTL4VisibilityOptions = [ .device ])
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func barrier(afterEncoderStages: Metal.MTLStages, beforeEncoderStages: Metal.MTLStages, visibilityOptions: Metal.MTL4VisibilityOptions = [ .device ])
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Metal.MTL4Compiler {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func makeComputePipelineState(descriptor: Metal.MTL4ComputePipelineDescriptor, dynamicLinkingDescriptor: Metal.MTL4PipelineStageDynamicLinkingDescriptor? = nil, compilerTaskOptions: Metal.MTL4CompilerTaskOptions? = nil) throws -> any Metal.MTLComputePipelineState
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func makeComputePipelineState(descriptor: Metal.MTL4ComputePipelineDescriptor, dynamicLinkingDescriptor: Metal.MTL4PipelineStageDynamicLinkingDescriptor? = nil, compilerTaskOptions: Metal.MTL4CompilerTaskOptions? = nil) async throws -> any Metal.MTLComputePipelineState
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func makeRenderPipelineState(descriptor: Metal.MTL4PipelineDescriptor, dynamicLinkingDescriptor: Metal.MTL4RenderPipelineDynamicLinkingDescriptor? = nil, compilerTaskOptions: Metal.MTL4CompilerTaskOptions? = nil) throws -> any Metal.MTLRenderPipelineState
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func makeRenderPipelineState(descriptor: Metal.MTL4PipelineDescriptor, dynamicLinkingDescriptor: Metal.MTL4RenderPipelineDynamicLinkingDescriptor? = nil, compilerTaskOptions: Metal.MTL4CompilerTaskOptions? = nil) async throws -> any Metal.MTLRenderPipelineState
  #endif
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func makeRenderPipelineStateBySpecialization(descriptor: Metal.MTL4PipelineDescriptor, pipeline: any Metal.MTLRenderPipelineState) throws -> any Metal.MTLRenderPipelineState
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func makeRenderPipelineStateBySpecialization(descriptor: Metal.MTL4PipelineDescriptor, pipeline: any Metal.MTLRenderPipelineState) async throws -> any Metal.MTLRenderPipelineState
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func makeBinaryFunction(descriptor: Metal.MTL4BinaryFunctionDescriptor, compilerTaskOptions: Metal.MTL4CompilerTaskOptions? = nil) throws -> any Metal.MTL4BinaryFunction
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func makeBinaryFunction(descriptor: Metal.MTL4BinaryFunctionDescriptor, compilerTaskOptions: Metal.MTL4CompilerTaskOptions? = nil) async throws -> any Metal.MTL4BinaryFunction
  #endif
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func makeLibrary(descriptor: Metal.MTL4LibraryDescriptor) async throws -> any Metal.MTLLibrary
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func makeDynamicLibrary(library: any Metal.MTLLibrary) async throws -> any Metal.MTLDynamicLibrary
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func makeDynamicLibrary(url: Foundation.URL) async throws -> any Metal.MTLDynamicLibrary
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func makeMachineLearningPipelineState(descriptor: Metal.MTL4MachineLearningPipelineDescriptor) throws -> any Metal.MTL4MachineLearningPipelineState
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func makeMachineLearningPipelineState(descriptor: Metal.MTL4MachineLearningPipelineDescriptor) async throws -> any Metal.MTL4MachineLearningPipelineState
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Metal.MTL4Archive {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func makeComputePipelineState(descriptor: Metal.MTL4ComputePipelineDescriptor, dynamicLinkingDescriptor: Metal.MTL4PipelineStageDynamicLinkingDescriptor? = nil) throws -> any Metal.MTLComputePipelineState
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func makeRenderPipelineState(descriptor: Metal.MTL4PipelineDescriptor, dynamicLinkingDescriptor: Metal.MTL4RenderPipelineDynamicLinkingDescriptor? = nil) throws -> any Metal.MTLRenderPipelineState
  #endif
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Metal.MTL4RenderPassDescriptor {
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public var samplePositions: [Metal.MTLSamplePosition] {
    get
    set(positions)
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Metal.MTLLogicalToPhysicalColorAttachmentMap {
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public subscript(logicalIndex: Swift.Int) -> Swift.Int {
    get
    set(physicalIndex)
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Metal.MTLTensorExtents {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  convenience public init?(_ values: [Swift.Int])
  #endif
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public var extents: [Swift.Int] {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Metal.MTL4MachineLearningPipelineDescriptor {
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func setInputDimensions(_ dimensions: [Metal.MTLTensorExtents], bufferIndex: Swift.Int)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Metal.MTLResourceViewPool {
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func copyResourceViews(sourcePool: any Metal.MTLResourceViewPool, sourceRange: Swift.Range<Swift.Int>, destinationIndex: Swift.Int) -> Metal.MTLResourceID
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Metal.MTLTextureViewDescriptor {
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public var levelRange: Swift.Range<Swift.Int> {
    get
    set(value)
  }
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public var sliceRange: Swift.Range<Swift.Int> {
    get
    set(value)
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Metal.MTL4CounterHeap {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func resolveCounterRange(_ range: Swift.Range<Swift.Int>) throws -> Foundation.Data?
  #endif
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func invalidateCounterRange(_ range: Swift.Range<Swift.Int>)
}
