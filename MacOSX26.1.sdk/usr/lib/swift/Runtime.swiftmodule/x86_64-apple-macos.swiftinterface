// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 effective-5.10 (swiftlang-6.2.1.4.7 clang-1700.4.4.1)
// swift-module-flags: -disable-objc-attr-requires-foundation-module -target x86_64-apple-macosx26.1 -target-variant x86_64-apple-ios26.1-macabi -enable-objc-interop -enable-library-evolution -module-link-name swiftRuntime -parse-stdlib -swift-version 5 -O -library-level api -enforce-exclusivity=unchecked -target-min-inlining-version min -enable-experimental-feature NoncopyableGenerics2 -enable-experimental-feature SuppressedAssociatedTypes -enable-experimental-feature SE427NoInferenceOnExtension -enable-experimental-feature NonescapableTypes -enable-experimental-feature LifetimeDependence -enable-experimental-feature InoutLifetimeDependence -enable-experimental-feature LifetimeDependenceMutableAccessors -enable-upcoming-feature MemberImportVisibility -disable-upcoming-feature MemberImportVisibility -user-module-version 6.2.1.4.7 -module-name Runtime
// swift-module-flags-ignorable: -enable-lexical-lifetimes=false -enable-ossa-modules -formal-cxx-interoperability-mode=swift-6 -interface-compiler-version 6.2.1
import Swift
extension Runtime.Backtrace.Address : Swift.Comparable {
  public static func < (lhs: Runtime.Backtrace.Address, rhs: Runtime.Backtrace.Address) -> Swift.Bool
  public static func == (lhs: Runtime.Backtrace.Address, rhs: Runtime.Backtrace.Address) -> Swift.Bool
}
extension Runtime.Backtrace.Address : Swift.LosslessStringConvertible {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ s: Swift.String)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ s: Swift.Substring)
  #endif
  public var description: Swift.String {
    get
  }
}
extension Runtime.Backtrace.Address : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.UInt64
  public init(integerLiteral: Runtime.Backtrace.Address.IntegerLiteralType)
}
extension Swift.FixedWidthInteger {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ address: Runtime.Backtrace.Address)
  #endif
}
extension Runtime.Backtrace.Address {
  public init(_ value: Swift.UInt16)
  public init(_ value: Swift.UInt32)
  public init(_ value: Swift.UInt64)
  #if compiler(>=5.3) && $NonescapableTypes
  public init?<T>(_ value: T) where T : Swift.FixedWidthInteger
  #endif
}
public struct Backtrace : Swift.CustomStringConvertible, Swift.Sendable {
  public struct Address : Swift.Hashable, Swift.Sendable {
    public var bitWidth: Swift.Int {
      get
    }
    public var isNull: Swift.Bool {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum UnwindAlgorithm {
    case auto
    case fast
    case precise
    public static func == (a: Runtime.Backtrace.UnwindAlgorithm, b: Runtime.Backtrace.UnwindAlgorithm) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Frame : Swift.CustomStringConvertible, Swift.Sendable {
    case programCounter(Runtime.Backtrace.Address)
    case returnAddress(Runtime.Backtrace.Address)
    case asyncResumePoint(Runtime.Backtrace.Address)
    case omittedFrames(Swift.Int)
    case truncated
    public var originalProgramCounter: Runtime.Backtrace.Address {
      get
    }
    public var adjustedProgramCounter: Runtime.Backtrace.Address {
      get
    }
    public var description: Swift.String {
      get
    }
  }
  public struct Image : Swift.CustomStringConvertible, Swift.Sendable {
    public var name: Swift.String? {
      get
    }
    public var path: Swift.String? {
      get
    }
    public var uniqueID: [Swift.UInt8]? {
      get
    }
    public var baseAddress: Runtime.Backtrace.Address {
      get
    }
    public var endOfText: Runtime.Backtrace.Address {
      get
    }
    public var description: Swift.String {
      get
    }
  }
  public var architecture: Swift.String {
    get
  }
  @available(macOS 10.15, *)
  public var frames: some Swift.Sequence<Runtime.Backtrace.Frame> {
    get
  }
  public var images: Runtime.ImageMap?
  #if compiler(>=5.3) && $NonescapableTypes
  @inline(never) @_semantics("use_frame_pointer") public static func capture(algorithm: Runtime.Backtrace.UnwindAlgorithm = .auto, limit: Swift.Int? = 64, offset: Swift.Int = 0, top: Swift.Int = 16, images: Runtime.ImageMap? = nil) throws -> Runtime.Backtrace
  #endif
  public struct SymbolicationOptions : Swift.OptionSet {
    public let rawValue: Swift.Int
    public static let showInlineFrames: Runtime.Backtrace.SymbolicationOptions
    public static let showSourceLocations: Runtime.Backtrace.SymbolicationOptions
    public static let useSymbolCache: Runtime.Backtrace.SymbolicationOptions
    public static let `default`: Runtime.Backtrace.SymbolicationOptions
    public init(rawValue: Swift.Int)
    public typealias ArrayLiteralElement = Runtime.Backtrace.SymbolicationOptions
    public typealias Element = Runtime.Backtrace.SymbolicationOptions
    public typealias RawValue = Swift.Int
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public func symbolicated(with images: Runtime.ImageMap? = nil, options: Runtime.Backtrace.SymbolicationOptions = .default) -> Runtime.SymbolicatedBacktrace?
  #endif
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, *)
extension Runtime.Backtrace : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ImageMap : Swift.Collection, Swift.Sendable, Swift.Hashable {
  public typealias Element = Runtime.Backtrace.Image
  public typealias Index = Swift.Int
  public var platform: Swift.String {
    get
  }
  public var startIndex: Runtime.ImageMap.Index {
    get
  }
  public var endIndex: Runtime.ImageMap.Index {
    get
  }
  public subscript(ndx: Runtime.ImageMap.Index) -> Runtime.ImageMap.Element {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public func indexOfImage(at address: Runtime.Backtrace.Address) -> Swift.Int?
  #endif
  public func index(after ndx: Runtime.ImageMap.Index) -> Runtime.ImageMap.Index
  public static func capture() -> Runtime.ImageMap
  public static func == (a: Runtime.ImageMap, b: Runtime.ImageMap) -> Swift.Bool
  public typealias Indices = Swift.DefaultIndices<Runtime.ImageMap>
  public typealias Iterator = Swift.IndexingIterator<Runtime.ImageMap>
  public typealias SubSequence = Swift.Slice<Runtime.ImageMap>
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Runtime.ImageMap : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Runtime.ImageMap : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@usableFromInline
internal protocol LimitableElement {
  static func omitted(_: Swift.Int) -> Self
  static var truncated: Self { get }
}
@usableFromInline
internal struct LimitSequence<T, S> : Swift.Sequence where T : Runtime.LimitableElement, T == S.Element, S : Swift.Sequence {
  @usableFromInline
  internal typealias Element = T
  @usableFromInline
  internal typealias Source = S
  @usableFromInline
  internal init(_ source: Runtime.LimitSequence<T, S>.Source, limit: Swift.Int, offset: Swift.Int = 0, top: Swift.Int = 0)
  public func makeIterator() -> Runtime.LimitSequence<T, S>.Iterator
  @usableFromInline
  internal struct Iterator : Swift.IteratorProtocol {
    #if compiler(>=5.3) && $NonescapableTypes
    public mutating func next() -> Runtime.LimitSequence<T, S>.Element?
    #endif
    @usableFromInline
    internal typealias Element = Runtime.LimitSequence<T, S>.Element
  }
}
public struct SymbolicatedBacktrace : Swift.CustomStringConvertible {
  public var backtrace: Runtime.Backtrace
  public struct SourceLocation : Swift.CustomStringConvertible, Swift.Sendable, Swift.Hashable {
    public var path: Swift.String
    public var line: Swift.Int
    public var column: Swift.Int
    public var description: Swift.String {
      get
    }
    public static func == (a: Runtime.SymbolicatedBacktrace.SourceLocation, b: Runtime.SymbolicatedBacktrace.SourceLocation) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Frame : Swift.CustomStringConvertible {
    public var captured: Runtime.Backtrace.Frame
    public var symbol: Runtime.SymbolicatedBacktrace.Symbol?
    public var inlined: Swift.Bool
    public var isSwiftRuntimeFailure: Swift.Bool {
      get
    }
    public var isSwiftThunk: Swift.Bool {
      get
    }
    public var isSystem: Swift.Bool {
      get
    }
    public var description: Swift.String {
      get
    }
  }
  public class Symbol : Swift.CustomStringConvertible {
    public var imageIndex: Swift.Int
    public var imageName: Swift.String
    public var rawName: Swift.String
    public var name: Swift.String {
      get
      set
    }
    public var offset: Swift.Int
    public var sourceLocation: Runtime.SymbolicatedBacktrace.SourceLocation?
    public var isSwiftRuntimeFailure: Swift.Bool {
      get
    }
    public var isSwiftThunk: Swift.Bool {
      get
    }
    public var isSystemFunction: Swift.Bool {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init(imageIndex: Swift.Int, imageName: Swift.String, rawName: Swift.String, offset: Swift.Int, sourceLocation: Runtime.SymbolicatedBacktrace.SourceLocation?)
    #endif
    public var description: Swift.String {
      get
    }
    @objc deinit
  }
  public var architecture: Swift.String {
    get
  }
  public var frames: [Runtime.SymbolicatedBacktrace.Frame] {
    get
  }
  public var images: Runtime.ImageMap {
    get
  }
  public var isSwiftRuntimeFailure: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var swiftRuntimeFailure: Swift.String? {
    get
  }
  #endif
  public var description: Swift.String {
    get
  }
}
extension Runtime.Backtrace.UnwindAlgorithm : Swift.Equatable {}
extension Runtime.Backtrace.UnwindAlgorithm : Swift.Hashable {}
