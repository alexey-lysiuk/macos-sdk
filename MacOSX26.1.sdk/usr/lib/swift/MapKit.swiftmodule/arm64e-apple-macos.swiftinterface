// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 effective-5.10 (swiftlang-6.2.1.4.7 clang-1700.4.4.1)
// swift-module-flags: -target arm64e-apple-macos26.1 -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftMapKit -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 14.20.6.27.1 -module-name MapKit
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.1
import Foundation
import GeoToolbox
@_exported import MapKit
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@available(iOS, unavailable)
@available(visionOS, unavailable)
@available(tvOS, unavailable)
@available(macOS, unavailable)
@available(watchOS, unavailable)
public typealias MKMapItemIdentifier = MapKit.MKMapItem.Identifier
@available(iOS 18.0, visionOS 2.0, tvOS 18.0, macOS 15.0, watchOS 11.0, *)
extension MapKit.MKMapItem.Identifier : Swift.RawRepresentable, Swift.Codable {
  public typealias RawValue = Swift.String
}
extension MapKit.MKAddressRepresentations {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 26.0, macOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public var region: Foundation.Locale.Region? {
    get
  }
  #endif
}
@available(iOS 14.0, tvOS 14.0, macOS 11.0, *)
extension MapKit.MKGradientPolylineRenderer {
  public var locations: [CoreFoundation.CGFloat] {
    get
  }
  public func setColors(_ colors: [AppKit.NSColor], locations: [CoreFoundation.CGFloat])
}
extension MapKit.MKCoordinateSpan : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout MapKit.MKCoordinateSpan?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout MapKit.MKCoordinateSpan?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> MapKit.MKCoordinateSpan
  #endif
  public typealias _ObjectiveCType = Foundation.NSValue
}
@available(iOS 18.0, macOS 15.0, visionOS 2.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension MapKit.MKSelectionAccessory.MapItemDetailPresentationStyle {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func automatic(presentationViewController: AppKit.NSViewController? = nil) -> MapKit.MKSelectionAccessory.MapItemDetailPresentationStyle
  #endif
  public static func callout(_ style: MapKit.MKSelectionAccessory.MapItemDetailPresentationStyle.CalloutStyle = .automatic) -> MapKit.MKSelectionAccessory.MapItemDetailPresentationStyle
}
extension GeoToolbox.PlaceDescriptor {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 26.0, macOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public init?(item: MapKit.MKMapItem)
  #endif
}
@available(iOS 14.0, tvOS 14.0, macOS 11.0, watchOS 7.0, *)
extension MapKit.MKMultiPoint {
  public func locations(at indexes: Foundation.IndexSet) -> [CoreFoundation.CGFloat]
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension MapKit.MKLocalSearch.Request {
  public typealias ResultType = MapKit.MKLocalSearch.ResultType
}
extension MapKit.MKMapItemRequest {
  @available(iOS 26.0, macOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
  convenience public init(placeDescriptor: GeoToolbox.PlaceDescriptor)
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 26.0, macOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public var placeDescriptor: GeoToolbox.PlaceDescriptor? {
    get
  }
  #endif
}
