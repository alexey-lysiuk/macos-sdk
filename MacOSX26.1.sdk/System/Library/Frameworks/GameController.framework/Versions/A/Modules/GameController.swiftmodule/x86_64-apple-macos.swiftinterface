// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 effective-5.10 (swiftlang-6.2.1.4.7 clang-1700.4.4.1)
// swift-module-flags: -target x86_64-apple-macos26.1 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=unchecked -O -library-level api -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 13.1.8 -module-name GameController
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.1
import CoreServices
import Dispatch
@_exported import GameController
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct GCPhysicalInputElementCollection<T> : Swift.Collection where T : GameController.GCPhysicalInputElement {
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript(elementName: Swift.String) -> T? {
    get
  }
  #endif
  public typealias Element = T
  public struct Index : Swift.Comparable {
    public static func == (lhs: GameController.GCPhysicalInputElementCollection<T>.Index, rhs: GameController.GCPhysicalInputElementCollection<T>.Index) -> Swift.Bool
    public static func < (lhs: GameController.GCPhysicalInputElementCollection<T>.Index, rhs: GameController.GCPhysicalInputElementCollection<T>.Index) -> Swift.Bool
  }
  public subscript(position: GameController.GCPhysicalInputElementCollection<T>.Index) -> GameController.GCPhysicalInputElementCollection<T>.Element {
    get
  }
  public var startIndex: GameController.GCPhysicalInputElementCollection<T>.Index {
    get
  }
  public var endIndex: GameController.GCPhysicalInputElementCollection<T>.Index {
    get
  }
  public func index(after i: GameController.GCPhysicalInputElementCollection<T>.Index) -> GameController.GCPhysicalInputElementCollection<T>.Index
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Indices = Swift.DefaultIndices<GameController.GCPhysicalInputElementCollection<T>>
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias Iterator = Swift.IndexingIterator<GameController.GCPhysicalInputElementCollection<T>>
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias SubSequence = Swift.Slice<GameController.GCPhysicalInputElementCollection<T>>
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
public protocol GCPhysicalInputElementTypedName : Swift.Hashable, Swift.RawRepresentable, Swift.Sendable where Self.RawValue == Swift.String {
  associatedtype PhysicalInputElement : GameController.GCPhysicalInputElement
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct GCPhysicalInputElementName : Swift.RawRepresentable, Swift.Hashable, Swift.Sendable {
  public init(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  @available(macOS 13.0, macCatalyst 16.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  public static let shifter: GameController.GCPhysicalInputElementName
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias RawValue = Swift.String
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension GameController.GCPhysicalInputElementName : GameController.GCPhysicalInputElementTypedName {
  public typealias PhysicalInputElement = GameController.GCPhysicalInputElement
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension GameController.GCPhysicalInputElementCollection where T == any GameController.GCPhysicalInputElement {
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript(elementName: GameController.GCPhysicalInputElementName) -> T? {
    get
  }
  #endif
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension GameController.GCPhysicalInputElementCollection {
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript<Name>(elementName: Name) -> Name.PhysicalInputElement? where Name : GameController.GCPhysicalInputElementTypedName {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript<Name>(elementName: Name) -> (any GameController.GCPhysicalInputElement)? where T == any GameController.GCPhysicalInputElement, Name : GameController.GCPhysicalInputElementTypedName {
    get
  }
  #endif
}
extension GameController.GCDevicePhysicalInputStateDiff {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @_transparent @_disfavoredOverload public func changedElements() -> Foundation.NSEnumerator? {
        return __changedElements()
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
  @backDeployed(before: macOS 14.0, iOS 17.0, tvOS 17.0)
  @inlinable public func changedElements() -> (some Swift.Sequence<any GameController.GCPhysicalInputElement>)? {
        return __changedElements()?.lazy.compactMap { $0 as? any GCPhysicalInputElement }
    }
  
  #endif
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct GCAxisElementName : Swift.RawRepresentable, Swift.Hashable, Swift.Sendable {
  public init(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  @available(macOS 13.0, macCatalyst 16.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  public static let steeringWheel: GameController.GCAxisElementName
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias RawValue = Swift.String
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension GameController.GCPhysicalInputElementCollection where T == any GameController.GCAxisElement {
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript(elementName: GameController.GCAxisElementName) -> T? {
    get
  }
  #endif
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension GameController.GCAxisElementName : GameController.GCPhysicalInputElementTypedName {
  public typealias PhysicalInputElement = GameController.GCAxisElement
}
@available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
extension GameController.GCMouse {
  @available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
  public struct DidConnectMessage : Foundation.NotificationCenter.MainActorMessage {
    public typealias Subject = GameController.GCMouse
    public static var name: Foundation.Notification.Name {
      get
    }
    public var mouse: GameController.GCMouse
    public init(mouse: GameController.GCMouse)
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public static func makeMessage(_ notification: Foundation.Notification) -> GameController.GCMouse.DidConnectMessage?
    #endif
  }
  @available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
  public struct DidDisconnectMessage : Foundation.NotificationCenter.MainActorMessage {
    public typealias Subject = GameController.GCMouse
    public static var name: Foundation.Notification.Name {
      get
    }
    public var mouse: GameController.GCMouse
    public init(mouse: GameController.GCMouse)
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public static func makeMessage(_ notification: Foundation.Notification) -> GameController.GCMouse.DidDisconnectMessage?
    #endif
  }
  @available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
  public struct DidBecomeCurrentMessage : Foundation.NotificationCenter.MainActorMessage {
    public typealias Subject = GameController.GCMouse
    public static var name: Foundation.Notification.Name {
      get
    }
    public var mouse: GameController.GCMouse
    public init(mouse: GameController.GCMouse)
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public static func makeMessage(_ notification: Foundation.Notification) -> GameController.GCMouse.DidBecomeCurrentMessage?
    #endif
  }
  @available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
  public struct DidStopBeingCurrentMessage : Foundation.NotificationCenter.MainActorMessage {
    public typealias Subject = GameController.GCMouse
    public static var name: Foundation.Notification.Name {
      get
    }
    public var mouse: GameController.GCMouse
    public init(mouse: GameController.GCMouse)
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public static func makeMessage(_ notification: Foundation.Notification) -> GameController.GCMouse.DidStopBeingCurrentMessage?
    #endif
  }
}
@available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
extension Foundation.NotificationCenter.MessageIdentifier where Self == Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCMouse.DidConnectMessage> {
  @_alwaysEmitIntoClient public static var didConnect: Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCMouse.DidConnectMessage> {
    get { .init() }
  }
}
@available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
extension Foundation.NotificationCenter.MessageIdentifier where Self == Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCMouse.DidDisconnectMessage> {
  @_alwaysEmitIntoClient public static var didDisconnect: Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCMouse.DidDisconnectMessage> {
    get { .init() }
  }
}
@available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
extension Foundation.NotificationCenter.MessageIdentifier where Self == Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCMouse.DidBecomeCurrentMessage> {
  @_alwaysEmitIntoClient public static var didBecomeCurrent: Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCMouse.DidBecomeCurrentMessage> {
    get { .init() }
  }
}
@available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
extension Foundation.NotificationCenter.MessageIdentifier where Self == Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCMouse.DidStopBeingCurrentMessage> {
  @_alwaysEmitIntoClient public static var didStopBeingCurrent: Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCMouse.DidStopBeingCurrentMessage> {
    get { .init() }
  }
}
@available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
extension GameController.GCKeyboard {
  @available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
  public struct DidConnectMessage : Foundation.NotificationCenter.MainActorMessage {
    public typealias Subject = GameController.GCKeyboard
    public static var name: Foundation.Notification.Name {
      get
    }
    public var keyboard: GameController.GCKeyboard
    public init(keyboard: GameController.GCKeyboard)
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public static func makeMessage(_ notification: Foundation.Notification) -> GameController.GCKeyboard.DidConnectMessage?
    #endif
  }
  @available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
  public struct DidDisconnectMessage : Foundation.NotificationCenter.MainActorMessage {
    public typealias Subject = GameController.GCKeyboard
    public static var name: Foundation.Notification.Name {
      get
    }
    public var keyboard: GameController.GCKeyboard
    public init(keyboard: GameController.GCKeyboard)
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public static func makeMessage(_ notification: Foundation.Notification) -> GameController.GCKeyboard.DidDisconnectMessage?
    #endif
  }
}
@available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
extension Foundation.NotificationCenter.MessageIdentifier where Self == Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCKeyboard.DidConnectMessage> {
  @_alwaysEmitIntoClient public static var didConnect: Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCKeyboard.DidConnectMessage> {
    get { .init() }
  }
}
@available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
extension Foundation.NotificationCenter.MessageIdentifier where Self == Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCKeyboard.DidDisconnectMessage> {
  @_alwaysEmitIntoClient public static var didDisconnect: Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCKeyboard.DidDisconnectMessage> {
    get { .init() }
  }
}
@available(macOS 26.0, macCatalyst 26.0, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
extension GameController.GCRacingWheel {
  @available(macOS 26.0, macCatalyst 26.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  @available(visionOS, unavailable)
  public struct DidConnectMessage : Foundation.NotificationCenter.MainActorMessage {
    public typealias Subject = GameController.GCRacingWheel
    public static var name: Foundation.Notification.Name {
      get
    }
    public var racingWheel: GameController.GCRacingWheel
    public init(racingWheel: GameController.GCRacingWheel)
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public static func makeMessage(_ notification: Foundation.Notification) -> GameController.GCRacingWheel.DidConnectMessage?
    #endif
  }
  @available(macOS 26.0, macCatalyst 26.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  @available(visionOS, unavailable)
  public struct DidDisconnectMessage : Foundation.NotificationCenter.MainActorMessage {
    public typealias Subject = GameController.GCRacingWheel
    public static var name: Foundation.Notification.Name {
      get
    }
    public var racingWheel: GameController.GCRacingWheel
    public init(racingWheel: GameController.GCRacingWheel)
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public static func makeMessage(_ notification: Foundation.Notification) -> GameController.GCRacingWheel.DidDisconnectMessage?
    #endif
  }
}
@available(macOS 26.0, macCatalyst 26.0, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
extension Foundation.NotificationCenter.MessageIdentifier where Self == Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCRacingWheel.DidConnectMessage> {
  @_alwaysEmitIntoClient public static var didConnect: Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCRacingWheel.DidConnectMessage> {
    get { .init() }
  }
}
@available(macOS 26.0, macCatalyst 26.0, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
extension Foundation.NotificationCenter.MessageIdentifier where Self == Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCRacingWheel.DidDisconnectMessage> {
  @_alwaysEmitIntoClient public static var didDisconnect: Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCRacingWheel.DidDisconnectMessage> {
    get { .init() }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension GameController.GCDevicePhysicalInputState {
  public var elements: GameController.GCPhysicalInputElementCollection<any GameController.GCPhysicalInputElement> {
    get
  }
  public var buttons: GameController.GCPhysicalInputElementCollection<any GameController.GCButtonElement> {
    get
  }
  public var axes: GameController.GCPhysicalInputElementCollection<any GameController.GCAxisElement> {
    get
  }
  public var switches: GameController.GCPhysicalInputElementCollection<any GameController.GCSwitchElement> {
    get
  }
  public var dpads: GameController.GCPhysicalInputElementCollection<any GameController.GCDirectionPadElement> {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct GCDirectionPadElementName : Swift.RawRepresentable, Swift.Hashable, Swift.Sendable {
  public init(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public static let directionPad: GameController.GCDirectionPadElementName
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public static let thumbstick: GameController.GCDirectionPadElementName
  public static let leftThumbstick: GameController.GCDirectionPadElementName
  public static let rightThumbstick: GameController.GCDirectionPadElementName
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias RawValue = Swift.String
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension GameController.GCPhysicalInputElementCollection where T == any GameController.GCDirectionPadElement {
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript(elementName: GameController.GCDirectionPadElementName) -> T? {
    get
  }
  #endif
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension GameController.GCDirectionPadElementName : GameController.GCPhysicalInputElementTypedName {
  public typealias PhysicalInputElement = GameController.GCDirectionPadElement
}
@available(visionOS 26.0, *)
@available(macOS, unavailable)
@available(iOS, unavailable)
@available(tvOS, unavailable)
extension GameController.GCStylus {
  @available(visionOS 26.0, *)
  @available(macOS, unavailable)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  public struct DidConnectMessage : Foundation.NotificationCenter.MainActorMessage {
    public typealias Subject = GameController.GCStylus
    public static var name: Foundation.Notification.Name {
      get
    }
    public var stylus: GameController.GCStylus
    public init(stylus: GameController.GCStylus)
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public static func makeMessage(_ notification: Foundation.Notification) -> GameController.GCStylus.DidConnectMessage?
    #endif
  }
  @available(visionOS 26.0, *)
  @available(macOS, unavailable)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  public struct DidDisconnectMessage : Foundation.NotificationCenter.MainActorMessage {
    public typealias Subject = GameController.GCStylus
    public static var name: Foundation.Notification.Name {
      get
    }
    public var stylus: GameController.GCStylus
    public init(stylus: GameController.GCStylus)
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public static func makeMessage(_ notification: Foundation.Notification) -> GameController.GCStylus.DidDisconnectMessage?
    #endif
  }
}
@available(visionOS 26.0, *)
@available(macOS, unavailable)
@available(iOS, unavailable)
@available(tvOS, unavailable)
extension Foundation.NotificationCenter.MessageIdentifier where Self == Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCStylus.DidConnectMessage> {
  @_alwaysEmitIntoClient public static var didConnect: Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCStylus.DidConnectMessage> {
    get { .init() }
  }
}
@available(visionOS 26.0, *)
@available(macOS, unavailable)
@available(iOS, unavailable)
@available(tvOS, unavailable)
extension Foundation.NotificationCenter.MessageIdentifier where Self == Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCStylus.DidDisconnectMessage> {
  @_alwaysEmitIntoClient public static var didDisconnect: Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCStylus.DidDisconnectMessage> {
    get { .init() }
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputButtonA: Swift.String {
  get { __GCInputButtonName.a.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputButtonB: Swift.String {
  get { __GCInputButtonName.b.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputButtonX: Swift.String {
  get { __GCInputButtonName.x.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputButtonY: Swift.String {
  get { __GCInputButtonName.y.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputDirectionPad: Swift.String {
  get { __GCInputDirectionPadName.directionPad.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputLeftThumbstick: Swift.String {
  get { __GCInputDirectionPadName.leftThumbstick.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputRightThumbstick: Swift.String {
  get { __GCInputDirectionPadName.rightThumbstick.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputLeftShoulder: Swift.String {
  get { __GCInputButtonName.leftShoulder.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputRightShoulder: Swift.String {
  get { __GCInputButtonName.rightShoulder.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputLeftTrigger: Swift.String {
  get { __GCInputButtonName.leftTrigger.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputRightTrigger: Swift.String {
  get { __GCInputButtonName.rightTrigger.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputLeftThumbstickButton: Swift.String {
  get { __GCInputButtonName.leftThumbstickButton.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputRightThumbstickButton: Swift.String {
  get { __GCInputButtonName.rightThumbstickButton.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputButtonHome: Swift.String {
  get { __GCInputButtonName.home.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputButtonMenu: Swift.String {
  get { __GCInputButtonName.menu.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputButtonOptions: Swift.String {
  get { __GCInputButtonName.options.rawValue }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, *)
@_alwaysEmitIntoClient public var GCInputButtonShare: Swift.String {
  get { __GCInputButtonName.share.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputXboxPaddleOne: Swift.String {
  get { __GCInputButtonName.xboxPaddleOne.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputXboxPaddleTwo: Swift.String {
  get { __GCInputButtonName.xboxPaddleTwo.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputXboxPaddleThree: Swift.String {
  get { __GCInputButtonName.xboxPaddleThree.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputXboxPaddleFour: Swift.String {
  get { __GCInputButtonName.xboxPaddleFour.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputDualShockTouchpadOne: Swift.String {
  get { __GCInputDirectionPadName.dualShockTouchpadOne.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputDualShockTouchpadTwo: Swift.String {
  get { __GCInputDirectionPadName.dualShockTouchpadTwo.rawValue }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, *)
@_alwaysEmitIntoClient public var GCInputDualShockTouchpadButton: Swift.String {
  get { __GCInputButtonName.dualShockTouchpadButton.rawValue }
}
@available(macOS 13.0, macCatalyst 16.0, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@_alwaysEmitIntoClient public var GCInputSteeringWheel: Swift.String {
  get { __GCInputAxisName.steeringWheel.rawValue }
}
@available(macOS 13.0, macCatalyst 16.0, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@_alwaysEmitIntoClient public var GCInputShifter: Swift.String {
  get { __GCInputElementName.shifter.rawValue }
}
@available(macOS 13.0, macCatalyst 16.0, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@_alwaysEmitIntoClient public var GCInputPedalAccelerator: Swift.String {
  get { __GCInputButtonName.pedalAccelerator.rawValue }
}
@available(macOS 13.0, macCatalyst 16.0, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@_alwaysEmitIntoClient public var GCInputPedalBrake: Swift.String {
  get { __GCInputButtonName.pedalBrake.rawValue }
}
@available(macOS 13.0, macCatalyst 16.0, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@_alwaysEmitIntoClient public var GCInputPedalClutch: Swift.String {
  get { __GCInputButtonName.pedalClutch.rawValue }
}
@available(macOS 13.0, macCatalyst 16.0, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@_alwaysEmitIntoClient public var GCInputLeftPaddle: Swift.String {
  get { __GCInputButtonName.leftPaddle.rawValue }
}
@available(macOS 13.0, macCatalyst 16.0, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@_alwaysEmitIntoClient public var GCInputRightPaddle: Swift.String {
  get { __GCInputButtonName.rightPaddle.rawValue }
}
@available(visionOS 26.0, *)
@available(macOS, unavailable)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@_alwaysEmitIntoClient public var GCInputStylusTip: Swift.String {
  get { __GCInputButtonName.stylusTip.rawValue }
}
@available(visionOS 26.0, *)
@available(macOS, unavailable)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@_alwaysEmitIntoClient public var GCInputStylusPrimaryButton: Swift.String {
  get { __GCInputButtonName.stylusPrimaryButton.rawValue }
}
@available(visionOS 26.0, *)
@available(macOS, unavailable)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@_alwaysEmitIntoClient public var GCInputStylusSecondaryButton: Swift.String {
  get { __GCInputButtonName.stylusSecondaryButton.rawValue }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct GCSwitchElementName : Swift.RawRepresentable, Swift.Hashable, Swift.Sendable {
  public init(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias RawValue = Swift.String
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension GameController.GCPhysicalInputElementCollection where T == any GameController.GCSwitchElement {
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript(elementName: GameController.GCSwitchElementName) -> T? {
    get
  }
  #endif
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension GameController.GCSwitchElementName : GameController.GCPhysicalInputElementTypedName {
  public typealias PhysicalInputElement = GameController.GCSwitchElement
}
@available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
extension GameController.GCController {
  @available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
  public struct DidConnectMessage : Foundation.NotificationCenter.MainActorMessage {
    public typealias Subject = GameController.GCController
    public static var name: Foundation.Notification.Name {
      get
    }
    public var controller: GameController.GCController
    public init(controller: GameController.GCController)
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public static func makeMessage(_ notification: Foundation.Notification) -> GameController.GCController.DidConnectMessage?
    #endif
  }
  @available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
  public struct DidDisconnectMessage : Foundation.NotificationCenter.MainActorMessage {
    public typealias Subject = GameController.GCController
    public static var name: Foundation.Notification.Name {
      get
    }
    public var controller: GameController.GCController
    public init(controller: GameController.GCController)
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public static func makeMessage(_ notification: Foundation.Notification) -> GameController.GCController.DidDisconnectMessage?
    #endif
  }
  @available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
  public struct DidBecomeCurrentMessage : Foundation.NotificationCenter.MainActorMessage {
    public typealias Subject = GameController.GCController
    public static var name: Foundation.Notification.Name {
      get
    }
    public var controller: GameController.GCController
    public init(controller: GameController.GCController)
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public static func makeMessage(_ notification: Foundation.Notification) -> GameController.GCController.DidBecomeCurrentMessage?
    #endif
  }
  @available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
  public struct DidStopBeingCurrentMessage : Foundation.NotificationCenter.MainActorMessage {
    public typealias Subject = GameController.GCController
    public static var name: Foundation.Notification.Name {
      get
    }
    public var controller: GameController.GCController
    public init(controller: GameController.GCController)
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public static func makeMessage(_ notification: Foundation.Notification) -> GameController.GCController.DidStopBeingCurrentMessage?
    #endif
  }
}
@available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
extension Foundation.NotificationCenter.MessageIdentifier where Self == Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCController.DidConnectMessage> {
  @_alwaysEmitIntoClient public static var didConnect: Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCController.DidConnectMessage> {
    get { .init() }
  }
}
@available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
extension Foundation.NotificationCenter.MessageIdentifier where Self == Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCController.DidDisconnectMessage> {
  @_alwaysEmitIntoClient public static var didDisconnect: Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCController.DidDisconnectMessage> {
    get { .init() }
  }
}
@available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
extension Foundation.NotificationCenter.MessageIdentifier where Self == Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCController.DidBecomeCurrentMessage> {
  @_alwaysEmitIntoClient public static var didBecomeCurrent: Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCController.DidBecomeCurrentMessage> {
    get { .init() }
  }
}
@available(macOS 26, iOS 26, tvOS 26, visionOS 26, *)
extension Foundation.NotificationCenter.MessageIdentifier where Self == Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCController.DidStopBeingCurrentMessage> {
  @_alwaysEmitIntoClient public static var didStopBeingCurrent: Foundation.NotificationCenter.BaseMessageIdentifier<GameController.GCController.DidStopBeingCurrentMessage> {
    get { .init() }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
public struct GCButtonElementName : Swift.RawRepresentable, Swift.Hashable, Swift.Sendable {
  public init(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public static let a: GameController.GCButtonElementName
  public static let b: GameController.GCButtonElementName
  public static let x: GameController.GCButtonElementName
  public static let y: GameController.GCButtonElementName
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public static let grip: GameController.GCButtonElementName
  public static let leftShoulder: GameController.GCButtonElementName
  public static let rightShoulder: GameController.GCButtonElementName
  @available(macOS 14.4, iOS 17.4, tvOS 17.4, visionOS 1.1, *)
  public static let leftBumper: GameController.GCButtonElementName
  @available(macOS 14.4, iOS 17.4, tvOS 17.4, visionOS 1.1, *)
  public static let rightBumper: GameController.GCButtonElementName
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public static let trigger: GameController.GCButtonElementName
  public static let leftTrigger: GameController.GCButtonElementName
  public static let rightTrigger: GameController.GCButtonElementName
  @available(macOS 26.0, iOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public static let thumbstickButton: GameController.GCButtonElementName
  public static let leftThumbstickButton: GameController.GCButtonElementName
  public static let rightThumbstickButton: GameController.GCButtonElementName
  @available(macOS 14.4, iOS 17.4, tvOS 17.4, visionOS 1.1, *)
  public static func backLeftButton(position: Swift.Int) -> GameController.GCButtonElementName
  @available(macOS 14.4, iOS 17.4, tvOS 17.4, visionOS 1.1, *)
  public static func backRightButton(position: Swift.Int) -> GameController.GCButtonElementName
  public static let home: GameController.GCButtonElementName
  public static let menu: GameController.GCButtonElementName
  public static let options: GameController.GCButtonElementName
  public static let share: GameController.GCButtonElementName
  @available(macOS 13.0, macCatalyst 16.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  public static let pedalAccelerator: GameController.GCButtonElementName
  @available(macOS 13.0, macCatalyst 16.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  public static let pedalBrake: GameController.GCButtonElementName
  @available(macOS 13.0, macCatalyst 16.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  public static let pedalClutch: GameController.GCButtonElementName
  @available(macOS 13.0, macCatalyst 16.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  public static let leftPaddle: GameController.GCButtonElementName
  @available(macOS 13.0, macCatalyst 16.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  public static let rightPaddle: GameController.GCButtonElementName
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
  public static func arcadeButton(row: Swift.Int, column: Swift.Int) -> GameController.GCButtonElementName
  @available(visionOS 26.0, *)
  @available(macOS, unavailable)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  public static let stylusTip: GameController.GCButtonElementName
  @available(visionOS 26.0, *)
  @available(macOS, unavailable)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  public static let stylusPrimaryButton: GameController.GCButtonElementName
  @available(visionOS 26.0, *)
  @available(macOS, unavailable)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  public static let stylusSecondaryButton: GameController.GCButtonElementName
  @available(iOS 16.0, tvOS 16.0, macOS 13.0, *)
  public typealias RawValue = Swift.String
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, *)
extension GameController.GCPhysicalInputElementCollection where T == any GameController.GCButtonElement {
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript(elementName: GameController.GCButtonElementName) -> T? {
    get
  }
  #endif
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, *)
extension GameController.GCButtonElementName : GameController.GCPhysicalInputElementTypedName {
  public typealias PhysicalInputElement = GameController.GCButtonElement
}
