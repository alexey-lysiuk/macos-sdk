// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 effective-5.10 (swiftlang-6.2.1.4.7 clang-1700.4.4.1)
// swift-module-flags: -target x86_64-apple-macos26.1 -target-variant x86_64-apple-ios26.1-macabi -enable-objc-interop -enable-library-evolution -module-link-name swiftNetwork -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-upcoming-feature MemberImportVisibility -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 5000.0.23 -module-name Network
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.1
import Darwin
import Dispatch
import Distributed
import Foundation
import Foundation/*.Data*/
import Foundation/*.FileManager*/
import Foundation/*.JSONSerialization*/
@_exported import Network
import Security
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public class NWProtocolWebSocket : Network.NWProtocol {
  public static let definition: Network.NWProtocolDefinition
  public enum Version : Swift.Sendable {
    case version13
    public static func == (a: Network.NWProtocolWebSocket.Version, b: Network.NWProtocolWebSocket.Version) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Opcode : Swift.UInt8, Swift.Sendable {
    case cont
    case text
    case binary
    case close
    case ping
    case pong
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum CloseCode : Swift.Equatable, Swift.Sendable {
    public enum Defined : Swift.UInt16, Swift.Sendable {
      case normalClosure
      case goingAway
      case protocolError
      case unsupportedData
      case noStatusReceived
      case abnormalClosure
      case invalidFramePayloadData
      case policyViolation
      case messageTooBig
      case mandatoryExtension
      case internalServerError
      case tlsHandshake
      #if compiler(>=5.3) && $NonescapableTypes
      public init?(rawValue: Swift.UInt16)
      #endif
      @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
      public typealias RawValue = Swift.UInt16
      public var rawValue: Swift.UInt16 {
        get
      }
    }
    case protocolCode(Network.NWProtocolWebSocket.CloseCode.Defined)
    case applicationCode(Swift.UInt16)
    case privateCode(Swift.UInt16)
    public init(rawValue: Swift.UInt16) throws
    public static func == (a: Network.NWProtocolWebSocket.CloseCode, b: Network.NWProtocolWebSocket.CloseCode) -> Swift.Bool
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Options : Network.NWProtocolOptions {
    public var autoReplyPing: Swift.Bool {
      get
      set
    }
    public var maximumMessageSize: Swift.Int {
      get
      set
    }
    public var skipHandshake: Swift.Bool {
      get
      set
    }
    public init(_ version: Network.NWProtocolWebSocket.Version = .version13)
    public func setAdditionalHeaders(_ headers: [(name: Swift.String, value: Swift.String)])
    public func setSubprotocols(_ subprotocols: [Swift.String])
    @preconcurrency public func setClientRequestHandler(_ queue: Dispatch.DispatchQueue, handler: @escaping @Sendable (_ subprotocols: [Swift.String], _ additionalHeaders: [(name: Swift.String, value: Swift.String)]) -> Network.NWProtocolWebSocket.Response)
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Metadata : Network.NWProtocolMetadata {
    final public let opcode: Network.NWProtocolWebSocket.Opcode
    public init(opcode: Network.NWProtocolWebSocket.Opcode)
    public var closeCode: Network.NWProtocolWebSocket.CloseCode {
      get
      set
    }
    #if compiler(>=5.3) && $NonescapableTypes
    @preconcurrency public func setPongHandler(_ queue: Dispatch.DispatchQueue, handler: @escaping @Sendable (Network.NWError?) -> Swift.Void)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var selectedSubprotocol: Swift.String? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var additionalServerHeaders: [(Swift.String, Swift.String)]? {
      get
    }
    #endif
    @objc deinit
  }
  public struct Response : Swift.Sendable {
    public enum Status : Swift.Sendable {
      case accept
      case reject
      public static func == (a: Network.NWProtocolWebSocket.Response.Status, b: Network.NWProtocolWebSocket.Response.Status) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public let status: Network.NWProtocolWebSocket.Response.Status
    public let subprotocol: Swift.String?
    public let additionalHeaders: [(name: Swift.String, value: Swift.String)]?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(status: Network.NWProtocolWebSocket.Response.Status, subprotocol: Swift.String?, additionalHeaders: [(name: Swift.String, value: Swift.String)]? = nil)
    #endif
  }
  @objc deinit
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol Connectable {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct UnexpectedEndpointType : Swift.Error {
  public let endpoint: Network.NWEndpoint
  public init(endpoint: Network.NWEndpoint)
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol BrowserProvider : Swift.Sendable {
  associatedtype Endpoint : Network.Connectable
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
final public class NetworkBrowser<Provider> : Swift.Sendable, Swift.CustomDebugStringConvertible where Provider : Network.BrowserProvider {
  public enum State : Swift.Equatable, Swift.Sendable {
    case setup
    case ready
    case failed(Network.NWError)
    case cancelled
    case waiting(Network.NWError)
    public static func == (a: Network.NetworkBrowser<Provider>.State, b: Network.NetworkBrowser<Provider>.State) -> Swift.Bool
  }
  #if compiler(>=5.3) && $IsolatedAny
  public typealias StateUpdateHandler = @isolated(any) @Sendable (Network.NetworkBrowser<Provider>, Network.NetworkBrowser<Provider>.State) -> Swift.Void
  #endif
  public enum RunResult<T> {
    case finish(T)
    case `continue`
  }
  final public var debugDescription: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init(for provider: Provider, using parameters: Network.NWParameters? = nil)
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @discardableResult
  final public func onStateUpdate(@_inheritActorContext _ handler: @escaping @isolated(any) @Sendable (Network.NetworkBrowser<Provider>, Network.NetworkBrowser<Provider>.State) -> Swift.Void) -> Self
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  final public func run(@_inheritActorContext _ handler: @escaping @isolated(any) @Sendable ([Provider.Endpoint]) async throws -> Swift.Void) async throws
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  final public func run<Return>(@_inheritActorContext _ handler: @escaping @isolated(any) @Sendable ([Provider.Endpoint]) async throws -> Network.NetworkBrowser<Provider>.RunResult<Return>) async throws -> Return
  #endif
  @objc deinit
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public struct TXTRecordDecoder : Swift.Sendable {
  public init()
  public func decode<T>(_ type: T.Type, from txtRecord: Network.NWTXTRecord) throws -> T where T : Swift.Decodable
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network14_NWProtocolTLS) public class NWProtocolTLS : Network.NWProtocol {
  public static let definition: Network.NWProtocolDefinition
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network14_NWProtocolTLS7Options) public class Options : Network.NWProtocolOptions {
    public var securityProtocolOptions: Security.sec_protocol_options_t {
      get
    }
    public init()
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network14_NWProtocolTLS8Metadata) public class Metadata : Network.NWProtocolMetadata {
    public var securityProtocolMetadata: Security.sec_protocol_metadata_t {
      get
    }
    @objc deinit
  }
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
final public class NWBrowser : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
  public enum Descriptor : Swift.Sendable {
    case bonjour(type: Swift.String, domain: Swift.String?)
    case bonjourWithTXTRecord(type: Swift.String, domain: Swift.String?)
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    case applicationService(name: Swift.String)
  }
  public struct Result : Swift.Hashable, Swift.Sendable {
    public let endpoint: Network.NWEndpoint
    public let interfaces: [Network.NWInterface]
    public let metadata: Network.NWBrowser.Result.Metadata
    public enum Metadata : Swift.Equatable, Swift.CustomDebugStringConvertible, Swift.Sendable {
      case none
      case bonjour(_: Network.NWTXTRecord)
      public static func == (lhs: Network.NWBrowser.Result.Metadata, rhs: Network.NWBrowser.Result.Metadata) -> Swift.Bool
      public var debugDescription: Swift.String {
        get
      }
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Network.NWBrowser.Result, rhs: Network.NWBrowser.Result) -> Swift.Bool
    public enum Change : Swift.Hashable, Swift.Sendable {
      case identical
      case added(Network.NWBrowser.Result)
      case removed(Network.NWBrowser.Result)
      case changed(old: Network.NWBrowser.Result, new: Network.NWBrowser.Result, flags: Network.NWBrowser.Result.Change.Flags)
      public static func == (lhs: Network.NWBrowser.Result.Change, rhs: Network.NWBrowser.Result.Change) -> Swift.Bool
      public struct Flags : Swift.OptionSet, Swift.Hashable, Swift.Sendable {
        public let rawValue: Swift.UInt8
        public init(rawValue: Swift.UInt8)
        public static let identical: Network.NWBrowser.Result.Change.Flags
        public static let interfaceAdded: Network.NWBrowser.Result.Change.Flags
        public static let interfaceRemoved: Network.NWBrowser.Result.Change.Flags
        public static let metadataChanged: Network.NWBrowser.Result.Change.Flags
        @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
        public typealias ArrayLiteralElement = Network.NWBrowser.Result.Change.Flags
        @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
        public typealias Element = Network.NWBrowser.Result.Change.Flags
        @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
        public typealias RawValue = Swift.UInt8
      }
      #if compiler(>=5.3) && $NonescapableTypes
      public init(between old: Network.NWBrowser.Result?, _ new: Network.NWBrowser.Result?)
      #endif
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum State : Swift.Equatable, Swift.Sendable {
    case setup
    case ready
    case failed(Network.NWError)
    case cancelled
    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    case waiting(Network.NWError)
    public static func == (a: Network.NWBrowser.State, b: Network.NWBrowser.State) -> Swift.Bool
  }
  final public let descriptor: Network.NWBrowser.Descriptor
  final public let parameters: Network.NWParameters
  final public var state: Network.NWBrowser.State {
    get
  }
  final public var browseResults: Swift.Set<Network.NWBrowser.Result> {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public var stateUpdateHandler: (@Sendable (_ newState: Network.NWBrowser.State) -> Swift.Void)? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public var browseResultsChangedHandler: (@Sendable (_ newResults: Swift.Set<Network.NWBrowser.Result>, _ changes: Swift.Set<Network.NWBrowser.Result.Change>) -> Swift.Void)? {
    get
    set
  }
  #endif
  public init(for descriptor: Network.NWBrowser.Descriptor, using parameters: Network.NWParameters)
  final public func start(queue: Dispatch.DispatchQueue)
  final public func cancel()
  @objc deinit
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension Network.NWBrowser : Swift.Sendable {
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public protocol IPAddress : Swift.Sendable {
  var rawValue: Foundation.Data { get }
  #if compiler(>=5.3) && $NonescapableTypes
  init?(_ rawValue: Foundation.Data, _ interface: Network.NWInterface?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  init?(_ string: Swift.String)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var interface: Network.NWInterface? { get }
  #endif
  var isLoopback: Swift.Bool { get }
  var isLinkLocal: Swift.Bool { get }
  var isMulticast: Swift.Bool { get }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public struct IPv4Address : Network.IPAddress, Swift.Hashable, Swift.CustomDebugStringConvertible {
  public static let any: Network.IPv4Address
  public static let broadcast: Network.IPv4Address
  public static let loopback: Network.IPv4Address
  public static let allHostsGroup: Network.IPv4Address
  public static let allRoutersGroup: Network.IPv4Address
  public static let allReportsGroup: Network.IPv4Address
  public static let mdnsGroup: Network.IPv4Address
  public var isLoopback: Swift.Bool {
    get
  }
  public var isLinkLocal: Swift.Bool {
    get
  }
  public var isMulticast: Swift.Bool {
    get
  }
  public var rawValue: Foundation.Data {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ rawValue: Foundation.Data, _ interface: Network.NWInterface? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ string: Swift.String)
  #endif
  public let interface: Network.NWInterface?
  public static func == (lhs: Network.IPv4Address, rhs: Network.IPv4Address) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public struct IPv6Address : Network.IPAddress, Swift.Hashable, Swift.CustomDebugStringConvertible {
  public static let any: Network.IPv6Address
  public static let broadcast: Network.IPv6Address
  public static let loopback: Network.IPv6Address
  public static let nodeLocalNodes: Network.IPv6Address
  public static let linkLocalNodes: Network.IPv6Address
  public static let linkLocalRouters: Network.IPv6Address
  public enum Scope : Swift.UInt8 {
    case nodeLocal
    case linkLocal
    case siteLocal
    case organizationLocal
    case global
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    @available(iOS 12.0, tvOS 12.0, watchOS 5.0, macOS 10.14, *)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public var isAny: Swift.Bool {
    get
  }
  public var isLoopback: Swift.Bool {
    get
  }
  public var isIPv4Compatabile: Swift.Bool {
    get
  }
  public var isIPv4Mapped: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var asIPv4: Network.IPv4Address? {
    get
  }
  #endif
  public var is6to4: Swift.Bool {
    get
  }
  public var isLinkLocal: Swift.Bool {
    get
  }
  public var isMulticast: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var multicastScope: Network.IPv6Address.Scope? {
    get
  }
  #endif
  @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
  @backDeployed(before: macOS 14, iOS 17, watchOS 10, tvOS 17)
  public var isUniqueLocal: Swift.Bool {
    get {
		return [0xfc, 0xfd].contains(self.rawValue[0])
	}
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ rawValue: Foundation.Data, _ interface: Network.NWInterface? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ string: Swift.String)
  #endif
  public let interface: Network.NWInterface?
  public var rawValue: Foundation.Data {
    get
  }
  public static func == (lhs: Network.IPv6Address, rhs: Network.IPv6Address) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public enum NWEndpoint : Swift.Hashable, Swift.CustomDebugStringConvertible, Swift.Sendable {
  case hostPort(host: Network.NWEndpoint.Host, port: Network.NWEndpoint.Port)
  case service(name: Swift.String, type: Swift.String, domain: Swift.String, interface: Network.NWInterface?)
  case unix(path: Swift.String)
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  case url(_: Foundation.URL)
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  case opaque(_: Network.nw_endpoint_t)
  public enum Host : Swift.Hashable, Swift.CustomDebugStringConvertible, Swift.ExpressibleByStringLiteral, Swift.Sendable {
    public typealias StringLiteralType = Swift.String
    case name(Swift.String, Network.NWInterface?)
    case ipv4(Network.IPv4Address)
    case ipv6(Network.IPv6Address)
    public init(stringLiteral: Network.NWEndpoint.Host.StringLiteralType)
    public init(_ string: Swift.String)
    #if compiler(>=5.3) && $NonescapableTypes
    public var interface: Network.NWInterface? {
      get
    }
    #endif
    public var debugDescription: Swift.String {
      get
    }
    public static func == (a: Network.NWEndpoint.Host, b: Network.NWEndpoint.Host) -> Swift.Bool
    @available(iOS 12.0, tvOS 12.0, watchOS 5.0, macOS 10.14, *)
    public typealias ExtendedGraphemeClusterLiteralType = Network.NWEndpoint.Host.StringLiteralType
    @available(iOS 12.0, tvOS 12.0, watchOS 5.0, macOS 10.14, *)
    public typealias UnicodeScalarLiteralType = Network.NWEndpoint.Host.StringLiteralType
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Port : Swift.Hashable, Swift.CustomDebugStringConvertible, Swift.ExpressibleByIntegerLiteral, Swift.RawRepresentable, Swift.Sendable {
    public typealias IntegerLiteralType = Swift.UInt16
    public static let any: Network.NWEndpoint.Port
    public static let ssh: Network.NWEndpoint.Port
    public static let smtp: Network.NWEndpoint.Port
    public static let http: Network.NWEndpoint.Port
    public static let pop: Network.NWEndpoint.Port
    public static let imap: Network.NWEndpoint.Port
    public static let https: Network.NWEndpoint.Port
    public static let imaps: Network.NWEndpoint.Port
    public static let socks: Network.NWEndpoint.Port
    public var rawValue: Swift.UInt16 {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(_ service: Swift.String)
    #endif
    public init(integerLiteral value: Network.NWEndpoint.Port.IntegerLiteralType)
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt16)
    #endif
    public var debugDescription: Swift.String {
      get
    }
    @available(iOS 12.0, tvOS 12.0, watchOS 5.0, macOS 10.14, *)
    public typealias RawValue = Swift.UInt16
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var interface: Network.NWInterface? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public var txtRecord: Network.NWTXTRecord? {
    get
  }
  #endif
  public static func == (lhs: Network.NWEndpoint, rhs: Network.NWEndpoint) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public class NWProtocolQUIC : Network.NWProtocol {
  public static let definition: Network.NWProtocolDefinition
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Options : Network.NWProtocolOptions {
    public init()
    convenience public init(alpn: [Swift.String])
    public var alpn: [Swift.String] {
      get
      set
    }
    public enum Direction : Swift.Sendable {
      case bidirectional
      case unidirectional
      public static func == (a: Network.NWProtocolQUIC.Options.Direction, b: Network.NWProtocolQUIC.Options.Direction) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public var direction: Network.NWProtocolQUIC.Options.Direction {
      get
      set
    }
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public var isDatagram: Swift.Bool {
      get
      set
    }
    public var securityProtocolOptions: Security.sec_protocol_options_t {
      get
    }
    public var idleTimeout: Swift.Int {
      get
      set
    }
    public var maxUDPPayloadSize: Swift.Int {
      get
      set
    }
    public var initialMaxData: Swift.Int {
      get
      set
    }
    public var initialMaxStreamDataBidirectionalRemote: Swift.Int {
      get
      set
    }
    public var initialMaxStreamDataBidirectionalLocal: Swift.Int {
      get
      set
    }
    public var initialMaxStreamDataUnidirectional: Swift.Int {
      get
      set
    }
    public var initialMaxStreamsBidirectional: Swift.Int {
      get
      set
    }
    public var initialMaxStreamsUnidirectional: Swift.Int {
      get
      set
    }
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public var maxDatagramFrameSize: Swift.Int {
      get
      set
    }
    @objc deinit
  }
  public struct ApplicationError : Swift.ExpressibleByIntegerLiteral, Swift.Sendable {
    public let code: Swift.UInt64
    public let reason: Swift.String?
    public init(integerLiteral code: Swift.UInt64)
    #if compiler(>=5.3) && $NonescapableTypes
    public init(code: Swift.UInt64, reason: Swift.String? = nil)
    #endif
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias IntegerLiteralType = Swift.UInt64
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Metadata : Network.NWProtocolMetadata {
    public var securityProtocolMetadata: Security.sec_protocol_metadata_t {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public var negotiatedALPN: Swift.String? {
      get
    }
    #endif
    public var streamIdentifier: Swift.UInt64 {
      get
    }
    public var remoteIdleTimeout: Swift.Int {
      get
    }
    public var applicationError: Network.NWProtocolQUIC.ApplicationError {
      get
      set
    }
    public var streamApplicationErrorCode: Swift.UInt64 {
      get
      set
    }
    public var localMaxStreamsUnidirectional: Swift.Int {
      get
      set
    }
    public var remoteMaxStreamsUnidirectional: Swift.Int {
      get
    }
    public var localMaxStreamsBidirectional: Swift.Int {
      get
      set
    }
    public var remoteMaxStreamsBidirectional: Swift.Int {
      get
    }
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public var usableDatagramFrameSize: Swift.Int {
      get
    }
    public enum KeepAliveBehavior : Swift.Sendable {
      case on
      case off
      case seconds(Swift.Int)
    }
    public var keepAlive: Network.NWProtocolQUIC.Metadata.KeepAliveBehavior {
      get
      set
    }
    @objc deinit
  }
  @objc deinit
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public enum NWError : Swift.Error, Swift.CustomDebugStringConvertible, Swift.Equatable {
  case posix(_DarwinFoundation1.POSIXErrorCode)
  case dns(dnssd.DNSServiceErrorType)
  case tls(Darwin.OSStatus)
  @available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
  case wifiAware(Swift.Int32)
  public var debugDescription: Swift.String {
    get
  }
  public static func == (a: Network.NWError, b: Network.NWError) -> Swift.Bool
}
@available(macOS 13.3, iOS 16.4, watchOS 9.4, tvOS 16.4, *)
extension Network.NWError : Foundation.CustomNSError {
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
  public var _domain: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network11_NWListener) final public class NWListener : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
  public struct Service : Swift.Equatable, Swift.CustomDebugStringConvertible, Swift.Sendable {
    public static func == (lhs: Network.NWListener.Service, rhs: Network.NWListener.Service) -> Swift.Bool
    public var debugDescription: Swift.String {
      get
    }
    public let name: Swift.String?
    public let type: Swift.String
    public let domain: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public var txtRecordObject: Network.NWTXTRecord? {
      get
      set
    }
    #endif
    public let txtRecord: Foundation.Data?
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public var noAutoRename: Swift.Bool {
      get
      set
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init(name: Swift.String? = nil, type: Swift.String, domain: Swift.String? = nil, txtRecord: Foundation.Data? = nil)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public init(name: Swift.String? = nil, type: Swift.String, domain: Swift.String? = nil, txtRecord: Network.NWTXTRecord)
    #endif
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public init(applicationService: Swift.String)
  }
  public enum State : Swift.Equatable, Swift.Sendable {
    case setup
    case waiting(Network.NWError)
    case ready
    case failed(Network.NWError)
    case cancelled
    public static func == (a: Network.NWListener.State, b: Network.NWListener.State) -> Swift.Bool
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public var newConnectionHandler: (@Sendable (_ connection: Network.NWConnection) -> Swift.Void)? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @preconcurrency final public var newConnectionGroupHandler: (@Sendable (_ group: Network.NWConnectionGroup) -> Swift.Void)? {
    get
    set
  }
  #endif
  final public var state: Network.NWListener.State {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public var stateUpdateHandler: (@Sendable (_ newState: Network.NWListener.State) -> Swift.Void)? {
    get
    set
  }
  #endif
  final public let parameters: Network.NWParameters
  #if compiler(>=5.3) && $NonescapableTypes
  final public var service: Network.NWListener.Service? {
    get
    set
  }
  #endif
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public static let InfiniteConnectionLimit: Swift.Int
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  final public var newConnectionLimit: Swift.Int {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var port: Network.NWEndpoint.Port? {
    get
  }
  #endif
  public enum ServiceRegistrationChange : Swift.Sendable {
    case add(Network.NWEndpoint)
    case remove(Network.NWEndpoint)
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public var serviceRegistrationUpdateHandler: (@Sendable (_ change: Network.NWListener.ServiceRegistrationChange) -> Swift.Void)? {
    get
    set
  }
  #endif
  public init(using: Network.NWParameters, on: Network.NWEndpoint.Port = .any) throws
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  convenience public init(applicationService name: Swift.String, using parameters: Network.NWParameters = .applicationService) throws
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  convenience public init(service: Network.NWListener.Service, using parameters: Network.NWParameters) throws
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS, introduced: 13.0, deprecated: 15.0, message: "Use init(launchdSocketKey:parameters:)")
  @available(iOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  convenience public init?(launchd key: Swift.String, using parameters: Network.NWParameters)
  #endif
  @available(macOS 13.0, *)
  @backDeployed(before: macOS 15.0)
  @available(iOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  convenience public init(launchdSocketKey: Swift.String, parameters: Network.NWParameters) {
		self.init(launchd: launchdSocketKey, using: parameters)!
	}
  final public func start(queue: Dispatch.DispatchQueue)
  #if compiler(>=5.3) && $NonescapableTypes
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  #endif
  final public func cancel()
  @objc deinit
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension Network.NWListener : Swift.Sendable {
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public struct NWInterface : Swift.Hashable, Swift.CustomDebugStringConvertible, Swift.Sendable {
  public var debugDescription: Swift.String {
    get
  }
  public enum InterfaceType : Swift.Sendable {
    case other
    case wifi
    case cellular
    case wiredEthernet
    case loopback
    public static func == (a: Network.NWInterface.InterfaceType, b: Network.NWInterface.InterfaceType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var type: Network.NWInterface.InterfaceType {
    get
  }
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public enum RadioType : Swift.Sendable {
    public enum WiFi : Swift.Sendable {
      case b
      case a
      case g
      case n
      case ac
      case ax
      public static func == (a: Network.NWInterface.RadioType.WiFi, b: Network.NWInterface.RadioType.WiFi) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Cellular : Swift.Sendable {
      public enum NewRadio5GVariant : Swift.Sendable {
        case sub6GHz
        case mmWave
        public static func == (a: Network.NWInterface.RadioType.Cellular.NewRadio5GVariant, b: Network.NWInterface.RadioType.Cellular.NewRadio5GVariant) -> Swift.Bool
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
      }
      case lte
      case dualConnectivity5G(Network.NWInterface.RadioType.Cellular.NewRadio5GVariant)
      case standalone5G(Network.NWInterface.RadioType.Cellular.NewRadio5GVariant)
      case wcdma
      case gsm
      case cdma
      case evdo
    }
    case wifi(Network.NWInterface.RadioType.WiFi)
    case cell(Network.NWInterface.RadioType.Cellular)
  }
  public var name: Swift.String {
    get
  }
  public var index: Swift.Int {
    get
  }
  public static func == (a: Network.NWInterface, b: Network.NWInterface) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public struct NWPath : Swift.Equatable, Swift.CustomDebugStringConvertible, Swift.Sendable {
  public var debugDescription: Swift.String {
    get
  }
  public enum Status : Swift.Sendable {
    case satisfied
    case unsatisfied
    case requiresConnection
    public static func == (a: Network.NWPath.Status, b: Network.NWPath.Status) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let status: Network.NWPath.Status
  @available(macOS 11.0, iOS 14.2, watchOS 7.1, tvOS 14.2, *)
  public enum UnsatisfiedReason : Swift.Sendable {
    case notAvailable
    case cellularDenied
    case wifiDenied
    case localNetworkDenied
    @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
    case vpnInactive
    public static func == (a: Network.NWPath.UnsatisfiedReason, b: Network.NWPath.UnsatisfiedReason) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 11.0, iOS 14.2, watchOS 7.1, tvOS 14.2, *)
  public var unsatisfiedReason: Network.NWPath.UnsatisfiedReason {
    get
  }
  @available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public enum LinkQuality : Swift.Sendable {
    case unknown
    case minimal
    case moderate
    case good
    public static func == (a: Network.NWPath.LinkQuality, b: Network.NWPath.LinkQuality) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let availableInterfaces: [Network.NWInterface]
  public let isExpensive: Swift.Bool
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var isConstrained: Swift.Bool {
    get
  }
  @available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public var isUltraConstrained: Swift.Bool {
    get
  }
  public let supportsIPv4: Swift.Bool
  public let supportsIPv6: Swift.Bool
  public let supportsDNS: Swift.Bool
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var gateways: [Network.NWEndpoint] {
    get
  }
  public let localEndpoint: Network.NWEndpoint?
  public let remoteEndpoint: Network.NWEndpoint?
  public func usesInterfaceType(_ type: Network.NWInterface.InterfaceType) -> Swift.Bool
  @available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public var linkQuality: Network.NWPath.LinkQuality {
    get
  }
  public static func == (lhs: Network.NWPath, rhs: Network.NWPath) -> Swift.Bool
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network14_NWPathMonitor) final public class NWPathMonitor {
  final public var currentPath: Network.NWPath {
    get
    @available(macOS, introduced: 10.14, deprecated: 14.0, message: "setting currentPath not supported")
    @available(iOS, introduced: 12.0, deprecated: 17.0, message: "setting currentPath not supported")
    @available(watchOS, introduced: 5.0, deprecated: 9.0, message: "setting currentPath not supported")
    @available(tvOS, introduced: 12.0, deprecated: 17.0, message: "setting currentPath not supported")
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public var pathUpdateHandler: (@Sendable (_ newPath: Network.NWPath) -> Swift.Void)? {
    get
    set
  }
  #endif
  final public func start(queue: Dispatch.DispatchQueue)
  final public func cancel()
  #if compiler(>=5.3) && $NonescapableTypes
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  #endif
  public init()
  @objc deinit
  @available(macOS 13.0, *)
  @available(iOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public static var ethernetChannel: Network.NWPathMonitor {
    get
  }
  public init(requiredInterfaceType: Network.NWInterface.InterfaceType)
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  public init(prohibitedInterfaceTypes: [Network.NWInterface.InterfaceType])
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension Network.NWPathMonitor : Swift.Sendable, Swift.CustomDebugStringConvertible, _Concurrency.AsyncSequence {
  public typealias Element = Network.NWPath
  public typealias AsyncIterator = Network.NWPathMonitor.Iterator
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  final public var debugDescription: Swift.String {
    get
  }
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $NonescapableTypes
    public mutating func next() async -> Network.NWPathMonitor.Element?
    #endif
    @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
    public typealias Element = Network.NWPathMonitor.Element
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
  }
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  final public __consuming func makeAsyncIterator() -> Network.NWPathMonitor.Iterator
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
}
@available(*, unavailable)
extension Network.NWPathMonitor.Iterator : Swift.Sendable {
}
@available(macOS 10.15, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
final public class NWEthernetChannel : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
  public enum State : Swift.Equatable, Swift.Sendable {
    case setup
    case waiting(Network.NWError)
    case preparing
    case ready
    case failed(Network.NWError)
    case cancelled
    public static func == (a: Network.NWEthernetChannel.State, b: Network.NWEthernetChannel.State) -> Swift.Bool
  }
  final public var state: Network.NWEthernetChannel.State {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public var stateUpdateHandler: (@Sendable (_ state: Network.NWEthernetChannel.State) -> Swift.Void)? {
    get
    set
  }
  #endif
  final public let etherType: Swift.UInt16
  final public let interface: Network.NWInterface
  public init(on interface: Network.NWInterface, etherType: Swift.UInt16)
  @available(macOS 13.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public init(on interface: Network.NWInterface, etherType: Swift.UInt16, parameters: Network.NWParameters)
  @available(macOS 13.0, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  final public var maximumPayloadSize: Swift.Int {
    get
  }
  final public func start(queue: Dispatch.DispatchQueue)
  #if compiler(>=5.3) && $NonescapableTypes
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  #endif
  final public func cancel()
  public struct EthernetAddress : Swift.Hashable, Swift.CustomDebugStringConvertible, Swift.Sendable {
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(_ rawValue: Foundation.Data)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(_ string: Swift.String)
    #endif
    public var debugDescription: Swift.String {
      get
    }
    public var rawValue: Foundation.Data {
      get
    }
    public static func == (a: Network.NWEthernetChannel.EthernetAddress, b: Network.NWEthernetChannel.EthernetAddress) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public func send(content: Foundation.Data, to remoteAddress: Network.NWEthernetChannel.EthernetAddress, vlanTag: Swift.UInt16, completion: @escaping @Sendable (_ error: Network.NWError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public var receiveHandler: (@Sendable (_ content: Foundation.Data, _ vlanTag: Swift.UInt16, _ localAddress: Network.NWEthernetChannel.EthernetAddress, _ remoteAddress: Network.NWEthernetChannel.EthernetAddress) -> Swift.Void)? {
    get
    set
  }
  #endif
  @objc deinit
}
@available(macOS 14.0, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Network.NWEthernetChannel : Swift.Sendable {
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network13_NWProtocolIP) public class NWProtocolIP : Network.NWProtocol {
  public static let definition: Network.NWProtocolDefinition
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network13_NWProtocolIP7Options) public class Options : Network.NWProtocolOptions {
    public enum Version {
      case any
      case v4
      case v6
      public static func == (a: Network.NWProtocolIP.Options.Version, b: Network.NWProtocolIP.Options.Version) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public var version: Network.NWProtocolIP.Options.Version {
      get
      set
    }
    public var hopLimit: Swift.UInt8 {
      get
      set
    }
    public var useMinimumMTU: Swift.Bool {
      get
      set
    }
    public var disableFragmentation: Swift.Bool {
      get
      set
    }
    public var shouldCalculateReceiveTime: Swift.Bool {
      get
      set
    }
    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    public enum AddressPreference {
      case `default`
      case temporary
      case stable
      public static func == (a: Network.NWProtocolIP.Options.AddressPreference, b: Network.NWProtocolIP.Options.AddressPreference) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    public var localAddressPreference: Network.NWProtocolIP.Options.AddressPreference {
      get
      set
    }
    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    public var disableMulticastLoopback: Swift.Bool {
      get
      set
    }
    @objc deinit
  }
  public enum ECN {
    case nonECT
    case ect0
    case ect1
    case ce
    public static func == (a: Network.NWProtocolIP.ECN, b: Network.NWProtocolIP.ECN) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network13_NWProtocolIP8Metadata) public class Metadata : Network.NWProtocolMetadata {
    public var ecn: Network.NWProtocolIP.ECN {
      get
      set
    }
    public var serviceClass: Network.NWParameters.ServiceClass {
      get
      set
    }
    public var receiveTime: Swift.UInt64 {
      get
    }
    public init()
    @objc deinit
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
final public class NetworkListener<ApplicationProtocol> : Swift.Sendable, Swift.CustomDebugStringConvertible where ApplicationProtocol : Network.NetworkProtocolOptions {
  public enum State : Swift.Equatable, Swift.Sendable {
    case setup
    case waiting(Network.NWError)
    case ready
    case failed(Network.NWError)
    case cancelled
    public static func == (a: Network.NetworkListener<ApplicationProtocol>.State, b: Network.NetworkListener<ApplicationProtocol>.State) -> Swift.Bool
  }
  public enum ServiceRegistrationChange : Swift.Sendable {
    case add(Network.NWEndpoint)
    case remove(Network.NWEndpoint)
  }
  #if compiler(>=5.3) && $IsolatedAny
  public typealias StateUpdateHandler = @isolated(any) @Sendable (_ listener: Network.NetworkListener<ApplicationProtocol>, _ state: Network.NetworkListener<ApplicationProtocol>.State) -> Swift.Void
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  public typealias ServiceRegistrationUpdateHandler = @isolated(any) @Sendable (_ listener: Network.NetworkListener<ApplicationProtocol>, _ change: Network.NetworkListener<ApplicationProtocol>.ServiceRegistrationChange) -> Swift.Void
  #endif
  final public var debugDescription: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(for provider: (any Network.ListenerProvider)? = nil, @Network.ProtocolStackBuilder<ApplicationProtocol> using builder: () -> ApplicationProtocol) throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(for provider: (any Network.ListenerProvider)? = nil, using builder: Network.NWParametersBuilder<ApplicationProtocol>) throws
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @discardableResult
  final public func onStateUpdate(@_inheritActorContext _ handler: @escaping @isolated(any) @Sendable (_ listener: Network.NetworkListener<ApplicationProtocol>, _ state: Network.NetworkListener<ApplicationProtocol>.State) -> Swift.Void) -> Self
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @discardableResult
  final public func onServiceRegistrationUpdate(@_inheritActorContext _ handler: @escaping @isolated(any) @Sendable (_ listener: Network.NetworkListener<ApplicationProtocol>, _ change: Network.NetworkListener<ApplicationProtocol>.ServiceRegistrationChange) -> Swift.Void) -> Self
  #endif
  final public func newConnectionLimit(_ limit: Swift.Int) -> Self
  final public var newConnectionLimit: Swift.Int {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var service: Network.NWListener.Service? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var port: Network.NWEndpoint.Port? {
    get
  }
  #endif
  @objc deinit
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NetworkListener where ApplicationProtocol : Network.OneToOneProtocol {
  #if compiler(>=5.3) && $IsolatedAny
  final public func run(@_inheritActorContext _ handler: @escaping @isolated(any) @Sendable (Network.NetworkConnection<ApplicationProtocol>) async throws -> Swift.Void) async throws
  #endif
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NetworkListener where ApplicationProtocol : Network.MultiplexProtocol {
  #if compiler(>=5.3) && $IsolatedAny
  final public func run(@_inheritActorContext _ handler: @escaping @isolated(any) @Sendable (Network.NetworkConnection<ApplicationProtocol>) async throws -> Swift.Void) async throws
  #endif
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol ListenerProvider {
  var service: Network.NWListener.Service { get }
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct BonjourListenerProvider : Network.ListenerProvider {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(name: Swift.String? = nil, type: Swift.String, domain: Swift.String? = nil, txtRecord: Network.NWTXTRecord? = nil)
  #endif
  public var service: Network.NWListener.Service {
    get
  }
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.ListenerProvider where Self == Network.BonjourListenerProvider {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func bonjour(name: Swift.String? = nil, type: Swift.String, domain: Swift.String? = nil, txtRecord: Network.NWTXTRecord? = nil) -> Network.BonjourListenerProvider
  #endif
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network21_NWProtocolDefinition) public class NWProtocolDefinition : Swift.Equatable, Swift.CustomDebugStringConvertible, @unchecked Swift.Sendable {
  public static func == (lhs: Network.NWProtocolDefinition, rhs: Network.NWProtocolDefinition) -> Swift.Bool
  final public let name: Swift.String
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network18_NWProtocolOptions) public class NWProtocolOptions : @unchecked Swift.Sendable {
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network19_NWProtocolMetadata) public class NWProtocolMetadata : @unchecked Swift.Sendable {
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network11_NWProtocol) public class NWProtocol : @unchecked Swift.Sendable {
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public class NWProtocolFramer : Network.NWProtocol {
  @_hasMissingDesignatedInitializers public class Definition : Network.NWProtocolDefinition {
    public init(implementation: any Network.NWProtocolFramerImplementation.Type)
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Options : Network.NWProtocolOptions {
    public init(definition: Network.NWProtocolFramer.Definition)
    #if compiler(>=5.3) && $NonescapableTypes
    @available(macOS 12.3, iOS 15.4, watchOS 8.4, tvOS 15.4, *)
    public subscript(key: Swift.String) -> Any? {
      get
      set(value)
    }
    #endif
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Message : Network.NWProtocolMetadata {
    public init(definition: Network.NWProtocolFramer.Definition)
    public init(instance: Network.NWProtocolFramer.Instance)
    #if compiler(>=5.3) && $NonescapableTypes
    public subscript(key: Swift.String) -> Any? {
      get
      set(value)
    }
    #endif
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class Instance : Swift.CustomDebugStringConvertible, Swift.Sendable {
    final public var debugDescription: Swift.String {
      get
    }
    final public func markReady()
    #if compiler(>=5.3) && $NonescapableTypes
    final public func markFailed(error: Network.NWError?)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    final public func parseInput(minimumIncompleteLength: Swift.Int, maximumLength: Swift.Int, parse: (_ buffer: Swift.UnsafeMutableRawBufferPointer?, _ isComplete: Swift.Bool) -> Swift.Int) -> Swift.Bool
    #endif
    final public func deliverInput(data: Foundation.Data, message: Network.NWProtocolFramer.Message, isComplete: Swift.Bool)
    final public func deliverInputNoCopy(length: Swift.Int, message: Network.NWProtocolFramer.Message, isComplete: Swift.Bool) -> Swift.Bool
    final public func passThroughInput()
    #if compiler(>=5.3) && $NonescapableTypes
    final public func parseOutput(minimumIncompleteLength: Swift.Int, maximumLength: Swift.Int, parse: (_ buffer: Swift.UnsafeMutableRawBufferPointer?, _ isComplete: Swift.Bool) -> Swift.Int) -> Swift.Bool
    #endif
    final public func writeOutput(data: Foundation.Data)
    @usableFromInline
    final internal func writeOutput(discontiguousData: Dispatch.DispatchData)
    @inlinable final public func writeOutput<Output>(data: Output) where Output : Foundation.DataProtocol {
			if let dispatchData = data as? DispatchData {
				writeOutput(discontiguousData: dispatchData)
			} else if let data = data as? Data {
				writeOutput(data: data)
			} else {
				writeOutput(data: Data(data))
			}
		}
    final public func writeOutputNoCopy(length: Swift.Int) throws
    final public func passThroughOutput()
    public enum WakeupTime {
      case milliseconds(Swift.UInt64)
      case forever
    }
    final public func scheduleWakeup(wakeupTime: Network.NWProtocolFramer.Instance.WakeupTime)
    final public func async(execute: @escaping () -> Swift.Void)
    #if compiler(>=5.3) && $NonescapableTypes
    final public var remote: Network.NWEndpoint? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    final public var local: Network.NWEndpoint? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    final public var parameters: Network.NWParameters? {
      get
    }
    #endif
    @available(macOS 12.3, iOS 15.4, watchOS 8.4, tvOS 15.4, *)
    final public var options: Network.NWProtocolFramer.Options {
      get
    }
    final public func prependApplicationProtocol(options: Network.NWProtocolOptions) throws
    @objc deinit
  }
  public enum StartResult {
    case ready
    case willMarkReady
    public static func == (a: Network.NWProtocolFramer.StartResult, b: Network.NWProtocolFramer.StartResult) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public protocol NWProtocolFramerImplementation : AnyObject {
  static var label: Swift.String { get }
  init(framer: Network.NWProtocolFramer.Instance)
  func start(framer: Network.NWProtocolFramer.Instance) -> Network.NWProtocolFramer.StartResult
  func handleInput(framer: Network.NWProtocolFramer.Instance) -> Swift.Int
  func handleOutput(framer: Network.NWProtocolFramer.Instance, message: Network.NWProtocolFramer.Message, messageLength: Swift.Int, isComplete: Swift.Bool)
  func wakeup(framer: Network.NWProtocolFramer.Instance)
  func stop(framer: Network.NWProtocolFramer.Instance) -> Swift.Bool
  func cleanup(framer: Network.NWProtocolFramer.Instance)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network14_NWProtocolUDP) public class NWProtocolUDP : Network.NWProtocol {
  public static let definition: Network.NWProtocolDefinition
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network14_NWProtocolUDP7Options) public class Options : Network.NWProtocolOptions {
    public var preferNoChecksum: Swift.Bool {
      get
      set
    }
    public init()
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network14_NWProtocolUDP8Metadata) public class Metadata : Network.NWProtocolMetadata {
    public init()
    @objc deinit
  }
  @objc deinit
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol NetworkFixedWidthInteger : Swift.FixedWidthInteger {
  init(bigEndian: Self)
  var bigEndian: Self { get }
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Swift.UInt8 : Network.NetworkFixedWidthInteger {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Swift.UInt16 : Network.NetworkFixedWidthInteger {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Swift.UInt32 : Network.NetworkFixedWidthInteger {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Swift.UInt64 : Network.NetworkFixedWidthInteger {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Swift.Int8 : Network.NetworkFixedWidthInteger {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Swift.Int16 : Network.NetworkFixedWidthInteger {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Swift.Int32 : Network.NetworkFixedWidthInteger {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Swift.Int64 : Network.NetworkFixedWidthInteger {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol NetworkMetadataProtocol {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol NetworkProtocolOptions {
  associatedtype BelowProtocol
  associatedtype ProtocolStorage : Network.ConnectionStorage = Network.DefaultProtocolStorage
  associatedtype Metadata : Network.NetworkMetadataProtocol
  typealias Message<T> = (content: T, metadata: Self.Metadata)
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol ConnectionStorage {
  init()
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct DefaultProtocolStorage : Network.ConnectionStorage, Swift.Sendable {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol OneToOneProtocol : Network.NetworkProtocolOptions {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol MultiplexProtocol : Network.NetworkProtocolOptions {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol StreamProtocol : Network.OneToOneProtocol {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol MessageProtocol : Network.OneToOneProtocol {
  associatedtype LegacyMessage
  associatedtype ContentType
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol DatagramProtocol : Network.MessageProtocol {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
@_functionBuilder public struct ProtocolStackBuilder<ApplicationProtocol, each P> where ApplicationProtocol : Network.NetworkProtocolOptions, repeat each P : Network.NetworkProtocolOptions {
  public static func buildBlock(_ applicationProtocol: ApplicationProtocol, _ belowProtocols: repeat each P) -> (ApplicationProtocol, repeat each P)
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
@_functionBuilder public struct ProtocolMetadataBuilder {
  public static func buildBlock(_ metadata: Network.NWProtocolMetadata...) -> [Network.NWProtocolMetadata]
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol NWParametersProvider {
  var parameters: Network.NWParameters { get }
  func requiredInterface(_ interface: Network.NWInterface) -> Self
  func requiredInterfaceType(_ type: Network.NWInterface.InterfaceType) -> Self
  func prohibitedInterfaces(_ interfaces: [Network.NWInterface]) -> Self
  func prohibitedInterfaceTypes(_ types: [Network.NWInterface.InterfaceType]) -> Self
  func expensivePathsProhibited(_ prohibited: Swift.Bool) -> Self
  func constrainedPathsProhibited(_ prohibited: Swift.Bool) -> Self
  func noProxiesPreferred(_ preferred: Swift.Bool) -> Self
  #if compiler(>=5.3) && $NonescapableTypes
  func localEndpoint(_ endpoint: Network.NWEndpoint?) -> Self
  #endif
  func localPort(_ port: Network.NWEndpoint.Port) -> Self
  func localEndpointReuseAllowed(_ allowed: Swift.Bool) -> Self
  func localOnly(_ local: Swift.Bool) -> Self
  func peerToPeerIncluded(_ included: Swift.Bool) -> Self
  func dnssecValidationRequired(_ required: Swift.Bool) -> Self
  func serviceClass(_ serviceClass: Network.NWParameters.ServiceClass) -> Self
  func multipathServiceType(_ type: Network.NWParameters.MultipathServiceType) -> Self
  func fastOpenAllowed(_ allowed: Swift.Bool) -> Self
  func expiredDNSBehavior(_ behavior: Network.NWParameters.ExpiredDNSBehavior) -> Self
  func ultraConstrainedPathsAllowed(_ allowed: Swift.Bool) -> Self
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NWParametersProvider {
  public func requiredInterface(_ interface: Network.NWInterface) -> Self
  public func requiredInterfaceType(_ type: Network.NWInterface.InterfaceType) -> Self
  public func prohibitedInterfaces(_ interfaces: [Network.NWInterface]) -> Self
  public func prohibitedInterfaceTypes(_ types: [Network.NWInterface.InterfaceType]) -> Self
  public func expensivePathsProhibited(_ prohibited: Swift.Bool) -> Self
  public func constrainedPathsProhibited(_ prohibited: Swift.Bool) -> Self
  public func noProxiesPreferred(_ noProxies: Swift.Bool) -> Self
  #if compiler(>=5.3) && $NonescapableTypes
  public func localEndpoint(_ endpoint: Network.NWEndpoint?) -> Self
  #endif
  public func localPort(_ port: Network.NWEndpoint.Port) -> Self
  public func localEndpointReuseAllowed(_ allowed: Swift.Bool) -> Self
  public func localOnly(_ local: Swift.Bool) -> Self
  public func peerToPeerIncluded(_ included: Swift.Bool) -> Self
  public func dnssecValidationRequired(_ required: Swift.Bool) -> Self
  public func serviceClass(_ serviceClass: Network.NWParameters.ServiceClass) -> Self
  public func multipathServiceType(_ type: Network.NWParameters.MultipathServiceType) -> Self
  public func fastOpenAllowed(_ allowed: Swift.Bool) -> Self
  public func expiredDNSBehavior(_ behavior: Network.NWParameters.ExpiredDNSBehavior) -> Self
  public func ultraConstrainedPathsAllowed(_ val: Swift.Bool) -> Self
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NWParameters : Network.NWParametersProvider {
  @available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
  final public var parameters: Network.NWParameters {
    get
  }
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct QUICDatagram : Network.DatagramProtocol {
  public struct Metadata : Network.NetworkMetadataProtocol {
    public let other: [Network.NWProtocolMetadata]
  }
  public typealias ContentType = Foundation.Data
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias BelowProtocol = Swift.Void
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias LegacyMessage = (content: Foundation.Data, metadata: [Network.NWProtocolMetadata]?)
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias ProtocolStorage = Network.DefaultProtocolStorage
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct TLS : Network.StreamProtocol {
  public struct Metadata : Network.NetworkMetadataProtocol {
    public let endOfStream: Swift.Bool
    public let other: [Network.NWProtocolMetadata]
  }
  public init()
  public init(@Network.ProtocolStackBuilder<Network.TCP> _ builder: () -> Network.TCP)
  public func localIdentity(_ identity: Security.sec_identity_t) -> Network.TLS
  #if compiler(>=5.3) && $IsolatedAny
  public func certificateValidator(@_inheritActorContext _ handler: @escaping @isolated(any) @Sendable (Security.sec_protocol_metadata_t, Security.sec_trust_t) async -> Swift.Bool) -> Network.TLS
  #endif
  public enum PeerAuthentication {
    case none
    case optional
    case required
    public static func == (a: Network.TLS.PeerAuthentication, b: Network.TLS.PeerAuthentication) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public func peerAuthentication(_ preference: Network.TLS.PeerAuthentication) -> Network.TLS
  public func applicationProtocols(_ protocols: [Swift.String]) -> Network.TLS
  public func cipherSuites(_ suites: [Security.tls_ciphersuite_t]) -> Network.TLS
  public func cipherSuiteGroups(_ groups: [Security.tls_ciphersuite_group_t]) -> Network.TLS
  public func earlyDataEnabled(_ enabled: Swift.Bool) -> Network.TLS
  public func ticketsEnabled(_ enabled: Swift.Bool) -> Network.TLS
  #if compiler(>=5.3) && $NonescapableTypes
  public func version(min: Security.tls_protocol_version_t? = nil, max: Security.tls_protocol_version_t? = nil) -> Network.TLS
  #endif
  @available(*, unavailable, message: "Pass a minimum or maximum version")
  public func version() -> Network.TLS
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias BelowProtocol = Network.TCP
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias ProtocolStorage = Network.DefaultProtocolStorage
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct TCP : Network.StreamProtocol {
  public struct Metadata : Network.NetworkMetadataProtocol {
    public let endOfStream: Swift.Bool
    public let other: [Network.NWProtocolMetadata]
  }
  public init()
  public init(@Network.ProtocolStackBuilder<Network.IP> _ builder: () -> Network.IP)
  public func noDelay(_ noDelay: Swift.Bool) -> Network.TCP
  public func noPush(_ noPush: Swift.Bool) -> Network.TCP
  public func noOptions(_ noOptions: Swift.Bool) -> Network.TCP
  public func keepalive(idleTimeInSeconds: Swift.UInt32, count: Swift.UInt32, intervalInSeconds: Swift.UInt32) -> Network.TCP
  public func maximumSegmentSize(_ bytes: Swift.UInt32) -> Network.TCP
  public func connectionTimeout(_ timeout: Swift.UInt32) -> Network.TCP
  public func persistTimeout(_ timeout: Swift.UInt32) -> Network.TCP
  public func retransmitConnectionDropTime(_ timeout: Swift.UInt32) -> Network.TCP
  public func retransmitFinDrop(_ drop: Swift.Bool) -> Network.TCP
  public func ackStretchingDisabled(_ disableAckStretching: Swift.Bool) -> Network.TCP
  public func ecnDisabled(_ disableECN: Swift.Bool) -> Network.TCP
  public func fastOpenAllowed(_ allowed: Swift.Bool) -> Network.TCP
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias BelowProtocol = Network.IP
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias ProtocolStorage = Network.DefaultProtocolStorage
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct QUIC : Network.MultiplexProtocol {
  public struct Metadata : Network.NetworkMetadataProtocol {
  }
  public init(alpn: [Swift.String])
  public init(alpn: [Swift.String], @Network.ProtocolStackBuilder<Network.UDP> _ builder: () -> Network.UDP)
  public struct ProtocolStorage : Network.ConnectionStorage {
    public init()
  }
  public func idleTimeout(_ timeout: Swift.Int) -> Network.QUIC
  public func maxUDPPayloadSize(_ size: Swift.Int) -> Network.QUIC
  public func initialMaxData(_ initialMaxData: Swift.Int) -> Network.QUIC
  public func initialMaxStreamDataBidirectionalRemote(_ initialMaxStreamDataBidiRemote: Swift.Int) -> Network.QUIC
  public func initialMaxStreamDataBidirectionalLocal(_ initialMaxStreamDataBidiLocal: Swift.Int) -> Network.QUIC
  public func initialMaxStreamDataUnidirectional(_ initialMaxStreamDataUni: Swift.Int) -> Network.QUIC
  public func initialMaxBidirectionalStreams(_ initialMaxStreamsBidi: Swift.Int) -> Network.QUIC
  public func initialMaxUnidirectionalStreams(_ initialMaxStreamDataUni: Swift.Int) -> Network.QUIC
  public func maxDatagramFrameSize(_ size: Swift.Int) -> Network.QUIC
  public var tls: Network.QUIC.TLS {
    get
  }
  public struct TLS {
    public func localIdentity(_ identity: Security.sec_identity_t) -> Network.QUIC
    #if compiler(>=5.3) && $IsolatedAny
    public func certificateValidator(@_inheritActorContext _ handler: @escaping @isolated(any) @Sendable (Security.sec_protocol_metadata_t, Security.sec_trust_t) async -> Swift.Bool) -> Network.QUIC
    #endif
    public func peerAuthentication(_ preference: Network.TLS.PeerAuthentication) -> Network.QUIC
    public func cipherSuites(_ suites: [Security.tls_ciphersuite_t]) -> Network.QUIC
    public func ciphersuiteGroups(_ groups: [Security.tls_ciphersuite_group_t]) -> Network.QUIC
  }
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias BelowProtocol = Network.UDP
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct QUICStream : Network.StreamProtocol {
  public struct Metadata : Network.NetworkMetadataProtocol {
    public let endOfStream: Swift.Bool
    public let other: [Network.NWProtocolMetadata]
  }
  public enum Directionality : Swift.Equatable {
    case unidirectional
    case bidirectional
    public static func == (a: Network.QUICStream.Directionality, b: Network.QUICStream.Directionality) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Initiator : Swift.Equatable {
    case client
    case server
    public static func == (a: Network.QUICStream.Initiator, b: Network.QUICStream.Initiator) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias BelowProtocol = Swift.Void
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias ProtocolStorage = Network.DefaultProtocolStorage
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct UDP : Network.DatagramProtocol {
  public struct Metadata : Network.NetworkMetadataProtocol {
    public let other: [Network.NWProtocolMetadata]
  }
  public typealias ContentType = Foundation.Data
  public init()
  public init(@Network.ProtocolStackBuilder<Network.IP> _ builder: () -> Network.IP)
  public func noChecksumPreferred(_ noChecksum: Swift.Bool) -> Network.UDP
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias BelowProtocol = Network.IP
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias LegacyMessage = (content: Foundation.Data, metadata: [Network.NWProtocolMetadata]?)
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias ProtocolStorage = Network.DefaultProtocolStorage
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct IP : Network.NetworkProtocolOptions {
  public struct Metadata : Network.NetworkMetadataProtocol {
    public let other: [Network.NWProtocolMetadata]
  }
  public init()
  public func version(_ version: Network.NWProtocolIP.Options.Version) -> Network.IP
  public func hopLimit(_ limit: Swift.UInt8) -> Network.IP
  public func minimumMTU(_ useMinimumMTU: Swift.Bool) -> Network.IP
  public func fragmentationDisabled(_ dontFragment: Swift.Bool) -> Network.IP
  public func receiveTimeCalculated(_ calculateReceiveTime: Swift.Bool) -> Network.IP
  public func localAddressPreference(_ preference: Network.NWProtocolIP.Options.AddressPreference) -> Network.IP
  public func multicastLoopbackDisabled(_ disableMulticastLoopback: Swift.Bool) -> Network.IP
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias BelowProtocol = Swift.Void
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias ProtocolStorage = Network.DefaultProtocolStorage
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct TLV : Network.MessageProtocol {
  public struct Metadata : Network.NetworkMetadataProtocol {
    public let type: Swift.Int
    public let length: Swift.Int
    public let isComplete: Swift.Bool
    public let lastMessage: Swift.Bool
    public let other: [Network.NWProtocolMetadata]
  }
  public init<BelowProtocol>(@Network.ProtocolStackBuilder<BelowProtocol> _ builder: () -> BelowProtocol) where BelowProtocol : Network.StreamProtocol
  public init<BelowProtocol>(@Network.ProtocolStackBuilder<BelowProtocol> _ builder: () -> BelowProtocol) where BelowProtocol : Network.MessageProtocol
  public init<T, L, BelowProtocol>(type: T.Type, length: L.Type, @Network.ProtocolStackBuilder<BelowProtocol> _ builder: () -> BelowProtocol) where T : Swift.Sendable, T : Swift.UnsignedInteger, L : Swift.Sendable, L : Swift.UnsignedInteger, BelowProtocol : Network.StreamProtocol
  public init<T, L, BelowProtocol>(type: T.Type, length: L.Type, @Network.ProtocolStackBuilder<BelowProtocol> _ builder: () -> BelowProtocol) where T : Swift.Sendable, T : Swift.UnsignedInteger, L : Swift.Sendable, L : Swift.UnsignedInteger, BelowProtocol : Network.MessageProtocol
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias BelowProtocol = any Network.NetworkProtocolOptions
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias ContentType = Foundation.Data
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias LegacyMessage = (type: Swift.Int, content: Foundation.Data, metadata: [Network.NWProtocolMetadata]?, isFinal: Swift.Bool)
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias ProtocolStorage = Network.DefaultProtocolStorage
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct Coder<Sending, Receiving, CoderType> : Network.MessageProtocol where Sending : Swift.Encodable, Receiving : Swift.Decodable, CoderType : Network.NetworkCoder {
  public struct Metadata : Network.NetworkMetadataProtocol {
    public let isComplete: Swift.Bool
    public let lastMessage: Swift.Bool
    public let other: [Network.NWProtocolMetadata]
  }
  public typealias ContentType = Receiving
  public init<BelowProtocol>(sending: Sending.Type, receiving: Receiving.Type, using: CoderType, @Network.ProtocolStackBuilder<BelowProtocol> _ builder: () -> BelowProtocol) where BelowProtocol : Network.StreamProtocol
  public init<BelowProtocol>(sending: Sending.Type, receiving: Receiving.Type, using: CoderType, @Network.ProtocolStackBuilder<BelowProtocol> _ builder: () -> BelowProtocol) where BelowProtocol : Network.DatagramProtocol
  public init<BelowProtocol>(receiving: Receiving.Type, sending: Sending.Type, using: CoderType, @Network.ProtocolStackBuilder<BelowProtocol> _ builder: () -> BelowProtocol) where BelowProtocol : Network.StreamProtocol
  public init<BelowProtocol>(receiving: Receiving.Type, sending: Sending.Type, using: CoderType, @Network.ProtocolStackBuilder<BelowProtocol> _ builder: () -> BelowProtocol) where BelowProtocol : Network.DatagramProtocol
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias BelowProtocol = any Network.NetworkProtocolOptions
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias LegacyMessage = (content: Network.Coder<Sending, Receiving, CoderType>.ContentType, metadata: [Network.NWProtocolMetadata]?, isFinal: Swift.Bool)
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias ProtocolStorage = Network.DefaultProtocolStorage
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.Coder where Sending : Swift.Decodable, Sending == Receiving {
  public init<BelowProtocol>(_ type: Sending.Type, using: CoderType, @Network.ProtocolStackBuilder<BelowProtocol> _ builder: () -> BelowProtocol) where BelowProtocol : Network.StreamProtocol
  public init<BelowProtocol>(_ type: Sending.Type, using: CoderType, @Network.ProtocolStackBuilder<BelowProtocol> _ builder: () -> BelowProtocol) where BelowProtocol : Network.DatagramProtocol
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct WebSocket : Network.MessageProtocol {
  public struct Metadata : Network.NetworkMetadataProtocol {
    public let opcode: Network.NWProtocolWebSocket.Opcode
    public let closeCode: Network.NWProtocolWebSocket.CloseCode?
    public let isComplete: Swift.Bool
    public let lastMessage: Swift.Bool
    public let other: [Network.NWProtocolMetadata]
  }
  public init<BelowProtocol>(@Network.ProtocolStackBuilder<BelowProtocol> _ builder: () -> BelowProtocol) where BelowProtocol : Network.StreamProtocol
  public init<BelowProtocol>(@Network.ProtocolStackBuilder<BelowProtocol> _ builder: () -> BelowProtocol) where BelowProtocol : Network.MessageProtocol
  public func additionalHeaders(_ headers: [(name: Swift.String, value: Swift.String)]) -> Network.WebSocket
  public func subprotocols(_ subprotocols: [Swift.String]) -> Network.WebSocket
  public func autoReplyPing(_ reply: Swift.Bool) -> Network.WebSocket
  public func skipHandshake(_ skip: Swift.Bool) -> Network.WebSocket
  public func maximumMessageSize(_ size: Swift.Int) -> Network.WebSocket
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias BelowProtocol = any Network.NetworkProtocolOptions
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias ContentType = Foundation.Data
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias LegacyMessage = (type: Network.NWProtocolWebSocket.Opcode, content: Foundation.Data, metadata: [Network.NWProtocolMetadata]?, isFinal: Swift.Bool)
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias ProtocolStorage = Network.DefaultProtocolStorage
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol FramerProtocol {
  static var definition: Network.NWProtocolFramer.Definition { get }
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct Framer<T> : Network.MessageProtocol where T : Network.FramerProtocol {
  public struct Metadata : Network.NetworkMetadataProtocol {
    public let framer: Network.NWProtocolFramer.Message
    public let isComplete: Swift.Bool
    public let lastMessage: Swift.Bool
    public let other: [Network.NWProtocolMetadata]
    #if compiler(>=5.3) && $NonescapableTypes
    public init(framer: Network.NWProtocolFramer.Message, isComplete: Swift.Bool, lastMessage: Swift.Bool, other: [Network.NWProtocolMetadata]?)
    #endif
  }
  public typealias ContentType = Foundation.Data
  public var options: Network.NWProtocolFramer.Options
  public init<BelowProtocol>(@Network.ProtocolStackBuilder<BelowProtocol> _ builder: () -> BelowProtocol) where BelowProtocol : Network.StreamProtocol
  public init<BelowProtocol>(@Network.ProtocolStackBuilder<BelowProtocol> _ builder: () -> BelowProtocol) where BelowProtocol : Network.MessageProtocol
  public init<BelowProtocol>(using framer: T.Type, @Network.ProtocolStackBuilder<BelowProtocol> _ builder: () -> BelowProtocol) where BelowProtocol : Network.StreamProtocol
  public init<BelowProtocol>(using framer: T.Type, @Network.ProtocolStackBuilder<BelowProtocol> _ builder: () -> BelowProtocol) where BelowProtocol : Network.MessageProtocol
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias BelowProtocol = any Network.NetworkProtocolOptions
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias LegacyMessage = (Foundation.Data, Network.Framer<T>.Metadata)
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias ProtocolStorage = Network.DefaultProtocolStorage
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol NetworkEncoder {
  func encode<T>(_ value: T) throws -> Foundation.Data where T : Swift.Encodable
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Foundation.JSONEncoder : Network.NetworkEncoder {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Foundation.PropertyListEncoder : Network.NetworkEncoder {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol NetworkDecoder {
  func decode<T>(_ type: T.Type, from data: Foundation.Data) throws -> T where T : Swift.Decodable
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Foundation.JSONDecoder : Network.NetworkDecoder {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Foundation.PropertyListDecoder : Network.NetworkDecoder {
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public protocol NetworkCoder : Swift.Sendable {
  associatedtype Encoder : Network.NetworkEncoder
  associatedtype Decoder : Network.NetworkDecoder
  init()
  func makeEncoder() -> Self.Encoder
  func makeDecoder() -> Self.Decoder
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NetworkCoder where Self == Network.NetworkJSONCoder {
  public static var json: Network.NetworkJSONCoder {
    get
  }
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NetworkCoder where Self == Network.NetworkPropertyListCoder {
  public static var propertyList: Network.NetworkPropertyListCoder {
    get
  }
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct NetworkJSONCoder : Network.NetworkCoder {
  public init()
  public func makeEncoder() -> Foundation.JSONEncoder
  public func makeDecoder() -> Foundation.JSONDecoder
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias Decoder = Foundation.JSONDecoder
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias Encoder = Foundation.JSONEncoder
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct NetworkPropertyListCoder : Network.NetworkCoder {
  public init()
  public func makeEncoder() -> Foundation.PropertyListEncoder
  public func makeDecoder() -> Foundation.PropertyListDecoder
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias Decoder = Foundation.PropertyListDecoder
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias Encoder = Foundation.PropertyListEncoder
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct NWParametersBuilder<Top, each P> : Network.NWParametersProvider where Top : Network.NetworkProtocolOptions, repeat each P : Network.NetworkProtocolOptions {
  public var parameters: Network.NWParameters
  public static func parameters(@Network.ProtocolStackBuilder<Top, repeat each P> _ builder: () -> (Top, repeat each P)) -> Network.NWParametersBuilder<Top, repeat each P>
  public static func parameters(initialParameters: Network.NWParameters, @Network.ProtocolStackBuilder<Top, repeat each P> _ builder: () -> (Top, repeat each P)) -> Network.NWParametersBuilder<Top, repeat each P>
  public init(auto: () -> (Top, repeat each P))
  public init(@Network.ProtocolStackBuilder<Top, repeat each P> _ builder: () -> (Top, repeat each P))
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NWProtocolIP.Metadata {
  @available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func ecn(_ ecn: Network.NWProtocolIP.ECN) -> Self
  @available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func serviceClass(_ serviceClass: Network.NWParameters.ServiceClass) -> Self
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
final public class NetworkConnection<ApplicationProtocol> : Network.NetworkChannel<ApplicationProtocol>, @unchecked Swift.Sendable where ApplicationProtocol : Network.NetworkProtocolOptions {
  #if compiler(>=5.3) && $NonescapableTypes
  final public var currentPath: Network.NWPath? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var localEndpoint: Network.NWEndpoint? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var remoteEndpoint: Network.NWEndpoint? {
    get
  }
  #endif
  final public func tryNextEndpoint()
  #if compiler(>=5.3) && $IsolatedAny
  @discardableResult
  final public func onStateUpdate(@_inheritActorContext _ handler: @escaping @isolated(any) @Sendable (_ connection: Network.NetworkConnection<ApplicationProtocol>, _ state: Network.NetworkChannel<ApplicationProtocol>.State) -> Swift.Void) -> Self
  #endif
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public class NetworkChannel<ApplicationProtocol> : Swift.CustomDebugStringConvertible, @unchecked Swift.Sendable where ApplicationProtocol : Network.NetworkProtocolOptions {
  public enum State : Swift.Equatable, Swift.Sendable {
    case setup
    case waiting(Network.NWError)
    case preparing
    case ready
    case failed(Network.NWError)
    case cancelled
    public static func == (a: Network.NetworkChannel<ApplicationProtocol>.State, b: Network.NetworkChannel<ApplicationProtocol>.State) -> Swift.Bool
  }
  public static func == (lhs: Network.NetworkChannel<ApplicationProtocol>, rhs: Network.NetworkChannel<ApplicationProtocol>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var id: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var state: Network.NetworkChannel<ApplicationProtocol>.State {
    get
  }
  public var maximumDatagramSize: Swift.Int {
    get
  }
  public var parameters: Network.NWParameters {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public func metadata(definition: Network.NWProtocolDefinition) -> Network.NWProtocolMetadata?
  #endif
  public func establishmentReport() async throws -> Network.NWConnection.EstablishmentReport
  public func dataTransferReport() async throws -> Network.NWConnection.DataTransferReport
  @objc deinit
}
@available(macOS 26.1, iOS 26.1, watchOS 26.1, tvOS 26.1, visionOS 26.1, *)
extension Network.NetworkChannel : Swift.Identifiable, Swift.Hashable {
  @available(iOS 26.1, tvOS 26.1, watchOS 26.1, visionOS 26.1, macOS 26.1, *)
  public typealias ID = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NetworkConnection where ApplicationProtocol : Network.OneToOneProtocol {
  convenience public init(to endpoint: Network.NWEndpoint, @Network.ProtocolStackBuilder<ApplicationProtocol> using builder: () -> ApplicationProtocol)
  convenience public init(to provider: any Network.Connectable, @Network.ProtocolStackBuilder<ApplicationProtocol> using builder: () -> ApplicationProtocol)
  convenience public init(to endpoint: Network.NWEndpoint, using builder: Network.NWParametersBuilder<ApplicationProtocol>)
  convenience public init(to provider: any Network.Connectable, using builder: Network.NWParametersBuilder<ApplicationProtocol>)
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NetworkConnection where ApplicationProtocol : Network.MultiplexProtocol {
  convenience public init(to endpoint: Network.NWEndpoint, @Network.ProtocolStackBuilder<ApplicationProtocol> using builder: () -> ApplicationProtocol)
  convenience public init(to provider: any Network.Connectable, @Network.ProtocolStackBuilder<ApplicationProtocol> using builder: () -> ApplicationProtocol)
  convenience public init(to endpoint: Network.NWEndpoint, using builder: Network.NWParametersBuilder<ApplicationProtocol>)
  convenience public init(to provider: any Network.Connectable, using builder: Network.NWParametersBuilder<ApplicationProtocol>)
  final public func start() -> Self
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NetworkConnection where ApplicationProtocol : Network.OneToOneProtocol {
  #if compiler(>=5.3) && $IsolatedAny
  @discardableResult
  final public func onPathUpdate(@_inheritActorContext _ handler: @escaping @isolated(any) @Sendable (_ connection: Network.NetworkConnection<ApplicationProtocol>, _ newPath: Network.NWPath) -> Swift.Void) -> Self
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @discardableResult
  final public func onViabilityUpdate(@_inheritActorContext _ handler: @escaping @isolated(any) @Sendable (_ connection: Network.NetworkConnection<ApplicationProtocol>, _ newViable: Swift.Bool) -> Swift.Void) -> Self
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  @discardableResult
  final public func onBetterPathUpdate(@_inheritActorContext _ handler: @escaping @isolated(any) @Sendable (_ connection: Network.NetworkConnection<ApplicationProtocol>, _ newValue: Swift.Bool) -> Swift.Void) -> Self
  #endif
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.QUIC {
  @_hasMissingDesignatedInitializers final public class Stream<ApplicationProtocol> : Network.NetworkChannel<ApplicationProtocol>, @unchecked Swift.Sendable where ApplicationProtocol : Network.NetworkProtocolOptions {
    final public let parent: Network.NetworkConnection<Network.QUIC>
    final public var streamID: Swift.UInt64 {
      get
    }
    final public var directionality: Network.QUICStream.Directionality {
      get
    }
    final public var initiator: Network.QUICStream.Initiator {
      get
    }
    final public var streamApplicationErrorCode: Swift.UInt64 {
      get
      set
    }
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class Datagrams<ApplicationProtocol> : Network.NetworkChannel<ApplicationProtocol>, @unchecked Swift.Sendable where ApplicationProtocol : Network.NetworkProtocolOptions {
    final public let parent: Network.NetworkConnection<Network.QUIC>
    @objc deinit
  }
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NetworkConnection where ApplicationProtocol == Network.QUIC {
  final public var securityProtocolMetadata: Security.sec_protocol_metadata_t {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var negotiatedALPN: Swift.String? {
    get
  }
  #endif
  final public var remoteIdleTimeout: Swift.Int {
    get
  }
  final public var applicationError: Network.NWProtocolQUIC.ApplicationError {
    get
    set
  }
  final public var remoteMaxStreamsUnidirectional: Swift.Int {
    get
  }
  final public var remoteMaxStreamsBidirectional: Swift.Int {
    get
  }
  final public var usableDatagramFrameSize: Swift.Int {
    get
  }
  final public var keepalive: Network.NWProtocolQUIC.Metadata.KeepAliveBehavior {
    get
    set
  }
  final public func openStream(directionality: Network.QUICStream.Directionality = .bidirectional) async throws -> Network.QUIC.Stream<Network.QUICStream>
  final public func openStream<NewApplicationProtocol>(directionality: Network.QUICStream.Directionality = .bidirectional, @Network.ProtocolStackBuilder<NewApplicationProtocol> _ prepending: (Network.QUICStream) -> NewApplicationProtocol) async throws -> Network.QUIC.Stream<NewApplicationProtocol> where NewApplicationProtocol : Network.OneToOneProtocol
  final public var datagrams: Network.QUIC.Datagrams<Network.QUICDatagram> {
    get async throws
  }
  #if compiler(>=5.3) && $IsolatedAny
  final public func inboundStreams(@_inheritActorContext _ handler: @escaping @isolated(any) @Sendable (Network.QUIC.Stream<Network.QUICStream>) async throws -> Swift.Void) async throws
  #endif
  #if compiler(>=5.3) && $IsolatedAny
  final public func inboundStreams<NewApplicationProtocol>(@Network.ProtocolStackBuilder<NewApplicationProtocol> prepending: @escaping (Network.QUICStream) -> NewApplicationProtocol, @_inheritActorContext _ handler: @escaping @isolated(any) @Sendable (Network.QUIC.Stream<NewApplicationProtocol>) async throws -> Swift.Void) async throws where NewApplicationProtocol : Network.OneToOneProtocol
  #endif
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NetworkChannel where ApplicationProtocol : Network.StreamProtocol {
  public func send<Content>(_ content: Content, endOfStream: Swift.Bool = false, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]}) async throws where Content : Foundation.DataProtocol
  public func send<Value>(_ value: Value, endOfStream: Swift.Bool = false, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]}) async throws where Value : Network.NetworkFixedWidthInteger
  public func sendIdempotent<Content>(_ content: Content, endOfStream: Swift.Bool = false, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]}) where Content : Foundation.DataProtocol
  public func sendIdempotent<Value>(_ value: Value, endOfStream: Swift.Bool = false, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]}) where Value : Network.NetworkFixedWidthInteger
  public func receive(atLeast: Swift.Int = 1, atMost: Swift.Int) async throws -> ApplicationProtocol.Message<Foundation.Data>
  public func receive(exactly: Swift.Int) async throws -> ApplicationProtocol.Message<Foundation.Data>
  public func receive<Value>(as type: Value.Type) async throws -> ApplicationProtocol.Message<Value> where Value : Network.NetworkFixedWidthInteger
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NetworkChannel where ApplicationProtocol : Network.DatagramProtocol {
  public func send<Content>(_ content: Content, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]}) async throws where Content : Foundation.DataProtocol
  public func receive() async throws -> ApplicationProtocol.Message<Foundation.Data>
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NetworkChannel where ApplicationProtocol == Network.WebSocket {
  public func send(_ content: Swift.String, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]}) async throws
  public func sendIdempotent(_ content: Swift.String, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]})
  public func send<Content>(_ content: Content, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]}) async throws where Content : Foundation.DataProtocol
  public func sendIdempotent<Content>(_ content: Content, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]}) where Content : Foundation.DataProtocol
  public func startSend(_ content: Swift.String, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]}, handler: (_ send: (_ content: Swift.String, _ isComplete: Swift.Bool) async throws -> Swift.Void) async throws -> Swift.Void) async throws
  public func startSend<Content>(_ content: Content, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]}, handler: (_ send: (_ content: Content, _ isComplete: Swift.Bool) async throws -> Swift.Void) async throws -> Swift.Void) async throws where Content : Foundation.DataProtocol
  #if compiler(>=5.3) && $NonescapableTypes
  public func ping<Content>(_ content: Content? = nil, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]}) async throws where Content : Foundation.DataProtocol
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func pong<Content>(_ content: Content? = nil, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]}) async throws where Content : Foundation.DataProtocol
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func close(code: Network.NWProtocolWebSocket.CloseCode = .protocolCode(.normalClosure), reason: Swift.String? = nil, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]}) async throws
  #endif
  public func receive() async throws -> ApplicationProtocol.Message<Foundation.Data>
  public func startReceive(_ handler: (_ receive: (_ atLeast: Swift.Int, _ atMost: Swift.Int) async throws -> ApplicationProtocol.Message<Foundation.Data>) async throws -> Swift.Void) async throws
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NetworkChannel where ApplicationProtocol == Network.TLV {
  public func send<Content>(_ content: Content, type: Swift.Int, lastMessage: Swift.Bool = false, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]}) async throws where Content : Foundation.DataProtocol
  public func sendIdempotent<Content>(_ content: Content, type: Swift.Int, lastMessage: Swift.Bool = false, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]}) where Content : Foundation.DataProtocol
  public func receive() async throws -> ApplicationProtocol.Message<Foundation.Data>
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NetworkChannel {
  public func send<Sending, Receiving, CoderType>(_ content: Sending, @Network.ProtocolMetadataBuilder metadata builder: () -> [Network.NWProtocolMetadata] = {[]}) async throws where ApplicationProtocol == Network.Coder<Sending, Receiving, CoderType>, Sending : Swift.Encodable, Receiving : Swift.Decodable, CoderType : Network.NetworkCoder
  public func receive<Sending, Receiving, CoderType>() async throws -> ApplicationProtocol.Message<Receiving> where ApplicationProtocol == Network.Coder<Sending, Receiving, CoderType>, Sending : Swift.Encodable, Receiving : Swift.Decodable, CoderType : Network.NetworkCoder
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NetworkChannel {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func send<T>(_ content: Foundation.Data, lastMessage: Swift.Bool = false, metadata: Network.NWProtocolFramer.Message? = nil, @Network.ProtocolMetadataBuilder other builder: () -> [Network.NWProtocolMetadata] = {[]}) async throws where ApplicationProtocol == Network.Framer<T>, T : Network.FramerProtocol
  #endif
  @available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public func receive<T>() async throws -> ApplicationProtocol.Message<Foundation.Data> where ApplicationProtocol == Network.Framer<T>, T : Network.FramerProtocol
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NetworkChannel where ApplicationProtocol : Network.MessageProtocol {
  public var messages: _Concurrency.AsyncThrowingStream<ApplicationProtocol.Message<ApplicationProtocol.ContentType>, any Swift.Error> {
    get
  }
}
#if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
nonisolated(nonsending) public func withNetworkConnection<ApplicationProtocol>(to endpoint: Network.NWEndpoint, @Network.ProtocolStackBuilder<ApplicationProtocol> using builder: () -> ApplicationProtocol, _ handler: (Network.NetworkConnection<ApplicationProtocol>) async throws -> Swift.Void) async throws where ApplicationProtocol : Network.OneToOneProtocol
#endif
#if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
nonisolated(nonsending) public func withNetworkConnection<ApplicationProtocol>(to endpoint: Network.NWEndpoint, using builder: Network.NWParametersBuilder<ApplicationProtocol>, _ handler: (Network.NetworkConnection<ApplicationProtocol>) async throws -> Swift.Void) async throws where ApplicationProtocol : Network.OneToOneProtocol
#endif
#if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
nonisolated(nonsending) public func withNetworkConnection<ApplicationProtocol>(to endpoint: Network.NWEndpoint, @Network.ProtocolStackBuilder<ApplicationProtocol> using builder: () -> ApplicationProtocol, _ handler: (Network.NetworkConnection<ApplicationProtocol>) async throws -> Swift.Void) async throws where ApplicationProtocol : Network.MultiplexProtocol
#endif
#if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
nonisolated(nonsending) public func withNetworkConnection<ApplicationProtocol>(to endpoint: Network.NWEndpoint, using builder: Network.NWParametersBuilder<ApplicationProtocol>, _ handler: (Network.NetworkConnection<ApplicationProtocol>) async throws -> Swift.Void) async throws where ApplicationProtocol : Network.MultiplexProtocol
#endif
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network14_NWProtocolTCP) public class NWProtocolTCP : Network.NWProtocol {
  public static let definition: Network.NWProtocolDefinition
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network14_NWProtocolTCP7Options) public class Options : Network.NWProtocolOptions {
    public var noDelay: Swift.Bool {
      get
      set
    }
    public var noPush: Swift.Bool {
      get
      set
    }
    public var noOptions: Swift.Bool {
      get
      set
    }
    public var enableKeepalive: Swift.Bool {
      get
      set
    }
    public var keepaliveCount: Swift.Int {
      get
      set
    }
    public var keepaliveIdle: Swift.Int {
      get
      set
    }
    public var keepaliveInterval: Swift.Int {
      get
      set
    }
    public var maximumSegmentSize: Swift.Int {
      get
      set
    }
    public var connectionTimeout: Swift.Int {
      get
      set
    }
    public var persistTimeout: Swift.Int {
      get
      set
    }
    public var connectionDropTime: Swift.Int {
      get
      set
    }
    public var retransmitFinDrop: Swift.Bool {
      get
      set
    }
    public var disableAckStretching: Swift.Bool {
      get
      set
    }
    public var enableFastOpen: Swift.Bool {
      get
      set
    }
    public var disableECN: Swift.Bool {
      get
      set
    }
    public init()
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network14_NWProtocolTCP8Metadata) public class Metadata : Network.NWProtocolMetadata {
    public var availableReceiveBuffer: Swift.UInt32 {
      get
    }
    public var availableSendBuffer: Swift.UInt32 {
      get
    }
    @objc deinit
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network13_NWConnection) final public class NWConnection : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
  public enum State : Swift.Equatable, Swift.Sendable {
    case setup
    case waiting(Network.NWError)
    case preparing
    case ready
    case failed(Network.NWError)
    case cancelled
    public static func == (a: Network.NWConnection.State, b: Network.NWConnection.State) -> Swift.Bool
  }
  final public var state: Network.NWConnection.State {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public var stateUpdateHandler: (@Sendable (_ state: Network.NWConnection.State) -> Swift.Void)? {
    get
    set
  }
  #endif
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public var maximumDatagramSize: Swift.Int {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var currentPath: Network.NWPath? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public var pathUpdateHandler: (@Sendable (_ newPath: Network.NWPath) -> Swift.Void)? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public var viabilityUpdateHandler: (@Sendable (_ newIsViable: Swift.Bool) -> Swift.Void)? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public var betterPathUpdateHandler: (@Sendable (_ newHasBetterPath: Swift.Bool) -> Swift.Void)? {
    get
    set
  }
  #endif
  final public let endpoint: Network.NWEndpoint
  final public let parameters: Network.NWParameters
  public init(to: Network.NWEndpoint, using: Network.NWParameters)
  convenience public init(host: Network.NWEndpoint.Host, port: Network.NWEndpoint.Port, using: Network.NWParameters)
  final public func start(queue: Dispatch.DispatchQueue)
  #if compiler(>=5.3) && $NonescapableTypes
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  #endif
  final public func cancel()
  final public func forceCancel()
  final public func cancelCurrentEndpoint()
  final public func restart()
  @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network13_NWConnection14ContentContext) public class ContentContext : @unchecked Swift.Sendable {
    final public let identifier: Swift.String
    final public let expirationMilliseconds: Swift.UInt64
    final public let relativePriority: Swift.Double
    final public let antecedent: Network.NWConnection.ContentContext?
    final public let isFinal: Swift.Bool
    public var protocolMetadata: [Network.NWProtocolMetadata] {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public func protocolMetadata(definition: Network.NWProtocolDefinition) -> Network.NWProtocolMetadata?
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init(identifier: Swift.String, expiration: Swift.UInt64 = 0, priority: Swift.Double = 0.5, isFinal: Swift.Bool = false, antecedent: Network.NWConnection.ContentContext? = nil, metadata: [Network.NWProtocolMetadata]? = [])
    #endif
    public static let defaultMessage: Network.NWConnection.ContentContext
    public static let finalMessage: Network.NWConnection.ContentContext
    public static let defaultStream: Network.NWConnection.ContentContext
    @objc deinit
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public func receive(minimumIncompleteLength: Swift.Int, maximumLength: Swift.Int, completion: @escaping @Sendable (_ content: Foundation.Data?, _ contentContext: Network.NWConnection.ContentContext?, _ isComplete: Swift.Bool, _ error: Network.NWError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @preconcurrency final public func receiveDiscontiguous(minimumIncompleteLength: Swift.Int, maximumLength: Swift.Int, completion: @escaping @Sendable (_ content: Dispatch.DispatchData?, _ contentContext: Network.NWConnection.ContentContext?, _ isComplete: Swift.Bool, _ error: Network.NWError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public func receiveMessage(completion: @escaping @Sendable (_ content: Foundation.Data?, _ contentContext: Network.NWConnection.ContentContext?, _ isComplete: Swift.Bool, _ error: Network.NWError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @preconcurrency final public func receiveMessageDiscontiguous(completion: @escaping @Sendable (_ content: Dispatch.DispatchData?, _ contentContext: Network.NWConnection.ContentContext?, _ isComplete: Swift.Bool, _ error: Network.NWError?) -> Swift.Void)
  #endif
  public enum SendCompletion {
    @preconcurrency case contentProcessed(@Sendable (_ error: Network.NWError?) -> Swift.Void)
    case idempotent
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public func send(content: Foundation.Data?, contentContext: Network.NWConnection.ContentContext = .defaultMessage, isComplete: Swift.Bool = true, completion: Network.NWConnection.SendCompletion)
  #endif
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @usableFromInline
  @preconcurrency final internal func send(discontiguousContent: Dispatch.DispatchData, contentContext: Network.NWConnection.ContentContext = .defaultMessage, isComplete: Swift.Bool = true, completion: Network.NWConnection.SendCompletion)
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @preconcurrency @inlinable final public func send<Content>(content: Content?, contentContext: Network.NWConnection.ContentContext = .defaultMessage, isComplete: Swift.Bool = true, completion: Network.NWConnection.SendCompletion) where Content : Foundation.DataProtocol {
		if let dispatchData = content as? DispatchData {
			send(discontiguousContent: dispatchData, contentContext: contentContext, isComplete: isComplete, completion: completion)
		} else if let data = content as? Data {
			send(content: data, contentContext: contentContext, isComplete: isComplete, completion: completion)
		} else if let content = content {
			send(content: Data(content), contentContext: contentContext, isComplete: isComplete, completion: completion)
		} else {
			send(content: nil, contentContext: contentContext, isComplete: isComplete, completion: completion)
		}
	}
  #endif
  final public func batch(_ block: () -> Swift.Void)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func metadata(definition: Network.NWProtocolDefinition) -> Network.NWProtocolMetadata?
  #endif
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public struct EstablishmentReport : Swift.CustomDebugStringConvertible, Swift.Sendable {
    public var debugDescription: Swift.String {
      get
    }
    public let duration: Foundation.TimeInterval
    public let attemptStartedAfterInterval: Foundation.TimeInterval
    public let previousAttemptCount: Swift.Int
    public let usedProxy: Swift.Bool
    public let proxyConfigured: Swift.Bool
    public let proxyEndpoint: Network.NWEndpoint?
    public struct Resolution : Swift.Sendable {
      public enum Source : Swift.Sendable {
        case query
        case cache
        case expiredCache
        public static func == (a: Network.NWConnection.EstablishmentReport.Resolution.Source, b: Network.NWConnection.EstablishmentReport.Resolution.Source) -> Swift.Bool
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
      }
      public let source: Network.NWConnection.EstablishmentReport.Resolution.Source
      public let duration: Foundation.TimeInterval
      public let endpointCount: Swift.Int
      public let successfulEndpoint: Network.NWEndpoint
      public let preferredEndpoint: Network.NWEndpoint
      @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
      public enum DNSProtocol : Swift.Sendable {
        case unknown
        case udp
        case tcp
        case tls
        case https
        public static func == (a: Network.NWConnection.EstablishmentReport.Resolution.DNSProtocol, b: Network.NWConnection.EstablishmentReport.Resolution.DNSProtocol) -> Swift.Bool
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
      }
      @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
      public var dnsProtocol: Network.NWConnection.EstablishmentReport.Resolution.DNSProtocol {
        get
      }
    }
    public let resolutions: [Network.NWConnection.EstablishmentReport.Resolution]
    public struct Handshake : Swift.Sendable {
      public let definition: Network.NWProtocolDefinition
      public let handshakeDuration: Foundation.TimeInterval
      public let handshakeRTT: Foundation.TimeInterval
    }
    public let handshakes: [Network.NWConnection.EstablishmentReport.Handshake]
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @preconcurrency final public func requestEstablishmentReport(queue: Dispatch.DispatchQueue, completion: @escaping @Sendable (_ report: Network.NWConnection.EstablishmentReport?) -> Swift.Void)
  #endif
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public struct DataTransferReport : Swift.CustomDebugStringConvertible, Swift.Sendable {
    public var debugDescription: Swift.String {
      get
    }
    public let duration: Foundation.TimeInterval
    public struct PathReport : Swift.Sendable {
      public let interface: Network.NWInterface
      #if compiler(>=5.3) && $NonescapableTypes
      @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
      public var radioType: Network.NWInterface.RadioType? {
        get
      }
      #endif
      public let receivedIPPacketCount: Swift.UInt64
      public let sentIPPacketCount: Swift.UInt64
      public let receivedTransportByteCount: Swift.UInt64
      public let receivedTransportDuplicateByteCount: Swift.UInt64
      public let receivedTransportOutOfOrderByteCount: Swift.UInt64
      public let sentTransportByteCount: Swift.UInt64
      public let retransmittedTransportByteCount: Swift.UInt64
      public let transportSmoothedRTT: Foundation.TimeInterval
      public let transportMinimumRTT: Foundation.TimeInterval
      public let transportRTTVariance: Foundation.TimeInterval
      public let receivedApplicationByteCount: Swift.UInt64
      public let sentApplicationByteCount: Swift.UInt64
    }
    public let aggregatePathReport: Network.NWConnection.DataTransferReport.PathReport
    public let pathReports: [Network.NWConnection.DataTransferReport.PathReport]
  }
  @_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public class PendingDataTransferReport : @unchecked Swift.Sendable {
    @preconcurrency public func collect(queue: Dispatch.DispatchQueue, completion: @escaping @Sendable (_ report: Network.NWConnection.DataTransferReport) -> Swift.Void)
    @objc deinit
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  final public func startDataTransferReport() -> Network.NWConnection.PendingDataTransferReport
  @objc deinit
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension Network.NWConnection : Swift.Sendable {
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public protocol NWGroupDescriptor : AnyObject, Swift.Sendable {
  var members: [Network.NWEndpoint] { get }
}
@_hasMissingDesignatedInitializers @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public class NWMulticastGroup : Network.NWGroupDescriptor, @unchecked Swift.Sendable {
  public var members: [Network.NWEndpoint] {
    get
  }
  final public let sourceFilter: Network.NWEndpoint?
  final public let isUnicastDisabled: Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public init(for groupAddresses: [Network.NWEndpoint], from: Network.NWEndpoint? = nil, disableUnicast: Swift.Bool = false) throws
  #endif
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public class NWMultiplexGroup : Network.NWGroupDescriptor, @unchecked Swift.Sendable {
  public var members: [Network.NWEndpoint] {
    get
  }
  public init(to: Network.NWEndpoint)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
final public class NWConnectionGroup : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
  public enum State : Swift.Equatable, Swift.Sendable {
    case setup
    case waiting(Network.NWError)
    case ready
    case failed(Network.NWError)
    case cancelled
    public static func == (a: Network.NWConnectionGroup.State, b: Network.NWConnectionGroup.State) -> Swift.Bool
  }
  final public var state: Network.NWConnectionGroup.State {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public var stateUpdateHandler: (@Sendable (_ state: Network.NWConnectionGroup.State) -> Swift.Void)? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  final public func metadata(definition: Network.NWProtocolDefinition) -> Network.NWProtocolMetadata?
  #endif
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Message : Network.NWConnection.ContentContext {
    public static let `default`: Network.NWConnectionGroup.Message
    #if compiler(>=5.3) && $NonescapableTypes
    public var remoteEndpoint: Network.NWEndpoint? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var localEndpoint: Network.NWEndpoint? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
    public func metadata(definition: Network.NWProtocolDefinition) -> Network.NWProtocolMetadata?
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var path: Network.NWPath? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public func reply(content: Foundation.Data?, message: Network.NWConnectionGroup.Message = .default)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public func extractConnection() -> Network.NWConnection?
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    override public init(identifier: Swift.String, expiration: Swift.UInt64 = super, priority: Swift.Double = super, isFinal: Swift.Bool = super, antecedent: Network.NWConnection.ContentContext? = nil, metadata: [Network.NWProtocolMetadata]? = super)
    #endif
    @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
    public init(nw: Network.nw_content_context_t)
    @objc deinit
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public func setReceiveHandler(maximumMessageSize: Swift.Int = Int.max, rejectOversizedMessages: Swift.Bool = true, handler: (@Sendable (_ message: Network.NWConnectionGroup.Message, _ content: Foundation.Data?, _ isComplete: Swift.Bool) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency final public func send(content: Foundation.Data?, to: Network.NWEndpoint? = nil, message: Network.NWConnectionGroup.Message = .default, completion: @escaping (_ error: Network.NWError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @preconcurrency final public var newConnectionHandler: (@Sendable (_ connection: Network.NWConnection) -> Swift.Void)? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  final public func extract(connectionTo: Network.NWEndpoint? = nil, using: Network.NWProtocolOptions? = nil) -> Network.NWConnection?
  #endif
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  final public func reinsert(connection: Network.NWConnection) -> Swift.Bool
  final public let descriptor: any Network.NWGroupDescriptor
  final public let parameters: Network.NWParameters
  public init(with: any Network.NWGroupDescriptor, using: Network.NWParameters)
  final public func start(queue: Dispatch.DispatchQueue)
  #if compiler(>=5.3) && $NonescapableTypes
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  #endif
  final public func cancel()
  @objc deinit
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension Network.NWConnectionGroup : Swift.Sendable {
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWConnection {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  convenience public init?(message: Network.NWConnectionGroup.Message)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  convenience public init?(from: Network.NWConnectionGroup, to: Network.NWEndpoint? = nil, using: Network.NWProtocolOptions? = nil)
  #endif
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
public struct Bonjour : Network.BrowserProvider {
  @available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
  public struct Endpoint : Swift.Equatable, Swift.Identifiable, Swift.Sendable, Network.Connectable, Swift.CustomStringConvertible {
    public let result: Network.NWBrowser.Result
    public let txtRecord: Network.NWTXTRecord
    public let name: Swift.String
    public let type: Swift.String
    public let domain: Swift.String
    public static func == (lhs: Network.Bonjour.Endpoint, rhs: Network.Bonjour.Endpoint) -> Swift.Bool
    public var id: Swift.String {
      get
    }
    public var nwEndpoint: Network.NWEndpoint {
      get
    }
    public var description: Swift.String {
      get
    }
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
    public typealias ID = Swift.String
  }
}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.BrowserProvider where Self == Network.Bonjour {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func bonjour(_ type: Swift.String, domain: Swift.String? = nil, includeTxtRecord: Swift.Bool = false) -> Network.Bonjour
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct NWTXTRecord : Swift.Sendable {
  public enum Entry : Swift.Hashable, Swift.CustomDebugStringConvertible, Swift.Sendable {
    case none
    case empty
    case string(Swift.String)
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    case data(Foundation.Data)
    #if compiler(>=5.3) && $NonescapableTypes
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public var data: Foundation.Data? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public init(_ data: Foundation.Data?)
    #endif
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Network.NWTXTRecord.Entry, rhs: Network.NWTXTRecord.Entry) -> Swift.Bool
    public var debugDescription: Swift.String {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(_ dictionary: [Swift.String : Swift.String] = [:])
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public init(_ data: Foundation.Data)
  @discardableResult
  public mutating func removeEntry(key: Swift.String) -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public func getEntry(for key: Swift.String) -> Network.NWTXTRecord.Entry?
  #endif
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public var data: Foundation.Data {
    get
  }
  @discardableResult
  public mutating func setEntry(_ entry: Network.NWTXTRecord.Entry, for key: Swift.String) -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript(key: Swift.String) -> Swift.String? {
    get
    set
  }
  #endif
  public var dictionary: [Swift.String : Swift.String] {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWTXTRecord : Swift.Equatable {
  public static func == (lhs: Network.NWTXTRecord, rhs: Network.NWTXTRecord) -> Swift.Bool
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWTXTRecord : Swift.Collection {
  public typealias Element = (key: Swift.String, value: Network.NWTXTRecord.Entry)
  public subscript(position: Network.NWTXTRecord.Index) -> Network.NWTXTRecord.Element {
    get
  }
  public struct Index : Swift.Comparable {
    public static func == (lhs: Network.NWTXTRecord.Index, rhs: Network.NWTXTRecord.Index) -> Swift.Bool
    public static func < (lhs: Network.NWTXTRecord.Index, rhs: Network.NWTXTRecord.Index) -> Swift.Bool
  }
  public var startIndex: Network.NWTXTRecord.Index {
    get
  }
  public var endIndex: Network.NWTXTRecord.Index {
    get
  }
  public func index(after i: Network.NWTXTRecord.Index) -> Network.NWTXTRecord.Index
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Indices = Swift.DefaultIndices<Network.NWTXTRecord>
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Iterator = Swift.IndexingIterator<Network.NWTXTRecord>
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias SubSequence = Swift.Slice<Network.NWTXTRecord>
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWTXTRecord : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@_objcRuntimeName(_TtC7Network13_NWParameters) final public class NWParameters : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(tls: Network.NWProtocolTLS.Options?, tcp: Network.NWProtocolTCP.Options = NWProtocolTCP.Options())
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(dtls: Network.NWProtocolTLS.Options?, udp: Network.NWProtocolUDP.Options = NWProtocolUDP.Options())
  #endif
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  convenience public init(quic: Network.NWProtocolQUIC.Options)
  @available(macOS 10.15, *)
  @available(iOS, unavailable)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public init(customIPProtocolNumber: Swift.UInt8)
  public init()
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  final public class var applicationService: Network.NWParameters {
    get
  }
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  final public class func quic(alpn: [Swift.String]) -> Network.NWParameters
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  final public class func quicDatagram(alpn: [Swift.String]) -> Network.NWParameters
  final public class var tls: Network.NWParameters {
    get
  }
  final public class var dtls: Network.NWParameters {
    get
  }
  final public class var tcp: Network.NWParameters {
    get
  }
  final public class var udp: Network.NWParameters {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var requiredInterface: Network.NWInterface? {
    get
    set
  }
  #endif
  final public var requiredInterfaceType: Network.NWInterface.InterfaceType {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var prohibitedInterfaces: [Network.NWInterface]? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var prohibitedInterfaceTypes: [Network.NWInterface.InterfaceType]? {
    get
    set
  }
  #endif
  final public var prohibitExpensivePaths: Swift.Bool {
    get
    set
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  final public var prohibitConstrainedPaths: Swift.Bool {
    get
    set
  }
  @available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
  final public var allowUltraConstrainedPaths: Swift.Bool {
    get
    set
  }
  final public var preferNoProxies: Swift.Bool {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var requiredLocalEndpoint: Network.NWEndpoint? {
    get
    set
  }
  #endif
  final public var allowLocalEndpointReuse: Swift.Bool {
    get
    set
  }
  final public var acceptLocalOnly: Swift.Bool {
    get
    set
  }
  final public var includePeerToPeer: Swift.Bool {
    get
    set
  }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  final public var requiresDNSSECValidation: Swift.Bool {
    get
    set
  }
  public enum ServiceClass : Swift.Sendable {
    case bestEffort
    case background
    case interactiveVideo
    case interactiveVoice
    case responsiveData
    case signaling
    public static func == (a: Network.NWParameters.ServiceClass, b: Network.NWParameters.ServiceClass) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public var serviceClass: Network.NWParameters.ServiceClass {
    get
    set
  }
  public enum MultipathServiceType : Swift.Sendable {
    case disabled
    case handover
    case interactive
    case aggregate
    public static func == (a: Network.NWParameters.MultipathServiceType, b: Network.NWParameters.MultipathServiceType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public var multipathServiceType: Network.NWParameters.MultipathServiceType {
    get
    set
  }
  final public var allowFastOpen: Swift.Bool {
    get
    set
  }
  public enum ExpiredDNSBehavior : Swift.Sendable {
    case systemDefault
    case allow
    case prohibit
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    case persistent
    public static func == (a: Network.NWParameters.ExpiredDNSBehavior, b: Network.NWParameters.ExpiredDNSBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public var expiredDNSBehavior: Network.NWParameters.ExpiredDNSBehavior {
    get
    set
  }
  @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCC7Network13_NWParameters13ProtocolStack) public class ProtocolStack {
    public var applicationProtocols: [Network.NWProtocolOptions] {
      get
      set
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public var transportProtocol: Network.NWProtocolOptions? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var internetProtocol: Network.NWProtocolOptions? {
      get
      set
    }
    #endif
    @objc deinit
  }
  final public var defaultProtocolStack: Network.NWParameters.ProtocolStack {
    get
  }
  @_hasMissingDesignatedInitializers @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  public class PrivacyContext : Swift.CustomDebugStringConvertible, @unchecked Swift.Sendable {
    public var debugDescription: Swift.String {
      get
    }
    public static let `default`: Network.NWParameters.PrivacyContext
    public init(description: Swift.String)
    public func flushCache()
    public func disableLogging()
    public enum ResolverConfiguration : Swift.CustomDebugStringConvertible, Swift.Sendable {
      public var debugDescription: Swift.String {
        get
      }
      case tls(_: Network.NWEndpoint, serverAddresses: [Network.NWEndpoint])
      case https(_: Foundation.URL, serverAddresses: [Network.NWEndpoint])
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public func requireEncryptedNameResolution(_ requireEncryption: Swift.Bool, fallbackResolver: Network.NWParameters.PrivacyContext.ResolverConfiguration?)
    #endif
    @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
    public var proxyConfigurations: [Network.ProxyConfiguration] {
      get
      set
    }
    @objc deinit
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  final public func setPrivacyContext(_ privacyContext: Network.NWParameters.PrivacyContext)
  final public func copy() -> Network.NWParameters
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public enum Attribution : Swift.Equatable, Swift.Sendable {
    case developer
    case user
    public static func == (a: Network.NWParameters.Attribution, b: Network.NWParameters.Attribution) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  final public var attribution: Network.NWParameters.Attribution {
    get
    set
  }
  @objc deinit
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
public struct ProxyConfiguration : Swift.CustomDebugStringConvertible, Swift.Sendable {
  public var debugDescription: Swift.String {
    get
  }
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public init(_nw: Network.nw_proxy_config_t)
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public var _nw: Network.nw_proxy_config_t {
    get
  }
  public var allowFailover: Swift.Bool {
    get
    set
  }
  public var matchDomains: [Swift.String] {
    get
    set
  }
  public var excludedDomains: [Swift.String] {
    get
    set
  }
  public func applyCredential(username: Swift.String, password: Swift.String)
  public init(socksv5Proxy: Network.NWEndpoint)
  #if compiler(>=5.3) && $NonescapableTypes
  public init(httpCONNECTProxy: Network.NWEndpoint, tlsOptions: Network.NWProtocolTLS.Options? = nil)
  #endif
  public struct RelayHop : Swift.CustomDebugStringConvertible, Swift.Sendable {
    public var debugDescription: Swift.String {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init(http3RelayEndpoint: Network.NWEndpoint, http2RelayEndpoint: Network.NWEndpoint? = nil, tlsOptions: Network.NWProtocolTLS.Options = .init(), additionalHTTPHeaderFields: [Swift.String : Swift.String] = [:])
    #endif
    public init(http2RelayEndpoint: Network.NWEndpoint, tlsOptions: Network.NWProtocolTLS.Options = .init(), additionalHTTPHeaderFields: [Swift.String : Swift.String] = [:])
  }
  public init(relayHops: [Network.ProxyConfiguration.RelayHop])
  public init(obliviousHTTPRelay: Network.ProxyConfiguration.RelayHop, relayResourcePath: Swift.String, gatewayKeyConfig: Foundation.Data, matchDomains: [Swift.String])
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension Network.NWParameters : Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension Network.NWParameters.ProtocolStack : @unchecked Swift.Sendable {
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension Foundation.URLSessionConfiguration {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public var proxyConfigurations: [Network.ProxyConfiguration] {
    get
    set
  }
}
prefix operator >>
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.Version : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.Version : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.Opcode : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.Opcode : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.Opcode : Swift.RawRepresentable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.CloseCode.Defined : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.CloseCode.Defined : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.CloseCode.Defined : Swift.RawRepresentable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.Response.Status : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolWebSocket.Response.Status : Swift.Hashable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.IPv6Address.Scope : Swift.Equatable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.IPv6Address.Scope : Swift.Hashable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.IPv6Address.Scope : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Network.NWProtocolQUIC.Options.Direction : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Network.NWProtocolQUIC.Options.Direction : Swift.Hashable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWInterface.InterfaceType : Swift.Equatable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWInterface.InterfaceType : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Network.NWInterface.RadioType.WiFi : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Network.NWInterface.RadioType.WiFi : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Network.NWInterface.RadioType.Cellular.NewRadio5GVariant : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Network.NWInterface.RadioType.Cellular.NewRadio5GVariant : Swift.Hashable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWPath.Status : Swift.Equatable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWPath.Status : Swift.Hashable {}
@available(macOS 11.0, iOS 14.2, watchOS 7.1, tvOS 14.2, *)
extension Network.NWPath.UnsatisfiedReason : Swift.Equatable {}
@available(macOS 11.0, iOS 14.2, watchOS 7.1, tvOS 14.2, *)
extension Network.NWPath.UnsatisfiedReason : Swift.Hashable {}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NWPath.LinkQuality : Swift.Equatable {}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.NWPath.LinkQuality : Swift.Hashable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWProtocolIP.Options.Version : Swift.Equatable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWProtocolIP.Options.Version : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Network.NWProtocolIP.Options.AddressPreference : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Network.NWProtocolIP.Options.AddressPreference : Swift.Hashable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWProtocolIP.ECN : Swift.Equatable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWProtocolIP.ECN : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolFramer.StartResult : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWProtocolFramer.StartResult : Swift.Hashable {}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.TLS.PeerAuthentication : Swift.Equatable {}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.TLS.PeerAuthentication : Swift.Hashable {}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.QUICStream.Directionality : Swift.Hashable {}
@available(macOS 26.0, iOS 26.0, watchOS 26.0, tvOS 26.0, visionOS 26.0, *)
extension Network.QUICStream.Initiator : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWConnection.EstablishmentReport.Resolution.Source : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Network.NWConnection.EstablishmentReport.Resolution.Source : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Network.NWConnection.EstablishmentReport.Resolution.DNSProtocol : Swift.Equatable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Network.NWConnection.EstablishmentReport.Resolution.DNSProtocol : Swift.Hashable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWParameters.ServiceClass : Swift.Equatable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWParameters.ServiceClass : Swift.Hashable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWParameters.MultipathServiceType : Swift.Equatable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWParameters.MultipathServiceType : Swift.Hashable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWParameters.ExpiredDNSBehavior : Swift.Equatable {}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
extension Network.NWParameters.ExpiredDNSBehavior : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Network.NWParameters.Attribution : Swift.Hashable {}
