// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 (swiftlang-6.2.1.4.7 clang-1700.4.4.1)
// swift-module-flags: -target x86_64-apple-macos26.1 -target-variant x86_64-apple-ios26.1-macabi -enable-objc-interop -enable-library-evolution -swift-version 6 -enforce-exclusivity=checked -O -library-level api -enable-upcoming-feature InternalImportsByDefault -enable-upcoming-feature MemberImportVisibility -enable-experimental-feature DebugDescriptionMacro -user-module-version 1.1.7 -module-name FoundationModels -package-name com.apple.foundationmodels
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.1
public import BackgroundAssets
public import CoreGraphics
public import Foundation
public import Observation
public import Swift
public import _Concurrency
public import _StringProcessing
public import _SwiftConcurrencyShims
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@attached(extension, conformances: FoundationModels.Generable, names: named(init(_:)), named(generatedContent)) @attached(member, names: arbitrary) public macro Generable(description: Swift.String? = nil) = #externalMacro(module: "FoundationModelsMacros", type: "GenerableMacro")
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@attached(peer) public macro Guide<T>(description: Swift.String? = nil, _ guides: FoundationModels.GenerationGuide<T>...) = #externalMacro(module: "FoundationModelsMacros", type: "GuideMacro") where T : FoundationModels.Generable
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@attached(peer) public macro Guide<RegexOutput>(description: Swift.String? = nil, _ guides: _StringProcessing.Regex<RegexOutput>) = #externalMacro(module: "FoundationModelsMacros", type: "GuideMacro")
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@attached(peer) public macro Guide(description: Swift.String) = #externalMacro(module: "FoundationModelsMacros", type: "GuideMacro")
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol Generable : FoundationModels.ConvertibleFromGeneratedContent, FoundationModels.ConvertibleToGeneratedContent {
  associatedtype PartiallyGenerated : FoundationModels.ConvertibleFromGeneratedContent = Self
  static var generationSchema: FoundationModels.GenerationSchema { get }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.Generable {
  public func asPartiallyGenerated() -> Self.PartiallyGenerated
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol ConvertibleFromGeneratedContent : Swift.SendableMetatype {
  init(_ content: FoundationModels.GeneratedContent) throws
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol ConvertibleToGeneratedContent : FoundationModels.InstructionsRepresentable, FoundationModels.PromptRepresentable {
  var generatedContent: FoundationModels.GeneratedContent { get }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.ConvertibleToGeneratedContent {
  public var instructionsRepresentation: FoundationModels.Instructions {
    get
  }
  public var promptRepresentation: FoundationModels.Prompt {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.Generable {
  public typealias PartiallyGenerated = Self
}
#if compiler(>=5.3) && $NonescapableTypes
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Swift.Optional where Wrapped : FoundationModels.Generable {
  public typealias PartiallyGenerated = Wrapped.PartiallyGenerated
}
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Swift.Optional : FoundationModels.ConvertibleToGeneratedContent, FoundationModels.PromptRepresentable, FoundationModels.InstructionsRepresentable where Wrapped : FoundationModels.ConvertibleToGeneratedContent {
  public var generatedContent: FoundationModels.GeneratedContent {
    get
  }
}
#endif
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Swift.Bool : FoundationModels.Generable {
  public static var generationSchema: FoundationModels.GenerationSchema {
    get
  }
  public init(_ content: FoundationModels.GeneratedContent) throws
  public var generatedContent: FoundationModels.GeneratedContent {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Swift.String : FoundationModels.Generable {
  public static var generationSchema: FoundationModels.GenerationSchema {
    get
  }
  public init(_ content: FoundationModels.GeneratedContent) throws
  public var generatedContent: FoundationModels.GeneratedContent {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Swift.Int : FoundationModels.Generable {
  public static var generationSchema: FoundationModels.GenerationSchema {
    get
  }
  public init(_ content: FoundationModels.GeneratedContent) throws
  public var generatedContent: FoundationModels.GeneratedContent {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Swift.Float : FoundationModels.Generable {
  public static var generationSchema: FoundationModels.GenerationSchema {
    get
  }
  public init(_ content: FoundationModels.GeneratedContent) throws
  public var generatedContent: FoundationModels.GeneratedContent {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Swift.Double : FoundationModels.Generable {
  public static var generationSchema: FoundationModels.GenerationSchema {
    get
  }
  public init(_ content: FoundationModels.GeneratedContent) throws
  public var generatedContent: FoundationModels.GeneratedContent {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Foundation.Decimal : FoundationModels.Generable {
  public static var generationSchema: FoundationModels.GenerationSchema {
    get
  }
  public init(_ content: FoundationModels.GeneratedContent) throws
  public var generatedContent: FoundationModels.GeneratedContent {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Swift.Array : FoundationModels.Generable where Element : FoundationModels.Generable {
  public typealias PartiallyGenerated = [Element.PartiallyGenerated]
  public static var generationSchema: FoundationModels.GenerationSchema {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Swift.Array : FoundationModels.ConvertibleToGeneratedContent where Element : FoundationModels.ConvertibleToGeneratedContent {
  public var generatedContent: FoundationModels.GeneratedContent {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Swift.Array : FoundationModels.ConvertibleFromGeneratedContent where Element : FoundationModels.ConvertibleFromGeneratedContent {
  public init(_ content: FoundationModels.GeneratedContent) throws
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Swift.Never : FoundationModels.Generable {
  public static var generationSchema: FoundationModels.GenerationSchema {
    get
  }
  public init(_ content: FoundationModels.GeneratedContent) throws
  public var generatedContent: FoundationModels.GeneratedContent {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct GeneratedContent : Swift.Sendable, Swift.Equatable, FoundationModels.Generable, Swift.CustomDebugStringConvertible {
  public static var generationSchema: FoundationModels.GenerationSchema {
    get
  }
  public var id: FoundationModels.GenerationID?
  public init(_ content: FoundationModels.GeneratedContent) throws
  public var generatedContent: FoundationModels.GeneratedContent {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init(properties: Swift.KeyValuePairs<Swift.String, any FoundationModels.ConvertibleToGeneratedContent>, id: FoundationModels.GenerationID? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init<S>(properties: S, id: FoundationModels.GenerationID? = nil, uniquingKeysWith combine: (FoundationModels.GeneratedContent, FoundationModels.GeneratedContent) throws -> some ConvertibleToGeneratedContent) rethrows where S : Swift.Sequence, S.Element == (Swift.String, any FoundationModels.ConvertibleToGeneratedContent)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init<S>(elements: S, id: FoundationModels.GenerationID? = nil) where S : Swift.Sequence, S.Element == any FoundationModels.ConvertibleToGeneratedContent
  #endif
  public init(_ value: some ConvertibleToGeneratedContent)
  public init(_ value: some ConvertibleToGeneratedContent, id: FoundationModels.GenerationID)
  public init(json: Swift.String) throws
  public var jsonString: Swift.String {
    get
  }
  public func value<Value>(_ type: Value.Type = Value.self) throws -> Value where Value : FoundationModels.ConvertibleFromGeneratedContent
  public func value<Value>(_ type: Value.Type = Value.self, forProperty property: Swift.String) throws -> Value where Value : FoundationModels.ConvertibleFromGeneratedContent
  #if compiler(>=5.3) && $NonescapableTypes
  public func value<Value>(_ type: Value?.Type = Value?.self, forProperty property: Swift.String) throws -> Value? where Value : FoundationModels.ConvertibleFromGeneratedContent
  #endif
  public var debugDescription: Swift.String {
    get
  }
  public var isComplete: Swift.Bool {
    get
  }
  public static func == (a: FoundationModels.GeneratedContent, b: FoundationModels.GeneratedContent) -> Swift.Bool
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.GeneratedContent {
  public enum Kind : Swift.Equatable, Swift.Sendable {
    case null
    case bool(Swift.Bool)
    case number(Swift.Double)
    case string(Swift.String)
    case array([FoundationModels.GeneratedContent])
    case structure(properties: [Swift.String : FoundationModels.GeneratedContent], orderedKeys: [Swift.String])
    public static func == (a: FoundationModels.GeneratedContent.Kind, b: FoundationModels.GeneratedContent.Kind) -> Swift.Bool
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init(kind: FoundationModels.GeneratedContent.Kind, id: FoundationModels.GenerationID? = nil)
  #endif
  public var kind: FoundationModels.GeneratedContent.Kind {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct GenerationGuide<Value> {
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.GenerationGuide where Value == Swift.String {
  public static func constant(_ value: Swift.String) -> FoundationModels.GenerationGuide<Swift.String>
  public static func anyOf(_ values: [Swift.String]) -> FoundationModels.GenerationGuide<Swift.String>
  public static func pattern<Output>(_ regex: _StringProcessing.Regex<Output>) -> FoundationModels.GenerationGuide<Swift.String>
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.GenerationGuide where Value == Swift.Int {
  public static func minimum(_ value: Swift.Int) -> FoundationModels.GenerationGuide<Swift.Int>
  public static func maximum(_ value: Swift.Int) -> FoundationModels.GenerationGuide<Swift.Int>
  public static func range(_ range: Swift.ClosedRange<Swift.Int>) -> FoundationModels.GenerationGuide<Swift.Int>
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.GenerationGuide where Value == Swift.Float {
  public static func minimum(_ value: Swift.Float) -> FoundationModels.GenerationGuide<Swift.Float>
  public static func maximum(_ value: Swift.Float) -> FoundationModels.GenerationGuide<Swift.Float>
  public static func range(_ range: Swift.ClosedRange<Swift.Float>) -> FoundationModels.GenerationGuide<Swift.Float>
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.GenerationGuide where Value == Foundation.Decimal {
  public static func minimum(_ value: Foundation.Decimal) -> FoundationModels.GenerationGuide<Foundation.Decimal>
  public static func maximum(_ value: Foundation.Decimal) -> FoundationModels.GenerationGuide<Foundation.Decimal>
  public static func range(_ range: Swift.ClosedRange<Foundation.Decimal>) -> FoundationModels.GenerationGuide<Foundation.Decimal>
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.GenerationGuide where Value == Swift.Double {
  public static func minimum(_ value: Swift.Double) -> FoundationModels.GenerationGuide<Swift.Double>
  public static func maximum(_ value: Swift.Double) -> FoundationModels.GenerationGuide<Swift.Double>
  public static func range(_ range: Swift.ClosedRange<Swift.Double>) -> FoundationModels.GenerationGuide<Swift.Double>
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.GenerationGuide {
  public static func minimumCount<Element>(_ count: Swift.Int) -> FoundationModels.GenerationGuide<[Element]> where Value == [Element]
  public static func maximumCount<Element>(_ count: Swift.Int) -> FoundationModels.GenerationGuide<[Element]> where Value == [Element]
  public static func count<Element>(_ range: Swift.ClosedRange<Swift.Int>) -> FoundationModels.GenerationGuide<[Element]> where Value == [Element]
  public static func count<Element>(_ count: Swift.Int) -> FoundationModels.GenerationGuide<[Element]> where Value == [Element]
  public static func element<Element>(_ guide: FoundationModels.GenerationGuide<Element>) -> FoundationModels.GenerationGuide<[Element]> where Value == [Element]
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@_documentation(visibility: private) extension FoundationModels.GenerationGuide where Value == [Swift.Never] {
  @_documentation(visibility: private) @_alwaysEmitIntoClient public static func minimumCount(_ count: Swift.Int) -> FoundationModels.GenerationGuide<Value> {
    fatalError("GenerationGuide<[Never]>.\(#function) should not be called.")
  }
  @_documentation(visibility: private) @_alwaysEmitIntoClient public static func maximumCount(_ count: Swift.Int) -> FoundationModels.GenerationGuide<Value> {
    fatalError("GenerationGuide<[Never]>.\(#function) should not be called.")
  }
  @_documentation(visibility: private) @_alwaysEmitIntoClient public static func count(_ range: Swift.ClosedRange<Swift.Int>) -> FoundationModels.GenerationGuide<Value> {
    fatalError("GenerationGuide<[Never]>.\(#function) should not be called.")
  }
  @_documentation(visibility: private) @_disfavoredOverload @_alwaysEmitIntoClient public static func count(_ count: Swift.Int) -> FoundationModels.GenerationGuide<Value> {
    fatalError("GenerationGuide<[Never]>.\(#function) should not be called.")
  }
}
@_hasMissingDesignatedInitializers @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
final public class LanguageModelSession {
  final public var transcript: FoundationModels.Transcript {
    get
  }
  final public var isResponding: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @_disfavoredOverload convenience public init(model: FoundationModels.SystemLanguageModel = .default, tools: [any FoundationModels.Tool] = [], instructions: Swift.String? = nil)
  #endif
  convenience public init(model: FoundationModels.SystemLanguageModel = .default, tools: [any FoundationModels.Tool] = [], @FoundationModels.InstructionsBuilder instructions: () throws -> FoundationModels.Instructions) rethrows
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(model: FoundationModels.SystemLanguageModel = .default, tools: [any FoundationModels.Tool] = [], instructions: FoundationModels.Instructions? = nil)
  #endif
  convenience public init(model: FoundationModels.SystemLanguageModel = .default, tools: [any FoundationModels.Tool] = [], transcript: FoundationModels.Transcript)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func prewarm(promptPrefix: FoundationModels.Prompt? = nil)
  #endif
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct Response<Content> where Content : FoundationModels.Generable {
    public let content: Content
    public let rawContent: FoundationModels.GeneratedContent
    public let transcriptEntries: Swift.ArraySlice<FoundationModels.Transcript.Entry>
  }
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  @discardableResult
  nonisolated(nonsending) final public func respond(to prompt: FoundationModels.Prompt, options: FoundationModels.GenerationOptions = GenerationOptions()) async throws -> FoundationModels.LanguageModelSession.Response<Swift.String>
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  @discardableResult
  @_disfavoredOverload nonisolated(nonsending) final public func respond(to prompt: Swift.String, options: FoundationModels.GenerationOptions = GenerationOptions()) async throws -> FoundationModels.LanguageModelSession.Response<Swift.String>
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  @discardableResult
  nonisolated(nonsending) final public func respond(options: FoundationModels.GenerationOptions = GenerationOptions(), @FoundationModels.PromptBuilder prompt: () throws -> FoundationModels.Prompt) async throws -> FoundationModels.LanguageModelSession.Response<Swift.String>
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  @discardableResult
  nonisolated(nonsending) final public func respond(to prompt: FoundationModels.Prompt, schema: FoundationModels.GenerationSchema, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions()) async throws -> FoundationModels.LanguageModelSession.Response<FoundationModels.GeneratedContent>
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  @discardableResult
  @_disfavoredOverload nonisolated(nonsending) final public func respond(to prompt: Swift.String, schema: FoundationModels.GenerationSchema, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions()) async throws -> FoundationModels.LanguageModelSession.Response<FoundationModels.GeneratedContent>
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  @discardableResult
  nonisolated(nonsending) final public func respond(schema: FoundationModels.GenerationSchema, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions(), @FoundationModels.PromptBuilder prompt: () throws -> FoundationModels.Prompt) async throws -> FoundationModels.LanguageModelSession.Response<FoundationModels.GeneratedContent>
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  @discardableResult
  nonisolated(nonsending) final public func respond<Content>(to prompt: FoundationModels.Prompt, generating type: Content.Type = Content.self, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions()) async throws -> FoundationModels.LanguageModelSession.Response<Content> where Content : FoundationModels.Generable
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  @discardableResult
  @_disfavoredOverload nonisolated(nonsending) final public func respond<Content>(to prompt: Swift.String, generating type: Content.Type = Content.self, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions()) async throws -> FoundationModels.LanguageModelSession.Response<Content> where Content : FoundationModels.Generable
  #endif
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  @discardableResult
  nonisolated(nonsending) final public func respond<Content>(generating type: Content.Type = Content.self, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions(), @FoundationModels.PromptBuilder prompt: () throws -> FoundationModels.Prompt) async throws -> FoundationModels.LanguageModelSession.Response<Content> where Content : FoundationModels.Generable
  #endif
  #if compiler(>=5.3) && $SendingArgsAndResults
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  final public func streamResponse(to prompt: FoundationModels.Prompt, schema: FoundationModels.GenerationSchema, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions()) -> sending FoundationModels.LanguageModelSession.ResponseStream<FoundationModels.GeneratedContent>
  #else
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  final public func streamResponse(to prompt: FoundationModels.Prompt, schema: FoundationModels.GenerationSchema, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions()) -> FoundationModels.LanguageModelSession.ResponseStream<FoundationModels.GeneratedContent>
  #endif
  @objc deinit
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.LanguageModelSession : @unchecked Swift.Sendable {
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.LanguageModelSession : nonisolated Observation.Observable {
}
extension FoundationModels.LanguageModelSession {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public enum GenerationError : Swift.Error, Foundation.LocalizedError {
    @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct Context : Swift.Sendable {
      public let debugDescription: Swift.String
      public init(debugDescription: Swift.String)
    }
    @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct Refusal : Swift.Sendable {
      public init(transcriptEntries: [FoundationModels.Transcript.Entry])
      public var explanation: FoundationModels.LanguageModelSession.Response<Swift.String> {
        get async throws
      }
      public var explanationStream: FoundationModels.LanguageModelSession.ResponseStream<Swift.String> {
        get
      }
    }
    case exceededContextWindowSize(FoundationModels.LanguageModelSession.GenerationError.Context)
    case assetsUnavailable(FoundationModels.LanguageModelSession.GenerationError.Context)
    case guardrailViolation(FoundationModels.LanguageModelSession.GenerationError.Context)
    case unsupportedGuide(FoundationModels.LanguageModelSession.GenerationError.Context)
    case unsupportedLanguageOrLocale(FoundationModels.LanguageModelSession.GenerationError.Context)
    case decodingFailure(FoundationModels.LanguageModelSession.GenerationError.Context)
    case rateLimited(FoundationModels.LanguageModelSession.GenerationError.Context)
    case concurrentRequests(FoundationModels.LanguageModelSession.GenerationError.Context)
    case refusal(FoundationModels.LanguageModelSession.GenerationError.Refusal, FoundationModels.LanguageModelSession.GenerationError.Context)
    #if compiler(>=5.3) && $NonescapableTypes
    public var errorDescription: Swift.String? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var recoverySuggestion: Swift.String? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var failureReason: Swift.String? {
      get
    }
    #endif
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct ToolCallError : Swift.Error, Foundation.LocalizedError {
    public var tool: any FoundationModels.Tool
    public var underlyingError: any Swift.Error
    public init(tool: any FoundationModels.Tool, underlyingError: any Swift.Error)
    #if compiler(>=5.3) && $NonescapableTypes
    public var errorDescription: Swift.String? {
      get
    }
    #endif
  }
}
extension FoundationModels.LanguageModelSession {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct ResponseStream<Content> where Content : FoundationModels.Generable {
    public struct Snapshot {
      public var content: Content.PartiallyGenerated
      public var rawContent: FoundationModels.GeneratedContent
    }
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.LanguageModelSession.ResponseStream : _Concurrency.AsyncSequence {
  public typealias Element = FoundationModels.LanguageModelSession.ResponseStream<Content>.Snapshot
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $NonescapableTypes
    public mutating func next(isolation actor: isolated (any _Concurrency.Actor)? = #isolation) async throws -> FoundationModels.LanguageModelSession.ResponseStream<Content>.Snapshot?
    #endif
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Element = FoundationModels.LanguageModelSession.ResponseStream<Content>.Snapshot
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable, introduced: 18.0)
    @available(watchOS, unavailable, introduced: 11.0)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
  }
  public func makeAsyncIterator() -> FoundationModels.LanguageModelSession.ResponseStream<Content>.AsyncIterator
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  #if compiler(>=5.3) && $SendingArgsAndResults
  nonisolated(nonsending) public func collect() async throws -> sending FoundationModels.LanguageModelSession.Response<Content>
  #else
  nonisolated(nonsending) public func collect() async throws -> FoundationModels.LanguageModelSession.Response<Content>
  #endif
  #endif
  @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
  @available(tvOS, unavailable, introduced: 18.0)
  @available(watchOS, unavailable, introduced: 11.0)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.LanguageModelSession {
  #if compiler(>=5.3) && $SendingArgsAndResults
  @_disfavoredOverload final public func streamResponse(to prompt: Swift.String, schema: FoundationModels.GenerationSchema, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions()) -> sending FoundationModels.LanguageModelSession.ResponseStream<FoundationModels.GeneratedContent>
  #else
  @_disfavoredOverload final public func streamResponse(to prompt: Swift.String, schema: FoundationModels.GenerationSchema, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions()) -> FoundationModels.LanguageModelSession.ResponseStream<FoundationModels.GeneratedContent>
  #endif
  #if compiler(>=5.3) && $SendingArgsAndResults
  final public func streamResponse(schema: FoundationModels.GenerationSchema, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions(), @FoundationModels.PromptBuilder prompt: () throws -> FoundationModels.Prompt) rethrows -> sending FoundationModels.LanguageModelSession.ResponseStream<FoundationModels.GeneratedContent>
  #else
  final public func streamResponse(schema: FoundationModels.GenerationSchema, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions(), @FoundationModels.PromptBuilder prompt: () throws -> FoundationModels.Prompt) rethrows -> FoundationModels.LanguageModelSession.ResponseStream<FoundationModels.GeneratedContent>
  #endif
  #if compiler(>=5.3) && $SendingArgsAndResults
  final public func streamResponse<Content>(to prompt: FoundationModels.Prompt, generating type: Content.Type = Content.self, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions()) -> sending FoundationModels.LanguageModelSession.ResponseStream<Content> where Content : FoundationModels.Generable
  #else
  final public func streamResponse<Content>(to prompt: FoundationModels.Prompt, generating type: Content.Type = Content.self, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions()) -> FoundationModels.LanguageModelSession.ResponseStream<Content> where Content : FoundationModels.Generable
  #endif
  #if compiler(>=5.3) && $SendingArgsAndResults
  @_disfavoredOverload final public func streamResponse<Content>(to prompt: Swift.String, generating type: Content.Type = Content.self, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions()) -> sending FoundationModels.LanguageModelSession.ResponseStream<Content> where Content : FoundationModels.Generable
  #else
  @_disfavoredOverload final public func streamResponse<Content>(to prompt: Swift.String, generating type: Content.Type = Content.self, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions()) -> FoundationModels.LanguageModelSession.ResponseStream<Content> where Content : FoundationModels.Generable
  #endif
  #if compiler(>=5.3) && $SendingArgsAndResults
  final public func streamResponse<Content>(generating type: Content.Type = Content.self, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions(), @FoundationModels.PromptBuilder prompt: () throws -> FoundationModels.Prompt) rethrows -> sending FoundationModels.LanguageModelSession.ResponseStream<Content> where Content : FoundationModels.Generable
  #else
  final public func streamResponse<Content>(generating type: Content.Type = Content.self, includeSchemaInPrompt: Swift.Bool = true, options: FoundationModels.GenerationOptions = GenerationOptions(), @FoundationModels.PromptBuilder prompt: () throws -> FoundationModels.Prompt) rethrows -> FoundationModels.LanguageModelSession.ResponseStream<Content> where Content : FoundationModels.Generable
  #endif
  #if compiler(>=5.3) && $SendingArgsAndResults
  final public func streamResponse(to prompt: FoundationModels.Prompt, options: FoundationModels.GenerationOptions = GenerationOptions()) -> sending FoundationModels.LanguageModelSession.ResponseStream<Swift.String>
  #else
  final public func streamResponse(to prompt: FoundationModels.Prompt, options: FoundationModels.GenerationOptions = GenerationOptions()) -> FoundationModels.LanguageModelSession.ResponseStream<Swift.String>
  #endif
  #if compiler(>=5.3) && $SendingArgsAndResults
  @_disfavoredOverload final public func streamResponse(to prompt: Swift.String, options: FoundationModels.GenerationOptions = GenerationOptions()) -> sending FoundationModels.LanguageModelSession.ResponseStream<Swift.String>
  #else
  @_disfavoredOverload final public func streamResponse(to prompt: Swift.String, options: FoundationModels.GenerationOptions = GenerationOptions()) -> FoundationModels.LanguageModelSession.ResponseStream<Swift.String>
  #endif
  #if compiler(>=5.3) && $SendingArgsAndResults
  final public func streamResponse(options: FoundationModels.GenerationOptions = GenerationOptions(), @FoundationModels.PromptBuilder prompt: () throws -> FoundationModels.Prompt) rethrows -> sending FoundationModels.LanguageModelSession.ResponseStream<Swift.String>
  #else
  final public func streamResponse(options: FoundationModels.GenerationOptions = GenerationOptions(), @FoundationModels.PromptBuilder prompt: () throws -> FoundationModels.Prompt) rethrows -> FoundationModels.LanguageModelSession.ResponseStream<Swift.String>
  #endif
}
@_hasMissingDesignatedInitializers @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
final public class SystemLanguageModel : Swift.Sendable {
  final public var availability: FoundationModels.SystemLanguageModel.Availability {
    get
  }
  final public var isAvailable: Swift.Bool {
    get
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct UseCase : Swift.Sendable, Swift.Equatable {
    public static let general: FoundationModels.SystemLanguageModel.UseCase
    public static let contentTagging: FoundationModels.SystemLanguageModel.UseCase
    public static func == (a: FoundationModels.SystemLanguageModel.UseCase, b: FoundationModels.SystemLanguageModel.UseCase) -> Swift.Bool
  }
  @objc deinit
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.SystemLanguageModel {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct Guardrails : Swift.Sendable {
    public static let `default`: FoundationModels.SystemLanguageModel.Guardrails
    public static let permissiveContentTransformations: FoundationModels.SystemLanguageModel.Guardrails
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.SystemLanguageModel {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @frozen public enum Availability : Swift.Equatable, Swift.Sendable {
    @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public enum UnavailableReason : Swift.Equatable, Swift.Sendable {
      case deviceNotEligible
      case appleIntelligenceNotEnabled
      case modelNotReady
      public static func == (a: FoundationModels.SystemLanguageModel.Availability.UnavailableReason, b: FoundationModels.SystemLanguageModel.Availability.UnavailableReason) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    case available
    case unavailable(FoundationModels.SystemLanguageModel.Availability.UnavailableReason)
    public static func == (a: FoundationModels.SystemLanguageModel.Availability, b: FoundationModels.SystemLanguageModel.Availability) -> Swift.Bool
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public static let `default`: FoundationModels.SystemLanguageModel
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  convenience public init(useCase: FoundationModels.SystemLanguageModel.UseCase = .general, guardrails: FoundationModels.SystemLanguageModel.Guardrails = Guardrails.default)
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  convenience public init(adapter: FoundationModels.SystemLanguageModel.Adapter, guardrails: FoundationModels.SystemLanguageModel.Guardrails = .default)
  final public var supportedLanguages: Swift.Set<Foundation.Locale.Language> {
    get
  }
  final public func supportsLocale(_ locale: Foundation.Locale = Locale.current) -> Swift.Bool
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.SystemLanguageModel : nonisolated Observation.Observable {
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.SystemLanguageModel {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct Adapter {
    public var creatorDefinedMetadata: [Swift.String : Any] {
      get
    }
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.SystemLanguageModel.Adapter {
  public init(fileURL: Foundation.URL) throws
  public init(name: Swift.String) throws
  public func compile() async throws
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public static func compatibleAdapterIdentifiers(name: Swift.String) -> [Swift.String]
  public static func removeObsoleteAdapters() throws
  public static func isCompatible(_ assetPack: BackgroundAssets.AssetPack) -> Swift.Bool
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension FoundationModels.SystemLanguageModel.Adapter {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public enum AssetError : Swift.Error, Foundation.LocalizedError {
    @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct Context : Swift.Sendable {
      public let debugDescription: Swift.String
      public init(debugDescription: Swift.String)
    }
    case invalidAsset(FoundationModels.SystemLanguageModel.Adapter.AssetError.Context)
    case invalidAdapterName(FoundationModels.SystemLanguageModel.Adapter.AssetError.Context)
    case compatibleAdapterNotFound(FoundationModels.SystemLanguageModel.Adapter.AssetError.Context)
    #if compiler(>=5.3) && $NonescapableTypes
    public var errorDescription: Swift.String? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var recoverySuggestion: Swift.String? {
      get
    }
    #endif
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct Transcript : Swift.Sendable, Swift.Equatable, Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public subscript(index: FoundationModels.Transcript.Index) -> FoundationModels.Transcript.Entry {
    get
    set
  }
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public init(entries: some Sequence<Entry> = [])
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public enum Entry : Swift.Sendable, Swift.Identifiable, Swift.Equatable {
    case instructions(FoundationModels.Transcript.Instructions)
    case prompt(FoundationModels.Transcript.Prompt)
    case toolCalls(FoundationModels.Transcript.ToolCalls)
    case toolOutput(FoundationModels.Transcript.ToolOutput)
    case response(FoundationModels.Transcript.Response)
    public var id: Swift.String {
      get
    }
    public static func == (a: FoundationModels.Transcript.Entry, b: FoundationModels.Transcript.Entry) -> Swift.Bool
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias ID = Swift.String
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public enum Segment : Swift.Sendable, Swift.Identifiable, Swift.Equatable {
    case text(FoundationModels.Transcript.TextSegment)
    case structure(FoundationModels.Transcript.StructuredSegment)
    public var id: Swift.String {
      get
    }
    public static func == (a: FoundationModels.Transcript.Segment, b: FoundationModels.Transcript.Segment) -> Swift.Bool
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias ID = Swift.String
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct TextSegment : Swift.Sendable, Swift.Identifiable, Swift.Equatable {
    public var id: Swift.String
    public var content: Swift.String
    public init(id: Swift.String = UUID().uuidString, content: Swift.String)
    public static func == (a: FoundationModels.Transcript.TextSegment, b: FoundationModels.Transcript.TextSegment) -> Swift.Bool
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias ID = Swift.String
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct StructuredSegment : Swift.Sendable, Swift.Identifiable, Swift.Equatable {
    public var id: Swift.String
    public var source: Swift.String
    public var content: FoundationModels.GeneratedContent {
      get
      set
    }
    public init(id: Swift.String = UUID().uuidString, source: Swift.String, content: FoundationModels.GeneratedContent)
    public static func == (a: FoundationModels.Transcript.StructuredSegment, b: FoundationModels.Transcript.StructuredSegment) -> Swift.Bool
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias ID = Swift.String
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct Instructions : Swift.Sendable, Swift.Identifiable, Swift.Equatable {
    public var id: Swift.String
    public var segments: [FoundationModels.Transcript.Segment]
    public var toolDefinitions: [FoundationModels.Transcript.ToolDefinition]
    public init(id: Swift.String = UUID().uuidString, segments: [FoundationModels.Transcript.Segment], toolDefinitions: [FoundationModels.Transcript.ToolDefinition])
    public static func == (a: FoundationModels.Transcript.Instructions, b: FoundationModels.Transcript.Instructions) -> Swift.Bool
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias ID = Swift.String
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct ToolDefinition : Swift.Sendable, Swift.Equatable {
    public var name: Swift.String
    public var description: Swift.String
    public init(name: Swift.String, description: Swift.String, parameters: FoundationModels.GenerationSchema)
    public init(tool: some Tool)
    public static func == (a: FoundationModels.Transcript.ToolDefinition, b: FoundationModels.Transcript.ToolDefinition) -> Swift.Bool
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct Prompt : Swift.Sendable, Swift.Identifiable, Swift.Equatable {
    public var id: Swift.String
    public var segments: [FoundationModels.Transcript.Segment]
    public var options: FoundationModels.GenerationOptions
    public var responseFormat: FoundationModels.Transcript.ResponseFormat?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(id: Swift.String = UUID().uuidString, segments: [FoundationModels.Transcript.Segment], options: FoundationModels.GenerationOptions = GenerationOptions(), responseFormat: FoundationModels.Transcript.ResponseFormat? = nil)
    #endif
    public static func == (a: FoundationModels.Transcript.Prompt, b: FoundationModels.Transcript.Prompt) -> Swift.Bool
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias ID = Swift.String
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct ResponseFormat : Swift.Sendable, Swift.Equatable {
    public var name: Swift.String {
      get
    }
    public init<Content>(type: Content.Type) where Content : FoundationModels.Generable
    public init(schema: FoundationModels.GenerationSchema)
    public static func == (a: FoundationModels.Transcript.ResponseFormat, b: FoundationModels.Transcript.ResponseFormat) -> Swift.Bool
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct ToolCalls : Swift.Sendable, Swift.Identifiable, Swift.Equatable, Swift.RandomAccessCollection {
    public var id: Swift.String
    public init<S>(id: Swift.String = UUID().uuidString, _ calls: S) where S : Swift.Sequence, S.Element == FoundationModels.Transcript.ToolCall
    public subscript(position: Swift.Int) -> FoundationModels.Transcript.ToolCall {
      get
    }
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public static func == (a: FoundationModels.Transcript.ToolCalls, b: FoundationModels.Transcript.ToolCalls) -> Swift.Bool
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Element = FoundationModels.Transcript.ToolCall
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias ID = Swift.String
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Index = Swift.Int
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Indices = Swift.Range<Swift.Int>
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Iterator = Swift.IndexingIterator<FoundationModels.Transcript.ToolCalls>
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias SubSequence = Swift.Slice<FoundationModels.Transcript.ToolCalls>
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct ToolCall : Swift.Sendable, Swift.Identifiable, Swift.Equatable {
    public var id: Swift.String
    public var toolName: Swift.String
    public var arguments: FoundationModels.GeneratedContent {
      get
      set
    }
    public init(id: Swift.String, toolName: Swift.String, arguments: FoundationModels.GeneratedContent)
    public static func == (a: FoundationModels.Transcript.ToolCall, b: FoundationModels.Transcript.ToolCall) -> Swift.Bool
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias ID = Swift.String
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct ToolOutput : Swift.Sendable, Swift.Identifiable, Swift.Equatable {
    public var id: Swift.String
    public var toolName: Swift.String
    public var segments: [FoundationModels.Transcript.Segment]
    public init(id: Swift.String, toolName: Swift.String, segments: [FoundationModels.Transcript.Segment])
    public static func == (a: FoundationModels.Transcript.ToolOutput, b: FoundationModels.Transcript.ToolOutput) -> Swift.Bool
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias ID = Swift.String
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct Response : Swift.Sendable, Swift.Identifiable, Swift.Equatable {
    public var id: Swift.String
    public var assetIDs: [Swift.String]
    public var segments: [FoundationModels.Transcript.Segment]
    public init(id: Swift.String = UUID().uuidString, assetIDs: [Swift.String], segments: [FoundationModels.Transcript.Segment])
    public static func == (a: FoundationModels.Transcript.Response, b: FoundationModels.Transcript.Response) -> Swift.Bool
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias ID = Swift.String
  }
  public static func == (a: FoundationModels.Transcript, b: FoundationModels.Transcript) -> Swift.Bool
  @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public typealias Element = FoundationModels.Transcript.Entry
  @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public typealias Indices = Swift.Range<FoundationModels.Transcript.Index>
  @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public typealias Iterator = Swift.IndexingIterator<FoundationModels.Transcript>
  @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public typealias SubSequence = Swift.Slice<FoundationModels.Transcript>
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension FoundationModels.Transcript : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension FoundationModels.Transcript.Entry : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension FoundationModels.Transcript.TextSegment : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension FoundationModels.Transcript.StructuredSegment : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension FoundationModels.Transcript.Segment : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension FoundationModels.Transcript.Instructions : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension FoundationModels.Transcript.Prompt : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension FoundationModels.Transcript.ResponseFormat : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension FoundationModels.Transcript.ToolCalls : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension FoundationModels.Transcript.ToolCall : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension FoundationModels.Transcript.ToolOutput : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension FoundationModels.Transcript.Response : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct Instructions : Swift.Sendable {
  public init(_ content: some InstructionsRepresentable)
  @usableFromInline
  internal init<each I>(_ components: repeat each I) where repeat each I : FoundationModels.InstructionsRepresentable
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol InstructionsRepresentable {
  @FoundationModels.InstructionsBuilder var instructionsRepresentation: FoundationModels.Instructions { get }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.Instructions : FoundationModels.InstructionsRepresentable {
  public var instructionsRepresentation: FoundationModels.Instructions {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Swift.String : FoundationModels.InstructionsRepresentable {
  public var instructionsRepresentation: FoundationModels.Instructions {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Swift.Array : FoundationModels.InstructionsRepresentable where Element : FoundationModels.InstructionsRepresentable {
  public var instructionsRepresentation: FoundationModels.Instructions {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@_functionBuilder public struct InstructionsBuilder {
  @_alwaysEmitIntoClient public static func buildBlock<each I>(_ components: repeat each I) -> FoundationModels.Instructions where repeat each I : FoundationModels.InstructionsRepresentable {
    Instructions(repeat each components)
  }
  @_alwaysEmitIntoClient public static func buildArray(_ instructions: [some InstructionsRepresentable]) -> FoundationModels.Instructions {
    Instructions(instructions)
  }
  @_alwaysEmitIntoClient public static func buildEither(first component: some InstructionsRepresentable) -> FoundationModels.Instructions {
    Instructions(component)
  }
  @_alwaysEmitIntoClient public static func buildEither(second component: some InstructionsRepresentable) -> FoundationModels.Instructions {
    Instructions(component)
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @_alwaysEmitIntoClient public static func buildOptional(_ instructions: FoundationModels.Instructions?) -> FoundationModels.Instructions {
    instructions ?? Instructions()
  }
  #endif
  @_alwaysEmitIntoClient public static func buildLimitedAvailability(_ instructions: some InstructionsRepresentable) -> FoundationModels.Instructions {
    Instructions(instructions)
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public static func buildExpression<I>(_ expression: I) -> I where I : FoundationModels.InstructionsRepresentable {
    expression
  }
  @_alwaysEmitIntoClient public static func buildExpression(_ expression: FoundationModels.Instructions) -> FoundationModels.Instructions {
    expression
  }
  @available(*, unavailable, message: "Only `Instructions` and `InstructionsRepresentable` are supported.")
  @_alwaysEmitIntoClient public static func buildExpression<T>(_ expression: T) -> FoundationModels.Instructions {
    fatalError()
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.Instructions {
  public init(@FoundationModels.InstructionsBuilder _ content: () throws -> FoundationModels.Instructions) rethrows
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct Prompt : Swift.Sendable {
  public init(_ content: some PromptRepresentable)
  @usableFromInline
  internal init<each P>(_ components: repeat each P) where repeat each P : FoundationModels.PromptRepresentable
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol PromptRepresentable {
  @FoundationModels.PromptBuilder var promptRepresentation: FoundationModels.Prompt { get }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.Prompt : FoundationModels.PromptRepresentable {
  public var promptRepresentation: FoundationModels.Prompt {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Swift.String : FoundationModels.PromptRepresentable {
  public var promptRepresentation: FoundationModels.Prompt {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Swift.Array : FoundationModels.PromptRepresentable where Element : FoundationModels.PromptRepresentable {
  public var promptRepresentation: FoundationModels.Prompt {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@_functionBuilder public struct PromptBuilder {
  @_alwaysEmitIntoClient public static func buildBlock<each P>(_ components: repeat each P) -> FoundationModels.Prompt where repeat each P : FoundationModels.PromptRepresentable {
    Prompt(repeat each components)
  }
  @_alwaysEmitIntoClient public static func buildArray(_ prompts: [some PromptRepresentable]) -> FoundationModels.Prompt {
    Prompt(prompts)
  }
  @_alwaysEmitIntoClient public static func buildEither(first component: some PromptRepresentable) -> FoundationModels.Prompt {
    Prompt(component)
  }
  @_alwaysEmitIntoClient public static func buildEither(second component: some PromptRepresentable) -> FoundationModels.Prompt {
    Prompt(component)
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @_alwaysEmitIntoClient public static func buildOptional(_ component: FoundationModels.Prompt?) -> FoundationModels.Prompt {
    component ?? Prompt()
  }
  #endif
  @_alwaysEmitIntoClient public static func buildLimitedAvailability(_ prompt: some PromptRepresentable) -> FoundationModels.Prompt {
    Prompt(prompt)
  }
  @_disfavoredOverload @_alwaysEmitIntoClient public static func buildExpression<P>(_ expression: P) -> P where P : FoundationModels.PromptRepresentable {
    expression
  }
  @_alwaysEmitIntoClient public static func buildExpression(_ expression: FoundationModels.Prompt) -> FoundationModels.Prompt {
    expression
  }
  @available(*, unavailable, message: "Only `Prompt` and `PromptRepresentable` are supported.")
  @_alwaysEmitIntoClient public static func buildExpression<T>(_ expression: T) -> FoundationModels.Prompt {
    fatalError()
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.Prompt {
  public init(@FoundationModels.PromptBuilder _ content: () throws -> FoundationModels.Prompt) rethrows
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol Tool<Arguments, Output> : Swift.Sendable {
  associatedtype Output : FoundationModels.PromptRepresentable
  associatedtype Arguments : FoundationModels.ConvertibleFromGeneratedContent
  var name: Swift.String { get }
  var description: Swift.String { get }
  var parameters: FoundationModels.GenerationSchema { get }
  var includesSchemaInInstructions: Swift.Bool { get }
  func call(arguments: Self.Arguments) async throws -> Self.Output
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.Tool {
  public var name: Swift.String {
    get
  }
  public var includesSchemaInInstructions: Swift.Bool {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.Tool where Self.Arguments : FoundationModels.Generable {
  public var parameters: FoundationModels.GenerationSchema {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.Tool where Self.Arguments == Swift.String {
  @available(*, unavailable, message: "'Tool' that uses 'String' as 'Arguments' type is unsupported. Use '@Generable' struct instead.")
  public var parameters: FoundationModels.GenerationSchema {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.Tool where Self.Arguments == Swift.Int {
  @available(*, unavailable, message: "'Tool' that uses 'Int' as 'Arguments' type is unsupported. Use '@Generable' struct instead.")
  public var parameters: FoundationModels.GenerationSchema {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.Tool where Self.Arguments == Swift.Double {
  @available(*, unavailable, message: "'Tool' that uses 'Double' as 'Arguments' type is unsupported. Use '@Generable' struct instead.")
  public var parameters: FoundationModels.GenerationSchema {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.Tool where Self.Arguments == Swift.Float {
  @available(*, unavailable, message: "'Tool' that uses 'Float' as 'Arguments' type is unsupported. Use '@Generable' struct instead.")
  public var parameters: FoundationModels.GenerationSchema {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.Tool where Self.Arguments == Foundation.Decimal {
  @available(*, unavailable, message: "'Tool' that uses 'Decimal' as 'Arguments' type is unsupported. Use '@Generable' struct instead.")
  public var parameters: FoundationModels.GenerationSchema {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.Tool where Self.Arguments == Swift.Bool {
  @available(*, unavailable, message: "'Tool' that uses 'Bool' as 'Arguments' type is unsupported. Use '@Generable' struct instead.")
  public var parameters: FoundationModels.GenerationSchema {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DynamicGenerationSchema : Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(name: Swift.String, description: Swift.String? = nil, properties: [FoundationModels.DynamicGenerationSchema.Property])
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(name: Swift.String, description: Swift.String? = nil, anyOf choices: [FoundationModels.DynamicGenerationSchema])
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(name: Swift.String, description: Swift.String? = nil, anyOf choices: [Swift.String])
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(arrayOf itemSchema: FoundationModels.DynamicGenerationSchema, minimumElements: Swift.Int? = nil, maximumElements: Swift.Int? = nil)
  #endif
  public init<Value>(type: Value.Type, guides: [FoundationModels.GenerationGuide<Value>] = []) where Value : FoundationModels.Generable
  public init(referenceTo name: Swift.String)
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct Property {
    #if compiler(>=5.3) && $NonescapableTypes
    public init(name: Swift.String, description: Swift.String? = nil, schema: FoundationModels.DynamicGenerationSchema, isOptional: Swift.Bool = false)
    #endif
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct GenerationID : Swift.Sendable, Swift.Hashable {
  public init()
  public static func == (a: FoundationModels.GenerationID, b: FoundationModels.GenerationID) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct GenerationOptions : Swift.Sendable, Swift.Equatable {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct SamplingMode : Swift.Sendable, Swift.Equatable {
    public static var greedy: FoundationModels.GenerationOptions.SamplingMode {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public static func random(top k: Swift.Int, seed: Swift.UInt64? = nil) -> FoundationModels.GenerationOptions.SamplingMode
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public static func random(probabilityThreshold: Swift.Double, seed: Swift.UInt64? = nil) -> FoundationModels.GenerationOptions.SamplingMode
    #endif
    public static func == (a: FoundationModels.GenerationOptions.SamplingMode, b: FoundationModels.GenerationOptions.SamplingMode) -> Swift.Bool
  }
  public var sampling: FoundationModels.GenerationOptions.SamplingMode?
  public var temperature: Swift.Double?
  public var maximumResponseTokens: Swift.Int?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(sampling: FoundationModels.GenerationOptions.SamplingMode? = nil, temperature: Swift.Double? = nil, maximumResponseTokens: Swift.Int? = nil)
  #endif
  public static func == (a: FoundationModels.GenerationOptions, b: FoundationModels.GenerationOptions) -> Swift.Bool
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct GenerationSchema : Swift.Sendable, Swift.Codable, Swift.CustomDebugStringConvertible {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct Property : Swift.Sendable {
    #if compiler(>=5.3) && $NonescapableTypes
    public init<Value>(name: Swift.String, description: Swift.String? = nil, type: Value.Type, guides: [FoundationModels.GenerationGuide<Value>] = []) where Value : FoundationModels.Generable
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init<Value>(name: Swift.String, description: Swift.String? = nil, type: Value?.Type, guides: [FoundationModels.GenerationGuide<Value>] = []) where Value : FoundationModels.Generable
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init<RegexOutput>(name: Swift.String, description: Swift.String? = nil, type: Swift.String.Type, guides: [_StringProcessing.Regex<RegexOutput>] = [])
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init<RegexOutput>(name: Swift.String, description: Swift.String? = nil, type: Swift.String?.Type, guides: [_StringProcessing.Regex<RegexOutput>] = [])
    #endif
  }
  public var debugDescription: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init(type: any FoundationModels.Generable.Type, description: Swift.String? = nil, properties: [FoundationModels.GenerationSchema.Property])
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(type: any FoundationModels.Generable.Type, description: Swift.String? = nil, anyOf choices: [Swift.String])
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(type: any FoundationModels.Generable.Type, description: Swift.String? = nil, anyOf types: [any FoundationModels.Generable.Type])
  #endif
  public init(root: FoundationModels.DynamicGenerationSchema, dependencies: [FoundationModels.DynamicGenerationSchema]) throws
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public enum SchemaError : Swift.Error, Foundation.LocalizedError {
    @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct Context : Swift.Sendable {
      public let debugDescription: Swift.String
      public init(debugDescription: Swift.String)
    }
    case duplicateType(schema: Swift.String?, type: Swift.String, context: FoundationModels.GenerationSchema.SchemaError.Context)
    case duplicateProperty(schema: Swift.String, property: Swift.String, context: FoundationModels.GenerationSchema.SchemaError.Context)
    case emptyTypeChoices(schema: Swift.String, context: FoundationModels.GenerationSchema.SchemaError.Context)
    case undefinedReferences(schema: Swift.String?, references: [Swift.String], context: FoundationModels.GenerationSchema.SchemaError.Context)
    #if compiler(>=5.3) && $NonescapableTypes
    public var errorDescription: Swift.String? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var recoverySuggestion: Swift.String? {
      get
    }
    #endif
  }
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct LanguageModelFeedback {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public enum Sentiment : Swift.Sendable, Swift.CaseIterable {
    case positive
    case negative
    case neutral
    public static func == (a: FoundationModels.LanguageModelFeedback.Sentiment, b: FoundationModels.LanguageModelFeedback.Sentiment) -> Swift.Bool
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias AllCases = [FoundationModels.LanguageModelFeedback.Sentiment]
    nonisolated public static var allCases: [FoundationModels.LanguageModelFeedback.Sentiment] {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public struct Issue : Swift.Sendable {
    @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public enum Category : Swift.Sendable, Swift.CaseIterable {
      case unhelpful
      case tooVerbose
      case didNotFollowInstructions
      case incorrect
      case stereotypeOrBias
      case suggestiveOrSexual
      case vulgarOrOffensive
      case triggeredGuardrailUnexpectedly
      public static func == (a: FoundationModels.LanguageModelFeedback.Issue.Category, b: FoundationModels.LanguageModelFeedback.Issue.Category) -> Swift.Bool
      @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
      @available(tvOS, unavailable)
      @available(watchOS, unavailable)
      public typealias AllCases = [FoundationModels.LanguageModelFeedback.Issue.Category]
      nonisolated public static var allCases: [FoundationModels.LanguageModelFeedback.Issue.Category] {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init(category: FoundationModels.LanguageModelFeedback.Issue.Category, explanation: Swift.String? = nil)
    #endif
  }
}
extension FoundationModels.LanguageModelSession {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @discardableResult
  final public func logFeedbackAttachment(sentiment: FoundationModels.LanguageModelFeedback.Sentiment?, issues: [FoundationModels.LanguageModelFeedback.Issue] = [], desiredOutput: FoundationModels.Transcript.Entry? = nil) -> Foundation.Data
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @backDeployed(before: iOS 26.1, macOS 26.1, visionOS 26.1)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @discardableResult
  final public func logFeedbackAttachment(sentiment: FoundationModels.LanguageModelFeedback.Sentiment?, issues: [FoundationModels.LanguageModelFeedback.Issue] = [], desiredResponseText: Swift.String?) -> Foundation.Data {
    let entry = desiredResponseText.map { content in
      let text = Transcript.TextSegment(content: content)
      let segment = Transcript.Segment.text(text)
      let response = Transcript.Response(assetIDs: [], segments: [segment])
      let entry = Transcript.Entry.response(response)
      return entry
    }
    return logFeedbackAttachment(
      sentiment: sentiment,
      issues: issues,
      desiredOutput: entry
    )
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @backDeployed(before: iOS 26.1, macOS 26.1, visionOS 26.1)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @discardableResult
  final public func logFeedbackAttachment(sentiment: FoundationModels.LanguageModelFeedback.Sentiment?, issues: [FoundationModels.LanguageModelFeedback.Issue] = [], desiredResponseContent: (any FoundationModels.ConvertibleToGeneratedContent)?) -> Foundation.Data {
    let entry = desiredResponseContent.map { desiredContent in
      let source = String(describing: type(of: desiredResponseContent))
      let content = desiredContent.generatedContent
      let structure = Transcript.StructuredSegment(source: source, content: content)
      let segment = Transcript.Segment.structure(structure)
      let response = Transcript.Response(assetIDs: [], segments: [segment])
      let entry = Transcript.Entry.response(response)
      return entry
    }
    return logFeedbackAttachment(
      sentiment: sentiment,
      issues: issues,
      desiredOutput: entry
    )
  }
  #endif
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.SystemLanguageModel.Availability.UnavailableReason : Swift.Hashable {}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.LanguageModelFeedback.Sentiment : Swift.Equatable {}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.LanguageModelFeedback.Sentiment : Swift.Hashable {}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.LanguageModelFeedback.Issue.Category : Swift.Equatable {}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension FoundationModels.LanguageModelFeedback.Issue.Category : Swift.Hashable {}
