// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 effective-5.10 (swiftlang-6.2.1.4.7 clang-1700.4.4.1)
// swift-module-flags: -target x86_64-apple-ios19.0-macabi -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 2303.1.8 -module-name AlarmKit -package-name com.apple.AlarmKit
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.1
import ActivityKit
@_exported import AlarmKit
import AppIntents
import Foundation
import Swift
import SwiftUI
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@available(iOS 26.0, *)
@available(macCatalyst, unavailable)
public struct AlarmAttributes<Metadata> : ActivityKit.ActivityAttributes, Swift.Sendable where Metadata : AlarmKit.AlarmMetadata {
  public typealias ContentState = AlarmKit.AlarmPresentationState
  public var presentation: AlarmKit.AlarmPresentation
  public var metadata: Metadata?
  public var tintColor: SwiftUICore.Color
  #if compiler(>=5.3) && $NonescapableTypes
  public init(presentation: AlarmKit.AlarmPresentation, metadata: Metadata? = nil, tintColor: SwiftUICore.Color)
  #endif
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 26.0, *)
@available(macCatalyst, unavailable)
public struct AlarmButton : Swift.Codable, Swift.Sendable {
  public var text: Foundation.LocalizedStringResource
  public var textColor: SwiftUICore.Color
  public var systemImageName: Swift.String
  public init(text: Foundation.LocalizedStringResource, textColor: SwiftUICore.Color, systemImageName: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 26.0, *)
@available(macCatalyst, unavailable)
public protocol AlarmMetadata : Swift.Decodable, Swift.Encodable, Swift.Hashable, Swift.Sendable {
}
@available(iOS 26.0, *)
@available(macCatalyst, unavailable)
public struct AlarmPresentation : Swift.Codable, Swift.Sendable {
  public struct Alert : Swift.Codable, Swift.Sendable {
    public enum SecondaryButtonBehavior : Swift.Codable, Swift.Sendable, Swift.Hashable {
      case countdown
      case custom
      public static func == (a: AlarmKit.AlarmPresentation.Alert.SecondaryButtonBehavior, b: AlarmKit.AlarmPresentation.Alert.SecondaryButtonBehavior) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public var title: Foundation.LocalizedStringResource
    public var stopButton: AlarmKit.AlarmButton
    public var secondaryButton: AlarmKit.AlarmButton?
    public var secondaryButtonBehavior: AlarmKit.AlarmPresentation.Alert.SecondaryButtonBehavior?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(title: Foundation.LocalizedStringResource, stopButton: AlarmKit.AlarmButton, secondaryButton: AlarmKit.AlarmButton? = nil, secondaryButtonBehavior: AlarmKit.AlarmPresentation.Alert.SecondaryButtonBehavior? = nil)
    #endif
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Countdown : Swift.Codable, Swift.Sendable {
    public var title: Foundation.LocalizedStringResource
    public var pauseButton: AlarmKit.AlarmButton?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(title: Foundation.LocalizedStringResource, pauseButton: AlarmKit.AlarmButton? = nil)
    #endif
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Paused : Swift.Codable, Swift.Sendable {
    public var title: Foundation.LocalizedStringResource
    public var resumeButton: AlarmKit.AlarmButton
    public init(title: Foundation.LocalizedStringResource, resumeButton: AlarmKit.AlarmButton)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public var alert: AlarmKit.AlarmPresentation.Alert
  public var countdown: AlarmKit.AlarmPresentation.Countdown?
  public var paused: AlarmKit.AlarmPresentation.Paused?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(alert: AlarmKit.AlarmPresentation.Alert, countdown: AlarmKit.AlarmPresentation.Countdown? = nil, paused: AlarmKit.AlarmPresentation.Paused? = nil)
  #endif
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 26.0, *)
@available(macCatalyst, unavailable)
public struct AlarmPresentationState : Swift.Codable, Swift.Sendable, Swift.Hashable {
  public enum Mode : Swift.Codable, Swift.Equatable, Swift.Sendable, Swift.Hashable {
    public struct Countdown : Swift.Codable, Swift.Equatable, Swift.Sendable, Swift.Hashable {
      public var totalCountdownDuration: Foundation.TimeInterval
      public var previouslyElapsedDuration: Foundation.TimeInterval
      public var startDate: Foundation.Date
      public var fireDate: Foundation.Date
      public init(totalCountdownDuration: Foundation.TimeInterval, previouslyElapsedDuration: Foundation.TimeInterval, startDate: Foundation.Date, fireDate: Foundation.Date)
      public static func == (a: AlarmKit.AlarmPresentationState.Mode.Countdown, b: AlarmKit.AlarmPresentationState.Mode.Countdown) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct Paused : Swift.Codable, Swift.Equatable, Swift.Sendable, Swift.Hashable {
      public var totalCountdownDuration: Foundation.TimeInterval
      public var previouslyElapsedDuration: Foundation.TimeInterval
      public init(totalCountdownDuration: Foundation.TimeInterval, previouslyElapsedDuration: Foundation.TimeInterval)
      public static func == (a: AlarmKit.AlarmPresentationState.Mode.Paused, b: AlarmKit.AlarmPresentationState.Mode.Paused) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct Alert : Swift.Codable, Swift.Equatable, Swift.Sendable, Swift.Hashable {
      public var time: AlarmKit.Alarm.Schedule.Relative.Time
      public init(time: AlarmKit.Alarm.Schedule.Relative.Time)
      public static func == (a: AlarmKit.AlarmPresentationState.Mode.Alert, b: AlarmKit.AlarmPresentationState.Mode.Alert) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    case alert(AlarmKit.AlarmPresentationState.Mode.Alert)
    case countdown(AlarmKit.AlarmPresentationState.Mode.Countdown)
    case paused(AlarmKit.AlarmPresentationState.Mode.Paused)
    public static func == (a: AlarmKit.AlarmPresentationState.Mode, b: AlarmKit.AlarmPresentationState.Mode) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public var alarmID: AlarmKit.Alarm.ID
  public var mode: AlarmKit.AlarmPresentationState.Mode
  public init(alarmID: AlarmKit.Alarm.ID, mode: AlarmKit.AlarmPresentationState.Mode)
  public static func == (a: AlarmKit.AlarmPresentationState, b: AlarmKit.AlarmPresentationState) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 26.0, *)
@available(macCatalyst, unavailable)
public struct Alarm : Swift.Identifiable, Swift.Codable, Swift.Sendable {
  public enum Schedule : Swift.Codable, Swift.Equatable, Swift.Hashable, Swift.Sendable {
    public struct Relative : Swift.Codable, Swift.Equatable, Swift.Sendable, Swift.Hashable {
      public struct Time : Swift.Codable, Swift.Equatable, Swift.Sendable, Swift.Hashable {
        public var hour: Swift.Int
        public var minute: Swift.Int
        public init(hour: Swift.Int, minute: Swift.Int)
        public static func == (a: AlarmKit.Alarm.Schedule.Relative.Time, b: AlarmKit.Alarm.Schedule.Relative.Time) -> Swift.Bool
        public func encode(to encoder: any Swift.Encoder) throws
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
        public init(from decoder: any Swift.Decoder) throws
      }
      public enum Recurrence : Swift.Codable, Swift.Equatable, Swift.Sendable, Swift.Hashable {
        case weekly([Foundation.Locale.Weekday])
        case never
        public static func == (a: AlarmKit.Alarm.Schedule.Relative.Recurrence, b: AlarmKit.Alarm.Schedule.Relative.Recurrence) -> Swift.Bool
        public func encode(to encoder: any Swift.Encoder) throws
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
        public init(from decoder: any Swift.Decoder) throws
      }
      public var repeats: AlarmKit.Alarm.Schedule.Relative.Recurrence
      public var time: AlarmKit.Alarm.Schedule.Relative.Time
      public init(time: AlarmKit.Alarm.Schedule.Relative.Time, repeats: AlarmKit.Alarm.Schedule.Relative.Recurrence = .never)
      public static func == (a: AlarmKit.Alarm.Schedule.Relative, b: AlarmKit.Alarm.Schedule.Relative) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    case fixed(Foundation.Date)
    case relative(AlarmKit.Alarm.Schedule.Relative)
    public static func == (a: AlarmKit.Alarm.Schedule, b: AlarmKit.Alarm.Schedule) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct CountdownDuration : Swift.Codable, Swift.Sendable, Swift.Equatable {
    public var preAlert: Foundation.TimeInterval?
    public var postAlert: Foundation.TimeInterval?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(preAlert: Foundation.TimeInterval?, postAlert: Foundation.TimeInterval?)
    #endif
    public static func == (a: AlarmKit.Alarm.CountdownDuration, b: AlarmKit.Alarm.CountdownDuration) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum State : Swift.Equatable, Swift.Codable, Swift.Sendable {
    case scheduled
    case countdown
    case paused
    case alerting
    public static func == (a: AlarmKit.Alarm.State, b: AlarmKit.Alarm.State) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public var id: Foundation.UUID
  public var schedule: AlarmKit.Alarm.Schedule?
  public var countdownDuration: AlarmKit.Alarm.CountdownDuration?
  public var state: AlarmKit.Alarm.State
  @available(iOS 26.0, *)
  @available(macCatalyst, unavailable)
  public typealias ID = Foundation.UUID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers @available(iOS 26.0, *)
@available(macCatalyst, unavailable)
public class AlarmManager {
  public enum AlarmError : Swift.Error {
    case maximumLimitReached
    public static func == (a: AlarmKit.AlarmManager.AlarmError, b: AlarmKit.AlarmManager.AlarmError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum AuthorizationState : Swift.Codable, Swift.Sendable {
    case notDetermined
    case denied
    case authorized
    public static func == (a: AlarmKit.AlarmManager.AuthorizationState, b: AlarmKit.AlarmManager.AuthorizationState) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct AlarmConfiguration<Metadata> where Metadata : AlarmKit.AlarmMetadata {
    #if compiler(>=5.3) && $NonescapableTypes
    public init(countdownDuration: AlarmKit.Alarm.CountdownDuration? = nil, schedule: AlarmKit.Alarm.Schedule? = nil, attributes: AlarmKit.AlarmAttributes<Metadata>, stopIntent: (any AppIntents.LiveActivityIntent)? = nil, secondaryIntent: (any AppIntents.LiveActivityIntent)? = nil, sound: ActivityKit.AlertConfiguration.AlertSound = .default)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public static func timer(duration: Foundation.TimeInterval, attributes: AlarmKit.AlarmAttributes<Metadata>, stopIntent: (any AppIntents.LiveActivityIntent)? = nil, secondaryIntent: (any AppIntents.LiveActivityIntent)? = nil, sound: ActivityKit.AlertConfiguration.AlertSound = .default) -> AlarmKit.AlarmManager.AlarmConfiguration<Metadata>
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public static func alarm(schedule: AlarmKit.Alarm.Schedule? = nil, attributes: AlarmKit.AlarmAttributes<Metadata>, stopIntent: (any AppIntents.LiveActivityIntent)? = nil, secondaryIntent: (any AppIntents.LiveActivityIntent)? = nil, sound: ActivityKit.AlertConfiguration.AlertSound = .default) -> AlarmKit.AlarmManager.AlarmConfiguration<Metadata>
    #endif
  }
  public static let shared: AlarmKit.AlarmManager
  public func schedule<Metadata>(id: AlarmKit.Alarm.ID, configuration: AlarmKit.AlarmManager.AlarmConfiguration<Metadata>) async throws -> AlarmKit.Alarm where Metadata : AlarmKit.AlarmMetadata
  public func countdown(id: AlarmKit.Alarm.ID) throws
  public func cancel(id: AlarmKit.Alarm.ID) throws
  public func stop(id: AlarmKit.Alarm.ID) throws
  public func pause(id: AlarmKit.Alarm.ID) throws
  public func resume(id: AlarmKit.Alarm.ID) throws
  public var alarms: [AlarmKit.Alarm] {
    get throws
  }
  public var alarmUpdates: some _Concurrency.AsyncSequence<Swift.Array<AlarmKit.Alarm>, Swift.Never> {
    get
  }
  public var authorizationState: AlarmKit.AlarmManager.AuthorizationState {
    get
  }
  public func requestAuthorization() async throws -> AlarmKit.AlarmManager.AuthorizationState
  public var authorizationUpdates: some _Concurrency.AsyncSequence<AlarmKit.AlarmManager.AuthorizationState, Swift.Never> {
    get
  }
  public struct AlarmUpdates : _Concurrency.AsyncSequence {
    public typealias Element = [AlarmKit.Alarm]
    public func makeAsyncIterator() -> AlarmKit.AlarmManager.AlarmUpdates.Iterator
    public struct Iterator : _Concurrency.AsyncIteratorProtocol {
      #if compiler(>=5.3) && $NonescapableTypes
      public mutating func next() async -> AlarmKit.AlarmManager.AlarmUpdates.Element?
      #endif
      @available(iOS 26.0, *)
      @available(macCatalyst, unavailable)
      public typealias Element = AlarmKit.AlarmManager.AlarmUpdates.Element
      @available(iOS 26.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
      @available(macCatalyst, unavailable)
      @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    }
    @available(iOS 26.0, *)
    @available(macCatalyst, unavailable)
    public typealias AsyncIterator = AlarmKit.AlarmManager.AlarmUpdates.Iterator
    @available(iOS 26.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @available(macCatalyst, unavailable)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  }
  public struct AlarmAuthorizationStateUpdates : _Concurrency.AsyncSequence {
    public typealias Element = AlarmKit.AlarmManager.AuthorizationState
    public func makeAsyncIterator() -> AlarmKit.AlarmManager.AlarmAuthorizationStateUpdates.Iterator
    public struct Iterator : _Concurrency.AsyncIteratorProtocol {
      #if compiler(>=5.3) && $NonescapableTypes
      public mutating func next() async -> AlarmKit.AlarmManager.AuthorizationState?
      #endif
      @available(iOS 26.0, *)
      @available(macCatalyst, unavailable)
      public typealias Element = AlarmKit.AlarmManager.AuthorizationState
      @available(iOS 26.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
      @available(macCatalyst, unavailable)
      @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    }
    @available(iOS 26.0, *)
    @available(macCatalyst, unavailable)
    public typealias AsyncIterator = AlarmKit.AlarmManager.AlarmAuthorizationStateUpdates.Iterator
    @available(iOS 26.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @available(macCatalyst, unavailable)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  }
  @objc deinit
}
@available(iOS 26.0, *)
@available(macCatalyst, unavailable)
extension AlarmKit.Alarm.State : Swift.Hashable {}
@available(iOS 26.0, *)
@available(macCatalyst, unavailable)
extension AlarmKit.AlarmManager.AlarmError : Swift.Equatable {}
@available(iOS 26.0, *)
@available(macCatalyst, unavailable)
extension AlarmKit.AlarmManager.AlarmError : Swift.Hashable {}
@available(iOS 26.0, *)
@available(macCatalyst, unavailable)
extension AlarmKit.AlarmManager.AuthorizationState : Swift.Equatable {}
@available(iOS 26.0, *)
@available(macCatalyst, unavailable)
extension AlarmKit.AlarmManager.AuthorizationState : Swift.Hashable {}
