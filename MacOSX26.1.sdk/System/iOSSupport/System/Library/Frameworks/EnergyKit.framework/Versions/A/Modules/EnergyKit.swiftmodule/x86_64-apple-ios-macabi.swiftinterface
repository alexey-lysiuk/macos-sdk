// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 effective-5.10 (swiftlang-6.2.1.4.7 clang-1700.4.4.1)
// swift-module-flags: -target x86_64-apple-ios26.1-macabi -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-upcoming-feature InternalImportsByDefault -enable-upcoming-feature ExistentialAny -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 378.2.7 -module-name EnergyKit
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.1
public import CoreLocation
public import Foundation
public import Swift
public import _Concurrency
public import _StringProcessing
public import _SwiftConcurrencyShims
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
@available(watchOS, unavailable)
public protocol ElectricalLoadEventProtocol : Swift.Decodable, Swift.Encodable, Swift.Identifiable, Swift.Sendable {
}
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
@available(watchOS, unavailable)
public struct ElectricHVACLoadEvent : EnergyKit.ElectricalLoadEventProtocol {
  public struct ElectricalMeasurement : Swift.Codable, Swift.Sendable {
    public let stage: Swift.Int
    public init(stage: Swift.Int)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Session : Swift.Codable, Swift.Sendable {
    public enum State : Swift.Codable, Swift.Equatable, Swift.Sendable {
      case begin
      case end
      case active
      public static func == (a: EnergyKit.ElectricHVACLoadEvent.Session.State, b: EnergyKit.ElectricHVACLoadEvent.Session.State) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct GuidanceState : Swift.Codable, Swift.Sendable {
      public let wasFollowingGuidance: Swift.Bool
      public var guidanceToken: Foundation.UUID
      public init(wasFollowingGuidance: Swift.Bool, guidanceToken: Foundation.UUID)
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
    }
    public let id: Foundation.UUID
    public let state: EnergyKit.ElectricHVACLoadEvent.Session.State
    public let guidanceState: EnergyKit.ElectricHVACLoadEvent.Session.GuidanceState
    public init(id: Foundation.UUID, state: EnergyKit.ElectricHVACLoadEvent.Session.State, guidanceState: EnergyKit.ElectricHVACLoadEvent.Session.GuidanceState)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public let id: Foundation.UUID
  public let timestamp: Foundation.Date
  public let session: EnergyKit.ElectricHVACLoadEvent.Session
  public let measurement: EnergyKit.ElectricHVACLoadEvent.ElectricalMeasurement
  public let deviceID: Swift.String
  public init(timestamp: Foundation.Date, measurement: EnergyKit.ElectricHVACLoadEvent.ElectricalMeasurement, session: EnergyKit.ElectricHVACLoadEvent.Session, deviceID: Swift.String)
  @available(iOS 26.0, macOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @available(visionOS, unavailable)
  public typealias ID = Foundation.UUID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
@available(watchOS, unavailable)
public struct ElectricVehicleLoadEvent : EnergyKit.ElectricalLoadEventProtocol {
  public struct ElectricalMeasurement : Swift.Codable, Swift.Sendable {
    public let stateOfCharge: Swift.Int
    public let power: Foundation.Measurement<Foundation.UnitPower>
    public let energy: Foundation.Measurement<Foundation.UnitEnergy>
    public let direction: EnergyKit.ElectricityFlowDirection
    public init(stateOfCharge: Swift.Int, direction: EnergyKit.ElectricityFlowDirection, power: Foundation.Measurement<Foundation.UnitPower>, energy: Foundation.Measurement<Foundation.UnitEnergy>)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Session : Swift.Codable, Swift.Sendable {
    public enum State : Swift.Codable, Swift.Equatable, Swift.Sendable {
      case begin
      case end
      case active
      public static func == (a: EnergyKit.ElectricVehicleLoadEvent.Session.State, b: EnergyKit.ElectricVehicleLoadEvent.Session.State) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct GuidanceState : Swift.Codable, Swift.Sendable {
      public let wasFollowingGuidance: Swift.Bool
      public var guidanceToken: Foundation.UUID
      public init(wasFollowingGuidance: Swift.Bool, guidanceToken: Foundation.UUID)
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
    }
    public let id: Foundation.UUID
    public let state: EnergyKit.ElectricVehicleLoadEvent.Session.State
    public let guidanceState: EnergyKit.ElectricVehicleLoadEvent.Session.GuidanceState
    public init(id: Foundation.UUID, state: EnergyKit.ElectricVehicleLoadEvent.Session.State, guidanceState: EnergyKit.ElectricVehicleLoadEvent.Session.GuidanceState)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public let id: Foundation.UUID
  public let timestamp: Foundation.Date
  public let session: EnergyKit.ElectricVehicleLoadEvent.Session
  public let measurement: EnergyKit.ElectricVehicleLoadEvent.ElectricalMeasurement
  public let deviceID: Swift.String
  public init(timestamp: Foundation.Date, measurement: EnergyKit.ElectricVehicleLoadEvent.ElectricalMeasurement, session: EnergyKit.ElectricVehicleLoadEvent.Session, deviceID: Swift.String)
  @available(iOS 26.0, macOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @available(visionOS, unavailable)
  public typealias ID = Foundation.UUID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
extension Foundation.UnitEnergy {
  @objc @_inheritsConvenienceInitializers public class EnergyKit : Foundation.Unit, @unchecked Swift.Sendable {
    public static let milliwattHours: Foundation.UnitEnergy
    @objc override dynamic public init(symbol: Swift.String)
    #if compiler(>=5.3) && $NonescapableTypes
    @objc required dynamic public init?(coder: Foundation.NSCoder)
    #endif
    @objc deinit
  }
}
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
public struct ElectricityGuidance : Swift.Codable, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class Service : Swift.Sendable {
    @objc deinit
    final public func guidance(using query: EnergyKit.ElectricityGuidance.Query, at energyVenueID: Foundation.UUID) -> some _Concurrency.AsyncSequence<EnergyKit.ElectricityGuidance, any Swift.Error>
    
  }
  public struct Query : Swift.Codable, Swift.Sendable {
    public init(suggestedAction: EnergyKit.ElectricityGuidance.SuggestedAction)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum SuggestedAction : Swift.Codable, Swift.Equatable, Swift.Sendable {
    case shift
    case reduce
    public static func == (a: EnergyKit.ElectricityGuidance.SuggestedAction, b: EnergyKit.ElectricityGuidance.SuggestedAction) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Value : Swift.Codable, Swift.Sendable {
    public let interval: Foundation.DateInterval
    public let rating: Swift.Double
    public init(interval: Foundation.DateInterval, rating: Swift.Double)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum Options : Swift.Codable, Swift.Hashable, Swift.Sendable, Swift.CaseIterable {
    case locationHasRatePlan
    case guidanceIncorporatesRatePlan
    public static func == (a: EnergyKit.ElectricityGuidance.Options, b: EnergyKit.ElectricityGuidance.Options) -> Swift.Bool
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, unavailable)
    public typealias AllCases = [EnergyKit.ElectricityGuidance.Options]
    nonisolated public static var allCases: [EnergyKit.ElectricityGuidance.Options] {
      get
    }
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public let guidanceToken: Foundation.UUID
  public let energyVenueID: Foundation.UUID
  public let suggestedAction: EnergyKit.ElectricityGuidance.SuggestedAction
  public let interval: Foundation.DateInterval
  public let values: [EnergyKit.ElectricityGuidance.Value]
  public let options: Swift.Set<EnergyKit.ElectricityGuidance.Options>
  public static let sharedService: EnergyKit.ElectricityGuidance.Service
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
@available(tvOS, unavailable)
public protocol ElectricityInsightMeasure {
}
@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
@available(tvOS, unavailable)
extension Swift.Duration : EnergyKit.ElectricityInsightMeasure {
}
@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
@available(tvOS, unavailable)
extension Foundation.Measurement : EnergyKit.ElectricityInsightMeasure where UnitType == Foundation.UnitEnergy {
}
@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
@available(tvOS, unavailable)
public struct ElectricityInsightQuery : Swift.Codable, Swift.Sendable {
  public struct Options : Swift.OptionSet, Swift.Codable, Swift.Hashable, Swift.Sendable {
    public let rawValue: Swift.UInt
    public static let cleanliness: EnergyKit.ElectricityInsightQuery.Options
    public static let tariff: EnergyKit.ElectricityInsightQuery.Options
    public init(rawValue: Swift.UInt)
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, unavailable)
    public typealias ArrayLiteralElement = EnergyKit.ElectricityInsightQuery.Options
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, unavailable)
    public typealias Element = EnergyKit.ElectricityInsightQuery.Options
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @available(visionOS, unavailable)
    public typealias RawValue = Swift.UInt
  }
  public enum Granularity : Swift.Codable, Swift.Equatable, Swift.Sendable {
    case hourly
    case daily
    case weekly
    case monthly
    case yearly
    public static func == (a: EnergyKit.ElectricityInsightQuery.Granularity, b: EnergyKit.ElectricityInsightQuery.Granularity) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public let range: Foundation.DateInterval
  public let options: EnergyKit.ElectricityInsightQuery.Options
  public let granularity: EnergyKit.ElectricityInsightQuery.Granularity
  public let flowDirection: EnergyKit.ElectricityFlowDirection
  public init(options: EnergyKit.ElectricityInsightQuery.Options, range: Foundation.DateInterval, granularity: EnergyKit.ElectricityInsightQuery.Granularity, flowDirection: EnergyKit.ElectricityFlowDirection)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
@available(tvOS, unavailable)
public struct ElectricityInsightRecord<Measure> where Measure : EnergyKit.ElectricityInsightMeasure {
  public let range: Foundation.DateInterval
  public var totalEnergy: Foundation.Measurement<Foundation.UnitEnergy>?
  public var totalRuntime: Swift.Duration?
  @available(iOS 26.1, macOS 26.1, *)
  @available(watchOS, unavailable)
  @available(visionOS, unavailable)
  @available(tvOS, unavailable)
  public var dataByGridCleanliness: EnergyKit.ElectricityInsightRecord<Measure>.GridCleanliness?
  public var dataByTariffPeak: EnergyKit.ElectricityInsightRecord<Measure>.TariffPeak?
  @available(iOS 26.1, macOS 26.1, *)
  @available(watchOS, unavailable)
  @available(visionOS, unavailable)
  @available(tvOS, unavailable)
  public struct GridCleanliness {
    public var cleaner: Measure?
    public var lessClean: Measure?
    public var avoid: Measure?
    public var unknown: Measure?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(cleaner: Measure?, lessClean: Measure?, avoid: Measure?, unknown: Measure?)
    #endif
  }
  public struct TariffPeak {
    public var superOffPeak: Measure?
    public var offPeak: Measure?
    public var partialPeak: Measure?
    public var onPeak: Measure?
    public var criticalPeak: Measure?
    public var unknown: Measure?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(superOffPeak: Measure?, offPeak: Measure?, partialPeak: Measure?, onPeak: Measure?, criticalPeak: Measure?, unknown: Measure?)
    #endif
  }
}
@_hasMissingDesignatedInitializers @available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
@available(tvOS, unavailable)
final public actor ElectricityInsightService {
  public static let shared: EnergyKit.ElectricityInsightService
  @available(watchOS, unavailable)
  final public func energyInsights(forDeviceID deviceID: Swift.String, using query: EnergyKit.ElectricityInsightQuery, atVenue energyVenueID: Foundation.UUID) async throws -> _Concurrency.AsyncStream<EnergyKit.ElectricityInsightRecord<Foundation.Measurement<Foundation.UnitEnergy>>>
  @available(watchOS, unavailable)
  final public func runtimeInsights(forDeviceID deviceID: Swift.String, using query: EnergyKit.ElectricityInsightQuery, atVenue energyVenueID: Foundation.UUID) async throws -> _Concurrency.AsyncStream<EnergyKit.ElectricityInsightRecord<Swift.Duration>>
  @objc deinit
  @available(iOS 26.0, macOS 26.0, *)
  @available(tvOS, unavailable, introduced: 13.0)
  @available(watchOS, unavailable)
  @available(visionOS, unavailable)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
public enum ElectricityFlowDirection : Swift.Codable, Swift.Equatable, Swift.Sendable {
  case imported
  case exported
  public static func == (a: EnergyKit.ElectricityFlowDirection, b: EnergyKit.ElectricityFlowDirection) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
public enum EnergyKitError : Foundation.LocalizedError {
  case guidanceUnavailable
  case inProgress
  case invalidLoadEvent
  @available(iOS 26.1, macOS 26.1, *)
  @available(visionOS, unavailable)
  case locationServicesDenied
  case permissionDenied
  @available(iOS 26.1, macOS 26.1, *)
  @available(visionOS, unavailable)
  case rateLimitExceeded
  case serviceUnavailable
  @available(iOS 26.1, macOS 26.1, *)
  @available(visionOS, unavailable)
  case unsupportedRegion
  case venueUnavailable
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var failureReason: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var helpAnchor: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var recoverySuggestion: Swift.String? {
    get
  }
  #endif
  public static func == (a: EnergyKit.EnergyKitError, b: EnergyKit.EnergyKitError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
public struct EnergyVenue : Swift.Codable, Swift.Identifiable, Swift.Sendable {
  public let name: Swift.String
  public let id: Foundation.UUID
  @available(iOS 26.1, macOS 26.1, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @available(visionOS, unavailable)
  public static func venues() async throws -> [EnergyKit.EnergyVenue]
  @available(iOS 26.0, macOS 26.0, *)
  @available(tvOS, unavailable)
  @available(visionOS, unavailable)
  @available(watchOS, unavailable)
  public func submitEvents<Event>(_ events: [Event]) async throws where Event : EnergyKit.ElectricalLoadEventProtocol
  @available(iOS 26.1, macOS 26.1, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @available(visionOS, unavailable)
  public static func venue(for id: Foundation.UUID) async throws -> EnergyKit.EnergyVenue
  @available(iOS 26.1, macOS 26.1, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @available(visionOS, unavailable)
  public static func venue(matchingHomeUniqueIdentifier: Foundation.UUID) async throws -> EnergyKit.EnergyVenue
  @available(iOS 26.0, macOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @available(visionOS, unavailable)
  public typealias ID = Foundation.UUID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
@available(watchOS, unavailable)
extension EnergyKit.ElectricHVACLoadEvent.Session.State : Swift.Hashable {}
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(visionOS, unavailable)
@available(watchOS, unavailable)
extension EnergyKit.ElectricVehicleLoadEvent.Session.State : Swift.Hashable {}
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension EnergyKit.ElectricityGuidance.SuggestedAction : Swift.Hashable {}
@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
@available(tvOS, unavailable)
extension EnergyKit.ElectricityInsightQuery.Granularity : Swift.Hashable {}
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension EnergyKit.ElectricityFlowDirection : Swift.Hashable {}
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension EnergyKit.EnergyKitError : Swift.Equatable {}
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension EnergyKit.EnergyKitError : Swift.Hashable {}
