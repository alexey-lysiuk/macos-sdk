// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2 effective-5.10 (swiftlang-6.2.0.17.14 clang-1700.3.17.1)
// swift-module-flags: -target x86_64-apple-macos26.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-upcoming-feature MemberImportVisibility -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 420.1.1 -module-name CompositorServices
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2
import ARKit
import Combine
@_exported import CompositorServices
import CoreImage
import CoreMedia
import Foundation
import Metal
import Network
import Spatial
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
extension CompositorServices.LayerRenderer {
  @available(visionOS 1.0, macOS 26.0, *)
  public struct Capabilities {
  }
}
@available(visionOS 1.0, macOS 26.0, *)
extension CompositorServices.LayerRenderer.Capabilities {
  public struct SupportedColorFormatsOptions : Swift.OptionSet {
    public let rawValue: Swift.UInt32
    public init(rawValue: Swift.UInt32)
    public static let progressiveImmersionEnabled: CompositorServices.LayerRenderer.Capabilities.SupportedColorFormatsOptions
    @available(visionOS 1.0, macOS 26.0, *)
    public typealias ArrayLiteralElement = CompositorServices.LayerRenderer.Capabilities.SupportedColorFormatsOptions
    @available(visionOS 1.0, macOS 26.0, *)
    public typealias Element = CompositorServices.LayerRenderer.Capabilities.SupportedColorFormatsOptions
    @available(visionOS 1.0, macOS 26.0, *)
    public typealias RawValue = Swift.UInt32
  }
  public struct SupportedLayoutsOptions : Swift.OptionSet {
    public let rawValue: Swift.UInt32
    public init(rawValue: Swift.UInt32)
    public static let foveationEnabled: CompositorServices.LayerRenderer.Capabilities.SupportedLayoutsOptions
    public static let progressiveImmersionEnabled: CompositorServices.LayerRenderer.Capabilities.SupportedLayoutsOptions
    @available(visionOS 1.0, macOS 26.0, *)
    public typealias ArrayLiteralElement = CompositorServices.LayerRenderer.Capabilities.SupportedLayoutsOptions
    @available(visionOS 1.0, macOS 26.0, *)
    public typealias Element = CompositorServices.LayerRenderer.Capabilities.SupportedLayoutsOptions
    @available(visionOS 1.0, macOS 26.0, *)
    public typealias RawValue = Swift.UInt32
  }
  @available(visionOS 26.0, *)
  public func supportedColorFormats(options: CompositorServices.LayerRenderer.Capabilities.SupportedColorFormatsOptions) -> [Metal.MTLPixelFormat]
  @available(macOS, unavailable)
  @available(visionOS, deprecated: 26.0, message: "Use supportedColorFormats(options: SupportedColorFormatsOptions) instead.")
  public var supportedColorFormats: [Metal.MTLPixelFormat] {
    get
  }
  public var supportedDepthFormats: [Metal.MTLPixelFormat] {
    get
  }
  @available(visionOS 26.0, *)
  public var supportedTrackingAreasFormats: [Metal.MTLPixelFormat] {
    get
  }
  public func supportedLayouts(options: CompositorServices.LayerRenderer.Capabilities.SupportedLayoutsOptions) -> [CompositorServices.LayerRenderer.Layout]
  public var supportsFoveation: Swift.Bool {
    get
  }
  public var supportedMinimumNearPlaneDistance: Swift.Float {
    get
  }
  @available(visionOS 26.0, *)
  public var drawableRenderContextSupportedStencilFormats: [Metal.MTLPixelFormat] {
    get
  }
  @available(visionOS 26.0, *)
  public var defaultRenderQuality: CompositorServices.LayerRenderer.RenderQuality {
    get
  }
}
@available(visionOS 2.0, macOS 26.0, *)
extension CompositorServices.LayerRenderer.Capabilities : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = CompositorServices.__CP_OBJECT_cp_layer_renderer_capabilities
  public func _bridgeToObjectiveC() -> CompositorServices.LayerRenderer.Capabilities._ObjectiveCType
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _forceBridgeFromObjectiveC(_ source: CompositorServices.LayerRenderer.Capabilities._ObjectiveCType, result: inout CompositorServices.LayerRenderer.Capabilities?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _conditionallyBridgeFromObjectiveC(_ source: CompositorServices.LayerRenderer.Capabilities._ObjectiveCType, result: inout CompositorServices.LayerRenderer.Capabilities?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _unconditionallyBridgeFromObjectiveC(_ source: CompositorServices.LayerRenderer.Capabilities._ObjectiveCType?) -> CompositorServices.LayerRenderer.Capabilities
  #endif
}
@available(visionOS 1.0, macOS 26.0, *)
extension CompositorServices.LayerRenderer {
  public struct Clock {
    public init()
    public struct Instant : Swift.Codable {
      public static let epoch: CompositorServices.LayerRenderer.Clock.Instant
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
    }
  }
}
@available(visionOS 1.0, macOS 26.0, *)
extension CompositorServices.LayerRenderer.Clock : _Concurrency.Clock {
  public var now: CompositorServices.LayerRenderer.Clock.Instant {
    get
  }
  public var minimumResolution: Swift.Duration {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public func sleep(until deadline: CompositorServices.LayerRenderer.Clock.Instant, tolerance: Swift.Duration?) async throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, noasync)
  public func wait(until deadline: CompositorServices.LayerRenderer.Clock.Instant, tolerance: Swift.Duration? = nil)
  #endif
  @available(visionOS 1.0, macOS 26.0, *)
  public typealias Duration = Swift.Duration
}
@available(visionOS 1.0, macOS 26.0, *)
extension CompositorServices.LayerRenderer.Clock.Instant : Swift.InstantProtocol {
  public func advanced(by duration: Swift.Duration) -> CompositorServices.LayerRenderer.Clock.Instant
  public func duration(to other: CompositorServices.LayerRenderer.Clock.Instant) -> Swift.Duration
  public static func < (lhs: CompositorServices.LayerRenderer.Clock.Instant, rhs: CompositorServices.LayerRenderer.Clock.Instant) -> Swift.Bool
  public static func <= (lhs: CompositorServices.LayerRenderer.Clock.Instant, rhs: CompositorServices.LayerRenderer.Clock.Instant) -> Swift.Bool
  public static func >= (lhs: CompositorServices.LayerRenderer.Clock.Instant, rhs: CompositorServices.LayerRenderer.Clock.Instant) -> Swift.Bool
  public static func > (lhs: CompositorServices.LayerRenderer.Clock.Instant, rhs: CompositorServices.LayerRenderer.Clock.Instant) -> Swift.Bool
  public static func == (a: CompositorServices.LayerRenderer.Clock.Instant, b: CompositorServices.LayerRenderer.Clock.Instant) -> Swift.Bool
  @available(visionOS 1.0, macOS 26.0, *)
  public typealias Duration = Swift.Duration
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension CompositorServices.LayerRenderer {
  @available(visionOS 1.0, macOS 26.0, *)
  public struct Configuration {
  }
}
@available(visionOS 1.0, macOS 26.0, *)
extension CompositorServices.LayerRenderer.Configuration {
  public var colorFormat: Metal.MTLPixelFormat {
    get
    set
  }
  public var colorUsage: Metal.MTLTextureUsage {
    get
    set
  }
  public var depthFormat: Metal.MTLPixelFormat {
    get
    set
  }
  public var depthUsage: Metal.MTLTextureUsage {
    get
    set
  }
  @available(visionOS 26.0, *)
  public var trackingAreasFormat: Metal.MTLPixelFormat {
    get
    set
  }
  @available(visionOS 26.0, *)
  public var trackingAreasUsage: Metal.MTLTextureUsage {
    get
    set
  }
  public var isFoveationEnabled: Swift.Bool {
    get
    set
  }
  public var generateFlippedRasterizationRateMaps: Swift.Bool {
    get
    set
  }
  public var layout: CompositorServices.LayerRenderer.Layout {
    get
    set
  }
  public var defaultDepthRange: Swift.SIMD2<Swift.Float> {
    get
    set
  }
  @available(visionOS 26.0, *)
  public var maxRenderQuality: CompositorServices.LayerRenderer.RenderQuality {
    get
    set
  }
  @available(visionOS 26.0, *)
  public var drawableRenderContextStencilFormat: Metal.MTLPixelFormat {
    get
    set
  }
  @available(visionOS 26.0, *)
  public var drawableRenderContextRasterSampleCount: Swift.Int {
    get
    set
  }
  @available(visionOS 26.0, *)
  public var supportsMTL4: Swift.Bool {
    get
    set
  }
}
@available(visionOS 2.0, macOS 26.0, *)
extension CompositorServices.LayerRenderer.Configuration : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = CompositorServices.__CP_OBJECT_cp_layer_renderer_configuration
  public func _bridgeToObjectiveC() -> CompositorServices.LayerRenderer.Configuration._ObjectiveCType
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _forceBridgeFromObjectiveC(_ source: CompositorServices.LayerRenderer.Configuration._ObjectiveCType, result: inout CompositorServices.LayerRenderer.Configuration?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _conditionallyBridgeFromObjectiveC(_ source: CompositorServices.LayerRenderer.Configuration._ObjectiveCType, result: inout CompositorServices.LayerRenderer.Configuration?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _unconditionallyBridgeFromObjectiveC(_ source: CompositorServices.LayerRenderer.Configuration._ObjectiveCType?) -> CompositorServices.LayerRenderer.Configuration
  #endif
}
@available(visionOS 1.0, macOS 26.0, *)
extension CompositorServices.LayerRenderer.Drawable {
  public var colorTextures: [any Metal.MTLTexture] {
    get
  }
  public var depthTextures: [any Metal.MTLTexture] {
    get
  }
  @available(visionOS 26.0, *)
  public var trackingAreasTextures: [any Metal.MTLTexture] {
    get
  }
  public var rasterizationRateMaps: [any Metal.MTLRasterizationRateMap] {
    get
  }
  public var flippedRasterizationRateMaps: [any Metal.MTLRasterizationRateMap] {
    get
  }
  public var views: [CompositorServices.LayerRenderer.Drawable.View] {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, *)
  public var deviceAnchor: ARKit.DeviceAnchor? {
    get
    nonmutating set
  }
  #endif
  @available(visionOS 2.0, *)
  public func computeProjection(convention: CompositorServices.AxisDirectionConvention = .rightUpBack, viewIndex: Swift.Int) -> simd.matrix_float4x4
}
@available(visionOS 1.0, macOS 26.0, *)
public enum LayerRendererConfigurationError : Swift.Int, Foundation.LocalizedError {
  case missingConfiguration
  case unsupportedColorFormat
  case unsupportedColorUsage
  case unsupportedDepthFormat
  case unsupportedDepthUsage
  case variableRasterizationRateIsNotSupported
  case temporalAntiAliasingNotSupported
  case notEnoughFramesRequested
  case tooManyFramesRequested
  case unsupportedForwardDepthRange
  case layoutNotSupported
  case unsupportedNearPlaneDistance
  @available(visionOS 26.0, *)
  case unsupportedTrackingAreasFormat
  @available(visionOS 26.0, *)
  case unsupportedTrackingAreasUsage
  @available(visionOS 26.0, *)
  case unsupportedDrawableRenderContextStencilFormat
  @available(visionOS 26.0, *)
  case unsupportedRenderQuality
  public var description: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  @available(visionOS 1.0, macOS 26.0, *)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@available(visionOS 1.0, macOS 26.0, *)
extension CompositorServices.LayerRenderer.Frame {
  #if compiler(>=5.3) && $NonescapableTypes
  public func predictTiming() -> CompositorServices.LayerRenderer.Frame.Timing?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(visionOS, introduced: 1.0, deprecated: 26.0, renamed: "queryDrawables")
  @available(macOS, unavailable)
  public func queryDrawable() -> CompositorServices.LayerRenderer.Drawable?
  #endif
  @available(visionOS 26.0, *)
  public func queryDrawables() -> [CompositorServices.LayerRenderer.Drawable]
  @available(visionOS 26.0, *)
  public func monocularFrustumMatrixForDrawableTarget(drawableTarget: CompositorServices.LayerRenderer.Drawable.Target, convention: CompositorServices.AxisDirectionConvention = .rightUpBack, viewIndex: Swift.Int, increaseTangents: Swift.SIMD4<Swift.Float>, depthRange: Swift.SIMD2<Swift.Float>) -> simd.matrix_float4x4
  @available(visionOS 26.0, *)
  public func binocularFrustumMatrixForDrawableTarget(drawableTarget: CompositorServices.LayerRenderer.Drawable.Target, convention: CompositorServices.AxisDirectionConvention = .rightUpBack, increaseTangents: Swift.SIMD4<Swift.Float>, depthRange: Swift.SIMD2<Swift.Float>) -> simd.matrix_float4x4
  @available(visionOS, introduced: 2.0, deprecated: 26.0, renamed: "monocularFrustumMatrixForDrawableTarget")
  public func monocularFrustumMatrix(convention: CompositorServices.AxisDirectionConvention = .rightUpBack, viewIndex: Swift.Int, increaseTangents: Swift.SIMD4<Swift.Float>, depthRange: Swift.SIMD2<Swift.Float>) -> simd.matrix_float4x4
  @available(visionOS, introduced: 2.0, deprecated: 26.0, renamed: "binocularFrustumMatrixForDrawableTarget")
  public func binocularFrustumMatrix(convention: CompositorServices.AxisDirectionConvention = .rightUpBack, increaseTangents: Swift.SIMD4<Swift.Float>, depthRange: Swift.SIMD2<Swift.Float>) -> simd.matrix_float4x4
}
@available(visionOS 1.0, macOS 26.0, *)
extension CompositorServices.LayerRenderer {
  public var properties: CompositorServices.LayerRenderer.Properties {
    get
  }
  public var configuration: CompositorServices.LayerRenderer.Configuration {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public func queryNextFrame() -> CompositorServices.LayerRenderer.Frame?
  #endif
}
extension CompositorServices.LayerRenderer {
  @available(visionOS 1.0, macOS 26.0, *)
  public struct Properties {
  }
}
@available(visionOS 1.0, macOS 26.0, *)
extension CompositorServices.LayerRenderer.Properties {
  public init(configuration: CompositorServices.LayerRenderer.Configuration) throws
  public var textureTopologies: [CompositorServices.TextureTopology] {
    get
  }
  public var viewCount: Swift.Int {
    get
  }
  @available(visionOS 26.0, *)
  public var trackingAreasMaxValue: CompositorServices.LayerRenderer.Drawable.TrackingArea.RenderValue {
    get
  }
}
@available(visionOS 2.0, macOS 26.0, *)
extension CompositorServices.LayerRenderer.Properties : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = CompositorServices.__CP_OBJECT_cp_layer_renderer_properties
  public func _bridgeToObjectiveC() -> CompositorServices.LayerRenderer.Properties._ObjectiveCType
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _forceBridgeFromObjectiveC(_ source: CompositorServices.LayerRenderer.Properties._ObjectiveCType, result: inout CompositorServices.LayerRenderer.Properties?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _conditionallyBridgeFromObjectiveC(_ source: CompositorServices.LayerRenderer.Properties._ObjectiveCType, result: inout CompositorServices.LayerRenderer.Properties?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _unconditionallyBridgeFromObjectiveC(_ source: CompositorServices.LayerRenderer.Properties._ObjectiveCType?) -> CompositorServices.LayerRenderer.Properties
  #endif
}
@available(visionOS 1.0, macOS 26.0, *)
extension CompositorServices.LayerRenderer.Frame.Timing {
  public var optimalInputTime: CompositorServices.LayerRenderer.Clock.Instant {
    get
  }
  public var renderingDeadline: CompositorServices.LayerRenderer.Clock.Instant {
    get
  }
  public var presentationTime: CompositorServices.LayerRenderer.Clock.Instant {
    get
  }
  @available(visionOS 2.0, *)
  public var trackableAnchorTime: CompositorServices.LayerRenderer.Clock.Instant {
    get
  }
}
@available(visionOS 26.0, macOS 26.0, *)
extension CompositorServices.LayerRenderer.Drawable.TrackingArea {
  public struct HoverEffect {
    public static let automatic: CompositorServices.LayerRenderer.Drawable.TrackingArea.HoverEffect
  }
  public func addHoverEffect(_ effect: CompositorServices.LayerRenderer.Drawable.TrackingArea.HoverEffect)
}
@available(visionOS 26.0, macOS 26.0, *)
extension CompositorServices.LayerRenderer.Drawable.TrackingArea.RenderValue {
  public static let invalid: CompositorServices.LayerRenderer.Drawable.TrackingArea.RenderValue
}
@available(visionOS 26.0, macOS 26.0, *)
extension CompositorServices.LayerRenderer.Drawable.TrackingArea.Identifier {
  public static let invalid: CompositorServices.LayerRenderer.Drawable.TrackingArea.Identifier
}
@available(visionOS 1.0, macOS 26.0, *)
extension CompositorServices.LayerRendererConfigurationError : Swift.Equatable {}
@available(visionOS 1.0, macOS 26.0, *)
extension CompositorServices.LayerRendererConfigurationError : Swift.Hashable {}
@available(visionOS 1.0, macOS 26.0, *)
extension CompositorServices.LayerRendererConfigurationError : Swift.RawRepresentable {}
