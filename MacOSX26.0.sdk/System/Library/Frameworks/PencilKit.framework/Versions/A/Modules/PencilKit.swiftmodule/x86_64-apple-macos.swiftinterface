// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2 effective-5.10 (swiftlang-6.2.0.17.14 clang-1700.3.17.1)
// swift-module-flags: -target x86_64-apple-macos26.0 -enable-objc-interop -autolink-force-load -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 567 -module-name PencilKit
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2
import AppKit
import CoreGraphics
import CoreImage
import DeveloperToolsSupport
import Foundation
@_exported import PencilKit
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
@available(iOS 14.0, macOS 11.0, *)
public struct PKStrokePath : Swift.RandomAccessCollection, Swift.Sendable {
  public init()
  public init<T>(controlPoints: T, creationDate: Foundation.Date) where T : Swift.Sequence, T.Element == PencilKit.PKStrokePoint
  public var creationDate: Foundation.Date {
    get
  }
  public func interpolatedLocation(at parametricValue: CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
  public func interpolatedPoint(at parametricValue: CoreFoundation.CGFloat) -> PencilKit.PKStrokePoint
  #if compiler(>=5.3) && $NonescapableTypes
  public func interpolatedPoints(in range: Swift.ClosedRange<CoreFoundation.CGFloat>? = nil, by stride: PencilKit.PKStrokePath.InterpolatedSlice.Stride) -> PencilKit.PKStrokePath.InterpolatedSlice
  #endif
  public func parametricValue(_ parametricValue: CoreFoundation.CGFloat, offsetBy step: PencilKit.PKStrokePath.InterpolatedSlice.Stride) -> CoreFoundation.CGFloat
  public struct InterpolatedSlice {
    public enum Stride {
      case distance(CoreFoundation.CGFloat)
      case time(Foundation.TimeInterval)
      case parametricStep(CoreFoundation.CGFloat)
    }
  }
  public typealias Element = PencilKit.PKStrokePoint
  public typealias Index = Swift.Int
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(index: PencilKit.PKStrokePath.Index) -> PencilKit.PKStrokePoint {
    get
  }
  @available(iOS 14.0, macOS 11.0, *)
  public typealias Indices = Swift.Range<PencilKit.PKStrokePath.Index>
  @available(iOS 14.0, macOS 11.0, *)
  public typealias Iterator = Swift.IndexingIterator<PencilKit.PKStrokePath>
  @available(iOS 14.0, macOS 11.0, *)
  public typealias SubSequence = Swift.Slice<PencilKit.PKStrokePath>
}
@available(iOS 14.0, macOS 11.0, *)
extension PencilKit.PKStrokePath : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = PencilKit.PKStrokePathReference
  public func _bridgeToObjectiveC() -> PencilKit.PKStrokePath._ObjectiveCType
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _forceBridgeFromObjectiveC(_ source: PencilKit.PKStrokePath._ObjectiveCType, result: inout PencilKit.PKStrokePath?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _conditionallyBridgeFromObjectiveC(_ source: PencilKit.PKStrokePath._ObjectiveCType, result: inout PencilKit.PKStrokePath?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _unconditionallyBridgeFromObjectiveC(_ source: PencilKit.PKStrokePath._ObjectiveCType?) -> PencilKit.PKStrokePath
  #endif
}
@available(iOS 14.0, macOS 11.0, *)
public struct PKInk : Swift.Sendable {
  public typealias InkType = PencilKit.PKInkingTool.InkType
  public init(_ inkType: PencilKit.PKInk.InkType, color: AppKit.NSColor = NSColor.black)
  public var inkType: PencilKit.PKInk.InkType {
    get
    set
  }
  public var color: AppKit.NSColor {
    get
    set
  }
  @available(iOS 17.0, macOS 14.0, *)
  public var requiredContentVersion: PencilKit.PKContentVersion {
    get
  }
}
@available(iOS 14.0, macOS 11.0, *)
extension PencilKit.PKInk : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = PencilKit.PKInkReference
  public func _bridgeToObjectiveC() -> PencilKit.PKInk._ObjectiveCType
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _forceBridgeFromObjectiveC(_ source: PencilKit.PKInk._ObjectiveCType, result: inout PencilKit.PKInk?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _conditionallyBridgeFromObjectiveC(_ source: PencilKit.PKInk._ObjectiveCType, result: inout PencilKit.PKInk?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _unconditionallyBridgeFromObjectiveC(_ source: PencilKit.PKInk._ObjectiveCType?) -> PencilKit.PKInk
  #endif
}
@available(iOS 13.0, macOS 11.0, *)
public struct PKInkingTool : PencilKit.PKTool, Swift.Equatable, Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(_ inkType: PencilKit.PKInkingTool.InkType, color: AppKit.NSColor = NSColor.black, width: CoreFoundation.CGFloat? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 26.0, *)
  public init(_ inkType: PencilKit.PKInkingTool.InkType, color: AppKit.NSColor = NSColor.black, width: CoreFoundation.CGFloat? = nil, azimuth: CoreFoundation.CGFloat)
  #endif
  public enum InkType : Swift.String {
    case pen
    case pencil
    case marker
    @available(iOS 17.0, macOS 14.0, *)
    case monoline
    @available(iOS 17.0, macOS 14.0, *)
    case fountainPen
    @available(iOS 17.0, macOS 14.0, *)
    case watercolor
    @available(iOS 17.0, macOS 14.0, *)
    case crayon
    @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
    case reed
    public var defaultWidth: CoreFoundation.CGFloat {
      get
    }
    public var validWidthRange: Swift.ClosedRange<CoreFoundation.CGFloat> {
      get
    }
    @available(iOS 17.0, macOS 14.0, *)
    public var requiredContentVersion: PencilKit.PKContentVersion {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    @available(iOS 13.0, macOS 11.0, *)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var color: AppKit.NSColor {
    get
    set
  }
  public var width: CoreFoundation.CGFloat {
    get
    set
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  public var azimuth: CoreFoundation.CGFloat {
    get
    set
  }
  public var inkType: PencilKit.PKInkingTool.InkType {
    get
    set
  }
  @available(iOS 17.0, macOS 14.0, *)
  public var requiredContentVersion: PencilKit.PKContentVersion {
    get
  }
  public static func == (a: PencilKit.PKInkingTool, b: PencilKit.PKInkingTool) -> Swift.Bool
}
@available(iOS 14.0, macOS 11.0, *)
extension PencilKit.PKInkingTool {
  public init(ink: PencilKit.PKInk, width: CoreFoundation.CGFloat)
  public var ink: PencilKit.PKInk {
    get
  }
}
@available(iOS 13.0, macOS 11.0, *)
extension PencilKit.PKInkingTool : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = PencilKit.PKInkingToolReference
  public func _bridgeToObjectiveC() -> PencilKit.PKInkingTool._ObjectiveCType
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _forceBridgeFromObjectiveC(_ source: PencilKit.PKInkingTool._ObjectiveCType, result: inout PencilKit.PKInkingTool?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _conditionallyBridgeFromObjectiveC(_ source: PencilKit.PKInkingTool._ObjectiveCType, result: inout PencilKit.PKInkingTool?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _unconditionallyBridgeFromObjectiveC(_ source: PencilKit.PKInkingTool._ObjectiveCType?) -> PencilKit.PKInkingTool
  #endif
}
@available(iOS 14.0, macOS 11.0, *)
public struct PKStrokePoint : Swift.Sendable {
  public init(location: CoreFoundation.CGPoint, timeOffset: Foundation.TimeInterval, size: CoreFoundation.CGSize, opacity: CoreFoundation.CGFloat, force: CoreFoundation.CGFloat, azimuth: CoreFoundation.CGFloat, altitude: CoreFoundation.CGFloat)
  @available(iOS 17.0, macOS 14.0, *)
  public init(location: CoreFoundation.CGPoint, timeOffset: Foundation.TimeInterval, size: CoreFoundation.CGSize, opacity: CoreFoundation.CGFloat, force: CoreFoundation.CGFloat, azimuth: CoreFoundation.CGFloat, altitude: CoreFoundation.CGFloat, secondaryScale: CoreFoundation.CGFloat)
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  public init(location: CoreFoundation.CGPoint, timeOffset: Foundation.TimeInterval, size: CoreFoundation.CGSize, opacity: CoreFoundation.CGFloat, force: CoreFoundation.CGFloat, azimuth: CoreFoundation.CGFloat, altitude: CoreFoundation.CGFloat, secondaryScale: CoreFoundation.CGFloat, threshold: CoreFoundation.CGFloat)
  public var location: CoreFoundation.CGPoint {
    get
  }
  public var timeOffset: Foundation.TimeInterval {
    get
  }
  public var size: CoreFoundation.CGSize {
    get
  }
  public var opacity: CoreFoundation.CGFloat {
    get
  }
  public var azimuth: CoreFoundation.CGFloat {
    get
  }
  public var force: CoreFoundation.CGFloat {
    get
  }
  public var altitude: CoreFoundation.CGFloat {
    get
  }
  @available(iOS 17.0, macOS 14.0, *)
  public var secondaryScale: CoreFoundation.CGFloat {
    get
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  public var threshold: CoreFoundation.CGFloat {
    get
  }
}
@available(iOS 14.0, macOS 11.0, *)
extension PencilKit.PKStrokePoint : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = PencilKit.PKStrokePointReference
  public func _bridgeToObjectiveC() -> PencilKit.PKStrokePoint._ObjectiveCType
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _forceBridgeFromObjectiveC(_ source: PencilKit.PKStrokePoint._ObjectiveCType, result: inout PencilKit.PKStrokePoint?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _conditionallyBridgeFromObjectiveC(_ source: PencilKit.PKStrokePoint._ObjectiveCType, result: inout PencilKit.PKStrokePoint?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _unconditionallyBridgeFromObjectiveC(_ source: PencilKit.PKStrokePoint._ObjectiveCType?) -> PencilKit.PKStrokePoint
  #endif
}
@available(iOS 18.0, visionOS 2.0, macOS 26.0, *)
extension PencilKit.PKToolPickerEraserItem {
  convenience public init(type: PencilKit.PKEraserTool.EraserType)
  convenience public init(type: PencilKit.PKEraserTool.EraserType, width: CoreFoundation.CGFloat)
  public var eraserTool: PencilKit.PKEraserTool {
    get
  }
}
@available(iOS 14.0, macOS 11.0, *)
public struct PKStroke : Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(ink: PencilKit.PKInk, path: PencilKit.PKStrokePath, transform: CoreFoundation.CGAffineTransform = .identity, mask: AppKit.NSBezierPath? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 16.0, macOS 13.0, *)
  public init(ink: PencilKit.PKInk, path: PencilKit.PKStrokePath, transform: CoreFoundation.CGAffineTransform = .identity, mask: AppKit.NSBezierPath? = nil, randomSeed: Swift.UInt32)
  #endif
  public var ink: PencilKit.PKInk {
    get
    set
  }
  public var transform: CoreFoundation.CGAffineTransform {
    get
    set
  }
  public var path: PencilKit.PKStrokePath {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var mask: AppKit.NSBezierPath? {
    get
    set
  }
  #endif
  public var renderBounds: CoreFoundation.CGRect {
    get
  }
  public var maskedPathRanges: [Swift.ClosedRange<CoreFoundation.CGFloat>] {
    get
  }
  @available(iOS 16.0, macOS 13.0, *)
  public var randomSeed: Swift.UInt32 {
    get
    set
  }
  @available(iOS 17.0, macOS 14.0, *)
  public var requiredContentVersion: PencilKit.PKContentVersion {
    get
  }
}
@available(iOS 14.0, macOS 11.0, *)
extension PencilKit.PKStroke : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = PencilKit.PKStrokeReference
  public func _bridgeToObjectiveC() -> PencilKit.PKStroke._ObjectiveCType
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _forceBridgeFromObjectiveC(_ source: PencilKit.PKStroke._ObjectiveCType, result: inout PencilKit.PKStroke?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _conditionallyBridgeFromObjectiveC(_ source: PencilKit.PKStroke._ObjectiveCType, result: inout PencilKit.PKStroke?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _unconditionallyBridgeFromObjectiveC(_ source: PencilKit.PKStroke._ObjectiveCType?) -> PencilKit.PKStroke
  #endif
}
@available(iOS 18.0, visionOS 2.0, macOS 26.0, *)
extension PencilKit.PKToolPickerInkingItem {
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(type: PencilKit.PKInkingTool.InkType, color: AppKit.NSColor? = nil, width: CoreFoundation.CGFloat? = nil, identifier: Swift.String? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(type: PencilKit.PKInkingTool.InkType, color: AppKit.NSColor? = nil, width: CoreFoundation.CGFloat? = nil, azimuth: CoreFoundation.CGFloat? = nil, identifier: Swift.String? = nil)
  #endif
  public var inkingTool: PencilKit.PKInkingTool {
    get
  }
}
@available(iOS 13.0, macOS 11.0, *)
public struct PKLassoTool : PencilKit.PKTool, Swift.Equatable, Swift.Sendable {
  public init()
  public static func == (a: PencilKit.PKLassoTool, b: PencilKit.PKLassoTool) -> Swift.Bool
}
@available(iOS 13.0, macOS 11.0, *)
extension PencilKit.PKLassoTool : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = PencilKit.PKLassoToolReference
  public func _bridgeToObjectiveC() -> PencilKit.PKLassoTool._ObjectiveCType
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _forceBridgeFromObjectiveC(_ source: PencilKit.PKLassoTool._ObjectiveCType, result: inout PencilKit.PKLassoTool?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _conditionallyBridgeFromObjectiveC(_ source: PencilKit.PKLassoTool._ObjectiveCType, result: inout PencilKit.PKLassoTool?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _unconditionallyBridgeFromObjectiveC(_ source: PencilKit.PKLassoTool._ObjectiveCType?) -> PencilKit.PKLassoTool
  #endif
}
@available(iOS 13.0, macOS 11.0, *)
public protocol PKTool {
}
@available(iOS 13.0, macOS 11.0, *)
public struct PKEraserTool : PencilKit.PKTool, Swift.Equatable, Swift.Sendable {
  public init(_ eraserType: PencilKit.PKEraserTool.EraserType)
  @available(iOS 16.4, macOS 13.3, *)
  public init(_ eraserType: PencilKit.PKEraserTool.EraserType, width: CoreFoundation.CGFloat)
  public enum EraserType {
    case vector
    case bitmap
    @available(iOS 16.4, macOS 13.3, *)
    case fixedWidthBitmap
    @available(iOS 16.4, macOS 13.3, *)
    public var defaultWidth: CoreFoundation.CGFloat {
      get
    }
    @available(iOS 16.4, macOS 13.3, *)
    public var validWidthRange: Swift.ClosedRange<CoreFoundation.CGFloat> {
      get
    }
    public static func == (a: PencilKit.PKEraserTool.EraserType, b: PencilKit.PKEraserTool.EraserType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var eraserType: PencilKit.PKEraserTool.EraserType {
    get
    set
  }
  @available(iOS 16.4, macOS 13.3, *)
  public var width: CoreFoundation.CGFloat {
    get
    set
  }
  public static func == (a: PencilKit.PKEraserTool, b: PencilKit.PKEraserTool) -> Swift.Bool
}
@available(iOS 13.0, macOS 11.0, *)
extension PencilKit.PKEraserTool : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = PencilKit.PKEraserToolReference
  public func _bridgeToObjectiveC() -> PencilKit.PKEraserTool._ObjectiveCType
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _forceBridgeFromObjectiveC(_ source: PencilKit.PKEraserTool._ObjectiveCType, result: inout PencilKit.PKEraserTool?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _conditionallyBridgeFromObjectiveC(_ source: PencilKit.PKEraserTool._ObjectiveCType, result: inout PencilKit.PKEraserTool?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _unconditionallyBridgeFromObjectiveC(_ source: PencilKit.PKEraserTool._ObjectiveCType?) -> PencilKit.PKEraserTool
  #endif
}
extension PencilKit.PKDrawing {
  #if compiler(>=5.3) && $AsyncExecutionBehaviorAttributes
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  nonisolated(nonsending) public func draw(in cgContext: CoreGraphics.CGContext, frame: CoreFoundation.CGRect, from sourceRect: CoreFoundation.CGRect, darkUserInterfaceStyle: Swift.Bool = false) async
  #endif
}
@available(iOS 14.0, macOS 11.0, *)
extension PencilKit.PKStrokePath.InterpolatedSlice : Swift.Sequence, Swift.IteratorProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  public mutating func next() -> PencilKit.PKStrokePoint?
  #endif
  @available(iOS 14.0, macOS 11.0, *)
  public typealias Element = PencilKit.PKStrokePoint
  @available(iOS 14.0, macOS 11.0, *)
  public typealias Iterator = PencilKit.PKStrokePath.InterpolatedSlice
}
@available(iOS 13.0, macOS 10.15, *)
public struct PKDrawing : Swift.Sendable {
  public init()
  public init(data: Foundation.Data) throws
  public func dataRepresentation() -> Foundation.Data
  public var bounds: CoreFoundation.CGRect {
    get
  }
  public func image(from rect: CoreFoundation.CGRect, scale: CoreFoundation.CGFloat) -> AppKit.NSImage
  public mutating func transform(using transform: CoreFoundation.CGAffineTransform)
  public func transformed(using transform: CoreFoundation.CGAffineTransform) -> PencilKit.PKDrawing
  public mutating func append(_ toAppend: PencilKit.PKDrawing)
  public func appending(_ toAppend: PencilKit.PKDrawing) -> PencilKit.PKDrawing
  @available(iOS 17.0, macOS 14.0, *)
  public var requiredContentVersion: PencilKit.PKContentVersion {
    get
  }
}
@available(iOS 14.0, macOS 11.0, *)
extension PencilKit.PKDrawing {
  public init<S>(strokes: S) where S : Swift.Sequence, S.Element == PencilKit.PKStroke
  public var strokes: [PencilKit.PKStroke] {
    get
    set
  }
}
@available(iOS 13.0, macOS 10.15, *)
extension PencilKit.PKDrawing : Swift.Equatable {
  public static func == (a: PencilKit.PKDrawing, b: PencilKit.PKDrawing) -> Swift.Bool
}
@available(iOS 13.0, macOS 10.15, *)
extension PencilKit.PKDrawing : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 13.0, macOS 10.15, *)
extension PencilKit.PKDrawing : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = PencilKit.PKDrawingReference
  public func _bridgeToObjectiveC() -> PencilKit.PKDrawing._ObjectiveCType
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _forceBridgeFromObjectiveC(_ source: PencilKit.PKDrawing._ObjectiveCType, result: inout PencilKit.PKDrawing?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _conditionallyBridgeFromObjectiveC(_ source: PencilKit.PKDrawing._ObjectiveCType, result: inout PencilKit.PKDrawing?) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func _unconditionallyBridgeFromObjectiveC(_ source: PencilKit.PKDrawing._ObjectiveCType?) -> PencilKit.PKDrawing
  #endif
}
@available(iOS 13.0, macOS 11.0, *)
extension PencilKit.PKInkingTool.InkType : Swift.Equatable {}
@available(iOS 13.0, macOS 11.0, *)
extension PencilKit.PKInkingTool.InkType : Swift.Hashable {}
@available(iOS 13.0, macOS 11.0, *)
extension PencilKit.PKInkingTool.InkType : Swift.RawRepresentable {}
@available(iOS 13.0, macOS 11.0, *)
extension PencilKit.PKEraserTool.EraserType : Swift.Equatable {}
@available(iOS 13.0, macOS 11.0, *)
extension PencilKit.PKEraserTool.EraserType : Swift.Hashable {}
