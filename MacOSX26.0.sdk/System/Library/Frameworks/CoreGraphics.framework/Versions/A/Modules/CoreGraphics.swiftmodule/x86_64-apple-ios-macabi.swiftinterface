// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2 effective-5.10 (swiftlang-6.2.0.17.14 clang-1700.3.17.1)
// swift-module-flags: -target x86_64-apple-ios26.0-macabi -enable-objc-interop -autolink-force-load -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 1957 -module-name CoreGraphics
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2
@_exported import CoreFoundation
@_exported import CoreGraphics
import Foundation
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGColor {
  #if compiler(>=5.3) && $NonescapableTypes
  public var components: [CoreFoundation.CGFloat]? {
    get
  }
  #endif
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
public protocol _CGColorInitTrampoline {
  #if compiler(>=5.3) && $NonescapableTypes
  init?(colorSpace space: CoreGraphics.CGColorSpace, components: Swift.UnsafePointer<CoreFoundation.CGFloat>)
  #endif
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics._CGColorInitTrampoline {
  public init(_colorLiteralRed red: Swift.Float, green: Swift.Float, blue: Swift.Float, alpha: Swift.Float)
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGColor : CoreGraphics._CGColorInitTrampoline, Swift._ExpressibleByColorLiteral {
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGColor : @unchecked Swift.Sendable {
}
@available(*, unavailable, message: "Use == instead")
public func CGAffineTransformEqualToTransform(_ t1: CoreFoundation.CGAffineTransform, _ t2: CoreFoundation.CGAffineTransform) -> Swift.Bool
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use class var white/black/clear instead")
public func CGColorGetConstantColor(_ colorName: CoreFoundation.CFString?) -> CoreGraphics.CGColor?
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use == instead")
public func CGColorEqualToColor(_ color1: CoreGraphics.CGColor?, _ color2: CoreGraphics.CGColor?) -> Swift.Bool
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, renamed: "getter:CGColor.components(self:)")
public func CGColorGetComponents(_ color: CoreGraphics.CGColor?) -> Swift.UnsafePointer<CoreFoundation.CGFloat>
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use colorTable.count instead")
public func CGColorSpaceGetColorTableCount(_ space: CoreGraphics.CGColorSpace?) -> Swift.Int
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, renamed: "CGColorSpace.colorTable(self:_:)")
public func CGColorSpaceGetColorTable(_ space: CoreGraphics.CGColorSpace?, _ table: Swift.UnsafeMutablePointer<Swift.UInt8>)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use setLineDash(self:phase:lengths:)")
public func CGContextSetLineDash(_ c: CoreGraphics.CGContext?, _ phase: CoreFoundation.CGFloat, _ lengths: Swift.UnsafePointer<CoreFoundation.CGFloat>, _ count: Swift.Int)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use move(to:) instead")
public func CGContextMoveToPoint(_ c: CoreGraphics.CGContext?, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addLine(to:) instead")
public func CGContextAddLineToPoint(_ c: CoreGraphics.CGContext?, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addCurve(to:control1:control2:) instead")
public func CGContextAddCurveToPoint(_ c: CoreGraphics.CGContext?, _ cp1x: CoreFoundation.CGFloat, _ cp1y: CoreFoundation.CGFloat, _ cp2x: CoreFoundation.CGFloat, _ cp2y: CoreFoundation.CGFloat, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addQuadCurve(to:control:)")
public func CGContextAddQuadCurveToPoint(_ c: CoreGraphics.CGContext?, _ cpx: CoreFoundation.CGFloat, _ cpy: CoreFoundation.CGFloat, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addRects(_:)")
public func CGContextAddRects(_ c: CoreGraphics.CGContext?, _ rects: Swift.UnsafePointer<CoreFoundation.CGRect>, _ count: Swift.Int)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addLines(between:)")
public func CGContextAddLines(_ c: CoreGraphics.CGContext?, _ points: Swift.UnsafePointer<CoreFoundation.CGPoint>, _ count: Swift.Int)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addArc(center:radius:startAngle:endAngle:clockwise:)")
public func CGContextAddArc(_ c: CoreGraphics.CGContext?, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat, _ radius: CoreFoundation.CGFloat, _ startAngle: CoreFoundation.CGFloat, _ endAngle: CoreFoundation.CGFloat, _ clockwise: Swift.Int32)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addArc(self:x1:y1:x2:y2:radius:)")
public func CGContextAddArcToPoint(_ c: CoreGraphics.CGContext?, _ x1: CoreFoundation.CGFloat, _ y1: CoreFoundation.CGFloat, _ x2: CoreFoundation.CGFloat, _ y2: CoreFoundation.CGFloat, _ radius: CoreFoundation.CGFloat)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use fill(self:_:count:)")
public func CGContextFillRects(_ c: CoreGraphics.CGContext?, _ rects: Swift.UnsafePointer<CoreFoundation.CGRect>, _ count: Swift.Int)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use strokeLineSegments(self:between:count:)")
public func CGContextStrokeLineSegments(_ c: CoreGraphics.CGContext?, _ points: Swift.UnsafePointer<CoreFoundation.CGPoint>, _ count: Swift.Int)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use clip(to:)")
public func CGContextClipToRects(_ c: CoreGraphics.CGContext?, _ rects: Swift.UnsafePointer<CoreFoundation.CGRect>, _ count: Swift.Int)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use draw(_:in:)")
public func CGContextDrawImage(_ c: CoreGraphics.CGContext?, _ rect: CoreFoundation.CGRect, _ image: CoreGraphics.CGImage?)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use draw(_:in:byTiling:)")
public func CGContextDrawTiledImage(_ c: CoreGraphics.CGContext?, _ rect: CoreFoundation.CGRect, _ image: CoreGraphics.CGImage?)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use draw(_:in:by:options:)")
public func CGContextDrawImageApplyingToneMapping(_ c: CoreGraphics.CGContext?, _ rect: CoreFoundation.CGRect, _ image: CoreGraphics.CGImage?, applying: CoreGraphics.CGToneMapping, options: CoreFoundation.CFDictionary?) -> Swift.Bool
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, renamed: "getter:CGContext.textPosition(self:)")
public func CGContextGetTextPosition(_ c: CoreGraphics.CGContext?) -> CoreFoundation.CGPoint
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use var textPosition")
public func CGContextSetTextPosition(_ c: CoreGraphics.CGContext?, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use showGlyphs(_:at:)")
public func CGContextShowGlyphsAtPositions(_ c: CoreGraphics.CGContext?, _ glyphs: Swift.UnsafePointer<CoreGraphics.CGGlyph>, _ Lpositions: Swift.UnsafePointer<CoreFoundation.CGPoint>, _ count: Swift.Int)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, renamed: "CGContext.fillPath(self:)")
public func CGContextFillPath(_ c: CoreGraphics.CGContext?)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use fillPath(using:)")
public func CGContextEOFillPath(_ c: CoreGraphics.CGContext?)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, renamed: "CGContext.clip(self:)")
public func CGContextClip(_ c: CoreGraphics.CGContext?)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use clip(using:)")
public func CGContextEOClip(_ c: CoreGraphics.CGContext?)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, renamed: "CGGetLastMouseDelta")
public func CGGetLastMouseDelta(_ deltaX: Swift.UnsafeMutablePointer<Swift.Int32>?, _ deltaY: Swift.UnsafeMutablePointer<Swift.Int32>?)
#endif
@available(*, unavailable, message: "Use divided(atDistance:from:)")
public func CGRectDivide(_ rect: CoreFoundation.CGRect, _ slice: Swift.UnsafeMutablePointer<CoreFoundation.CGRect>, _ remainder: Swift.UnsafeMutablePointer<CoreFoundation.CGRect>, _ amount: CoreFoundation.CGFloat, _ edge: CoreFoundation.CGRectEdge)
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use CGPoint.init(dictionaryRepresentation:)")
public func CGPointMakeWithDictionaryRepresentation(_ dict: CoreFoundation.CFDictionary?, _ point: Swift.UnsafeMutablePointer<CoreFoundation.CGPoint>) -> Swift.Bool
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use CGSize.init(dictionaryRepresentation:)")
public func CGSizeMakeWithDictionaryRepresentation(_ dict: CoreFoundation.CFDictionary?, _ size: Swift.UnsafeMutablePointer<CoreFoundation.CGSize>) -> Swift.Bool
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use CGRect.init(dictionaryRepresentation:)")
public func CGRectMakeWithDictionaryRepresentation(_ dict: CoreFoundation.CFDictionary?, _ rect: Swift.UnsafeMutablePointer<CoreFoundation.CGRect>) -> Swift.Bool
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, renamed: "CGImage.copy(self:maskingColorComponents:)")
public func CGImageCreateWithMaskingColors(_ image: CoreGraphics.CGImage?, _ components: Swift.UnsafePointer<CoreFoundation.CGFloat>) -> CoreGraphics.CGImage?
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use draw(_:in:)")
public func CGContextDrawLayerInRect(_ context: CoreGraphics.CGContext?, _ rect: CoreFoundation.CGRect, _ layer: CoreGraphics.CGLayer?)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use draw(_:at:)")
public func CGContextDrawLayerAtPoint(_ context: CoreGraphics.CGContext?, _ point: CoreFoundation.CGPoint, _ layer: CoreGraphics.CGLayer?)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use copy(byDashingWithPhase:lengths:transform:)")
public func CGPathCreateCopyByDashingPath(_ path: CoreGraphics.CGPath?, _ transform: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ phase: CoreFoundation.CGFloat, _ lengths: Swift.UnsafePointer<CoreFoundation.CGFloat>, _ count: Swift.Int) -> CoreGraphics.CGPath?
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use copy(byStroking:lineWidth:lineCap:lineJoin:miterLimit:transform:)")
public func CGPathCreateCopyByStrokingPath(_ path: CoreGraphics.CGPath?, _ transform: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ lineWidth: CoreFoundation.CGFloat, _ lineCap: CoreGraphics.CGLineCap, _ lineJoin: CoreGraphics.CGLineJoin, _ miterLimit: CoreFoundation.CGFloat) -> CoreGraphics.CGPath?
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use == instead")
public func CGPathEqualToPath(_ path1: CoreGraphics.CGPath?, _ path2: CoreGraphics.CGPath?) -> Swift.Bool
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use move(to:transform:)")
public func CGPathMoveToPoint(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addLine(to:transform:)")
public func CGPathAddLineToPoint(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addCurve(to:control1:control2:transform:)")
public func CGPathAddCurveToPoint(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ cp1x: CoreFoundation.CGFloat, _ cp1y: CoreFoundation.CGFloat, _ cp2x: CoreFoundation.CGFloat, _ cp2y: CoreFoundation.CGFloat, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addQuadCurve(to:control:transform:)")
public func CGPathAddQuadCurveToPoint(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ cpx: CoreFoundation.CGFloat, _ cpy: CoreFoundation.CGFloat, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addRect(_:transform:)")
public func CGPathAddRect(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ rect: CoreFoundation.CGRect)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addRects(_:transform:)")
public func CGPathAddRects(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ rects: Swift.UnsafePointer<CoreFoundation.CGRect>, _ count: Swift.Int)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addLines(between:transform:)")
public func CGPathAddLines(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ points: Swift.UnsafePointer<CoreFoundation.CGPoint>, _ count: Swift.Int)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addEllipse(rect:transform:)")
public func CGPathAddEllipseInRect(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ rect: CoreFoundation.CGRect)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addRelativeArc(center:radius:startAngle:delta:transform:)")
public func CGPathAddRelativeArc(_ path: CoreGraphics.CGMutablePath?, _ matrix: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat, _ radius: CoreFoundation.CGFloat, _ startAngle: CoreFoundation.CGFloat, _ delta: CoreFoundation.CGFloat)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addArc(center:radius:startAngle:endAngle:clockwise:transform:)")
public func CGPathAddArc(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat, _ radius: CoreFoundation.CGFloat, _ startAngle: CoreFoundation.CGFloat, _ endAngle: CoreFoundation.CGFloat, _ clockwise: Swift.Bool)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addArc(tangent1End:tangent2End:radius:transform:)")
public func CGPathAddArcToPoint(_ path: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ x1: CoreFoundation.CGFloat, _ y1: CoreFoundation.CGFloat, _ x2: CoreFoundation.CGFloat, _ y2: CoreFoundation.CGFloat, _ radius: CoreFoundation.CGFloat)
#endif
#if compiler(>=5.3) && $NonescapableTypes
@available(*, unavailable, message: "Use addPath(_:transform:)")
public func CGPathAddPath(_ path1: CoreGraphics.CGMutablePath?, _ m: Swift.UnsafePointer<CoreFoundation.CGAffineTransform>, _ path2: CoreGraphics.CGPath?)
#endif
@available(*, unavailable, message: "Use CGColor.white")
public var kCGColorWhite: CoreFoundation.CFString {
  get
}
@available(*, unavailable, message: "Use CGColor.black")
public var kCGColorBlack: CoreFoundation.CFString {
  get
}
@available(*, unavailable, message: "Use CGColor.clear")
public var kCGColorClear: CoreFoundation.CFString {
  get
}
extension CoreFoundation.CGFloat {
  @available(*, unavailable, renamed: "leastNormalMagnitude")
  public static var min: CoreFoundation.CGFloat {
    get
  }
  @available(*, unavailable, renamed: "greatestFiniteMagnitude")
  public static var max: CoreFoundation.CGFloat {
    get
  }
}
@available(*, unavailable, renamed: "CGFloat.leastNormalMagnitude")
public var CGFLOAT_MIN: CoreFoundation.CGFloat {
  get
}
@available(*, unavailable, renamed: "CGFloat.greatestFiniteMagnitude")
public var CGFLOAT_MAX: CoreFoundation.CGFloat {
  get
}
@available(*, unavailable, message: "Use truncatingRemainder instead")
@_transparent public func % (lhs: CoreFoundation.CGFloat, rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    fatalError("% is not available.")
}
@available(*, unavailable, message: "Use formTruncatingRemainder instead")
@_transparent public func %= (lhs: inout CoreFoundation.CGFloat, rhs: CoreFoundation.CGFloat) {
    fatalError("%= is not available.")
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func acos(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(acos(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func asin(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(asin(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func atan(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(atan(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func cos(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(cos(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func sin(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(sin(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func tan(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(tan(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func acosh(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(acosh(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func asinh(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(asinh(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func atanh(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(atanh(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func cosh(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(cosh(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func sinh(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(sinh(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func tanh(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(tanh(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func exp(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(exp(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func exp2(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(exp2(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func expm1(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(expm1(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func log(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(log(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func log10(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(log10(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func log1p(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(log1p(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func log2(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(log2(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func logb(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(logb(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func cbrt(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(cbrt(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func erf(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(erf(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func erfc(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(erfc(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func tgamma(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(tgamma(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func nearbyint(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(nearbyint(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func rint(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(rint(x.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func atan2(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(atan2(lhs.native, rhs.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func hypot(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(hypot(lhs.native, rhs.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func pow(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(pow(lhs.native, rhs.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func copysign(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(copysign(lhs.native, rhs.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func nextafter(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(nextafter(lhs.native, rhs.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func fdim(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(fdim(lhs.native, rhs.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func fmax(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(fmax(lhs.native, rhs.native))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func fmin(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(fmin(lhs.native, rhs.native))
}
@available(*, unavailable, message: "use the floatingPointClass property.")
@_transparent public func fpclassify(_ x: CoreFoundation.CGFloat) -> Swift.Int {
    fatalError("unavailable")
}
@available(*, unavailable, message: "use the isNormal property.")
public func isnormal(_ value: CoreFoundation.CGFloat) -> Swift.Bool
@available(*, unavailable, message: "use the isFinite property.")
public func isfinite(_ value: CoreFoundation.CGFloat) -> Swift.Bool
@available(*, unavailable, message: "use the isInfinite property.")
public func isinf(_ value: CoreFoundation.CGFloat) -> Swift.Bool
@available(*, unavailable, message: "use the isNaN property.")
public func isnan(_ value: CoreFoundation.CGFloat) -> Swift.Bool
@available(*, unavailable, message: "use the sign property.")
public func signbit(_ value: CoreFoundation.CGFloat) -> Swift.Int
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@available(swift, deprecated: 4.2, renamed: "scalbn")
@_transparent public func ldexp(_ x: CoreFoundation.CGFloat, _ n: Swift.Int) -> CoreFoundation.CGFloat {
    return CGFloat(ldexp(x.native, n))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@available(swift, deprecated: 4.2, message: "use the exponent property.")
@_transparent public func ilogb(_ x: CoreFoundation.CGFloat) -> Swift.Int {
    return Int(x.exponent)
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func lgamma(_ x: CoreFoundation.CGFloat) -> (CoreFoundation.CGFloat, Swift.Int) {
    let (value, sign) = lgamma(x.native)
    return (CGFloat(value), sign)
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func remquo(_ x: CoreFoundation.CGFloat, _ y: CoreFoundation.CGFloat) -> (CoreFoundation.CGFloat, Swift.Int) {
    let (rem, quo) = remquo(x.native, y.native)
    return (CGFloat(rem), quo)
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@available(swift, deprecated: 4.2, message: "use CGFloat(nan: CGFloat.RawSignificand) instead.")
@_transparent public func nan(_ tag: Swift.String) -> CoreFoundation.CGFloat {
    return CGFloat(nan(tag) as CGFloat.NativeType)
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func j0(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(j0(Double(x.native)))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func j1(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(j1(Double(x.native)))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func jn(_ n: Swift.Int, _ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(jn(n, Double(x.native)))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func y0(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(y0(Double(x.native)))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func y1(_ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(y1(Double(x.native)))
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
@_transparent public func yn(_ n: Swift.Int, _ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    return CGFloat(yn(n, Double(x.native)))
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@_cdecl("CGFloatNearlyEqualToFloat")
@usableFromInline
internal func CGFloatNearlyEqualToFloat(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat) -> Swift.Bool
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@_cdecl("CGFloatNearlyEqualToFloatWithTolerance")
@usableFromInline
internal func CGFloatNearlyEqualToFloatWithTolerance(_ lhs: CoreFoundation.CGFloat, _ rhs: CoreFoundation.CGFloat, _ tolerance: CoreFoundation.CGFloat) -> Swift.Bool
@available(macOS 15.4, iOS 18.4, tvOS 18.4, watchOS 11.4, visionOS 2.4, *)
@usableFromInline
internal let finity: Swift.Range<CoreFoundation.CGFloat>
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGPoint {
  public static var zero: CoreFoundation.CGPoint {
    @_transparent get { return CGPoint(x: 0, y: 0) }
  }
  @_transparent public init(x: Swift.Int, y: Swift.Int) {
        self.init(x: CGFloat(x), y: CGFloat(y))
    }
  @_transparent public init(x: Swift.Double, y: Swift.Double) {
        self.init(x: CGFloat(x), y: CGFloat(y))
    }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(dictionaryRepresentation dict: CoreFoundation.CFDictionary)
  #endif
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGPoint : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGPoint : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "CGPoint.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGPoint : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGPoint : Swift.Equatable {
  @_transparent public static func == (lhs: CoreFoundation.CGPoint, rhs: CoreFoundation.CGPoint) -> Swift.Bool {
        return lhs.x == rhs.x && lhs.y == rhs.y
    }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGPoint {
  @_alwaysEmitIntoClient public func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(x)
        hasher.combine(y)
    }
  @_alwaysEmitIntoClient public var hashValue: Swift.Int {
    get {
        var hasher = Hasher()
        hash(into: &hasher)
        return hasher.finalize()
    }
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreFoundation.CGPoint : Swift.Hashable {
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGPoint : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@_cdecl("CGPointNearlyEqualToPoint")
@usableFromInline
internal func CGPointNearlyEqualToPoint(_ lhs: CoreFoundation.CGPoint, _ rhs: CoreFoundation.CGPoint) -> Swift.Bool
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@_cdecl("CGPointNearlyEqualToPointWithTolerance")
@usableFromInline
internal func CGPointNearlyEqualToPointWithTolerance(_ lhs: CoreFoundation.CGPoint, _ rhs: CoreFoundation.CGPoint, _ tolerance: CoreFoundation.CGFloat) -> Swift.Bool
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGImage {
  #if compiler(>=5.3) && $NonescapableTypes
  public func copy(maskingColorComponents components: [CoreFoundation.CGFloat]) -> CoreGraphics.CGImage?
  #endif
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGImage : @unchecked Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, visionOS 1.0, *)
extension CoreGraphics.CGEvent {
  #if compiler(>=5.3) && $NonescapableTypes
  public var data: CoreFoundation.CFData? {
    get
  }
  #endif
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public protocol _CGRenderingBufferProviderInit {
  #if compiler(>=5.3) && $NonescapableTypes
  init?<T>(info: T, size: Swift.Int) where T : CoreGraphics.CGRenderingBufferProvider.Info
  #endif
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreGraphics._CGRenderingBufferProviderInit where Self : CoreGraphics.CGRenderingBufferProvider {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?<T>(info: T, size: Swift.Int) where T : CoreGraphics.CGRenderingBufferProvider.Info
  #endif
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreGraphics.CGRenderingBufferProvider : CoreGraphics._CGRenderingBufferProviderInit {
  public protocol Info : AnyObject {
    #if compiler(>=5.3) && $NonescapableTypes
    func lock() -> Swift.UnsafeMutableRawPointer?
    #endif
    func unlock(_: Swift.UnsafeMutableRawPointer)
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreGraphics.CGImageByteOrderInfo : Swift.CaseIterable {
  public static let allCases: [CoreGraphics.CGImageByteOrderInfo]
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias AllCases = [CoreGraphics.CGImageByteOrderInfo]
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGImageByteOrderInfo : Swift.CustomDebugStringConvertible {
  @_alwaysEmitIntoClient public var debugDescription: Swift.String {
    get {
        switch self {
        case .orderDefault: "orderDefault"
        case .order16Little: "order16Little"
        case .order32Little: "order32Little"
        case .order16Big: "order16Big"
        case .order32Big: "order32Big"
        default: "init(rawValue: \(rawValue))"
        }
    }
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGRect {
  public static var zero: CoreFoundation.CGRect {
    @_transparent get { return CGRect(x: 0, y: 0, width: 0, height: 0) }
  }
  @_transparent public init(x: CoreFoundation.CGFloat, y: CoreFoundation.CGFloat, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat) {
        self.init(origin: CGPoint(x: x, y: y), size: CGSize(width: width, height: height))
    }
  @_transparent public init(x: Swift.Double, y: Swift.Double, width: Swift.Double, height: Swift.Double) {
        self.init(origin: CGPoint(x: x, y: y), size: CGSize(width: width, height: height))
    }
  @_transparent public init(x: Swift.Int, y: Swift.Int, width: Swift.Int, height: Swift.Int) {
        self.init(origin: CGPoint(x: x, y: y), size: CGSize(width: width, height: height))
    }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(dictionaryRepresentation dict: CoreFoundation.CFDictionary)
  #endif
  @_transparent public func divided(atDistance: CoreFoundation.CGFloat, from fromEdge: CoreFoundation.CGRectEdge) -> (slice: CoreFoundation.CGRect, remainder: CoreFoundation.CGRect) {
        var slice = CGRect.zero
        var remainder = CGRect.zero
        self.__divided(
            slice: &slice, remainder: &remainder, atDistance: atDistance,
            from: fromEdge)
        return (slice, remainder)
    }
  @available(*, unavailable, renamed: "minX")
  public var x: CoreFoundation.CGFloat {
    get
  }
  @available(*, unavailable, renamed: "minY")
  public var y: CoreFoundation.CGFloat {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGRect : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGRect : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "CGRect.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGRect : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGRect : Swift.Equatable {
  @_transparent public static func == (lhs: CoreFoundation.CGRect, rhs: CoreFoundation.CGRect) -> Swift.Bool {
        return lhs.equalTo(rhs)
    }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGRect {
  @_alwaysEmitIntoClient public func hash(into hasher: inout Swift.Hasher) {
        let standard = standardized
        hasher.combine(standard.origin.x)
        hasher.combine(standard.origin.y)
        hasher.combine(standard.size.width)
        hasher.combine(standard.size.height)
    }
  @_alwaysEmitIntoClient public var hashValue: Swift.Int {
    get {
        var hasher = Hasher()
        hash(into: &hasher)
        return hasher.finalize()
    }
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreFoundation.CGRect : Swift.Hashable {
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGRect : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@_cdecl("CGRectNearlyEqualToRect")
@usableFromInline
internal func CGRectNearlyEqualToRect(_ lhs: CoreFoundation.CGRect, _ rhs: CoreFoundation.CGRect) -> Swift.Bool
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@_cdecl("CGRectNearlyEqualToRectWithTolerance")
@usableFromInline
internal func CGRectNearlyEqualToRectWithTolerance(_ lhs: CoreFoundation.CGRect, _ rhs: CoreFoundation.CGRect, _ tolerance: CoreFoundation.CGFloat) -> Swift.Bool
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreGraphics.CGImagePixelFormatInfo : Swift.CaseIterable {
  public static let allCases: [CoreGraphics.CGImagePixelFormatInfo]
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias AllCases = [CoreGraphics.CGImagePixelFormatInfo]
}
@available(macOS 10.14, iOS 12.0, tvOS 12.0, watchOS 5.0, visionOS 1.0, *)
extension CoreGraphics.CGImagePixelFormatInfo : Swift.CustomDebugStringConvertible {
  @_alwaysEmitIntoClient public var debugDescription: Swift.String {
    get {
        switch self {
        case .packed: "packed"
        case .RGB555: "RGB555"
        case .RGB565: "RGB565"
        case .RGB101010: "RGB101010"
        case .RGBCIF10: "RGBCIF10"
        default: "init(rawValue: \(rawValue))"
        }
    }
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreGraphics.CGImageAlphaInfo : Swift.CaseIterable {
  public static let allCases: [CoreGraphics.CGImageAlphaInfo]
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias AllCases = [CoreGraphics.CGImageAlphaInfo]
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGImageAlphaInfo : Swift.CustomDebugStringConvertible {
  @_alwaysEmitIntoClient public var debugDescription: Swift.String {
    get {
        switch self {
        case .none: "none"
        case .premultipliedLast: "premultipliedLast"
        case .premultipliedFirst: "premultipliedFirst"
        case .last: "last"
        case .first: "first"
        case .noneSkipLast: "noneSkipLast"
        case .noneSkipFirst: "noneSkipFirst"
        case .alphaOnly: "alphaOnly"
        default: "init(rawValue: \(rawValue))"
        }
    }
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGAffineTransform {
  public static var identity: CoreFoundation.CGAffineTransform {
    @_transparent get { return CGAffineTransform(a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0) }
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGAffineTransform : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGAffineTransform : Swift.Equatable {
  public static func == (lhs: CoreFoundation.CGAffineTransform, rhs: CoreFoundation.CGAffineTransform) -> Swift.Bool
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGAffineTransform {
  @_alwaysEmitIntoClient public func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(a)
        hasher.combine(b)
        hasher.combine(c)
        hasher.combine(d)
        hasher.combine(tx)
        hasher.combine(ty)
    }
  @_alwaysEmitIntoClient public var hashValue: Swift.Int {
    get {
        var hasher = Hasher()
        hash(into: &hasher)
        return hasher.finalize()
    }
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreFoundation.CGAffineTransform : Swift.Hashable {
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGVector {
  public static var zero: CoreFoundation.CGVector {
    @_transparent get { return CGVector(dx: 0, dy: 0) }
  }
  @_transparent public init(dx: Swift.Int, dy: Swift.Int) {
        self.init(dx: CGFloat(dx), dy: CGFloat(dy))
    }
  @_transparent public init(dx: Swift.Double, dy: Swift.Double) {
        self.init(dx: CGFloat(dx), dy: CGFloat(dy))
    }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGVector : Swift.Equatable {
  @_transparent public static func == (lhs: CoreFoundation.CGVector, rhs: CoreFoundation.CGVector) -> Swift.Bool {
        return lhs.dx == rhs.dx && lhs.dy == rhs.dy
    }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGVector {
  @_alwaysEmitIntoClient public func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(dx)
        hasher.combine(dy)
    }
  @_alwaysEmitIntoClient public var hashValue: Swift.Int {
    get {
        var hasher = Hasher()
        hash(into: &hasher)
        return hasher.finalize()
    }
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreFoundation.CGVector : Swift.Hashable {
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGVector : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGVector : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@_cdecl("CGVectorNearlyEqualToVector")
@usableFromInline
internal func CGVectorNearlyEqualToVector(_ lhs: CoreFoundation.CGVector, _ rhs: CoreFoundation.CGVector) -> Swift.Bool
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@_cdecl("CGVectorNearlyEqualToVectorWithTolerance")
@usableFromInline
internal func CGVectorNearlyEqualToVectorWithTolerance(_ lhs: CoreFoundation.CGVector, _ rhs: CoreFoundation.CGVector, _ tolerance: CoreFoundation.CGFloat) -> Swift.Bool
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGBitmapInfo {
  @available(macOS 10.14, iOS 12.0, tvOS 12.0, watchOS 5.0, visionOS 1.0, *)
  @_alwaysEmitIntoClient public init(alpha: CoreGraphics.CGImageAlphaInfo = .none, component: CoreGraphics.CGImageComponentInfo = .integer, byteOrder: CoreGraphics.CGImageByteOrderInfo = .orderDefault, pixelFormat: CoreGraphics.CGImagePixelFormatInfo = .packed) {
        self = __CGBitmapInfoMake(alpha, component, byteOrder, pixelFormat)
    }
  @_alwaysEmitIntoClient public init(alpha: CoreGraphics.CGImageAlphaInfo = .none, component: CoreGraphics.CGImageComponentInfo = .integer, byteOrder: CoreGraphics.CGImageByteOrderInfo = .orderDefault) {
        self.init(rawValue: alpha.rawValue | component.rawValue | byteOrder.rawValue)
    }
  @_alwaysEmitIntoClient public var alpha: CoreGraphics.CGImageAlphaInfo {
    get {
            .init(rawValue: rawValue & CGBitmapInfo.__alphaInfoMask.rawValue)!
        }
    set {
            self = .init(rawValue: (rawValue & ~CGBitmapInfo.__alphaInfoMask.rawValue) | newValue.rawValue)
        }
  }
  @_alwaysEmitIntoClient public var component: CoreGraphics.CGImageComponentInfo {
    get {
            .init(rawValue: rawValue & CGBitmapInfo.__componentInfoMask.rawValue)!
        }
    set {
            self = .init(rawValue: (rawValue & ~CGBitmapInfo.__componentInfoMask.rawValue) | newValue.rawValue)
        }
  }
  @_alwaysEmitIntoClient public var byteOrder: CoreGraphics.CGImageByteOrderInfo {
    get {
            .init(rawValue: rawValue & CGBitmapInfo.__byteOrderInfoMask.rawValue)!
        }
    set {
            self = .init(rawValue: (rawValue & ~CGBitmapInfo.__byteOrderInfoMask.rawValue) | newValue.rawValue)
        }
  }
  @available(macOS 10.14, iOS 12.0, tvOS 12.0, watchOS 5.0, visionOS 1.0, *)
  @_alwaysEmitIntoClient public var pixelFormat: CoreGraphics.CGImagePixelFormatInfo {
    get {
            .init(rawValue: rawValue & CGBitmapInfo.__pixelFormatInfoMask.rawValue)!
        }
    set {
            self = .init(rawValue: (rawValue & ~CGBitmapInfo.__pixelFormatInfoMask.rawValue) | newValue.rawValue)
        }
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGBitmapInfo : Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  @_alwaysEmitIntoClient public var debugDescription: Swift.String {
    get {
        if #available(macOS 10.14, iOS 12.0, tvOS 12.0, watchOS 5.0, visionOS 1.0, *) {
            "CGBitmapInfo(alpha: .\(alpha), component: .\(component), byteOrder: .\(byteOrder), pixelFormat: .\(pixelFormat))"
        } else {
            "CGBitmapInfo(alpha: .\(alpha), component: .\(component), byteOrder: .\(byteOrder))"
        }
    }
  }
  @_alwaysEmitIntoClient public var customMirror: Swift.Mirror {
    get {
        let children: KeyValuePairs<String, Any>
        if #available(macOS 10.14, iOS 12.0, tvOS 12.0, watchOS 5.0, visionOS 1.0, *) {
            children = [
                "alpha": alpha,
                "component": component,
                "byteOrder": byteOrder,
                "pixelFormat": pixelFormat
            ]
        } else {
            children = [
                "alpha": alpha,
                "component": component,
                "byteOrder": byteOrder
            ]
        }
        return Mirror(self, children: children, displayStyle: .struct)
    }
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGBitmapInfo {
  @available(macOS, deprecated: 10000.0, message: "Use .alpha instead")
  @available(iOS, deprecated: 10000.0, message: "Use .alpha instead")
  @available(tvOS, deprecated: 10000.0, message: "Use .alpha instead")
  @available(watchOS, deprecated: 10000.0, message: "Use .alpha instead")
  @available(visionOS, deprecated: 10000.0, message: "Use .alpha instead")
  @_alwaysEmitIntoClient public static var alphaInfoMask: CoreGraphics.CGBitmapInfo {
    get { CGBitmapInfo.__alphaInfoMask }
  }
  @available(macOS, deprecated: 10000.0, message: "Use .component instead")
  @available(iOS, deprecated: 10000.0, message: "Use .component instead")
  @available(tvOS, deprecated: 10000.0, message: "Use .component instead")
  @available(watchOS, deprecated: 10000.0, message: "Use .component instead")
  @available(visionOS, deprecated: 10000.0, message: "Use .component instead")
  @_alwaysEmitIntoClient public static var floatInfoMask: CoreGraphics.CGBitmapInfo {
    get { CGBitmapInfo.__componentInfoMask }
  }
  @available(macOS, deprecated: 10000.0, message: "Use .byteOrder instead")
  @available(iOS, deprecated: 10000.0, message: "Use .byteOrder instead")
  @available(tvOS, deprecated: 10000.0, message: "Use .byteOrder instead")
  @available(watchOS, deprecated: 10000.0, message: "Use .byteOrder instead")
  @available(visionOS, deprecated: 10000.0, message: "Use .byteOrder instead")
  @_alwaysEmitIntoClient public static var byteOrderMask: CoreGraphics.CGBitmapInfo {
    get { CGBitmapInfo.__byteOrderInfoMask }
  }
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @_disfavoredOverload @_alwaysEmitIntoClient public init(arrayLiteral: CoreGraphics.CGBitmapInfo...) {
        self.init()
        for e in arrayLiteral { insert(e) }
    }
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @_alwaysEmitIntoClient public init(_ sequence: some Sequence<CGBitmapInfo>) {
        self.init()
        for e in sequence { insert(e) }
    }
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @_alwaysEmitIntoClient public func union(_ other: CoreGraphics.CGBitmapInfo) -> CoreGraphics.CGBitmapInfo {
        CGBitmapInfo(rawValue: self.rawValue | other.rawValue)
    }
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @_alwaysEmitIntoClient public func intersection(_ other: CoreGraphics.CGBitmapInfo) -> CoreGraphics.CGBitmapInfo {
        CGBitmapInfo(rawValue: self.rawValue & other.rawValue)
    }
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @_alwaysEmitIntoClient public func symmetricDifference(_ other: CoreGraphics.CGBitmapInfo) -> CoreGraphics.CGBitmapInfo {
        CGBitmapInfo(rawValue: self.rawValue ^ other.rawValue)
    }
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @_alwaysEmitIntoClient public func contains(_ member: CoreGraphics.CGBitmapInfo) -> Swift.Bool {
        rawValue & member.rawValue == member.rawValue
    }
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @discardableResult
  @_alwaysEmitIntoClient public mutating func insert(_ newMember: CoreGraphics.CGBitmapInfo) -> (inserted: Swift.Bool, memberAfterInsert: CoreGraphics.CGBitmapInfo) {
        let oldMember = self.intersection(newMember)
        let shouldInsert = oldMember != newMember
        let result = (
            inserted: shouldInsert,
            memberAfterInsert: shouldInsert ? newMember : oldMember)
        if shouldInsert {
            formUnion(newMember)
        }
        return result
    }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @discardableResult
  @_alwaysEmitIntoClient public mutating func remove(_ member: CoreGraphics.CGBitmapInfo) -> CoreGraphics.CGBitmapInfo? {
        let intersectionElements = intersection(member)
        guard !intersectionElements.isEmpty else {
            return nil
        }
        
        subtract(member)
        return intersectionElements
    }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @discardableResult
  @_alwaysEmitIntoClient public mutating func update(with newMember: CoreGraphics.CGBitmapInfo) -> CoreGraphics.CGBitmapInfo? {
        let r = self.intersection(newMember)
        formUnion(newMember)
        return r.isEmpty ? nil : r
    }
  #endif
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @_alwaysEmitIntoClient public mutating func formUnion(_ other: CoreGraphics.CGBitmapInfo) {
        self = CGBitmapInfo(rawValue: self.rawValue | other.rawValue)
    }
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @_alwaysEmitIntoClient public mutating func formIntersection(_ other: CoreGraphics.CGBitmapInfo) {
        self = CGBitmapInfo(rawValue: self.rawValue & other.rawValue)
    }
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @_alwaysEmitIntoClient public mutating func formSymmetricDifference(_ other: CoreGraphics.CGBitmapInfo) {
        self = CGBitmapInfo(rawValue: self.rawValue ^ other.rawValue)
    }
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @_alwaysEmitIntoClient public func subtracting(_ other: CoreGraphics.CGBitmapInfo) -> CoreGraphics.CGBitmapInfo {
        CGBitmapInfo(rawValue: self.rawValue & ~other.rawValue)
    }
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @_alwaysEmitIntoClient public func isSubset(of other: CoreGraphics.CGBitmapInfo) -> Swift.Bool {
        rawValue & other.rawValue == rawValue
    }
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @_alwaysEmitIntoClient public func isDisjoint(with other: CoreGraphics.CGBitmapInfo) -> Swift.Bool {
        rawValue & other.rawValue == 0
    }
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @_alwaysEmitIntoClient public func isSuperset(of other: CoreGraphics.CGBitmapInfo) -> Swift.Bool {
        rawValue & other.rawValue == other.rawValue
    }
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @_alwaysEmitIntoClient public var isEmpty: Swift.Bool {
    get {
        rawValue == 0
    }
  }
  @available(macOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(iOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(tvOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(watchOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @available(visionOS, deprecated: 10000.0, message: "Use init(alpha:component:byteOrder:pixelFormat:) instead")
  @_alwaysEmitIntoClient public mutating func subtract(_ other: CoreGraphics.CGBitmapInfo) {
        self = CGBitmapInfo(rawValue: self.rawValue & ~other.rawValue)
    }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreGraphics.CGImageComponentInfo : Swift.CaseIterable {
  public static let allCases: [CoreGraphics.CGImageComponentInfo]
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias AllCases = [CoreGraphics.CGImageComponentInfo]
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGImageComponentInfo : Swift.CustomDebugStringConvertible {
  @_alwaysEmitIntoClient public var debugDescription: Swift.String {
    get {
        switch self {
        case .integer: "integer"
        case .float: "float"
        default: "init(rawValue: \(rawValue))"
        }
    }
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGSize {
  public static var zero: CoreFoundation.CGSize {
    @_transparent get { return CGSize(width: 0, height: 0) }
  }
  @_transparent public init(width: Swift.Int, height: Swift.Int) {
        self.init(width: CGFloat(width), height: CGFloat(height))
    }
  @_transparent public init(width: Swift.Double, height: Swift.Double) {
        self.init(width: CGFloat(width), height: CGFloat(height))
    }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(dictionaryRepresentation dict: CoreFoundation.CFDictionary)
  #endif
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGSize : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGSize : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "CGSize.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGSize : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGSize : Swift.Equatable {
  @_transparent public static func == (lhs: CoreFoundation.CGSize, rhs: CoreFoundation.CGSize) -> Swift.Bool {
        return lhs.width == rhs.width && lhs.height == rhs.height
    }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGSize {
  @_alwaysEmitIntoClient public func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(width)
        hasher.combine(height)
    }
  @_alwaysEmitIntoClient public var hashValue: Swift.Int {
    get {
        var hasher = Hasher()
        hash(into: &hasher)
        return hasher.finalize()
    }
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension CoreFoundation.CGSize : Swift.Hashable {
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGSize : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@_cdecl("CGSizeNearlyEqualToSize")
@usableFromInline
internal func CGSizeNearlyEqualToSize(_ lhs: CoreFoundation.CGSize, _ rhs: CoreFoundation.CGSize) -> Swift.Bool
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@_cdecl("CGSizeNearlyEqualToSizeWithTolerance")
@usableFromInline
internal func CGSizeNearlyEqualToSizeWithTolerance(_ lhs: CoreFoundation.CGSize, _ rhs: CoreFoundation.CGSize, _ tolerance: CoreFoundation.CGFloat) -> Swift.Bool
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
public enum CGPathFillRule : Swift.Int {
  case winding
  case evenOdd
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  @available(iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, macOS 10.9, *)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGPath {
  public func copy(dashingWithPhase phase: CoreFoundation.CGFloat, lengths: [CoreFoundation.CGFloat], transform: CoreFoundation.CGAffineTransform = .identity) -> CoreGraphics.CGPath
  public func copy(strokingWithWidth lineWidth: CoreFoundation.CGFloat, lineCap: CoreGraphics.CGLineCap, lineJoin: CoreGraphics.CGLineJoin, miterLimit: CoreFoundation.CGFloat, transform: CoreFoundation.CGAffineTransform = .identity) -> CoreGraphics.CGPath
  public func contains(_ point: CoreFoundation.CGPoint, using rule: CoreGraphics.CGPathFillRule = .winding, transform: CoreFoundation.CGAffineTransform = .identity) -> Swift.Bool
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGMutablePath {
  public func addRoundedRect(in rect: CoreFoundation.CGRect, cornerWidth: CoreFoundation.CGFloat, cornerHeight: CoreFoundation.CGFloat, transform: CoreFoundation.CGAffineTransform = .identity)
  public func move(to point: CoreFoundation.CGPoint, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addLine(to point: CoreFoundation.CGPoint, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addQuadCurve(to end: CoreFoundation.CGPoint, control: CoreFoundation.CGPoint, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addCurve(to end: CoreFoundation.CGPoint, control1: CoreFoundation.CGPoint, control2: CoreFoundation.CGPoint, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addRect(_ rect: CoreFoundation.CGRect, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addRects(_ rects: [CoreFoundation.CGRect], transform: CoreFoundation.CGAffineTransform = .identity)
  public func addLines(between points: [CoreFoundation.CGPoint], transform: CoreFoundation.CGAffineTransform = .identity)
  public func addEllipse(in rect: CoreFoundation.CGRect, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addRelativeArc(center: CoreFoundation.CGPoint, radius: CoreFoundation.CGFloat, startAngle: CoreFoundation.CGFloat, delta: CoreFoundation.CGFloat, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addArc(center: CoreFoundation.CGPoint, radius: CoreFoundation.CGFloat, startAngle: CoreFoundation.CGFloat, endAngle: CoreFoundation.CGFloat, clockwise: Swift.Bool, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addArc(tangent1End: CoreFoundation.CGPoint, tangent2End: CoreFoundation.CGPoint, radius: CoreFoundation.CGFloat, transform: CoreFoundation.CGAffineTransform = .identity)
  public func addPath(_ path: CoreGraphics.CGPath, transform: CoreFoundation.CGAffineTransform = .identity)
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension CoreGraphics.CGPath {
  public func union(_ other: CoreGraphics.CGPath, using rule: CoreGraphics.CGPathFillRule = .winding) -> CoreGraphics.CGPath
  public func intersection(_ other: CoreGraphics.CGPath, using rule: CoreGraphics.CGPathFillRule = .winding) -> CoreGraphics.CGPath
  public func subtracting(_ other: CoreGraphics.CGPath, using rule: CoreGraphics.CGPathFillRule = .winding) -> CoreGraphics.CGPath
  public func symmetricDifference(_ other: CoreGraphics.CGPath, using rule: CoreGraphics.CGPathFillRule = .winding) -> CoreGraphics.CGPath
  public func lineSubtracting(_ other: CoreGraphics.CGPath, using rule: CoreGraphics.CGPathFillRule = .winding) -> CoreGraphics.CGPath
  public func lineIntersection(_ other: CoreGraphics.CGPath, using rule: CoreGraphics.CGPathFillRule = .winding) -> CoreGraphics.CGPath
  public func normalized(using rule: CoreGraphics.CGPathFillRule = .winding) -> CoreGraphics.CGPath
  public func flattened(threshold: CoreFoundation.CGFloat) -> CoreGraphics.CGPath
  public func intersects(_ other: CoreGraphics.CGPath, using rule: CoreGraphics.CGPathFillRule = .winding) -> Swift.Bool
  public func componentsSeparated(using rule: CoreGraphics.CGPathFillRule = .winding) -> [CoreGraphics.CGPath]
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public enum CGContentToneMappingInfo {
  public enum LightLevel : Swift.Equatable, Swift.Hashable {
    case relative(Swift.Float)
    case nits(Swift.Int)
    public static func == (a: CoreGraphics.CGContentToneMappingInfo.LightLevel, b: CoreGraphics.CGContentToneMappingInfo.LightLevel) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum DynamicRange : Swift.Equatable, Swift.Hashable {
    case high
    case constrained
    case standard
    public static func == (a: CoreGraphics.CGContentToneMappingInfo.DynamicRange, b: CoreGraphics.CGContentToneMappingInfo.DynamicRange) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct DefaultOptions : Swift.Equatable, Swift.Hashable {
    public var contentAverageLightLevel: CoreGraphics.CGContentToneMappingInfo.LightLevel
    public var preferredDynamicRange: CoreGraphics.CGContentToneMappingInfo.DynamicRange
    public init()
    @_alwaysEmitIntoClient public init(contentAverageLightLevel: CoreGraphics.CGContentToneMappingInfo.LightLevel = .relative(0.0), preferredDynamicRange: CoreGraphics.CGContentToneMappingInfo.DynamicRange = .standard) {
            self.init()
            self.contentAverageLightLevel = contentAverageLightLevel
            self.preferredDynamicRange = preferredDynamicRange
        }
    public static func == (a: CoreGraphics.CGContentToneMappingInfo.DefaultOptions, b: CoreGraphics.CGContentToneMappingInfo.DefaultOptions) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct ITURecommendedOptions : Swift.Equatable, Swift.Hashable {
    public var skipBoostToHDR: Swift.Bool
    public var use100nitsHLGOOTF: Swift.Bool
    public var useBT1886ForCoreVideoGamma: Swift.Bool
    public var useLegacyHDREcosystem: Swift.Bool
    public init()
    @_alwaysEmitIntoClient public init(skipBoostToHDR: Swift.Bool = true, use100nitsHLGOOTF: Swift.Bool = true, useBT1886ForCoreVideoGamma: Swift.Bool = true, useLegacyHDREcosystem: Swift.Bool = true) {
            self.init()
            self.skipBoostToHDR = skipBoostToHDR
            self.use100nitsHLGOOTF = use100nitsHLGOOTF
            self.useBT1886ForCoreVideoGamma = useBT1886ForCoreVideoGamma
            self.useLegacyHDREcosystem = useLegacyHDREcosystem
        }
    public static func == (a: CoreGraphics.CGContentToneMappingInfo.ITURecommendedOptions, b: CoreGraphics.CGContentToneMappingInfo.ITURecommendedOptions) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct EXRGammaOptions : Swift.Equatable, Swift.Hashable {
    public var defog: Swift.Float
    public var exposure: Swift.Float
    public var kneeHigh: Swift.Float
    public var kneeLow: Swift.Float
    public init()
    @_alwaysEmitIntoClient public init(defog: Swift.Float = 0.0, exposure: Swift.Float = 0.0, kneeHigh: Swift.Float = 5.0, kneeLow: Swift.Float = 0.0) {
            self.init()
            self.defog = defog
            self.exposure = exposure
            self.kneeHigh = kneeHigh
            self.kneeLow = kneeLow
        }
    public static func == (a: CoreGraphics.CGContentToneMappingInfo.EXRGammaOptions, b: CoreGraphics.CGContentToneMappingInfo.EXRGammaOptions) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  case `default`(CoreGraphics.CGContentToneMappingInfo.DefaultOptions)
  case imageSpecificLumaScaling(CoreGraphics.CGContentToneMappingInfo.DefaultOptions)
  case referenceWhiteBased(CoreGraphics.CGContentToneMappingInfo.DefaultOptions)
  case ituRecommended(CoreGraphics.CGContentToneMappingInfo.ITURecommendedOptions)
  case exrGamma(CoreGraphics.CGContentToneMappingInfo.EXRGammaOptions)
  case none
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreGraphics.CGContentToneMappingInfo : Swift.Equatable, Swift.Hashable {
  public static func == (a: CoreGraphics.CGContentToneMappingInfo, b: CoreGraphics.CGContentToneMappingInfo) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreGraphics.CGContentToneMappingInfo : Swift.Identifiable {
  @_alwaysEmitIntoClient public var id: CoreGraphics.CGToneMapping {
    get {
        switch self {
        case .default: .default
        case .imageSpecificLumaScaling: .imageSpecificLumaScaling
        case .referenceWhiteBased: .referenceWhiteBased
        case .ituRecommended: .ituRecommended
        case .exrGamma: .exrGamma
        case .none: .none
        @unknown default: .none
        }
    }
  }
  @available(iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, macOS 26.0, *)
  public typealias ID = CoreGraphics.CGToneMapping
}
extension CoreFoundation.CGAffineTransform {
  @_alwaysEmitIntoClient public init(translationX tx: CoreFoundation.CGFloat, y ty: CoreFoundation.CGFloat) {
        self = CGAffineTransformMakeTranslation(tx, ty)
    }
  @_alwaysEmitIntoClient public init(scaleX sx: CoreFoundation.CGFloat, y sy: CoreFoundation.CGFloat) {
        self = CGAffineTransformMakeScale(sx, sy)
    }
  @_alwaysEmitIntoClient public init(rotationAngle angle: CoreFoundation.CGFloat) {
        self = CGAffineTransformMakeRotation(angle)
    }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init(_ components: CoreFoundation.CGAffineTransformComponents) {
        self = __CGAffineTransformMakeWithComponents(components)
    }
  @_alwaysEmitIntoClient public var isIdentity: Swift.Bool {
    get { CGAffineTransformIsIdentity(self) }
  }
  @_alwaysEmitIntoClient public func translatedBy(x tx: CoreFoundation.CGFloat, y ty: CoreFoundation.CGFloat) -> CoreFoundation.CGAffineTransform {
        CGAffineTransformTranslate(self, tx, ty)
    }
  @_alwaysEmitIntoClient public func scaledBy(x sx: CoreFoundation.CGFloat, y sy: CoreFoundation.CGFloat) -> CoreFoundation.CGAffineTransform {
        CGAffineTransformScale(self, sx, sy)
    }
  @_alwaysEmitIntoClient public func rotated(by angle: CoreFoundation.CGFloat) -> CoreFoundation.CGAffineTransform {
        CGAffineTransformRotate(self, angle)
    }
  @_alwaysEmitIntoClient public func inverted() -> CoreFoundation.CGAffineTransform {
        CGAffineTransformInvert(self)
    }
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public func decomposed() -> CoreFoundation.CGAffineTransformComponents {
        __CGAffineTransformDecompose(self)
    }
  @_alwaysEmitIntoClient public func concatenating(_ t2: CoreFoundation.CGAffineTransform) -> CoreFoundation.CGAffineTransform {
        CGAffineTransformConcat(self, t2)
    }
}
extension CoreFoundation.CGAffineTransformComponents {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init(scale: CoreFoundation.CGSize = .init(width: 1, height: 1), horizontalShear: CoreFoundation.CGFloat = 0, rotation: CoreFoundation.CGFloat = 0, translation: CoreFoundation.CGVector = .zero) {
        self.init()
        self.scale = scale
        self.horizontalShear = horizontalShear
        self.rotation = rotation
        self.translation = translation
    }
}
extension CoreFoundation.CGPoint {
  @_alwaysEmitIntoClient public func applying(_ t: CoreFoundation.CGAffineTransform) -> CoreFoundation.CGPoint {
        CGPointApplyAffineTransform(self, t)
    }
}
extension CoreFoundation.CGSize {
  @_alwaysEmitIntoClient public func applying(_ t: CoreFoundation.CGAffineTransform) -> CoreFoundation.CGSize {
        CGSizeApplyAffineTransform(self, t)
    }
}
extension CoreFoundation.CGRect {
  @_alwaysEmitIntoClient public func applying(_ t: CoreFoundation.CGAffineTransform) -> CoreFoundation.CGRect {
        CGRectApplyAffineTransform(self, t)
    }
}
extension CoreFoundation.CGAffineTransform {
  @_alwaysEmitIntoClient public init(_ a: CoreFoundation.CGFloat, _ b: CoreFoundation.CGFloat, _ c: CoreFoundation.CGFloat, _ d: CoreFoundation.CGFloat, _ tx: CoreFoundation.CGFloat, _ ty: CoreFoundation.CGFloat) {
        self = CGAffineTransformMake(a, b, c, d, tx, ty)
    }
}
extension CoreFoundation.CGPoint {
  @_alwaysEmitIntoClient public func equalTo(_ point2: CoreFoundation.CGPoint) -> Swift.Bool {
        CGPointEqualToPoint(self, point2)
    }
  @_alwaysEmitIntoClient public var dictionaryRepresentation: CoreFoundation.CFDictionary {
    get {
        CGPointCreateDictionaryRepresentation(self)
    }
  }
}
extension CoreFoundation.CGSize {
  @_alwaysEmitIntoClient public func equalTo(_ size2: CoreFoundation.CGSize) -> Swift.Bool {
        CGSizeEqualToSize(self, size2)
    }
  @_alwaysEmitIntoClient public var dictionaryRepresentation: CoreFoundation.CFDictionary {
    get {
        CGSizeCreateDictionaryRepresentation(self)
    }
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreFoundation.CGRect {
  @_transparent public func __divided(slice: Swift.UnsafeMutablePointer<CoreFoundation.CGRect>, remainder: Swift.UnsafeMutablePointer<CoreFoundation.CGRect>, atDistance: CoreFoundation.CGFloat, from: CoreFoundation.CGRectEdge) {
        __CGRectDivide(self, slice, remainder, atDistance, from)
    }
  @_alwaysEmitIntoClient public static var null: CoreFoundation.CGRect {
    get { CGRectNull }
  }
  @_alwaysEmitIntoClient public static var infinite: CoreFoundation.CGRect {
    get { CGRectInfinite }
  }
  @_alwaysEmitIntoClient public var minX: CoreFoundation.CGFloat {
    get { CGRectGetMinX(self) }
  }
  @_alwaysEmitIntoClient public var midX: CoreFoundation.CGFloat {
    get { CGRectGetMidX(self) }
  }
  @_alwaysEmitIntoClient public var maxX: CoreFoundation.CGFloat {
    get { CGRectGetMaxX(self) }
  }
  @_alwaysEmitIntoClient public var minY: CoreFoundation.CGFloat {
    get { CGRectGetMinY(self) }
  }
  @_alwaysEmitIntoClient public var midY: CoreFoundation.CGFloat {
    get { CGRectGetMidY(self) }
  }
  @_alwaysEmitIntoClient public var maxY: CoreFoundation.CGFloat {
    get { CGRectGetMaxY(self) }
  }
  @_alwaysEmitIntoClient public var width: CoreFoundation.CGFloat {
    get { CGRectGetWidth(self) }
  }
  @_alwaysEmitIntoClient public var height: CoreFoundation.CGFloat {
    get { CGRectGetHeight(self) }
  }
  @_alwaysEmitIntoClient public func equalTo(_ rect2: CoreFoundation.CGRect) -> Swift.Bool {
        CGRectEqualToRect(self, rect2)
    }
  @_alwaysEmitIntoClient public var standardized: CoreFoundation.CGRect {
    get { CGRectStandardize(self) }
  }
  @_alwaysEmitIntoClient public var isEmpty: Swift.Bool {
    get { CGRectIsEmpty(self) }
  }
  @_alwaysEmitIntoClient public var isNull: Swift.Bool {
    get { CGRectIsNull(self) }
  }
  @_alwaysEmitIntoClient public var isInfinite: Swift.Bool {
    get { CGRectIsInfinite(self) }
  }
  @_alwaysEmitIntoClient public func insetBy(dx: CoreFoundation.CGFloat, dy: CoreFoundation.CGFloat) -> CoreFoundation.CGRect {
        CGRectInset(self, dx, dy)
    }
  @_alwaysEmitIntoClient public var integral: CoreFoundation.CGRect {
    get { CGRectIntegral(self) }
  }
  @_alwaysEmitIntoClient public func union(_ r2: CoreFoundation.CGRect) -> CoreFoundation.CGRect {
        CGRectUnion(self, r2)
    }
  @_alwaysEmitIntoClient public func intersection(_ r2: CoreFoundation.CGRect) -> CoreFoundation.CGRect {
        CGRectIntersection(self, r2)
    }
  @_alwaysEmitIntoClient public func offsetBy(dx: CoreFoundation.CGFloat, dy: CoreFoundation.CGFloat) -> CoreFoundation.CGRect {
        CGRectOffset(self, dx, dy)
    }
  @_alwaysEmitIntoClient public func contains(_ point: CoreFoundation.CGPoint) -> Swift.Bool {
        CGRectContainsPoint(self, point)
    }
  @_alwaysEmitIntoClient public func contains(_ rect2: CoreFoundation.CGRect) -> Swift.Bool {
        CGRectContainsRect(self, rect2)
    }
  @_alwaysEmitIntoClient public func intersects(_ rect2: CoreFoundation.CGRect) -> Swift.Bool {
        CGRectIntersectsRect(self, rect2)
    }
  @_alwaysEmitIntoClient public var dictionaryRepresentation: CoreFoundation.CFDictionary {
    get {
        CGRectCreateDictionaryRepresentation(self)
    }
  }
}
@_alwaysEmitIntoClient public func __CGAffineTransformMake(_ a: CoreFoundation.CGFloat, _ b: CoreFoundation.CGFloat, _ c: CoreFoundation.CGFloat, _ d: CoreFoundation.CGFloat, _ tx: CoreFoundation.CGFloat, _ ty: CoreFoundation.CGFloat) -> CoreFoundation.CGAffineTransform {
    CGAffineTransformMake(a, b, c, d, tx, ty)
}
@_alwaysEmitIntoClient public func __CGPointApplyAffineTransform(_ point: CoreFoundation.CGPoint, _ t: CoreFoundation.CGAffineTransform) -> CoreFoundation.CGPoint {
    CGPointApplyAffineTransform(point, t)
}
@_alwaysEmitIntoClient public func __CGSizeApplyAffineTransform(_ size: CoreFoundation.CGSize, _ t: CoreFoundation.CGAffineTransform) -> CoreFoundation.CGSize {
    CGSizeApplyAffineTransform(size, t)
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGColorSpace {
  #if compiler(>=5.3) && $NonescapableTypes
  public var colorTable: [Swift.UInt8]? {
    get
  }
  #endif
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGColorSpace : @unchecked Swift.Sendable {
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGContext {
  public func setLineDash(phase: CoreFoundation.CGFloat, lengths: [CoreFoundation.CGFloat])
  public func move(to point: CoreFoundation.CGPoint)
  public func addLine(to point: CoreFoundation.CGPoint)
  public func addCurve(to end: CoreFoundation.CGPoint, control1: CoreFoundation.CGPoint, control2: CoreFoundation.CGPoint)
  public func addQuadCurve(to end: CoreFoundation.CGPoint, control: CoreFoundation.CGPoint)
  public func addRects(_ rects: [CoreFoundation.CGRect])
  public func addLines(between points: [CoreFoundation.CGPoint])
  public func addArc(center: CoreFoundation.CGPoint, radius: CoreFoundation.CGFloat, startAngle: CoreFoundation.CGFloat, endAngle: CoreFoundation.CGFloat, clockwise: Swift.Bool)
  public func addArc(tangent1End: CoreFoundation.CGPoint, tangent2End: CoreFoundation.CGPoint, radius: CoreFoundation.CGFloat)
  public func fillPath(using rule: CoreGraphics.CGPathFillRule = .winding)
  public func clip(using rule: CoreGraphics.CGPathFillRule = .winding)
  public func fill(_ rects: [CoreFoundation.CGRect])
  public func strokeLineSegments(between points: [CoreFoundation.CGPoint])
  public func clip(to rects: [CoreFoundation.CGRect])
  public func draw(_ image: CoreGraphics.CGImage, in rect: CoreFoundation.CGRect, byTiling: Swift.Bool = false)
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public func draw(_ image: CoreGraphics.CGImage, in rect: CoreFoundation.CGRect, by toneMapping: CoreGraphics.CGToneMapping = .default, options: CoreFoundation.CFDictionary?) -> Swift.Bool
  #endif
  public var textPosition: CoreFoundation.CGPoint {
    get
    set
  }
  public func showGlyphs(_ glyphs: [CoreGraphics.CGGlyph], at positions: [CoreFoundation.CGPoint])
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGContext {
  public func draw(_ layer: CoreGraphics.CGLayer, in rect: CoreFoundation.CGRect)
  public func draw(_ layer: CoreGraphics.CGLayer, at point: CoreFoundation.CGPoint)
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
@dynamicMemberLookup public struct CGBitmapParameters {
  @usableFromInline
  internal var params: Swift.UnsafeMutablePointer<CoreGraphics.__CGBitmapParameters> {
    get
  }
  @_alwaysEmitIntoClient public subscript<T>(dynamicMember keyPath: Swift.KeyPath<CoreGraphics.__CGBitmapParameters, T>) -> T {
    get {
        params.pointee[keyPath: keyPath]
    }
  }
  @_alwaysEmitIntoClient public subscript<T>(dynamicMember keyPath: Swift.WritableKeyPath<CoreGraphics.__CGBitmapParameters, T>) -> T {
    get {
            params.pointee[keyPath: keyPath]
        }
    _modify {
            yield &params.pointee[keyPath: keyPath]
        }
  }
  @_alwaysEmitIntoClient public var colorSpace: CoreGraphics.CGColorSpace {
    get {
            params.pointee.colorSpace.takeUnretainedValue()
        }
    set {
            let retainedNewValue = Unmanaged.passRetained(newValue)
            params.pointee.colorSpace.release()
            params.pointee.colorSpace = retainedNewValue
        }
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
public protocol _CGContextInit {
  #if compiler(>=5.3) && $NonescapableTypes
  init?(width: Swift.Int, height: Swift.Int, auxiliaryInfo: CoreGraphics.CGContext.AuxiliaryInfo, onResolve: ((CoreGraphics.CGContentInfo, inout CoreGraphics.CGBitmapParameters) -> Swift.Bool)?, onAllocate: ((CoreGraphics.CGContentInfo, CoreGraphics.CGBitmapParameters) -> CoreGraphics.CGRenderingBufferProvider?)?, onRelease: ((CoreGraphics.CGRenderingBufferProvider?, CoreGraphics.CGContentInfo, CoreGraphics.CGBitmapParameters) -> Swift.Void)?, onError: ((Foundation.NSError, CoreGraphics.CGContentInfo, CoreGraphics.CGBitmapParameters) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  init?(width: Swift.Int, height: Swift.Int, auxiliaryInfo: CoreGraphics.CGContext.AuxiliaryInfo, onResolve: ((CoreGraphics.CGContentInfo, inout CoreGraphics.CGBitmapParameters) -> Swift.Bool)?)
  #endif
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreGraphics._CGContextInit where Self : CoreGraphics.CGContext {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(width: Swift.Int, height: Swift.Int, auxiliaryInfo: CoreGraphics.CGContext.AuxiliaryInfo = CGContext.AuxiliaryInfo(), onResolve: ((CoreGraphics.CGContentInfo, inout CoreGraphics.CGBitmapParameters) -> Swift.Bool)? = nil, onAllocate: ((CoreGraphics.CGContentInfo, CoreGraphics.CGBitmapParameters) -> CoreGraphics.CGRenderingBufferProvider?)? = nil, onRelease: ((CoreGraphics.CGRenderingBufferProvider?, CoreGraphics.CGContentInfo, CoreGraphics.CGBitmapParameters) -> Swift.Void)? = nil, onError: ((Foundation.NSError, CoreGraphics.CGContentInfo, CoreGraphics.CGBitmapParameters) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(width: Swift.Int, height: Swift.Int, auxiliaryInfo: CoreGraphics.CGContext.AuxiliaryInfo, onResolve: ((CoreGraphics.CGContentInfo, inout CoreGraphics.CGBitmapParameters) -> Swift.Bool)? = nil)
  #endif
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreGraphics.CGContext : CoreGraphics._CGContextInit {
  public struct AuxiliaryInfo : Swift.Equatable, Swift.Hashable, Swift.Sendable {
    public var maximumBitDepth: CoreGraphics.CGComponent
    public init()
    @_alwaysEmitIntoClient public init(maximumBitDepth: CoreGraphics.CGComponent = .float16Bit) {
            self.init()
            self.maximumBitDepth = maximumBitDepth
        }
    public static func == (a: CoreGraphics.CGContext.AuxiliaryInfo, b: CoreGraphics.CGContext.AuxiliaryInfo) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, visionOS 26.0, *)
extension CoreGraphics.CGContext {
  public var contentToneMappingInfo: CoreGraphics.CGContentToneMappingInfo {
    get
    set
  }
}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGPathFillRule : Swift.Equatable {}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGPathFillRule : Swift.Hashable {}
@available(macOS 10.9, iOS 7.0, tvOS 9.0, watchOS 2.0, visionOS 1.0, *)
extension CoreGraphics.CGPathFillRule : Swift.RawRepresentable {}
