// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2 effective-5.10 (swiftlang-6.2.0.17.14 clang-1700.3.17.1)
// swift-module-flags: -target x86_64-apple-macos26.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 7622.1.22.11.14 -module-name AuthenticationServices
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2
@_exported import AuthenticationServices
import CryptoKit
import DeveloperToolsSupport
import Foundation
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os
@available(macOS 15.4, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationProviderExtensionLoginManager {
  public func attestKey(ofType keyType: AuthenticationServices.ASAuthorizationProviderExtensionKeyType, clientDataHash: Foundation.Data) async throws -> [Security.SecCertificate]
  public func attestPendingKey(ofType pendingKeyType: AuthenticationServices.ASAuthorizationProviderExtensionKeyType, clientDataHash: Foundation.Data) async throws -> [Security.SecCertificate]
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ASPasskeyAssertionCredentialExtensionInput {
  #if compiler(>=5.3) && $NonescapableTypes
  public var largeBlob: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobAssertionInput? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var prf: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFAssertionInput? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(largeBlob: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobAssertionInput? = nil, prf: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFAssertionInput? = nil)
  #endif
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ASPasskeyAssertionCredentialExtensionOutput {
  #if compiler(>=5.3) && $NonescapableTypes
  public var largeBlob: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobAssertionOutput? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var prf: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFAssertionOutput? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(largeBlob: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobAssertionOutput? = nil, prf: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFAssertionOutput? = nil)
  #endif
}
@objc @_hasMissingDesignatedInitializers @available(macOS 26.0, iOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public class ASAuthorizationAccountCreationPlatformPublicKeyCredentialRequest : AuthenticationServices.ASAuthorizationRequest, Swift.Codable, @unchecked Swift.Sendable {
  final public let acceptedContactIdentifiers: [AuthenticationServices.ASContactIdentifierRequest]
  final public let shouldRequestName: Swift.Bool
  final public let relyingPartyIdentifier: Swift.String
  final public let challenge: Foundation.Data
  final public let userID: Foundation.Data
  @objc override dynamic public func encode(with coder: Foundation.NSCoder)
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ASPasskeyRegistrationCredentialExtensionOutput {
  #if compiler(>=5.3) && $NonescapableTypes
  public var largeBlob: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobRegistrationOutput? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var prf: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFRegistrationOutput? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(largeBlob: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobRegistrationOutput? = nil, prf: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFRegistrationOutput? = nil)
  #endif
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialRegistration {
  #if compiler(>=5.3) && $NonescapableTypes
  public var prf: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFRegistrationOutput? {
    get
  }
  #endif
}
@available(macOS 26.0, iOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public enum ASContactIdentifier : Swift.Sendable {
  case phoneNumber(AuthenticationServices.ASPhoneNumberIdentifier)
  case email(AuthenticationServices.ASEmailIdentifier)
}
@available(macOS 26.0, iOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ASPhoneNumberIdentifier : Swift.Sendable {
  public var value: Swift.String
}
@available(macOS 26.0, iOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ASEmailIdentifier : Swift.Sendable {
  public var value: Swift.String
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
final public class ASCredentialUpdater {
  public init()
  final public func reportPublicKeyCredentialUpdate(relyingPartyIdentifier: Swift.String, userHandle: Foundation.Data, newName: Swift.String) async throws
  final public func reportUnknownPublicKeyCredential(relyingPartyIdentifier: Swift.String, credentialID: Foundation.Data) async throws
  final public func reportAllAcceptedPublicKeyCredentials(relyingPartyIdentifier: Swift.String, userHandle: Foundation.Data, acceptedCredentialIDs: [Foundation.Data]) async throws
  final public func reportUnusedPasswordCredential(domain: Swift.String, userName: Swift.String) async throws
  @objc deinit
}
@available(macOS 14.0, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationProviderExtensionLoginConfiguration {
  public var jwksTrustedRootCertificates: [Security.SecCertificate] {
    get
  }
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialRegistrationRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  public var prf: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFRegistrationInput? {
    get
    set
  }
  #endif
}
@available(macOS 14.0, iOS 17.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ASAuthorizationPublicKeyCredentialLargeBlobAssertionInput {
  public static var read: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobAssertionInput {
    get
  }
  public static func write(_ data: Foundation.Data) -> AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobAssertionInput
  public enum Operation {
    case read
    case write(Foundation.Data)
  }
  public var operation: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobAssertionInput.Operation
}
@available(macOS 14.0, iOS 17.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ASAuthorizationPublicKeyCredentialLargeBlobRegistrationInput {
  public static var supportRequired: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobRegistrationInput {
    get
  }
  public static var supportPreferred: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobRegistrationInput {
    get
  }
  public enum SupportRequirement {
    case required
    case preferred
    public static func == (a: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobRegistrationInput.SupportRequirement, b: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobRegistrationInput.SupportRequirement) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var supportRequirement: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobRegistrationInput.SupportRequirement
}
@available(macOS 14.0, iOS 17.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ASAuthorizationPublicKeyCredentialLargeBlobAssertionOutput {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public static func read(data: Foundation.Data?) -> AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobAssertionOutput
  #endif
  @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public static func write(success: Swift.Bool) -> AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobAssertionOutput
  public enum OperationResult {
    case read(data: Foundation.Data?)
    case write(success: Swift.Bool)
  }
  public var result: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobAssertionOutput.OperationResult
}
@available(macOS 14.0, iOS 17.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ASAuthorizationPublicKeyCredentialLargeBlobRegistrationOutput {
  @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public static var supported: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobRegistrationOutput {
    get
  }
  @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public static var unsupported: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobRegistrationOutput {
    get
  }
  public var isSupported: Swift.Bool
}
@available(macOS 14.0, iOS 17.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialRegistrationRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  public var largeBlob: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobRegistrationInput? {
    get
    set
  }
  #endif
}
@available(macOS 14.0, iOS 17.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialAssertionRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  public var largeBlob: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobAssertionInput? {
    get
    set
  }
  #endif
}
@available(macOS 14.0, iOS 17.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialRegistration {
  #if compiler(>=5.3) && $NonescapableTypes
  public var largeBlob: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobRegistrationOutput? {
    get
  }
  #endif
}
@available(macOS 14.0, iOS 17.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialAssertion {
  #if compiler(>=5.3) && $NonescapableTypes
  public var largeBlob: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobAssertionOutput? {
    get
  }
  #endif
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ASAuthorizationPublicKeyCredentialPRFAssertionInput {
  public struct InputValues {
    #if compiler(>=5.3) && $NonescapableTypes
    public init(saltInput1: Foundation.Data, saltInput2: Foundation.Data? = nil)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public static func saltInput1(_ saltInput1: Foundation.Data, saltInput2: Foundation.Data? = nil) -> AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFAssertionInput.InputValues
    #endif
    public var saltInput1: Foundation.Data
    public var saltInput2: Foundation.Data?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public static func inputValues(_ inputValues: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFAssertionInput.InputValues, perCredentialInputValues: [Foundation.Data : AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFAssertionInput.InputValues]? = nil) -> AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFAssertionInput
  #endif
  public static func perCredentialInputValues(_ perCredentialInputValues: [Foundation.Data : AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFAssertionInput.InputValues]) -> AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFAssertionInput
  public let inputValues: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFAssertionInput.InputValues?
  public let perCredentialInputValues: [Foundation.Data : AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFAssertionInput.InputValues]?
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ASAuthorizationPublicKeyCredentialPRFAssertionOutput {
  public let first: CryptoKit.SymmetricKey
  public let second: CryptoKit.SymmetricKey?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(first: CryptoKit.SymmetricKey, second: CryptoKit.SymmetricKey?)
  #endif
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ASAuthorizationPublicKeyCredentialPRFRegistrationInput {
  public typealias InputValues = AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFAssertionInput.InputValues
  public static var checkForSupport: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFRegistrationInput {
    get
  }
  public static func inputValues(_ inputValues: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFRegistrationInput.InputValues) -> AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFRegistrationInput
  public let shouldCheckForSupport: Swift.Bool
  public let inputValues: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFRegistrationInput.InputValues?
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ASAuthorizationPublicKeyCredentialPRFRegistrationOutput {
  public static var supported: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFRegistrationOutput {
    get
  }
  public static var unsupported: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFRegistrationOutput {
    get
  }
  public let isSupported: Swift.Bool
  public let first: CryptoKit.SymmetricKey?
  public let second: CryptoKit.SymmetricKey?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(first: CryptoKit.SymmetricKey, second: CryptoKit.SymmetricKey?)
  #endif
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.__ASAuthorizationPublicKeyCredentialPRFRegistrationInput {
  @objc public static var checkForSupport: AuthenticationServices.__ASAuthorizationPublicKeyCredentialPRFRegistrationInput {
    @objc get
  }
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASPasskeyCredentialRequestParameters {
  #if compiler(>=5.3) && $NonescapableTypes
  public var extensionInput: AuthenticationServices.ASPasskeyAssertionCredentialExtensionInput? {
    get
  }
  #endif
}
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
extension AuthenticationServices.ASAuthorization : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
extension AuthenticationServices.ASAuthorizationAppleIDCredential : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
extension AuthenticationServices.ASAuthorizationAppleIDProvider : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
extension AuthenticationServices.ASAuthorizationAppleIDRequest : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
extension AuthenticationServices.ASAuthorizationOpenIDRequest : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
extension AuthenticationServices.ASAuthorizationPasswordProvider : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
extension AuthenticationServices.ASAuthorizationPasswordRequest : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationSingleSignOnCredential : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationSingleSignOnProvider : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationSingleSignOnRequest : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
extension AuthenticationServices.ASPasswordCredential : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialAssertion : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialAssertionRequest : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialDescriptor : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialProvider : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialRegistration : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialRegistrationRequest : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPublicKeyCredentialParameters : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialAssertion : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialAssertionRequest : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialDescriptor : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialProvider : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialRegistration : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialRegistrationRequest : @unchecked Swift.Sendable {
}
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
extension AuthenticationServices.ASAuthorizationRequest : @unchecked Swift.Sendable {
}
@available(macOS 13.3, macCatalyst 16.4, iOS 17.4, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
public struct ASAuthorizationWebBrowserPlatformPublicKeyCredential : Swift.Sendable {
  public let name: Swift.String
  @available(macOS 14.0, macCatalyst 17.0, *)
  public let customTitle: Swift.String
  public let relyingParty: Swift.String
  public let credentialID: Foundation.Data
  public let userHandle: Foundation.Data
  @available(macOS 14.0, macCatalyst 17.0, *)
  public let providerName: Swift.String
}
@available(macOS 13.3, macCatalyst 16.4, iOS 17.4, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension AuthenticationServices.ASAuthorizationWebBrowserPublicKeyCredentialManager {
  public func platformCredentials(forRelyingParty relyingParty: Swift.String) async -> [AuthenticationServices.ASAuthorizationWebBrowserPlatformPublicKeyCredential]
}
@available(macOS 13.5, macCatalyst 16.6, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationWebBrowserPlatformPublicKeyCredentialRegistrationRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  public var clientData: AuthenticationServices.ASPublicKeyCredentialClientData? {
    get
  }
  #endif
}
@available(macOS 13.5, macCatalyst 16.6, *)
@available(iOS, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationWebBrowserPlatformPublicKeyCredentialAssertionRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  public var clientData: AuthenticationServices.ASPublicKeyCredentialClientData? {
    get
  }
  #endif
}
@available(macOS 13.5, macCatalyst 16.6, iOS 17.4, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
public protocol ASAuthorizationWebBrowserPlatformPublicKeyCredentialProvider {
  func createCredentialRegistrationRequest(clientData: AuthenticationServices.ASPublicKeyCredentialClientData, name: Swift.String, userID: Foundation.Data) -> AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialRegistrationRequest
  @available(macOS 15.0, iOS 18.0, *)
  func createCredentialRegistrationRequest(clientData: AuthenticationServices.ASPublicKeyCredentialClientData, name: Swift.String, userID: Foundation.Data, requestStyle: AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialRegistrationRequest.RequestStyle) -> AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialRegistrationRequest
  func createCredentialAssertionRequest(clientData: AuthenticationServices.ASPublicKeyCredentialClientData) -> AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialAssertionRequest
}
@available(macOS 13.5, macCatalyst 16.6, iOS 17.4, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialProvider : AuthenticationServices.ASAuthorizationWebBrowserPlatformPublicKeyCredentialProvider {
  public func createCredentialRegistrationRequest(clientData: AuthenticationServices.ASPublicKeyCredentialClientData, name: Swift.String, userID: Foundation.Data) -> AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialRegistrationRequest
  public func createCredentialAssertionRequest(clientData: AuthenticationServices.ASPublicKeyCredentialClientData) -> AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialAssertionRequest
  @available(macOS 15.0, iOS 18.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @available(visionOS, unavailable)
  public func createCredentialRegistrationRequest(clientData: AuthenticationServices.ASPublicKeyCredentialClientData, name: Swift.String, userID: Foundation.Data, requestStyle: AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialRegistrationRequest.RequestStyle) -> AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialRegistrationRequest
}
@available(macOS 14.4, iOS 17.4, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension AuthenticationServices.ASAuthorizationWebBrowserSecurityKeyPublicKeyCredentialAssertionRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  public var clientData: AuthenticationServices.ASPublicKeyCredentialClientData? {
    get
  }
  #endif
}
@available(macOS 14.4, iOS 17.4, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension AuthenticationServices.ASAuthorizationWebBrowserSecurityKeyPublicKeyCredentialRegistrationRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  public var clientData: AuthenticationServices.ASPublicKeyCredentialClientData? {
    get
  }
  #endif
}
@available(macOS 14.4, iOS 17.4, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
public protocol ASAuthorizationWebBrowserSecurityKeyPublicKeyCredentialProvider {
  func createCredentialRegistrationRequest(clientData: AuthenticationServices.ASPublicKeyCredentialClientData, displayName: Swift.String, name: Swift.String, userID: Foundation.Data) -> AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialRegistrationRequest
  func createCredentialAssertionRequest(clientData: AuthenticationServices.ASPublicKeyCredentialClientData) -> AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialAssertionRequest
}
@available(macOS 14.4, iOS 17.4, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialProvider : AuthenticationServices.ASAuthorizationWebBrowserSecurityKeyPublicKeyCredentialProvider {
  public func createCredentialRegistrationRequest(clientData: AuthenticationServices.ASPublicKeyCredentialClientData, displayName: Swift.String, name: Swift.String, userID: Foundation.Data) -> AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialRegistrationRequest
  public func createCredentialAssertionRequest(clientData: AuthenticationServices.ASPublicKeyCredentialClientData) -> AuthenticationServices.ASAuthorizationSecurityKeyPublicKeyCredentialAssertionRequest
}
@objc @_hasMissingDesignatedInitializers @available(macOS 26.0, iOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public class ASAuthorizationAccountCreationPlatformPublicKeyCredential : ObjectiveC.NSObject, AuthenticationServices.ASAuthorizationCredential, @unchecked Swift.Sendable {
  @objc public static let supportsSecureCoding: Swift.Bool
  public var name: Foundation.PersonNameComponents?
  public var contactIdentifier: AuthenticationServices.ASContactIdentifier {
    get
  }
  public var credentialRegistration: AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialRegistration
  #if compiler(>=5.3) && $NonescapableTypes
  @objc public func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  #endif
  @objc public func encode(with coder: Foundation.NSCoder)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc required convenience public init?(coder: Foundation.NSCoder)
  #endif
  @objc deinit
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialAssertion {
  #if compiler(>=5.3) && $NonescapableTypes
  public var prf: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFAssertionOutput? {
    get
  }
  #endif
}
@objc @_inheritsConvenienceInitializers @available(macOS 26.0, iOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public class ASAuthorizationAccountCreationProvider : ObjectiveC.NSObject, AuthenticationServices.ASAuthorizationProvider {
  public func createPlatformPublicKeyCredentialRegistrationRequest(acceptedContactIdentifiers: [AuthenticationServices.ASContactIdentifierRequest], shouldRequestName: Swift.Bool, relyingPartyIdentifier: Swift.String, challenge: Foundation.Data, userID: Foundation.Data) -> AuthenticationServices.ASAuthorizationAccountCreationPlatformPublicKeyCredentialRequest
  @objc override dynamic public init()
  @objc deinit
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASPasskeyAssertionCredential {
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(userHandle: Foundation.Data, relyingParty: Swift.String, signature: Foundation.Data, clientDataHash: Foundation.Data, authenticatorData: Foundation.Data, credentialID: Foundation.Data, extensionOutput: AuthenticationServices.ASPasskeyAssertionCredentialExtensionOutput?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var extensionOutput: AuthenticationServices.ASPasskeyAssertionCredentialExtensionOutput? {
    get
    set
  }
  #endif
}
@available(macOS 14.0, iOS 17.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASPasskeyCredentialIdentity {
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(relyingPartyIdentifier: Swift.String, userName: Swift.String, credentialID: Foundation.Data, userHandle: Foundation.Data, recordIdentifier: Swift.String? = nil)
  #endif
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct ASPasskeyRegistrationCredentialExtensionInput {
  #if compiler(>=5.3) && $NonescapableTypes
  public var largeBlob: AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobRegistrationInput? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var prf: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFRegistrationInput? {
    get
  }
  #endif
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public enum ASPasskeyCredentialExtensionInput {
  case none
  case assertion(AuthenticationServices.ASPasskeyAssertionCredentialExtensionInput)
  case registration(AuthenticationServices.ASPasskeyRegistrationCredentialExtensionInput)
}
@available(iOS 17.0, macOS 14.0, *)
extension AuthenticationServices.ASPasskeyCredentialRequest {
  convenience public init(credentialIdentity: AuthenticationServices.ASPasskeyCredentialIdentity, clientDataHash: Foundation.Data, userVerificationPreference: AuthenticationServices.ASAuthorizationPublicKeyCredentialUserVerificationPreference, supportedAlgorithms: [AuthenticationServices.ASCOSEAlgorithmIdentifier])
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  convenience public init(credentialIdentity: AuthenticationServices.ASPasskeyCredentialIdentity, clientDataHash: Foundation.Data, userVerificationPreference: AuthenticationServices.ASAuthorizationPublicKeyCredentialUserVerificationPreference, supportedAlgorithms: [AuthenticationServices.ASCOSEAlgorithmIdentifier], extensionInput: AuthenticationServices.ASPasskeyRegistrationCredentialExtensionInput?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  convenience public init(credentialIdentity: AuthenticationServices.ASPasskeyCredentialIdentity, clientDataHash: Foundation.Data, userVerificationPreference: AuthenticationServices.ASAuthorizationPublicKeyCredentialUserVerificationPreference, supportedAlgorithms: [AuthenticationServices.ASCOSEAlgorithmIdentifier], extensionInput: AuthenticationServices.ASPasskeyAssertionCredentialExtensionInput?)
  #endif
  public var supportedAlgorithms: [AuthenticationServices.ASCOSEAlgorithmIdentifier] {
    get
  }
  @available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var extensionInput: AuthenticationServices.ASPasskeyCredentialExtensionInput {
    get
  }
}
@available(macOS 14.4, iOS 17.4, visionOS 1.1, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASCredentialIdentityStore {
  #if compiler(>=5.3) && $NonescapableTypes
  public func credentialIdentities(forService serviceIdentifier: AuthenticationServices.ASCredentialServiceIdentifier? = nil, credentialIdentityTypes: AuthenticationServices.ASCredentialIdentityStore.IdentityTypes = []) async -> [any AuthenticationServices.ASCredentialIdentity]
  #endif
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASPasskeyRegistrationCredential {
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(relyingParty: Swift.String, clientDataHash: Foundation.Data, credentialID: Foundation.Data, attestationObject: Foundation.Data, extensionOutput: AuthenticationServices.ASPasskeyRegistrationCredentialExtensionOutput?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var extensionOutput: AuthenticationServices.ASPasskeyRegistrationCredentialExtensionOutput? {
    get
    set
  }
  #endif
}
@available(macOS 13.5, macCatalyst 16.6, iOS 17.4, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
public struct ASPublicKeyCredentialClientData : Swift.Sendable {
  public enum CrossOriginValue : Swift.Sendable {
    case crossOrigin
    case sameOriginWithAncestors
    public static func == (a: AuthenticationServices.ASPublicKeyCredentialClientData.CrossOriginValue, b: AuthenticationServices.ASPublicKeyCredentialClientData.CrossOriginValue) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var challenge: Foundation.Data
  public var origin: Swift.String
  public var topOrigin: Swift.String?
  public var crossOrigin: AuthenticationServices.ASPublicKeyCredentialClientData.CrossOriginValue?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(challenge: Foundation.Data, origin: Swift.String, topOrigin: Swift.String? = nil, crossOrigin: AuthenticationServices.ASPublicKeyCredentialClientData.CrossOriginValue? = nil)
  #endif
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public let ASCredentialExchangeActivity: Swift.String
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public let ASCredentialImportToken: Swift.String
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public struct ASExportedCredentialData : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public enum FormatVersion : Swift.String, Swift.CaseIterable, Swift.Codable, Swift.Equatable, Swift.Hashable, Swift.Sendable {
    case v1
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias AllCases = [AuthenticationServices.ASExportedCredentialData.FormatVersion]
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [AuthenticationServices.ASExportedCredentialData.FormatVersion] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public let formatVersion: AuthenticationServices.ASExportedCredentialData.FormatVersion
  public let exporterRelyingPartyIdentifier: Swift.String
  public let exporterDisplayName: Swift.String
  public let timestamp: Foundation.Date
  public var accounts: [AuthenticationServices.ASImportableAccount]
  public init(accounts: [AuthenticationServices.ASImportableAccount], formatVersion: AuthenticationServices.ASExportedCredentialData.FormatVersion, exporterRelyingPartyIdentifier: Swift.String, exporterDisplayName: Swift.String, timestamp: Foundation.Date)
  public static func == (a: AuthenticationServices.ASExportedCredentialData, b: AuthenticationServices.ASExportedCredentialData) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public struct ASImportableAccount : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public var id: Foundation.Data
  public var userName: Swift.String
  public var email: Swift.String
  public var fullName: Swift.String?
  public var collections: [AuthenticationServices.ASImportableCollection]
  public var items: [AuthenticationServices.ASImportableItem]
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: Foundation.Data, userName: Swift.String, email: Swift.String, fullName: Swift.String? = nil, collections: [AuthenticationServices.ASImportableCollection], items: [AuthenticationServices.ASImportableItem])
  #endif
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: AuthenticationServices.ASImportableAccount, b: AuthenticationServices.ASImportableAccount) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public struct ASImportableCollection : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public var id: Foundation.Data
  public var created: Foundation.Date?
  public var lastModified: Foundation.Date?
  public var title: Swift.String
  public var subtitle: Swift.String?
  public var items: [AuthenticationServices.ASImportableLinkedItem]
  public var subcollections: [AuthenticationServices.ASImportableCollection]
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: Foundation.Data, created: Foundation.Date?, lastModified: Foundation.Date?, title: Swift.String, subtitle: Swift.String? = nil, items: [AuthenticationServices.ASImportableLinkedItem], subcollections: [AuthenticationServices.ASImportableCollection] = [])
  #endif
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: AuthenticationServices.ASImportableCollection, b: AuthenticationServices.ASImportableCollection) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public struct ASImportableLinkedItem : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public var item: Foundation.Data
  public var account: Foundation.Data?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(item: Foundation.Data, account: Foundation.Data? = nil)
  #endif
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: AuthenticationServices.ASImportableLinkedItem, b: AuthenticationServices.ASImportableLinkedItem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public struct ASImportableItem : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public var id: Foundation.Data
  public var created: Foundation.Date?
  public var lastModified: Foundation.Date?
  public var title: Swift.String
  public var subtitle: Swift.String?
  public var favorite: Swift.Bool
  public var scope: AuthenticationServices.ASImportableCredentialScope?
  public var tags: [Swift.String]
  public var credentials: [AuthenticationServices.ASImportableCredential]
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: Foundation.Data, created: Foundation.Date, lastModified: Foundation.Date, title: Swift.String, subtitle: Swift.String? = nil, favorite: Swift.Bool = false, scope: AuthenticationServices.ASImportableCredentialScope? = nil, credentials: [AuthenticationServices.ASImportableCredential], tags: [Swift.String] = [])
  #endif
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: AuthenticationServices.ASImportableItem, b: AuthenticationServices.ASImportableItem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public struct ASImportableCredentialScope : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public var urls: [Foundation.URL]
  public var androidApps: [AuthenticationServices.ASImportableCredentialScope.AndroidAppID]
  public init(urls: [Foundation.URL], androidApps: [AuthenticationServices.ASImportableCredentialScope.AndroidAppID] = [])
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: AuthenticationServices.ASImportableCredentialScope, b: AuthenticationServices.ASImportableCredentialScope) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AuthenticationServices.ASImportableCredentialScope {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public struct AndroidAppID : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var bundleID: Swift.String
    public var certificate: AuthenticationServices.ASImportableCredentialScope.AndroidAppCertificationFingerprint?
    public var name: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(bundleID: Swift.String, certificate: AuthenticationServices.ASImportableCredentialScope.AndroidAppCertificationFingerprint?, name: Swift.String?)
    #endif
    public static func == (a: AuthenticationServices.ASImportableCredentialScope.AndroidAppID, b: AuthenticationServices.ASImportableCredentialScope.AndroidAppID) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public struct AndroidAppCertificationFingerprint : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var fingerprint: Foundation.Data
    public var hashAlgorithm: Swift.String
    public init(fingerprint: Foundation.Data, hashAlgorithm: Swift.String)
    public init(from decoder: any Swift.Decoder) throws
    public static func == (a: AuthenticationServices.ASImportableCredentialScope.AndroidAppCertificationFingerprint, b: AuthenticationServices.ASImportableCredentialScope.AndroidAppCertificationFingerprint) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public struct ASImportableEditableField : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public enum FieldType : Swift.String, Swift.Codable, Swift.Hashable, Swift.Sendable {
    case string
    case concealedString
    case email
    case number
    case boolean
    case date
    case yearMonth
    case wifiNetworkSecurityType
    case countryCode
    case subdivisionCode
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var id: Foundation.Data?
  public var fieldType: AuthenticationServices.ASImportableEditableField.FieldType
  public var value: Swift.String
  public var label: Swift.String?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: Foundation.Data?, fieldType: AuthenticationServices.ASImportableEditableField.FieldType, value: Swift.String, label: Swift.String? = nil)
  #endif
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: AuthenticationServices.ASImportableEditableField, b: AuthenticationServices.ASImportableEditableField) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public enum ASImportableCredential : Swift.Codable, Swift.Hashable, Swift.Sendable {
  case address(AuthenticationServices.ASImportableCredential.Address)
  case apiKey(AuthenticationServices.ASImportableCredential.APIKey)
  case basicAuthentication(AuthenticationServices.ASImportableCredential.BasicAuthentication)
  case creditCard(AuthenticationServices.ASImportableCredential.CreditCard)
  case customFields(AuthenticationServices.ASImportableCredential.CustomFields)
  case driversLicense(AuthenticationServices.ASImportableCredential.DriversLicense)
  case generatedPassword(AuthenticationServices.ASImportableCredential.GeneratedPassword)
  case identityDocument(AuthenticationServices.ASImportableCredential.IdentityDocument)
  case itemReference(AuthenticationServices.ASImportableCredential.ItemReference)
  case note(AuthenticationServices.ASImportableCredential.Note)
  case passkey(AuthenticationServices.ASImportableCredential.Passkey)
  case passport(AuthenticationServices.ASImportableCredential.Passport)
  case personName(AuthenticationServices.ASImportableCredential.PersonName)
  case sshKey(AuthenticationServices.ASImportableCredential.SSHKey)
  case totp(AuthenticationServices.ASImportableCredential.TOTP)
  case wifi(AuthenticationServices.ASImportableCredential.WiFi)
  public struct Address : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var streetAddress: AuthenticationServices.ASImportableEditableField?
    public var postalCode: AuthenticationServices.ASImportableEditableField?
    public var city: AuthenticationServices.ASImportableEditableField?
    public var territory: AuthenticationServices.ASImportableEditableField?
    public var country: AuthenticationServices.ASImportableEditableField?
    public var telephone: AuthenticationServices.ASImportableEditableField?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(streetAddress: AuthenticationServices.ASImportableEditableField?, postalCode: AuthenticationServices.ASImportableEditableField?, city: AuthenticationServices.ASImportableEditableField?, territory: AuthenticationServices.ASImportableEditableField?, country: AuthenticationServices.ASImportableEditableField?, telephone: AuthenticationServices.ASImportableEditableField?)
    #endif
    public static func == (a: AuthenticationServices.ASImportableCredential.Address, b: AuthenticationServices.ASImportableCredential.Address) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct APIKey : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var key: AuthenticationServices.ASImportableEditableField?
    public var userName: AuthenticationServices.ASImportableEditableField?
    public var keyType: AuthenticationServices.ASImportableEditableField?
    public var url: AuthenticationServices.ASImportableEditableField?
    public var validFrom: AuthenticationServices.ASImportableEditableField?
    public var expiryDate: AuthenticationServices.ASImportableEditableField?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(key: AuthenticationServices.ASImportableEditableField?, userName: AuthenticationServices.ASImportableEditableField?, keyType: AuthenticationServices.ASImportableEditableField?, url: AuthenticationServices.ASImportableEditableField?, validFrom: AuthenticationServices.ASImportableEditableField?, expiryDate: AuthenticationServices.ASImportableEditableField?)
    #endif
    public static func == (a: AuthenticationServices.ASImportableCredential.APIKey, b: AuthenticationServices.ASImportableCredential.APIKey) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct BasicAuthentication : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var userName: AuthenticationServices.ASImportableEditableField?
    public var password: AuthenticationServices.ASImportableEditableField?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(userName: AuthenticationServices.ASImportableEditableField? = nil, password: AuthenticationServices.ASImportableEditableField? = nil)
    #endif
    public static func == (a: AuthenticationServices.ASImportableCredential.BasicAuthentication, b: AuthenticationServices.ASImportableCredential.BasicAuthentication) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct CreditCard : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var number: AuthenticationServices.ASImportableEditableField?
    public var fullName: AuthenticationServices.ASImportableEditableField?
    public var cardType: AuthenticationServices.ASImportableEditableField?
    public var verificationNumber: AuthenticationServices.ASImportableEditableField?
    public var pin: AuthenticationServices.ASImportableEditableField?
    public var expiryDate: AuthenticationServices.ASImportableEditableField?
    public var validFrom: AuthenticationServices.ASImportableEditableField?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(number: AuthenticationServices.ASImportableEditableField?, fullName: AuthenticationServices.ASImportableEditableField?, cardType: AuthenticationServices.ASImportableEditableField?, verificationNumber: AuthenticationServices.ASImportableEditableField?, pin: AuthenticationServices.ASImportableEditableField?, expiryDate: AuthenticationServices.ASImportableEditableField?, validFrom: AuthenticationServices.ASImportableEditableField?)
    #endif
    public static func == (a: AuthenticationServices.ASImportableCredential.CreditCard, b: AuthenticationServices.ASImportableCredential.CreditCard) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct CustomFields : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var id: Foundation.Data?
    public var label: Swift.String?
    public var fields: [AuthenticationServices.ASImportableEditableField]
    #if compiler(>=5.3) && $NonescapableTypes
    public init(id: Foundation.Data? = nil, label: Swift.String? = nil, fields: [AuthenticationServices.ASImportableEditableField])
    #endif
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public static func == (a: AuthenticationServices.ASImportableCredential.CustomFields, b: AuthenticationServices.ASImportableCredential.CustomFields) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct DriversLicense : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var fullName: AuthenticationServices.ASImportableEditableField?
    public var birthDate: AuthenticationServices.ASImportableEditableField?
    public var issueDate: AuthenticationServices.ASImportableEditableField?
    public var expiryDate: AuthenticationServices.ASImportableEditableField?
    public var issuingAuthority: AuthenticationServices.ASImportableEditableField?
    public var territory: AuthenticationServices.ASImportableEditableField?
    public var country: AuthenticationServices.ASImportableEditableField?
    public var licenseNumber: AuthenticationServices.ASImportableEditableField?
    public var licenseClass: AuthenticationServices.ASImportableEditableField?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(fullName: AuthenticationServices.ASImportableEditableField?, birthDate: AuthenticationServices.ASImportableEditableField?, issueDate: AuthenticationServices.ASImportableEditableField?, expiryDate: AuthenticationServices.ASImportableEditableField?, issuingAuthority: AuthenticationServices.ASImportableEditableField?, territory: AuthenticationServices.ASImportableEditableField?, country: AuthenticationServices.ASImportableEditableField?, licenseNumber: AuthenticationServices.ASImportableEditableField?, licenseClass: AuthenticationServices.ASImportableEditableField?)
    #endif
    public static func == (a: AuthenticationServices.ASImportableCredential.DriversLicense, b: AuthenticationServices.ASImportableCredential.DriversLicense) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct GeneratedPassword : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var password: Swift.String
    public init(password: Swift.String)
    public static func == (a: AuthenticationServices.ASImportableCredential.GeneratedPassword, b: AuthenticationServices.ASImportableCredential.GeneratedPassword) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct IdentityDocument : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var issuingCountry: AuthenticationServices.ASImportableEditableField?
    public var documentNumber: AuthenticationServices.ASImportableEditableField?
    public var identificationNumber: AuthenticationServices.ASImportableEditableField?
    public var nationality: AuthenticationServices.ASImportableEditableField?
    public var fullName: AuthenticationServices.ASImportableEditableField?
    public var birthDate: AuthenticationServices.ASImportableEditableField?
    public var birthPlace: AuthenticationServices.ASImportableEditableField?
    public var sex: AuthenticationServices.ASImportableEditableField?
    public var issueDate: AuthenticationServices.ASImportableEditableField?
    public var expiryDate: AuthenticationServices.ASImportableEditableField?
    public var issuingAuthority: AuthenticationServices.ASImportableEditableField?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(issuingCountry: AuthenticationServices.ASImportableEditableField?, documentNumber: AuthenticationServices.ASImportableEditableField?, identificationNumber: AuthenticationServices.ASImportableEditableField?, nationality: AuthenticationServices.ASImportableEditableField?, fullName: AuthenticationServices.ASImportableEditableField?, birthDate: AuthenticationServices.ASImportableEditableField?, birthPlace: AuthenticationServices.ASImportableEditableField?, sex: AuthenticationServices.ASImportableEditableField?, issueDate: AuthenticationServices.ASImportableEditableField?, expiryDate: AuthenticationServices.ASImportableEditableField?, issuingAuthority: AuthenticationServices.ASImportableEditableField?)
    #endif
    public static func == (a: AuthenticationServices.ASImportableCredential.IdentityDocument, b: AuthenticationServices.ASImportableCredential.IdentityDocument) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Note : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var content: AuthenticationServices.ASImportableEditableField
    public init(content: AuthenticationServices.ASImportableEditableField)
    public static func == (a: AuthenticationServices.ASImportableCredential.Note, b: AuthenticationServices.ASImportableCredential.Note) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ItemReference : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var reference: AuthenticationServices.ASImportableLinkedItem
    public init(reference: AuthenticationServices.ASImportableLinkedItem)
    public static func == (a: AuthenticationServices.ASImportableCredential.ItemReference, b: AuthenticationServices.ASImportableCredential.ItemReference) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Passkey : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var credentialID: Foundation.Data
    public var relyingPartyIdentifier: Swift.String
    public var userName: Swift.String
    public var userDisplayName: Swift.String
    public var userHandle: Foundation.Data
    public var key: Foundation.Data
    public init(credentialID: Foundation.Data, relyingPartyIdentifier: Swift.String, userName: Swift.String, userDisplayName: Swift.String, userHandle: Foundation.Data, key: Foundation.Data)
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public static func == (a: AuthenticationServices.ASImportableCredential.Passkey, b: AuthenticationServices.ASImportableCredential.Passkey) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Passport : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var issuingCountry: AuthenticationServices.ASImportableEditableField?
    public var passportType: AuthenticationServices.ASImportableEditableField?
    public var passportNumber: AuthenticationServices.ASImportableEditableField?
    public var nationalIdentificationNumber: AuthenticationServices.ASImportableEditableField?
    public var nationality: AuthenticationServices.ASImportableEditableField?
    public var fullName: AuthenticationServices.ASImportableEditableField?
    public var birthDate: AuthenticationServices.ASImportableEditableField?
    public var birthPlace: AuthenticationServices.ASImportableEditableField?
    public var sex: AuthenticationServices.ASImportableEditableField?
    public var issueDate: AuthenticationServices.ASImportableEditableField?
    public var expiryDate: AuthenticationServices.ASImportableEditableField?
    public var issuingAuthority: AuthenticationServices.ASImportableEditableField?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(issuingCountry: AuthenticationServices.ASImportableEditableField?, passportType: AuthenticationServices.ASImportableEditableField?, passportNumber: AuthenticationServices.ASImportableEditableField?, nationalIdentificationNumber: AuthenticationServices.ASImportableEditableField?, nationality: AuthenticationServices.ASImportableEditableField?, fullName: AuthenticationServices.ASImportableEditableField?, birthDate: AuthenticationServices.ASImportableEditableField?, birthPlace: AuthenticationServices.ASImportableEditableField?, sex: AuthenticationServices.ASImportableEditableField?, issueDate: AuthenticationServices.ASImportableEditableField?, expiryDate: AuthenticationServices.ASImportableEditableField?, issuingAuthority: AuthenticationServices.ASImportableEditableField?)
    #endif
    public static func == (a: AuthenticationServices.ASImportableCredential.Passport, b: AuthenticationServices.ASImportableCredential.Passport) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct PersonName : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var title: AuthenticationServices.ASImportableEditableField?
    public var given: AuthenticationServices.ASImportableEditableField?
    public var givenInformal: AuthenticationServices.ASImportableEditableField?
    public var given2: AuthenticationServices.ASImportableEditableField?
    public var surnamePrefix: AuthenticationServices.ASImportableEditableField?
    public var surname: AuthenticationServices.ASImportableEditableField?
    public var surname2: AuthenticationServices.ASImportableEditableField?
    public var credentials: AuthenticationServices.ASImportableEditableField?
    public var generation: AuthenticationServices.ASImportableEditableField?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(title: AuthenticationServices.ASImportableEditableField?, given: AuthenticationServices.ASImportableEditableField?, givenInformal: AuthenticationServices.ASImportableEditableField?, given2: AuthenticationServices.ASImportableEditableField?, surnamePrefix: AuthenticationServices.ASImportableEditableField?, surname: AuthenticationServices.ASImportableEditableField?, surname2: AuthenticationServices.ASImportableEditableField?, credentials: AuthenticationServices.ASImportableEditableField?, generation: AuthenticationServices.ASImportableEditableField?)
    #endif
    public static func == (a: AuthenticationServices.ASImportableCredential.PersonName, b: AuthenticationServices.ASImportableCredential.PersonName) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct SSHKey : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var keyType: Swift.String
    public var privateKey: Foundation.Data
    public var keyComment: Swift.String?
    public var creationDate: AuthenticationServices.ASImportableEditableField?
    public var expiryDate: AuthenticationServices.ASImportableEditableField?
    public var keyGenerationSource: AuthenticationServices.ASImportableEditableField?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(keyType: Swift.String, privateKey: Foundation.Data, keyComment: Swift.String?, creationDate: AuthenticationServices.ASImportableEditableField?, expiryDate: AuthenticationServices.ASImportableEditableField?, keyGenerationSource: AuthenticationServices.ASImportableEditableField?)
    #endif
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public static func == (a: AuthenticationServices.ASImportableCredential.SSHKey, b: AuthenticationServices.ASImportableCredential.SSHKey) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct TOTP : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public enum Algorithm : Swift.String, Swift.Codable, Swift.Hashable, Swift.Sendable {
      case sha1
      case sha256
      case sha512
      #if compiler(>=5.3) && $NonescapableTypes
      public init?(rawValue: Swift.String)
      #endif
      @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
      @available(tvOS, unavailable)
      @available(watchOS, unavailable)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public var secret: Foundation.Data
    public var period: Swift.UInt16
    public var digits: Swift.UInt16
    public var userName: Swift.String?
    public var algorithm: AuthenticationServices.ASImportableCredential.TOTP.Algorithm
    public var issuer: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(secret: Foundation.Data, period: Swift.UInt16, digits: Swift.UInt16, userName: Swift.String?, algorithm: AuthenticationServices.ASImportableCredential.TOTP.Algorithm, issuer: Swift.String? = nil)
    #endif
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public static func == (a: AuthenticationServices.ASImportableCredential.TOTP, b: AuthenticationServices.ASImportableCredential.TOTP) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct WiFi : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var ssid: AuthenticationServices.ASImportableEditableField?
    public var networkSecurityType: AuthenticationServices.ASImportableEditableField?
    public var passphrase: AuthenticationServices.ASImportableEditableField?
    public var hidden: AuthenticationServices.ASImportableEditableField?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(ssid: AuthenticationServices.ASImportableEditableField?, networkSecurityType: AuthenticationServices.ASImportableEditableField?, passphrase: AuthenticationServices.ASImportableEditableField?, hidden: AuthenticationServices.ASImportableEditableField? = nil)
    #endif
    public static func == (a: AuthenticationServices.ASImportableCredential.WiFi, b: AuthenticationServices.ASImportableCredential.WiFi) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: AuthenticationServices.ASImportableCredential, b: AuthenticationServices.ASImportableCredential) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public class ASCredentialExportManager {
  public struct ExportOptions : Swift.Codable, Swift.Equatable, Swift.Hashable {
    public let formatVersion: AuthenticationServices.ASExportedCredentialData.FormatVersion
    public static func == (a: AuthenticationServices.ASCredentialExportManager.ExportOptions, b: AuthenticationServices.ASCredentialExportManager.ExportOptions) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public func requestExport(for extensionBundleIdentifier: Swift.String? = nil) async throws -> AuthenticationServices.ASCredentialExportManager.ExportOptions
  #endif
  public func exportCredentials(_ credentialData: AuthenticationServices.ASExportedCredentialData) async throws
  convenience public init(presentationAnchor: AuthenticationServices.ASPresentationAnchor)
  @objc deinit
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public class ASCredentialImportManager {
  public func importCredentials(token: Foundation.UUID) async throws -> AuthenticationServices.ASExportedCredentialData
  public init()
  @objc deinit
}
@available(macOS 26.0, iOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public enum ASContactIdentifierRequest : Swift.Sendable {
  case phoneNumber
  case email
  public static func == (a: AuthenticationServices.ASContactIdentifierRequest, b: AuthenticationServices.ASContactIdentifierRequest) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 26.0, iOS 26.0, visionOS 26.0, *)
extension AuthenticationServices.ASContactIdentifierRequest : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15.0, iOS 18.0, visionOS 2.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPlatformPublicKeyCredentialAssertionRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  public var prf: AuthenticationServices.ASAuthorizationPublicKeyCredentialPRFAssertionInput? {
    get
    set
  }
  #endif
}
@available(macOS 14.0, iOS 17.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobRegistrationInput.SupportRequirement : Swift.Equatable {}
@available(macOS 14.0, iOS 17.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASAuthorizationPublicKeyCredentialLargeBlobRegistrationInput.SupportRequirement : Swift.Hashable {}
@available(macOS 13.5, macCatalyst 16.6, iOS 17.4, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension AuthenticationServices.ASPublicKeyCredentialClientData.CrossOriginValue : Swift.Equatable {}
@available(macOS 13.5, macCatalyst 16.6, iOS 17.4, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@available(visionOS, unavailable)
extension AuthenticationServices.ASPublicKeyCredentialClientData.CrossOriginValue : Swift.Hashable {}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension AuthenticationServices.ASExportedCredentialData.FormatVersion : Swift.RawRepresentable {}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension AuthenticationServices.ASImportableEditableField.FieldType : Swift.RawRepresentable {}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension AuthenticationServices.ASImportableCredential.TOTP.Algorithm : Swift.RawRepresentable {}
@available(macOS 26.0, iOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASContactIdentifierRequest : Swift.Equatable {}
@available(macOS 26.0, iOS 26.0, visionOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension AuthenticationServices.ASContactIdentifierRequest : Swift.Hashable {}
