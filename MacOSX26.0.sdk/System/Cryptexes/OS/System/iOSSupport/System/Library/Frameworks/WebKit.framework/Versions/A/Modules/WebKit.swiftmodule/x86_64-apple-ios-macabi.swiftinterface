// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2 (swiftlang-6.2.0.17.14 clang-1700.3.17.1)
// swift-module-flags: -target x86_64-apple-ios26.0-macabi -enable-objc-interop -enable-library-evolution -swift-version 6 -enforce-exclusivity=checked -O -library-level api -enable-experimental-feature DebugDescriptionMacro -user-module-version 7622.1.22.11.14 -module-name WebKit
// swift-module-flags-ignorable:  -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2
import CoreTransferable
import Foundation
import Network
import Observation
import Swift
import UIKit
import UniformTypeIdentifiers
@_exported import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public struct URLScheme : Swift.Hashable, Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public init?(_ rawValue: Swift.String)
  #endif
  public let rawValue: Swift.String
  public static func == (a: WebKit.URLScheme, b: WebKit.URLScheme) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public enum URLSchemeTaskResult : Swift.Sendable {
  case response(Foundation.URLResponse)
  case data(Foundation.Data)
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
public protocol URLSchemeHandler {
  associatedtype TaskSequence : _Concurrency.AsyncSequence where Self.TaskSequence.Element == WebKit.URLSchemeTaskResult, Self.TaskSequence.Failure == any Swift.Error
  func reply(for request: Foundation.URLRequest) -> Self.TaskSequence
}
@available(iOS 14.0, macOS 11.0, *)
extension WebKit.WKPDFConfiguration {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public var rect: CoreFoundation.CGRect? {
    get
    set
  }
  #endif
}
@available(iOS 14.0, macOS 11.0, *)
extension WebKit.WKWebView {
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency @_Concurrency.MainActor public func callAsyncJavaScript(_ functionBody: Swift.String, arguments: [Swift.String : Any] = [:], in frame: WebKit.WKFrameInfo? = nil, in contentWorld: WebKit.WKContentWorld, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Any, any Swift.Error>) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency @_Concurrency.MainActor public func createPDF(configuration: WebKit.WKPDFConfiguration = .init(), completionHandler: @escaping @_Concurrency.MainActor @Sendable (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency @_Concurrency.MainActor public func createWebArchiveData(completionHandler: @escaping @_Concurrency.MainActor @Sendable (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @preconcurrency @_Concurrency.MainActor public func evaluateJavaScript(_ javaScript: Swift.String, in frame: WebKit.WKFrameInfo? = nil, in contentWorld: WebKit.WKContentWorld, completionHandler: (@_Concurrency.MainActor @Sendable (Swift.Result<Any, any Swift.Error>) -> Swift.Void)? = nil)
  #endif
  @preconcurrency @_Concurrency.MainActor public func find(_ string: Swift.String, configuration: WebKit.WKFindConfiguration = .init(), completionHandler: @escaping @_Concurrency.MainActor @Sendable (WebKit.WKFindResult) -> Swift.Void)
}
@available(iOS 15.0, macOS 12.0, *)
extension WebKit.WKWebView {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public func callAsyncJavaScript(_ functionBody: Swift.String, arguments: [Swift.String : Any] = [:], in frame: WebKit.WKFrameInfo? = nil, contentWorld: WebKit.WKContentWorld) async throws -> Any?
  #endif
  @_Concurrency.MainActor @preconcurrency public func pdf(configuration: WebKit.WKPDFConfiguration = .init()) async throws -> Foundation.Data
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public func evaluateJavaScript(_ javaScript: Swift.String, in frame: WebKit.WKFrameInfo? = nil, contentWorld: WebKit.WKContentWorld) async throws -> Any?
  #endif
  @_Concurrency.MainActor @preconcurrency public func find(_ string: Swift.String, configuration: WebKit.WKFindConfiguration = .init()) async throws -> WebKit.WKFindResult
}
@available(iOS 18.4, macOS 15.4, visionOS 2.4, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension WebKit.WKWebExtension {
  @_Concurrency.MainActor @preconcurrency convenience public init(appExtensionBundle: Foundation.Bundle) async throws
  @_Concurrency.MainActor @preconcurrency convenience public init(resourceBaseURL: Foundation.URL) async throws
}
@available(iOS 18.4, macOS 15.4, visionOS 2.4, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension WebKit.WKWebExtensionController {
  @_Concurrency.MainActor @preconcurrency public func didCloseTab(_ closedTab: any WebKit.WKWebExtensionTab, windowIsClosing: Swift.Bool = false)
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public func didActivateTab(_ activatedTab: any WebKit.WKWebExtensionTab, previousActiveTab previousTab: (any WebKit.WKWebExtensionTab)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public func didMoveTab(_ movedTab: any WebKit.WKWebExtensionTab, from index: Swift.Int, in oldWindow: (any WebKit.WKWebExtensionWindow)? = nil)
  #endif
}
@available(iOS 18.4, macOS 15.4, visionOS 2.4, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension WebKit.WKWebExtensionContext {
  @_Concurrency.MainActor @preconcurrency public func didCloseTab(_ closedTab: any WebKit.WKWebExtensionTab, windowIsClosing: Swift.Bool = false)
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public func didActivateTab(_ activatedTab: any WebKit.WKWebExtensionTab, previousActiveTab previousTab: (any WebKit.WKWebExtensionTab)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public func didMoveTab(_ movedTab: any WebKit.WKWebExtensionTab, from index: Swift.Int, in oldWindow: (any WebKit.WKWebExtensionWindow)? = nil)
  #endif
}
extension WebKit.WebPage {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @_Concurrency.MainActor public struct BackForwardList : Swift.Equatable, Swift.Sendable {
    public struct Item : Swift.Equatable, Swift.Identifiable, Swift.Sendable {
      public struct ID : Swift.Hashable, Swift.Sendable {
        public static func == (a: WebKit.WebPage.BackForwardList.Item.ID, b: WebKit.WebPage.BackForwardList.Item.ID) -> Swift.Bool
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
      }
      public let id: WebKit.WebPage.BackForwardList.Item.ID
      public let title: Swift.String?
      public let url: Foundation.URL
      public let initialURL: Foundation.URL
      public static func == (a: WebKit.WebPage.BackForwardList.Item, b: WebKit.WebPage.BackForwardList.Item) -> Swift.Bool
    }
    @_Concurrency.MainActor public var backList: [WebKit.WebPage.BackForwardList.Item] {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public var currentItem: WebKit.WebPage.BackForwardList.Item? {
      get
    }
    #endif
    @_Concurrency.MainActor public var forwardList: [WebKit.WebPage.BackForwardList.Item] {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public subscript(index: Swift.Int) -> WebKit.WebPage.BackForwardList.Item? {
      get
    }
    #endif
    nonisolated public static func == (a: WebKit.WebPage.BackForwardList, b: WebKit.WebPage.BackForwardList) -> Swift.Bool
  }
}
extension WebKit.WebPage {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @_Concurrency.MainActor public struct Configuration {
    @_Concurrency.MainActor public init()
    @_Concurrency.MainActor public var websiteDataStore: WebKit.WKWebsiteDataStore
    @_Concurrency.MainActor public var userContentController: WebKit.WKUserContentController
    @_Concurrency.MainActor public var webExtensionController: WebKit.WKWebExtensionController?
    @_Concurrency.MainActor public var defaultNavigationPreferences: WebKit.WebPage.NavigationPreferences
    @_Concurrency.MainActor public var urlSchemeHandlers: [WebKit.URLScheme : any WebKit.URLSchemeHandler]
    @_Concurrency.MainActor public var deviceSensorAuthorization: WebKit.WebPage.DeviceSensorAuthorization
    @_Concurrency.MainActor public var applicationNameForUserAgent: Swift.String?
    @_Concurrency.MainActor public var limitsNavigationsToAppBoundDomains: Swift.Bool
    @_Concurrency.MainActor public var upgradeKnownHostsToHTTPS: Swift.Bool
    @_Concurrency.MainActor public var suppressesIncrementalRendering: Swift.Bool
    @_Concurrency.MainActor public var allowsAirPlayForMediaPlayback: Swift.Bool
    @_Concurrency.MainActor public var loadsSubresources: Swift.Bool
    @_Concurrency.MainActor public var allowsInlinePredictions: Swift.Bool
    @_Concurrency.MainActor public var supportsAdaptiveImageGlyph: Swift.Bool
    @available(visionOS, unavailable)
    @_Concurrency.MainActor public var showsSystemScreenTimeBlockingView: Swift.Bool {
      get
      set
    }
    @_Concurrency.MainActor public var dataDetectorTypes: WebKit.WKDataDetectorTypes
    @_Concurrency.MainActor public var ignoresViewportScaleLimits: Swift.Bool
    @_Concurrency.MainActor public var mediaPlaybackBehavior: WebKit.WebPage.Configuration.MediaPlaybackBehavior
  }
}
extension WebKit.WebPage {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public struct DeviceSensorAuthorization {
    public enum Permission : Swift.Hashable, Swift.Sendable {
      case deviceOrientationAndMotion
      case mediaCapture(WebKit.WKMediaCaptureType)
      public static func == (a: WebKit.WebPage.DeviceSensorAuthorization.Permission, b: WebKit.WebPage.DeviceSensorAuthorization.Permission) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(decisionHandler: @escaping (WebKit.WebPage.DeviceSensorAuthorization.Permission, WebKit.WebPage.FrameInfo, WebKit.WKSecurityOrigin) async -> WebKit.WKPermissionDecision)
    public init(decision: WebKit.WKPermissionDecision)
  }
}
extension WebKit.WebPage.Configuration {
  @available(iOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @available(macOS, unavailable)
  public enum MediaPlaybackBehavior : Swift.Sendable {
    case automatic
    case allowsInlinePlayback
    case alwaysFullscreen
    public static func == (a: WebKit.WebPage.Configuration.MediaPlaybackBehavior, b: WebKit.WebPage.Configuration.MediaPlaybackBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension WebKit.WebPage {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public enum JavaScriptConfirmResult : Swift.Hashable, Swift.Sendable {
    case ok
    case cancel
    public static func == (a: WebKit.WebPage.JavaScriptConfirmResult, b: WebKit.WebPage.JavaScriptConfirmResult) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public enum JavaScriptPromptResult : Swift.Hashable, Swift.Sendable {
    case ok(Swift.String)
    case cancel
    public static func == (a: WebKit.WebPage.JavaScriptPromptResult, b: WebKit.WebPage.JavaScriptPromptResult) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public enum FileInputPromptResult : Swift.Hashable, Swift.Sendable {
    case selected([Foundation.URL])
    case cancel
    public static func == (a: WebKit.WebPage.FileInputPromptResult, b: WebKit.WebPage.FileInputPromptResult) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension WebKit.WebPage {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public protocol DialogPresenting {
    @_Concurrency.MainActor func handleJavaScriptAlert(message: Swift.String, initiatedBy frame: WebKit.WebPage.FrameInfo) async
    @_Concurrency.MainActor func handleJavaScriptConfirm(message: Swift.String, initiatedBy frame: WebKit.WebPage.FrameInfo) async -> WebKit.WebPage.JavaScriptConfirmResult
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor func handleJavaScriptPrompt(message: Swift.String, defaultText: Swift.String?, initiatedBy frame: WebKit.WebPage.FrameInfo) async -> WebKit.WebPage.JavaScriptPromptResult
    #endif
    @_Concurrency.MainActor func handleFileInputPrompt(parameters: WebKit.WKOpenPanelParameters, initiatedBy frame: WebKit.WebPage.FrameInfo) async -> WebKit.WebPage.FileInputPromptResult
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension WebKit.WebPage.DialogPresenting {
  @_Concurrency.MainActor public func handleJavaScriptAlert(message: Swift.String, initiatedBy frame: WebKit.WebPage.FrameInfo) async
  @_Concurrency.MainActor public func handleJavaScriptConfirm(message: Swift.String, initiatedBy frame: WebKit.WebPage.FrameInfo) async -> WebKit.WebPage.JavaScriptConfirmResult
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func handleJavaScriptPrompt(message: Swift.String, defaultText: Swift.String?, initiatedBy frame: WebKit.WebPage.FrameInfo) async -> WebKit.WebPage.JavaScriptPromptResult
  #endif
  @_Concurrency.MainActor public func handleFileInputPrompt(parameters: WebKit.WKOpenPanelParameters, initiatedBy frame: WebKit.WebPage.FrameInfo) async -> WebKit.WebPage.FileInputPromptResult
}
extension WebKit.WebPage {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @_Concurrency.MainActor public struct FrameInfo {
    @_Concurrency.MainActor public var isMainFrame: Swift.Bool {
      get
    }
    @_Concurrency.MainActor public var request: Foundation.URLRequest {
      get
    }
    @_Concurrency.MainActor public var securityOrigin: WebKit.WKSecurityOrigin {
      get
    }
  }
}
extension WebKit.WebPage {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public enum NavigationEvent : Swift.Hashable, Swift.Sendable {
    case startedProvisionalNavigation
    case receivedServerRedirect
    case committed
    case finished
    public static func == (a: WebKit.WebPage.NavigationEvent, b: WebKit.WebPage.NavigationEvent) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public enum NavigationError : Swift.Error {
    case failedProvisionalNavigation(any Swift.Error)
    case pageClosed
    case webContentProcessTerminated
    case invalidURL
  }
}
extension WebKit.WebPage {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @_Concurrency.MainActor public struct NavigationAction {
    @_Concurrency.MainActor public var source: WebKit.WebPage.FrameInfo {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor public var target: WebKit.WebPage.FrameInfo? {
      get
    }
    #endif
    @_Concurrency.MainActor public var navigationType: WebKit.WKNavigationType {
      get
    }
    @_Concurrency.MainActor public var request: Foundation.URLRequest {
      get
    }
    @_Concurrency.MainActor public var shouldPerformDownload: Swift.Bool {
      get
    }
    @_Concurrency.MainActor public var buttonNumber: UIKit.UIEvent.ButtonMask {
      get
    }
    @_Concurrency.MainActor public var isContentRuleListRedirect: Swift.Bool {
      get
    }
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @_Concurrency.MainActor public struct NavigationResponse {
    @_Concurrency.MainActor public var response: Foundation.URLResponse {
      get
    }
    @_Concurrency.MainActor public var canShowMimeType: Swift.Bool {
      get
    }
  }
}
extension WebKit.WebPage {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public protocol NavigationDeciding {
    @_Concurrency.MainActor mutating func decidePolicy(for action: WebKit.WebPage.NavigationAction, preferences: inout WebKit.WebPage.NavigationPreferences) async -> WebKit.WKNavigationActionPolicy
    @_Concurrency.MainActor mutating func decidePolicy(for response: WebKit.WebPage.NavigationResponse) async -> WebKit.WKNavigationResponsePolicy
    #if compiler(>=5.3) && $NonescapableTypes
    @_Concurrency.MainActor mutating func decideAuthenticationChallengeDisposition(for challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
    #endif
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension WebKit.WebPage.NavigationDeciding {
  @_Concurrency.MainActor public func decidePolicy(for action: WebKit.WebPage.NavigationAction, preferences: inout WebKit.WebPage.NavigationPreferences) async -> WebKit.WKNavigationActionPolicy
  @_Concurrency.MainActor public func decidePolicy(for response: WebKit.WebPage.NavigationResponse) async -> WebKit.WKNavigationResponsePolicy
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func decideAuthenticationChallengeDisposition(for challenge: Foundation.URLAuthenticationChallenge) async -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?)
  #endif
}
extension WebKit.WebPage {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public struct NavigationPreferences : Swift.Sendable {
    public enum ContentMode : Swift.Sendable {
      case recommended
      case mobile
      case desktop
      public static func == (a: WebKit.WebPage.NavigationPreferences.ContentMode, b: WebKit.WebPage.NavigationPreferences.ContentMode) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum UpgradeToHTTPSPolicy : Swift.Sendable {
      case keepAsRequested
      case automaticFallbackToHTTP
      case userMediatedFallbackToHTTP
      case errorOnFailure
      public static func == (a: WebKit.WebPage.NavigationPreferences.UpgradeToHTTPSPolicy, b: WebKit.WebPage.NavigationPreferences.UpgradeToHTTPSPolicy) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init()
    public var preferredContentMode: WebKit.WebPage.NavigationPreferences.ContentMode
    public var allowsContentJavaScript: Swift.Bool
    public var preferredHTTPSNavigationPolicy: WebKit.WebPage.NavigationPreferences.UpgradeToHTTPSPolicy
    public var isLockdownModeEnabled: Swift.Bool {
      get
      set
    }
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension WebKit.WebPage : CoreTransferable.Transferable {
  nonisolated public struct ExportedContentConfiguration : Swift.Sendable {
    public struct Region : Swift.Sendable {
      public static func rect(_ rect: CoreFoundation.CGRect) -> WebKit.WebPage.ExportedContentConfiguration.Region
      public static var contents: WebKit.WebPage.ExportedContentConfiguration.Region {
        get
      }
    }
    public static func pdf(region: WebKit.WebPage.ExportedContentConfiguration.Region = .contents, allowTransparentBackground: Swift.Bool = false) -> WebKit.WebPage.ExportedContentConfiguration
    #if compiler(>=5.3) && $NonescapableTypes
    public static func image(region: WebKit.WebPage.ExportedContentConfiguration.Region = .contents, allowTransparentBackground: Swift.Bool = false, snapshotWidth: CoreFoundation.CGFloat? = nil, afterScreenUpdates: Swift.Bool = true) -> WebKit.WebPage.ExportedContentConfiguration
    #endif
  }
  nonisolated public static var transferRepresentation: some CoreTransferable.TransferRepresentation {
    get
  }
  nonisolated final public func exported(as representation: WebKit.WebPage.ExportedContentConfiguration) async throws -> Foundation.Data
  @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public typealias Representation = @_opaqueReturnTypeOf("$s6WebKit0A4PageC22transferRepresentationQrvpZ", 0) __
}
@_hasMissingDesignatedInitializers @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
@_Concurrency.MainActor final public class WebPage {
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public struct CSSMediaType : Swift.Hashable, Swift.RawRepresentable, Swift.Sendable {
    public static let all: WebKit.WebPage.CSSMediaType
    public static let screen: WebKit.WebPage.CSSMediaType
    public static let print: WebKit.WebPage.CSSMediaType
    public init(rawValue: Swift.String)
    public let rawValue: Swift.String
    @available(iOS 26.0, visionOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias RawValue = Swift.String
  }
  @available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  public enum FullscreenState : Swift.Hashable, Swift.Sendable {
    case enteringFullscreen
    case exitingFullscreen
    case inFullscreen
    case notInFullscreen
    public static func == (a: WebKit.WebPage.FullscreenState, b: WebKit.WebPage.FullscreenState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor convenience public init(configuration: WebKit.WebPage.Configuration = Configuration(), navigationDecider: some NavigationDeciding, dialogPresenter: some DialogPresenting)
  @_Concurrency.MainActor convenience public init(configuration: WebKit.WebPage.Configuration = Configuration(), dialogPresenter: some DialogPresenting)
  @_Concurrency.MainActor convenience public init(configuration: WebKit.WebPage.Configuration = Configuration(), navigationDecider: some NavigationDeciding)
  @_Concurrency.MainActor convenience public init(configuration: WebKit.WebPage.Configuration = Configuration())
  @_Concurrency.MainActor final public var backForwardList: WebKit.WebPage.BackForwardList {
    get
  }
  @_Concurrency.MainActor final public var navigations: some _Concurrency.AsyncSequence<WebKit.WebPage.NavigationEvent, any Swift.Error> {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor final public var url: Foundation.URL? {
    get
  }
  #endif
  @_Concurrency.MainActor final public var title: Swift.String {
    get
  }
  @_Concurrency.MainActor final public var estimatedProgress: Swift.Double {
    get
  }
  @_Concurrency.MainActor final public var isLoading: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor final public var serverTrust: Security.SecTrust? {
    get
  }
  #endif
  @_Concurrency.MainActor final public var hasOnlySecureContent: Swift.Bool {
    get
  }
  @_Concurrency.MainActor final public var isWritingToolsActive: Swift.Bool {
    get
  }
  @available(visionOS, unavailable)
  @_Concurrency.MainActor final public var isBlockedByScreenTime: Swift.Bool {
    get
  }
  @_Concurrency.MainActor final public var fullscreenState: WebKit.WebPage.FullscreenState {
    get
  }
  @_Concurrency.MainActor final public var cameraCaptureState: WebKit.WKMediaCaptureState {
    get
  }
  @_Concurrency.MainActor final public var microphoneCaptureState: WebKit.WKMediaCaptureState {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor final public var mediaType: WebKit.WebPage.CSSMediaType? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor final public var customUserAgent: Swift.String? {
    get
    set
  }
  #endif
  @_Concurrency.MainActor final public var isInspectable: Swift.Bool {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor final public func load(_ url: Foundation.URL?) -> some _Concurrency.AsyncSequence<WebKit.WebPage.NavigationEvent, any Swift.Error>
  
  #endif
  @discardableResult
  @_Concurrency.MainActor final public func load(_ request: Foundation.URLRequest) -> some _Concurrency.AsyncSequence<WebKit.WebPage.NavigationEvent, any Swift.Error>
  
  @discardableResult
  @_Concurrency.MainActor final public func load(_ data: Foundation.Data, mimeType: Swift.String, characterEncoding: Swift.String.Encoding, baseURL: Foundation.URL) -> some _Concurrency.AsyncSequence<WebKit.WebPage.NavigationEvent, any Swift.Error>
  
  @discardableResult
  @_Concurrency.MainActor final public func load(html: Swift.String, baseURL: Foundation.URL = URL(string: "about:blank")!) -> some _Concurrency.AsyncSequence<WebKit.WebPage.NavigationEvent, any Swift.Error>
  
  @discardableResult
  @_Concurrency.MainActor final public func load(simulatedRequest request: Foundation.URLRequest, response: Foundation.URLResponse, responseData: Foundation.Data) -> some _Concurrency.AsyncSequence<WebKit.WebPage.NavigationEvent, any Swift.Error>
  
  @discardableResult
  @_Concurrency.MainActor final public func load(simulatedRequest request: Foundation.URLRequest, responseHTML htmlString: Swift.String) -> some _Concurrency.AsyncSequence<WebKit.WebPage.NavigationEvent, any Swift.Error>
  
  @discardableResult
  @_Concurrency.MainActor final public func load(_ item: WebKit.WebPage.BackForwardList.Item) -> some _Concurrency.AsyncSequence<WebKit.WebPage.NavigationEvent, any Swift.Error>
  
  @discardableResult
  @_Concurrency.MainActor final public func reload(fromOrigin: Swift.Bool = false) -> some _Concurrency.AsyncSequence<WebKit.WebPage.NavigationEvent, any Swift.Error>
  
  @_Concurrency.MainActor final public func stopLoading()
  #if compiler(>=5.3) && $NonescapableTypes
  #if compiler(>=5.3) && $SendingArgsAndResults
  @discardableResult
  @_Concurrency.MainActor final public func callJavaScript(_ functionBody: Swift.String, arguments: [Swift.String : Any] = [:], in frame: WebKit.WebPage.FrameInfo? = nil, contentWorld: WebKit.WKContentWorld? = nil) async throws -> sending Any?
  #else
  @discardableResult
  @_Concurrency.MainActor final public func callJavaScript(_ functionBody: Swift.String, arguments: [Swift.String : Any] = [:], in frame: WebKit.WebPage.FrameInfo? = nil, contentWorld: WebKit.WKContentWorld? = nil) async throws -> Any?
  #endif
  #endif
  @_Concurrency.MainActor final public func pauseAllMediaPlayback() async
  @_Concurrency.MainActor final public func mediaPlaybackState() async -> WebKit.WKMediaPlaybackState
  @_Concurrency.MainActor final public func setAllMediaPlaybackSuspended(_ suspended: Swift.Bool) async
  @_Concurrency.MainActor final public func closeAllMediaPresentations() async
  @_Concurrency.MainActor final public func setCameraCaptureState(_ state: WebKit.WKMediaCaptureState) async
  @_Concurrency.MainActor final public func setMicrophoneCaptureState(_ state: WebKit.WKMediaCaptureState) async
  @objc deinit
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension WebKit.WebPage : nonisolated Observation.Observable {
}
extension WebKit.WKWebsiteDataStore {
  @available(iOS 17.0, macOS 14.0, visionOS 1.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @_Concurrency.MainActor @preconcurrency public var proxyConfigurations: [Network.ProxyConfiguration] {
    get
    set
  }
}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension WebKit.WebPage.Configuration : Swift.Sendable {}
@available(iOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
@available(macOS, unavailable)
extension WebKit.WebPage.Configuration.MediaPlaybackBehavior : Swift.Equatable {}
@available(iOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
@available(macOS, unavailable)
extension WebKit.WebPage.Configuration.MediaPlaybackBehavior : Swift.Hashable {}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension WebKit.WebPage.FrameInfo : Swift.Sendable {}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension WebKit.WebPage.NavigationAction : Swift.Sendable {}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension WebKit.WebPage.NavigationResponse : Swift.Sendable {}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension WebKit.WebPage.NavigationPreferences.ContentMode : Swift.Equatable {}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension WebKit.WebPage.NavigationPreferences.ContentMode : Swift.Hashable {}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension WebKit.WebPage.NavigationPreferences.UpgradeToHTTPSPolicy : Swift.Equatable {}
@available(iOS 26.0, macOS 26.0, visionOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension WebKit.WebPage.NavigationPreferences.UpgradeToHTTPSPolicy : Swift.Hashable {}
