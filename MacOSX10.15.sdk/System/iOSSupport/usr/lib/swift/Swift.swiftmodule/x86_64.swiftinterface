// swift-interface-format-version: 1.0
// swift-tools-version: Apple Swift version 5.1 (swiftlang-1100.8.32.26 clang-1100.0.18.2)
// swift-module-flags: -disable-objc-attr-requires-foundation-module -target x86_64-apple-ios13.0-macabi -enable-objc-interop -enable-library-evolution -module-link-name swiftCore -parse-stdlib -swift-version 5 -O -enforce-exclusivity=unchecked -module-name Swift
import SwiftShims
@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Swift.Comparable {
  // In case `x == y` we pick `x`.
  // This preserves any pre-existing order in case `T` has identity,
  // which is important for e.g. the stability of sorting algorithms.
  // `(min(x, y), max(x, y))` should return `(x, y)` in case `x == y`.
  return y < x ? y : x
}
@inlinable public func min<T>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T where T : Swift.Comparable {
  var minValue = min(min(x, y), z)
  // In case `value == minValue`, we pick `minValue`. See min(_:_:).
  for value in rest where value < minValue {
    minValue = value
  }
  return minValue
}
@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Swift.Comparable {
  // In case `x == y`, we pick `y`. See min(_:_:).
  return y >= x ? y : x
}
@inlinable public func max<T>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T where T : Swift.Comparable {
  var maxValue = max(max(x, y), z)
  // In case `value == maxValue`, we pick `value`. See min(_:_:).
  for value in rest where value >= maxValue {
    maxValue = value
  }
  return maxValue
}
@_fixed_layout public struct EnumeratedSequence<Base> where Base : Swift.Sequence {
  @usableFromInline
  internal var _base: Base
  @inlinable internal init(_base: Base) {
    self._base = _base
  }
}
extension EnumeratedSequence {
  @_fixed_layout public struct Iterator {
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal var _count: Int
    @inlinable internal init(_base: Base.Iterator) {
      self._base = _base
      self._count = 0
    }
  }
}
extension EnumeratedSequence.Iterator : IteratorProtocol, Sequence {
  public typealias Element = (offset: Int, element: Base.Element)
  @inlinable mutating public func next() -> Element? {
    guard let b = _base.next() else { return nil }
    let result = (offset: _count, element: b)
    _count += 1 
    return result
  }
  public typealias Iterator = Swift.EnumeratedSequence<Base>.Iterator
}
extension EnumeratedSequence : Sequence {
  @inlinable __consuming public func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator())
  }
  public typealias Element = (offset: Swift.Int, element: Base.Element)
}
@usableFromInline
@_fixed_layout internal struct _ArrayBody {
  @usableFromInline
  internal var _storage: _SwiftArrayBodyStorage
  @inlinable internal init(count: Int, capacity: Int, elementTypeIsBridgedVerbatim: Bool = false) {
    _internalInvariant(count >= 0)
    _internalInvariant(capacity >= 0)
    
    _storage = _SwiftArrayBodyStorage(
      count: count,
      _capacityAndFlags:
        (UInt(truncatingIfNeeded: capacity) &<< 1) |
        (elementTypeIsBridgedVerbatim ? 1 : 0))
  }
  @inlinable internal init() {
    _storage = _SwiftArrayBodyStorage(count: 0, _capacityAndFlags: 0)
  }
  @inlinable internal var count: Int {
    get {
      return _assumeNonNegative(_storage.count)
    }
    set(newCount) {
      _storage.count = newCount
    }
  }
  @inlinable internal var capacity: Int {
    get {
    return Int(_capacityAndFlags &>> 1)
  }
  }
  @inlinable internal var elementTypeIsBridgedVerbatim: Bool {
    get {
      return (_capacityAndFlags & 0x1) != 0
    }
    set {
      _capacityAndFlags
        = newValue ? _capacityAndFlags | 1 : _capacityAndFlags & ~1
    }
  }
  @inlinable internal var _capacityAndFlags: UInt {
    get {
      return _storage._capacityAndFlags
    }
    set {
      _storage._capacityAndFlags = newValue
    }
  }
}
@usableFromInline
internal typealias _ArrayBridgeStorage = _BridgeStorage<__ContiguousArrayStorageBase>
@usableFromInline
@_fixed_layout internal struct _ArrayBuffer<Element> : _ArrayBufferProtocol {
  @inlinable internal init() {
    _storage = _ArrayBridgeStorage(native: _emptyArrayStorage)
  }
  @inlinable internal init(nsArray: AnyObject) {
    _internalInvariant(_isClassOrObjCExistential(Element.self))
    _storage = _ArrayBridgeStorage(objC: nsArray)
  }
  @inlinable __consuming internal func cast<U>(toBufferOf _: U.Type) -> _ArrayBuffer<U> {
    _internalInvariant(_isClassOrObjCExistential(Element.self))
    _internalInvariant(_isClassOrObjCExistential(U.self))
    return _ArrayBuffer<U>(storage: _storage)
  }
  @inlinable __consuming internal func downcast<U>(toBufferWithDeferredTypeCheckOf _: U.Type) -> _ArrayBuffer<U> {
    _internalInvariant(_isClassOrObjCExistential(Element.self))
    _internalInvariant(_isClassOrObjCExistential(U.self))
    
    // FIXME: can't check that U is derived from Element pending
    // <rdar://problem/20028320> generic metatype casting doesn't work
    // _internalInvariant(U.self is Element.Type)

    return _ArrayBuffer<U>(
      storage: _ArrayBridgeStorage(native: _native._storage, isFlagged: true))
  }
  @inlinable internal var needsElementTypeCheck: Bool {
    get {
    // NSArray's need an element typecheck when the element type isn't AnyObject
    return !_isNativeTypeChecked && !(AnyObject.self is Element.Type)
  }
  }
  @inlinable internal init(storage: _ArrayBridgeStorage) {
    _storage = storage
  }
  @usableFromInline
  internal var _storage: _ArrayBridgeStorage
  @usableFromInline
  internal typealias Index = Swift.Int
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Swift._ArrayBuffer<Element>>
  @usableFromInline
  internal typealias SubSequence = Swift._SliceBuffer<Element>
}
extension _ArrayBuffer {
  @inlinable internal init(_buffer source: NativeBuffer, shiftedToStartIndex: Int) {
    _internalInvariant(shiftedToStartIndex == 0, "shiftedToStartIndex must be 0")
    _storage = _ArrayBridgeStorage(native: source._storage)
  }
  @inlinable internal var arrayPropertyIsNativeTypeChecked: Bool {
    get {
    return _isNativeTypeChecked
  }
  }
  @inlinable mutating internal func isUniquelyReferenced() -> Bool {
    if !_isClassOrObjCExistential(Element.self) {
      return _storage.isUniquelyReferencedUnflaggedNative()
    }

    // This is a performance optimization. This code used to be:
    //
    //   return _storage.isUniquelyReferencedNative() && _isNative.
    //
    // SR-6437
    if !_storage.isUniquelyReferencedNative() {
      return false
    }
    return _isNative
  }
  @inlinable internal func _asCocoaArray() -> AnyObject {
    return _fastPath(_isNative) ? _native._asCocoaArray() : _nonNative.buffer
  }
  @inlinable mutating internal func requestUniqueMutableBackingBuffer(minimumCapacity: Int) -> NativeBuffer? {
    if _fastPath(isUniquelyReferenced()) {
      let b = _native
      if _fastPath(b.capacity >= minimumCapacity) {
        return b
      }
    }
    return nil
  }
  @inlinable mutating internal func isMutableAndUniquelyReferenced() -> Bool {
    return isUniquelyReferenced()
  }
  @inlinable internal func requestNativeBuffer() -> NativeBuffer? {
    if !_isClassOrObjCExistential(Element.self) {
      return _native
    }
    return _fastPath(_storage.isNative) ? _native : nil
  }
  @usableFromInline
  @inline(never) internal func _typeCheckSlowPath(_ index: Int)
  @inlinable internal func _typeCheck(_ subRange: Range<Int>) {
    if !_isClassOrObjCExistential(Element.self) {
      return
    }

    if _slowPath(needsElementTypeCheck) {
      // Could be sped up, e.g. by using
      // enumerateObjectsAtIndexes:options:usingBlock: in the
      // non-native case.
      for i in subRange.lowerBound ..< subRange.upperBound {
        _typeCheckSlowPath(i)
      }
    }
  }
  @discardableResult
  @inlinable __consuming internal func _copyContents(subRange bounds: Range<Int>, initializing target: UnsafeMutablePointer<Element>) -> UnsafeMutablePointer<Element> {
    _typeCheck(bounds)
    if _fastPath(_isNative) {
      return _native._copyContents(subRange: bounds, initializing: target)
    }
    let buffer = UnsafeMutableRawPointer(target)
      .assumingMemoryBound(to: AnyObject.self)
    let result = _nonNative._copyContents(
      subRange: bounds,
      initializing: buffer)
    return UnsafeMutableRawPointer(result).assumingMemoryBound(to: Element.self)
  }
  __consuming public func _copyContents(initializing buffer: UnsafeMutableBufferPointer<Element>) -> (Iterator, UnsafeMutableBufferPointer<Element>.Index)
  @inlinable internal subscript(bounds: Range<Int>) -> _SliceBuffer<Element> {
    get {
      _typeCheck(bounds)
      if _fastPath(_isNative) {
        return _native[bounds]
      }
      return _nonNative[bounds].unsafeCastElements(to: Element.self)
    }
    set {
      fatalError("not implemented")
    }
  }
  @inlinable internal var firstElementAddress: UnsafeMutablePointer<Element> {
    get {
    _internalInvariant(_isNative, "must be a native buffer")
    return _native.firstElementAddress
  }
  }
  @inlinable internal var firstElementAddressIfContiguous: UnsafeMutablePointer<Element>? {
    get {
    return _fastPath(_isNative) ? firstElementAddress : nil
  }
  }
  @inlinable internal var count: Int {
    @inline(__always) get {
      return _fastPath(_isNative) ? _native.count : _nonNative.count
    }
    set {
      _internalInvariant(_isNative, "attempting to update count of Cocoa array")
      _native.count = newValue
    }
  }
  @inlinable internal func _checkInoutAndNativeBounds(_ index: Int, wasNative: Bool) {
    _precondition(
      _isNative == wasNative,
      "inout rules were violated: the array was overwritten")

    if _fastPath(wasNative) {
      _native._checkValidSubscript(index)
    }
  }
  @inlinable internal func _checkInoutAndNativeTypeCheckedBounds(_ index: Int, wasNativeTypeChecked: Bool) {
    _precondition(
      _isNativeTypeChecked == wasNativeTypeChecked,
      "inout rules were violated: the array was overwritten")

    if _fastPath(wasNativeTypeChecked) {
      _native._checkValidSubscript(index)
    }
  }
  @inlinable internal var capacity: Int {
    get {
    return _fastPath(_isNative) ? _native.capacity : _nonNative.count
  }
  }
  @inlinable @inline(__always) internal func getElement(_ i: Int, wasNativeTypeChecked: Bool) -> Element {
    if _fastPath(wasNativeTypeChecked) {
      return _nativeTypeChecked[i]
    }
    return unsafeBitCast(_getElementSlowPath(i), to: Element.self)
  }
  @inline(never) @inlinable internal func _getElementSlowPath(_ i: Int) -> AnyObject {
    _internalInvariant(
      _isClassOrObjCExistential(Element.self),
      "Only single reference elements can be indexed here.")
    let element: AnyObject
    if _isNative {
      // _checkInoutAndNativeTypeCheckedBounds does no subscript
      // checking for the native un-typechecked case.  Therefore we
      // have to do it here.
      _native._checkValidSubscript(i)
      
      element = cast(toBufferOf: AnyObject.self)._native[i]
      precondition(
        element is Element,
        """
        Down-casted Array element failed to match the target type
        Expected \(Element.self) but found \(type(of: element))
        """
      )
    } else {
      // ObjC arrays do their own subscript checking.
      element = _nonNative[i]
      precondition(
        element is Element,
        """
        NSArray element failed to match the Swift Array Element type
        Expected \(Element.self) but found \(type(of: element))
        """
      )
    }
    return element
  }
  @inlinable internal subscript(i: Int) -> Element {
    get {
      return getElement(i, wasNativeTypeChecked: _isNativeTypeChecked)
    }
    nonmutating set {
      if _fastPath(_isNative) {
        _native[i] = newValue
      }
      else {
        var refCopy = self
        refCopy.replaceSubrange(
          i..<(i + 1),
          with: 1,
          elementsOf: CollectionOfOne(newValue))
      }
    }
  }
  @inlinable internal func withUnsafeBufferPointer<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    if _fastPath(_isNative) {
      defer { _fixLifetime(self) }
      return try body(
        UnsafeBufferPointer(start: firstElementAddress, count: count))
    }
    return try ContiguousArray(self).withUnsafeBufferPointer(body)
  }
  @inlinable mutating internal func withUnsafeMutableBufferPointer<R>(_ body: (UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    _internalInvariant(
      _isNative || count == 0,
      "Array is bridging an opaque NSArray; can't get a pointer to the elements"
    )
    defer { _fixLifetime(self) }
    return try body(UnsafeMutableBufferPointer(
      start: firstElementAddressIfContiguous, count: count))
  }
  @inlinable internal var owner: AnyObject {
    get {
    return _fastPath(_isNative) ? _native._storage : _nonNative.buffer
  }
  }
  @inlinable internal var nativeOwner: AnyObject {
    get {
    _internalInvariant(_isNative, "Expect a native array")
    return _native._storage
  }
  }
  @inlinable internal var identity: UnsafeRawPointer {
    get {
    if _isNative {
      return _native.identity
    }
    else {
      return UnsafeRawPointer(
        Unmanaged.passUnretained(_nonNative.buffer).toOpaque())
    }
  }
  }
  @inlinable internal var startIndex: Int {
    get {
    return 0
  }
  }
  @inlinable internal var endIndex: Int {
    get {
    return count
  }
  }
  @usableFromInline
  internal typealias Indices = Range<Int>
  @usableFromInline
  internal typealias NativeBuffer = _ContiguousArrayBuffer<Element>
  @inlinable internal var _isNative: Bool {
    get {
    if !_isClassOrObjCExistential(Element.self) {
      return true
    } else {
      return _storage.isNative
    }
  }
  }
  @inlinable internal var _isNativeTypeChecked: Bool {
    get {
    if !_isClassOrObjCExistential(Element.self) {
      return true
    } else {
      return _storage.isUnflaggedNative
    }
  }
  }
  @inlinable internal var _native: NativeBuffer {
    get {
    return NativeBuffer(
      _isClassOrObjCExistential(Element.self)
      ? _storage.nativeInstance : _storage.unflaggedNativeInstance)
  }
  }
  @inlinable internal var _nativeTypeChecked: NativeBuffer {
    get {
    return NativeBuffer(_storage.unflaggedNativeInstance)
  }
  }
  @inlinable internal var _nonNative: _CocoaArrayWrapper {
    @inline(__always) get {
      _internalInvariant(_isClassOrObjCExistential(Element.self))
      return _CocoaArrayWrapper(_storage.objCInstance)
    }
  }
}
@usableFromInline
internal protocol _ArrayBufferProtocol : Swift.MutableCollection, Swift.RandomAccessCollection where Self.Indices == Swift.Range<Swift.Int> {
  init()
  init(_buffer: _ContiguousArrayBuffer<Element>, shiftedToStartIndex: Int)
  init(copying buffer: Self)
  @discardableResult
  __consuming func _copyContents(subRange bounds: Range<Int>, initializing target: UnsafeMutablePointer<Element>) -> UnsafeMutablePointer<Element>
  mutating func requestUniqueMutableBackingBuffer(minimumCapacity: Int) -> _ContiguousArrayBuffer<Element>?
  mutating func isMutableAndUniquelyReferenced() -> Bool
  func requestNativeBuffer() -> _ContiguousArrayBuffer<Element>?
  mutating func replaceSubrange<C>(_ subrange: Range<Int>, with newCount: Int, elementsOf newValues: __owned C) where C : Swift.Collection, Self.Element == C.Element
  subscript(bounds: Range<Int>) -> _SliceBuffer<Element> { get }
  func withUnsafeBufferPointer<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R
  mutating func withUnsafeMutableBufferPointer<R>(_ body: (UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R
  override var count: Int { get set }
  var capacity: Int { get }
  var owner: AnyObject { get }
  var firstElementAddress: UnsafeMutablePointer<Element> { get }
  var firstElementAddressIfContiguous: UnsafeMutablePointer<Element>? { get }
  var subscriptBaseAddress: UnsafeMutablePointer<Element> { get }
  var identity: UnsafeRawPointer { get }
}
extension _ArrayBufferProtocol {
  @inlinable internal var subscriptBaseAddress: UnsafeMutablePointer<Element> {
    get {
    return firstElementAddress
  }
  }
  @inline(never) @inlinable internal init(copying buffer: Self) {
    let newBuffer = _ContiguousArrayBuffer<Element>(
      _uninitializedCount: buffer.count, minimumCapacity: buffer.count)
    buffer._copyContents(
      subRange: buffer.indices,
      initializing: newBuffer.firstElementAddress)
    self = Self( _buffer: newBuffer, shiftedToStartIndex: buffer.startIndex)
  }
  @inlinable mutating internal func replaceSubrange<C>(_ subrange: Range<Int>, with newCount: Int, elementsOf newValues: __owned C) where C : Swift.Collection, Self.Element == C.Element {
    _internalInvariant(startIndex == 0, "_SliceBuffer should override this function.")
    let oldCount = self.count
    let eraseCount = subrange.count

    let growth = newCount - eraseCount
    self.count = oldCount + growth

    let elements = self.subscriptBaseAddress
    let oldTailIndex = subrange.upperBound
    let oldTailStart = elements + oldTailIndex
    let newTailIndex = oldTailIndex + growth
    let newTailStart = oldTailStart + growth
    let tailCount = oldCount - subrange.upperBound

    if growth > 0 {
      // Slide the tail part of the buffer forwards, in reverse order
      // so as not to self-clobber.
      newTailStart.moveInitialize(from: oldTailStart, count: tailCount)

      // Assign over the original subrange
      var i = newValues.startIndex
      for j in subrange {
        elements[j] = newValues[i]
        newValues.formIndex(after: &i)
      }
      // Initialize the hole left by sliding the tail forward
      for j in oldTailIndex..<newTailIndex {
        (elements + j).initialize(to: newValues[i])
        newValues.formIndex(after: &i)
      }
      _expectEnd(of: newValues, is: i)
    }
    else { // We're not growing the buffer
      // Assign all the new elements into the start of the subrange
      var i = subrange.lowerBound
      var j = newValues.startIndex
      for _ in 0..<newCount {
        elements[i] = newValues[j]
        i += 1
        newValues.formIndex(after: &j)
      }
      _expectEnd(of: newValues, is: j)

      // If the size didn't change, we're done.
      if growth == 0 {
        return
      }

      // Move the tail backward to cover the shrinkage.
      let shrinkage = -growth
      if tailCount > shrinkage {   // If the tail length exceeds the shrinkage

        // Assign over the rest of the replaced range with the first
        // part of the tail.
        newTailStart.moveAssign(from: oldTailStart, count: shrinkage)

        // Slide the rest of the tail back
        oldTailStart.moveInitialize(
          from: oldTailStart + shrinkage, count: tailCount - shrinkage)
      }
      else {                      // Tail fits within erased elements
        // Assign over the start of the replaced range with the tail
        newTailStart.moveAssign(from: oldTailStart, count: tailCount)

        // Destroy elements remaining after the tail in subrange
        (newTailStart + tailCount).deinitialize(
          count: shrinkage - tailCount)
      }
    }
  }
}
@inlinable public func _arrayForceCast<SourceElement, TargetElement>(_ source: Array<SourceElement>) -> Array<TargetElement> {
  if _isClassOrObjCExistential(SourceElement.self)
  && _isClassOrObjCExistential(TargetElement.self) {
    let src = source._buffer
    if let native = src.requestNativeBuffer() {
      if native.storesOnlyElementsOfType(TargetElement.self) {
        // A native buffer that is known to store only elements of the
        // TargetElement can be used directly
        return Array(_buffer: src.cast(toBufferOf: TargetElement.self))
      }
      // Other native buffers must use deferred element type checking
      return Array(_buffer:
        src.downcast(toBufferWithDeferredTypeCheckOf: TargetElement.self))
    }
    return Array(_immutableCocoaArray: source._buffer._asCocoaArray())
  }
  return source.map { $0 as! TargetElement }
}
@inlinable public func _arrayConditionalCast<SourceElement, TargetElement>(_ source: [SourceElement]) -> [TargetElement]? {
  var successfulCasts = ContiguousArray<TargetElement>()
  successfulCasts.reserveCapacity(source.count)
  for element in source {
    if let casted = element as? TargetElement {
      successfulCasts.append(casted)
    } else {
      return nil
    }
  }
  return Array(successfulCasts)
}
@_fixed_layout public struct Array<Element> : _DestructorSafeContainer {
  @usableFromInline
  internal typealias _Buffer = _ArrayBuffer<Element>
  @usableFromInline
  internal var _buffer: _Buffer
  @inlinable internal init(_buffer: _Buffer) {
    self._buffer = _buffer
  }
}
extension Array {
  @inlinable @_semantics("array.props.isNativeTypeChecked") public func _hoistableIsNativeTypeChecked() -> Bool {
   return _buffer.arrayPropertyIsNativeTypeChecked
  }
  @inlinable @_semantics("array.get_count") internal func _getCount() -> Int {
    return _buffer.count
  }
  @inlinable @_semantics("array.get_capacity") internal func _getCapacity() -> Int {
    return _buffer.capacity
  }
  @inlinable @_semantics("array.make_mutable") mutating internal func _makeMutableAndUnique() {
    if _slowPath(!_buffer.isMutableAndUniquelyReferenced()) {
      _buffer = _Buffer(copying: _buffer)
    }
  }
  @inlinable @inline(__always) internal func _checkSubscript_native(_ index: Int) {
    _ = _checkSubscript(index, wasNativeTypeChecked: true)
  }
  @inlinable @_semantics("array.check_subscript") public func _checkSubscript(_ index: Int, wasNativeTypeChecked: Bool) -> _DependenceToken {
    _buffer._checkInoutAndNativeTypeCheckedBounds(
      index, wasNativeTypeChecked: wasNativeTypeChecked)
    return _DependenceToken()
  }
  @inlinable @_semantics("array.check_index") internal func _checkIndex(_ index: Int) {
    _precondition(index <= endIndex, "Array index is out of range")
    _precondition(index >= startIndex, "Negative Array index is out of range")
  }
  @_semantics("array.get_element") @inlinable @inline(__always) public func _getElement(_ index: Int, wasNativeTypeChecked: Bool, matchingSubscriptCheck: _DependenceToken) -> Element {
    return _buffer.getElement(index, wasNativeTypeChecked: wasNativeTypeChecked)
  }
  @inlinable @_semantics("array.get_element_address") internal func _getElementAddress(_ index: Int) -> UnsafeMutablePointer<Element> {
    return _buffer.subscriptBaseAddress + index
  }
}
extension Array : _ArrayProtocol {
  @inlinable public var capacity: Int {
    get {
    return _getCapacity()
  }
  }
  @inlinable public var _owner: AnyObject? {
    @inlinable @inline(__always) get {
      return _buffer.owner      
    }
  }
  @inlinable public var _baseAddressIfContiguous: UnsafeMutablePointer<Element>? {
    @inline(__always) get { return _buffer.firstElementAddressIfContiguous }
  }
}
extension Array : RandomAccessCollection, MutableCollection {
  public typealias Index = Int
  public typealias Indices = Range<Int>
  public typealias Iterator = IndexingIterator<Array>
  @inlinable public var startIndex: Int {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Int {
    @inlinable get {
      return _getCount()
    }
  }
  @inlinable public func index(after i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + 1
  }
  @inlinable public func formIndex(after i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i += 1
  }
  @inlinable public func index(before i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i - 1
  }
  @inlinable public func formIndex(before i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i -= 1
  }
  @inlinable public func index(_ i: Int, offsetBy distance: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + distance
  }
  @inlinable public func index(_ i: Int, offsetBy distance: Int, limitedBy limit: Int) -> Int? {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    let l = limit - i
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return i + distance
  }
  @inlinable public func distance(from start: Int, to end: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return end - start
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Int, bounds: Range<Int>) {
    // NOTE: This method is a no-op for performance reasons.
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Range<Int>, bounds: Range<Int>) {
    // NOTE: This method is a no-op for performance reasons.
  }
  @inlinable public subscript(index: Int) -> Element {
    get {
      // This call may be hoisted or eliminated by the optimizer.  If
      // there is an inout violation, this value may be stale so needs to be
      // checked again below.
      let wasNativeTypeChecked = _hoistableIsNativeTypeChecked()

      // Make sure the index is in range and wasNativeTypeChecked is
      // still valid.
      let token = _checkSubscript(
        index, wasNativeTypeChecked: wasNativeTypeChecked)

      return _getElement(
        index, wasNativeTypeChecked: wasNativeTypeChecked,
        matchingSubscriptCheck: token)
    }
    _modify {
      _makeMutableAndUnique() // makes the array native, too
      _checkSubscript_native(index)
      let address = _buffer.subscriptBaseAddress + index
      yield &address.pointee
    }
  }
  @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> {
    get {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      return ArraySlice(_buffer: _buffer[bounds])
    }
    set(rhs) {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      // If the replacement buffer has same identity, and the ranges match,
      // then this was a pinned in-place modification, nothing further needed.
      if self[bounds]._buffer.identity != rhs._buffer.identity
      || bounds != rhs.startIndex..<rhs.endIndex {
        self.replaceSubrange(bounds, with: rhs)
      }
    }
  }
  @inlinable public var count: Int {
    get {
    return _getCount()
  }
  }
  public typealias SubSequence = Swift.ArraySlice<Element>
}
extension Array : ExpressibleByArrayLiteral {
  @inlinable public init(arrayLiteral elements: Element...) {
    self = elements
  }
  public typealias ArrayLiteralElement = Element
}
extension Array : RangeReplaceableCollection {
  @inlinable @_semantics("array.init.empty") public init() {
    _buffer = _Buffer()
  }
  @inlinable public init<S>(_ s: S) where Element == S.Element, S : Swift.Sequence {
    self = Array(
      _buffer: _Buffer(
        _buffer: s._copyToContiguousArray()._buffer,
        shiftedToStartIndex: 0))
  }
  @inlinable @_semantics("array.init") public init(repeating repeatedValue: Element, count: Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = Array._allocateUninitialized(count)
    for _ in 0..<count {
      p.initialize(to: repeatedValue)
      p += 1
    }
  }
  @usableFromInline
  @inline(never) internal static func _allocateBufferUninitialized(minimumCapacity: Int) -> _Buffer
  @inlinable internal init(_uninitializedCount count: Int) {
    _precondition(count >= 0, "Can't construct Array with count < 0")
    // Note: Sinking this constructor into an else branch below causes an extra
    // Retain/Release.
    _buffer = _Buffer()
    if count > 0 {
      // Creating a buffer instead of calling reserveCapacity saves doing an
      // unnecessary uniqueness check. We disable inlining here to curb code
      // growth.
      _buffer = Array._allocateBufferUninitialized(minimumCapacity: count)
      _buffer.count = count
    }
    // Can't store count here because the buffer might be pointing to the
    // shared empty array.
  }
  @inlinable @_semantics("array.uninitialized") internal static func _allocateUninitialized(_ count: Int) -> (Array, UnsafeMutablePointer<Element>) {
    let result = Array(_uninitializedCount: count)
    return (result, result._buffer.firstElementAddress)
  }
  @inlinable @_semantics("array.uninitialized") internal static func _adoptStorage(_ storage: __owned _ContiguousArrayStorage<Element>, count: Int) -> (Array, UnsafeMutablePointer<Element>) {

    let innerBuffer = _ContiguousArrayBuffer<Element>(
      count: count,
      storage: storage)

    return (
      Array(
        _buffer: _Buffer(_buffer: innerBuffer, shiftedToStartIndex: 0)),
        innerBuffer.firstElementAddress)
  }
  @inlinable mutating internal func _deallocateUninitialized() {
    // Set the count to zero and just release as normal.
    // Somewhat of a hack.
    _buffer.count = 0
  }
  @inlinable @_semantics("array.mutate_unknown") mutating public func reserveCapacity(_ minimumCapacity: Int) {
    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: minimumCapacity) == nil {

      let newBuffer = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: count, minimumCapacity: minimumCapacity)

      _buffer._copyContents(
        subRange: _buffer.indices,
        initializing: newBuffer.firstElementAddress)
      _buffer = _Buffer(
        _buffer: newBuffer, shiftedToStartIndex: _buffer.startIndex)
    }
    _internalInvariant(capacity >= minimumCapacity)
  }
  @inline(never) @inlinable mutating internal func _copyToNewBuffer(oldCount: Int) {
    let newCount = oldCount + 1
    var newBuffer = _buffer._forceCreateUniqueMutableBuffer(
      countForNewBuffer: oldCount, minNewCapacity: newCount)
    _buffer._arrayOutOfPlaceUpdate(&newBuffer, oldCount, 0)
  }
  @inlinable @_semantics("array.make_mutable") mutating internal func _makeUniqueAndReserveCapacityIfNotUnique() {
    if _slowPath(!_buffer.isMutableAndUniquelyReferenced()) {
      _copyToNewBuffer(oldCount: _buffer.count)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") mutating internal func _reserveCapacityAssumingUniqueBuffer(oldCount: Int) {
    // This is a performance optimization. This code used to be in an ||
    // statement in the _internalInvariant below.
    //
    //   _internalInvariant(_buffer.capacity == 0 ||
    //                _buffer.isMutableAndUniquelyReferenced())
    //
    // SR-6437
    let capacity = _buffer.capacity == 0

    // Due to make_mutable hoisting the situation can arise where we hoist
    // _makeMutableAndUnique out of loop and use it to replace
    // _makeUniqueAndReserveCapacityIfNotUnique that preceeds this call. If the
    // array was empty _makeMutableAndUnique does not replace the empty array
    // buffer by a unique buffer (it just replaces it by the empty array
    // singleton).
    // This specific case is okay because we will make the buffer unique in this
    // function because we request a capacity > 0 and therefore _copyToNewBuffer
    // will be called creating a new buffer.
    _internalInvariant(capacity ||
                 _buffer.isMutableAndUniquelyReferenced())

    if _slowPath(oldCount + 1 > _buffer.capacity) {
      _copyToNewBuffer(oldCount: oldCount)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") mutating internal func _appendElementAssumeUniqueAndCapacity(_ oldCount: Int, newElement: __owned Element) {
    _internalInvariant(_buffer.isMutableAndUniquelyReferenced())
    _internalInvariant(_buffer.capacity >= _buffer.count + 1)

    _buffer.count = oldCount + 1
    (_buffer.firstElementAddress + oldCount).initialize(to: newElement)
  }
  @inlinable @_semantics("array.append_element") mutating public func append(_ newElement: __owned Element) {
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _getCount()
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
  }
  @inlinable @_semantics("array.append_contentsOf") mutating public func append<S>(contentsOf newElements: __owned S) where Element == S.Element, S : Swift.Sequence {

    let newElementsCount = newElements.underestimatedCount
    reserveCapacityForAppend(newElementsCount: newElementsCount)

    let oldCount = self.count
    let startNewElements = _buffer.firstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements, 
                count: self.capacity - oldCount)

    let (remainder,writtenUpTo) = buf.initialize(from: newElements)
    
    // trap on underflow from the sequence's underestimate:
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    _precondition(newElementsCount <= writtenCount, 
      "newElements.underestimatedCount was an overestimate")
    // can't check for overflow as sequences can underestimate

    // This check prevents a data race writting to _swiftEmptyArrayStorage
    if writtenCount > 0 {
      _buffer.count += writtenCount
    }

    if writtenUpTo == buf.endIndex {
      // there may be elements that didn't fit in the existing buffer,
      // append them in slow sequence-only mode
      _buffer._arrayAppendSequence(IteratorSequence(remainder))
    }
  }
  @inlinable @_semantics("array.reserve_capacity_for_append") mutating internal func reserveCapacityForAppend(newElementsCount: Int) {
    let oldCount = self.count
    let oldCapacity = self.capacity
    let newCount = oldCount + newElementsCount

    // Ensure uniqueness, mutability, and sufficient storage.  Note that
    // for consistency, we need unique self even if newElements is empty.
    self.reserveCapacity(
      newCount > oldCapacity ?
      Swift.max(newCount, _growArrayCapacity(oldCapacity))
      : newCount)
  }
  @inlinable mutating public func _customRemoveLast() -> Element? {
    let newCount = _getCount() - 1
    _precondition(newCount >= 0, "Can't removeLast from an empty Array")
    _makeUniqueAndReserveCapacityIfNotUnique()
    let pointer = (_buffer.firstElementAddress + newCount)
    let element = pointer.move()
    _buffer.count = newCount
    return element
  }
  @discardableResult
  @inlinable mutating public func remove(at index: Int) -> Element {
    _precondition(index < endIndex, "Index out of range")
    _precondition(index >= startIndex, "Index out of range")
    _makeUniqueAndReserveCapacityIfNotUnique()
    let newCount = _getCount() - 1
    let pointer = (_buffer.firstElementAddress + index)
    let result = pointer.move()
    pointer.moveInitialize(from: pointer + 1, count: newCount - index)
    _buffer.count = newCount
    return result
  }
  @inlinable mutating public func insert(_ newElement: __owned Element, at i: Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
  @inlinable mutating public func removeAll(keepingCapacity keepCapacity: Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
  }
  @inlinable mutating public func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable mutating public func withContiguousMutableStorageIfAvailable<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeBufferPointer {
      (bufferPointer) -> R in
      return try body(bufferPointer)
    }
  }
  @inlinable __consuming public func _copyToContiguousArray() -> ContiguousArray<Element> {
    if let n = _buffer.requestNativeBuffer() {
      return ContiguousArray(_buffer: n)
    }
    return _copyCollectionToContiguousArray(self)
  }
}
extension Array {
  @inlinable public static func + (lhs: Array, rhs: Array) -> Array {
    var lhs = lhs
    lhs.append(contentsOf: rhs)
    return lhs
  }
  @inlinable public static func += (lhs: inout Array, rhs: Array) {
    lhs.append(contentsOf: rhs)
  }
}
extension Array : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Array : CustomStringConvertible, CustomDebugStringConvertible {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
}
extension Array {
  @usableFromInline
  @_transparent internal func _cPointerArgs() -> (AnyObject?, UnsafeRawPointer?) {
    let p = _baseAddressIfContiguous
    if _fastPath(p != nil || isEmpty) {
      return (_owner, UnsafeRawPointer(p))
    }
    let n = ContiguousArray(self._buffer)._buffer
    return (n.owner, UnsafeRawPointer(n.firstElementAddress))
  }
}
extension Array {
  @inlinable internal init(_unsafeUninitializedCapacity: Int, initializingWith initializer: (_ buffer: inout UnsafeMutableBufferPointer<Element>, _ initializedCount: inout Int) throws -> Void) rethrows {
    var firstElementAddress: UnsafeMutablePointer<Element>
    (self, firstElementAddress) =
      Array._allocateUninitialized(_unsafeUninitializedCapacity)

    var initializedCount = 0
    var buffer = UnsafeMutableBufferPointer<Element>(
      start: firstElementAddress, count: _unsafeUninitializedCapacity)
    defer {
      // Update self.count even if initializer throws an error.
      _precondition(
        initializedCount <= _unsafeUninitializedCapacity,
        "Initialized count set to greater than specified capacity."
      )
      _precondition(
        buffer.baseAddress == firstElementAddress,
        "Can't reassign buffer in Array(unsafeUninitializedCapacity:initializingWith:)"
      )
      self._buffer.count = initializedCount
    }
    try initializer(&buffer, &initializedCount)
  }
  @_alwaysEmitIntoClient @inlinable public init(unsafeUninitializedCapacity: Int, initializingWith initializer: (_ buffer: inout UnsafeMutableBufferPointer<Element>, _ initializedCount: inout Int) throws -> Void) rethrows {
    self = try Array(
      _unsafeUninitializedCapacity: unsafeUninitializedCapacity,
      initializingWith: initializer)
  }
  @inlinable public func withUnsafeBufferPointer<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
  @_semantics("array.withUnsafeMutableBufferPointer") @inlinable @inline(__always) mutating public func withUnsafeMutableBufferPointer<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    let count = self.count
    // Ensure unique storage
    _buffer._outlinedMakeUniqueBuffer(bufferCount: count)

    // Ensure that body can't invalidate the storage or its bounds by
    // moving self into a temporary working array.
    // NOTE: The stack promotion optimization that keys of the
    // "array.withUnsafeMutableBufferPointer" semantics annotation relies on the
    // array buffer not being able to escape in the closure. It can do this
    // because we swap the array buffer in self with an empty buffer here. Any
    // escape via the address of self in the closure will therefore escape the
    // empty array.

    var work = Array()
    (work, self) = (self, work)

    // Create an UnsafeBufferPointer over work that we can pass to body
    let pointer = work._buffer.firstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    // Put the working array back before returning.
    defer {
      _precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "Array withUnsafeMutableBufferPointer: replacing the buffer is not allowed")

      (work, self) = (self, work)
    }

    // Invoke the body.
    return try body(&inoutBufferPointer)
  }
  @inlinable __consuming public func _copyContents(initializing buffer: UnsafeMutableBufferPointer<Element>) -> (Iterator, UnsafeMutableBufferPointer<Element>.Index) {

    guard !self.isEmpty else { return (makeIterator(),buffer.startIndex) }

    // It is not OK for there to be no pointer/not enough space, as this is
    // a precondition and Array never lies about its count.
    guard var p = buffer.baseAddress
      else { _preconditionFailure("Attempt to copy contents into nil buffer pointer") }
    _precondition(self.count <= buffer.count, 
      "Insufficient space allocated to copy array contents")

    if let s = _baseAddressIfContiguous {
      p.initialize(from: s, count: self.count)
      // Need a _fixLifetime bracketing the _baseAddressIfContiguous getter
      // and all uses of the pointer it returns:
      _fixLifetime(self._owner)
    } else {
      for x in self {
        p.initialize(to: x)
        p += 1
      }
    }

    var it = IndexingIterator(_elements: self)
    it._position = endIndex
    return (it,buffer.index(buffer.startIndex, offsetBy: self.count))
  }
}
extension Array {
  @inlinable @_semantics("array.mutate_unknown") mutating public func replaceSubrange<C>(_ subrange: Range<Int>, with newElements: __owned C) where Element == C.Element, C : Swift.Collection {
    _precondition(subrange.lowerBound >= self._buffer.startIndex,
      "Array replace: subrange start is negative")

    _precondition(subrange.upperBound <= _buffer.endIndex,
      "Array replace: subrange extends past the end")

    let oldCount = _buffer.count
    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: oldCount + growth) != nil {

      _buffer.replaceSubrange(
        subrange, with: insertCount, elementsOf: newElements)
    } else {
      _buffer._arrayOutOfPlaceReplace(subrange, with: newElements, count: insertCount)
    }
  }
}
extension Array : Equatable where Element : Swift.Equatable {
  @inlinable public static func == (lhs: Array<Element>, rhs: Array<Element>) -> Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

    // Test referential equality.
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    _internalInvariant(lhs.startIndex == 0 && rhs.startIndex == 0)
    _internalInvariant(lhs.endIndex == lhsCount && rhs.endIndex == lhsCount)

    // We know that lhs.count == rhs.count, compare element wise.
    for idx in 0..<lhsCount {
      if lhs[idx] != rhs[idx] {
        return false
      }
    }

    return true
  }
}
extension Array : Hashable where Element : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine(count) // discriminator
    for element in self {
      hasher.combine(element)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Array {
  @inlinable mutating public func withUnsafeMutableBytes<R>(_ body: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeMutableBufferPointer {
      return try body(UnsafeMutableRawBufferPointer($0))
    }
  }
  @inlinable public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeBufferPointer {
      try body(UnsafeRawBufferPointer($0))
    }
  }
}
@usableFromInline
internal func _bridgeCocoaArray<T>(_ _immutableCocoaArray: AnyObject) -> Array<T>
extension Array {
  @inlinable public func _bridgeToObjectiveCImpl() -> AnyObject {
    return _buffer._asCocoaArray()
  }
  @inlinable public static func _bridgeFromObjectiveCAdoptingNativeStorageOf(_ source: AnyObject) -> Array? {
    // If source is deferred, we indirect to get its native storage
    let maybeNative = (source as? __SwiftDeferredNSArray)?._nativeStorage ?? source

    return (maybeNative as? _ContiguousArrayStorage<Element>).map {
      Array(_ContiguousArrayBuffer($0))
    }
  }
  @inlinable public init(_immutableCocoaArray: AnyObject) {
    self = _bridgeCocoaArray(_immutableCocoaArray)
  }
}
extension Array : _HasCustomAnyHashableRepresentation where Element : Swift.Hashable {
  __consuming public func _toCustomAnyHashable() -> AnyHashable?
}
@_fixed_layout public struct _DependenceToken {
  @inlinable public init() {
  }
}
@inlinable @inline(__always) @_semantics("array.uninitialized_intrinsic") public func _allocateUninitializedArray<Element>(_ builtinCount: Builtin.Word) -> (Array<Element>, Builtin.RawPointer) {
  let count = Int(builtinCount)
  if count > 0 {
    // Doing the actual buffer allocation outside of the array.uninitialized
    // semantics function enables stack propagation of the buffer.
    let bufferObject = Builtin.allocWithTailElems_1(
      _ContiguousArrayStorage<Element>.self, builtinCount, Element.self)

    let (array, ptr) = Array<Element>._adoptStorage(bufferObject, count: count)
    return (array, ptr._rawValue)
  }
  // For an empty array no buffer allocation is needed.
  let (array, ptr) = Array<Element>._allocateUninitialized(count)
  return (array, ptr._rawValue)
}
@inlinable @_semantics("array.dealloc_uninitialized") public func _deallocateUninitializedArray<Element>(_ array: __owned Array<Element>) {
  var array = array
  array._deallocateUninitialized()
}
extension _ArrayBufferProtocol {
  @inlinable @inline(never) mutating internal func _arrayOutOfPlaceReplace<C>(_ bounds: Range<Int>, with newValues: __owned C, count insertCount: Int) where C : Swift.Collection, Self.Element == C.Element {

    let growth = insertCount - bounds.count
    let newCount = self.count + growth
    var newBuffer = _forceCreateUniqueMutableBuffer(
      newCount: newCount, requiredCapacity: newCount)

    _arrayOutOfPlaceUpdate(
      &newBuffer, bounds.lowerBound - startIndex, insertCount,
      { rawMemory, count in
        var p = rawMemory
        var q = newValues.startIndex
        for _ in 0..<count {
          p.initialize(to: newValues[q])
          newValues.formIndex(after: &q)
          p += 1
        }
        _expectEnd(of: newValues, is: q)
      }
    )
  }
}
@inlinable internal func _expectEnd<C>(of s: C, is i: C.Index) where C : Swift.Collection {
  _debugPrecondition(
    i == s.endIndex,
    "invalid Collection: count differed in successive traversals")
}
@inlinable internal func _growArrayCapacity(_ capacity: Int) -> Int {
  return capacity * 2
}
extension _ArrayBufferProtocol {
  @inline(never) @inlinable internal func _forceCreateUniqueMutableBuffer(newCount: Int, requiredCapacity: Int) -> _ContiguousArrayBuffer<Element> {
    return _forceCreateUniqueMutableBufferImpl(
      countForBuffer: newCount, minNewCapacity: newCount,
      requiredCapacity: requiredCapacity)
  }
  @inline(never) @inlinable internal func _forceCreateUniqueMutableBuffer(countForNewBuffer: Int, minNewCapacity: Int) -> _ContiguousArrayBuffer<Element> {
    return _forceCreateUniqueMutableBufferImpl(
      countForBuffer: countForNewBuffer, minNewCapacity: minNewCapacity,
      requiredCapacity: minNewCapacity)
  }
  @inlinable internal func _forceCreateUniqueMutableBufferImpl(countForBuffer: Int, minNewCapacity: Int, requiredCapacity: Int) -> _ContiguousArrayBuffer<Element> {
    _internalInvariant(countForBuffer >= 0)
    _internalInvariant(requiredCapacity >= countForBuffer)
    _internalInvariant(minNewCapacity >= countForBuffer)

    let minimumCapacity = Swift.max(requiredCapacity,
      minNewCapacity > capacity
         ? _growArrayCapacity(capacity) : capacity)

    return _ContiguousArrayBuffer(
      _uninitializedCount: countForBuffer, minimumCapacity: minimumCapacity)
  }
}
extension _ArrayBufferProtocol {
  @inline(never) @inlinable mutating internal func _arrayOutOfPlaceUpdate(_ dest: inout _ContiguousArrayBuffer<Element>, _ headCount: Int, _ newCount: Int, _ initializeNewElements: ((UnsafeMutablePointer<Element>, _ count: Int) -> ()) = { ptr, count in
      _internalInvariant(count == 0)
    }) {

    _internalInvariant(headCount >= 0)
    _internalInvariant(newCount >= 0)

    // Count of trailing source elements to copy/move
    let sourceCount = self.count
    let tailCount = dest.count - headCount - newCount
    _internalInvariant(headCount + tailCount <= sourceCount)

    let oldCount = sourceCount - headCount - tailCount
    let destStart = dest.firstElementAddress
    let newStart = destStart + headCount
    let newEnd = newStart + newCount

    // Check to see if we have storage we can move from
    if let backing = requestUniqueMutableBackingBuffer(
      minimumCapacity: sourceCount) {

      let sourceStart = firstElementAddress
      let oldStart = sourceStart + headCount

      // Destroy any items that may be lurking in a _SliceBuffer before
      // its real first element
      let backingStart = backing.firstElementAddress
      let sourceOffset = sourceStart - backingStart
      backingStart.deinitialize(count: sourceOffset)

      // Move the head items
      destStart.moveInitialize(from: sourceStart, count: headCount)

      // Destroy unused source items
      oldStart.deinitialize(count: oldCount)

      initializeNewElements(newStart, newCount)

      // Move the tail items
      newEnd.moveInitialize(from: oldStart + oldCount, count: tailCount)

      // Destroy any items that may be lurking in a _SliceBuffer after
      // its real last element
      let backingEnd = backingStart + backing.count
      let sourceEnd = sourceStart + sourceCount
      sourceEnd.deinitialize(count: backingEnd - sourceEnd)
      backing.count = 0
    }
    else {
      let headStart = startIndex
      let headEnd = headStart + headCount
      let newStart = _copyContents(
        subRange: headStart..<headEnd,
        initializing: destStart)
      initializeNewElements(newStart, newCount)
      let tailStart = headEnd + oldCount
      let tailEnd = endIndex
      _copyContents(subRange: tailStart..<tailEnd, initializing: newEnd)
    }
    self = Self(_buffer: dest, shiftedToStartIndex: startIndex)
  }
}
extension _ArrayBufferProtocol {
  @usableFromInline
  @inline(never) mutating internal func _outlinedMakeUniqueBuffer(bufferCount: Int)
  @inlinable mutating internal func _arrayAppendSequence<S>(_ newItems: __owned S) where S : Swift.Sequence, Self.Element == S.Element {
    
    // this function is only ever called from append(contentsOf:)
    // which should always have exhausted its capacity before calling
    _internalInvariant(count == capacity)
    var newCount = self.count

    // there might not be any elements to append remaining,
    // so check for nil element first, then increase capacity,
    // then inner-loop to fill that capacity with elements
    var stream = newItems.makeIterator()
    var nextItem = stream.next()
    while nextItem != nil {

      // grow capacity, first time around and when filled
      var newBuffer = _forceCreateUniqueMutableBuffer(
        countForNewBuffer: newCount, 
        // minNewCapacity handles the exponential growth, just
        // need to request 1 more than current count/capacity
        minNewCapacity: newCount + 1)

      _arrayOutOfPlaceUpdate(&newBuffer, newCount, 0)

      let currentCapacity = self.capacity
      let base = self.firstElementAddress

      // fill while there is another item and spare capacity
      while let next = nextItem, newCount < currentCapacity {
        (base + newCount).initialize(to: next)
        newCount += 1
        nextItem = stream.next()
      }
      self.count = newCount
    }
  }
}
@_fixed_layout public struct ArraySlice<Element> : _DestructorSafeContainer {
  @usableFromInline
  internal typealias _Buffer = _SliceBuffer<Element>
  @usableFromInline
  internal var _buffer: _Buffer
  @inlinable internal init(_buffer: _Buffer) {
    self._buffer = _buffer
  }
  @inlinable internal init(_buffer buffer: _ContiguousArrayBuffer<Element>) {
    self.init(_buffer: _Buffer(_buffer: buffer, shiftedToStartIndex: 0))
  }
}
extension ArraySlice {
  @inlinable @_semantics("array.props.isNativeTypeChecked") public func _hoistableIsNativeTypeChecked() -> Bool {
   return _buffer.arrayPropertyIsNativeTypeChecked
  }
  @inlinable @_semantics("array.get_count") internal func _getCount() -> Int {
    return _buffer.count
  }
  @inlinable @_semantics("array.get_capacity") internal func _getCapacity() -> Int {
    return _buffer.capacity
  }
  @inlinable @_semantics("array.make_mutable") mutating internal func _makeMutableAndUnique() {
    if _slowPath(!_buffer.isMutableAndUniquelyReferenced()) {
      _buffer = _Buffer(copying: _buffer)
    }
  }
  @inlinable @inline(__always) internal func _checkSubscript_native(_ index: Int) {
    _buffer._checkValidSubscript(index)
  }
  @inlinable @_semantics("array.check_subscript") public func _checkSubscript(_ index: Int, wasNativeTypeChecked: Bool) -> _DependenceToken {
    _buffer._checkValidSubscript(index)
    return _DependenceToken()
  }
  @inlinable @_semantics("array.check_index") internal func _checkIndex(_ index: Int) {
    _precondition(index <= endIndex, "ArraySlice index is out of range")
    _precondition(index >= startIndex, "ArraySlice index is out of range (before startIndex)")
  }
  @_semantics("array.get_element") @inlinable @inline(__always) public func _getElement(_ index: Int, wasNativeTypeChecked: Bool, matchingSubscriptCheck: _DependenceToken) -> Element {
    return _buffer.getElement(index)
  }
  @inlinable @_semantics("array.get_element_address") internal func _getElementAddress(_ index: Int) -> UnsafeMutablePointer<Element> {
    return _buffer.subscriptBaseAddress + index
  }
}
extension ArraySlice : _ArrayProtocol {
  @inlinable public var capacity: Int {
    get {
    return _getCapacity()
  }
  }
  @inlinable public var _owner: AnyObject? {
    get {
    return _buffer.owner
  }
  }
  @inlinable public var _baseAddressIfContiguous: UnsafeMutablePointer<Element>? {
    @inline(__always) get { return _buffer.firstElementAddressIfContiguous }
  }
  @inlinable internal var _baseAddress: UnsafeMutablePointer<Element> {
    get {
    return _buffer.firstElementAddress
  }
  }
}
extension ArraySlice : RandomAccessCollection, MutableCollection {
  public typealias Index = Int
  public typealias Indices = Range<Int>
  public typealias Iterator = IndexingIterator<ArraySlice>
  @inlinable public var startIndex: Int {
    get {
    return _buffer.startIndex
  }
  }
  @inlinable public var endIndex: Int {
    get {
    return _buffer.endIndex
  }
  }
  @inlinable public func index(after i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + 1
  }
  @inlinable public func formIndex(after i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i += 1
  }
  @inlinable public func index(before i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i - 1
  }
  @inlinable public func formIndex(before i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i -= 1
  }
  @inlinable public func index(_ i: Int, offsetBy distance: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + distance
  }
  @inlinable public func index(_ i: Int, offsetBy distance: Int, limitedBy limit: Int) -> Int? {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    let l = limit - i
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return i + distance
  }
  @inlinable public func distance(from start: Int, to end: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return end - start
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Int, bounds: Range<Int>) {
    // NOTE: This method is a no-op for performance reasons.
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Range<Int>, bounds: Range<Int>) {
    // NOTE: This method is a no-op for performance reasons.
  }
  @inlinable public subscript(index: Int) -> Element {
    get {
      // This call may be hoisted or eliminated by the optimizer.  If
      // there is an inout violation, this value may be stale so needs to be
      // checked again below.
      let wasNativeTypeChecked = _hoistableIsNativeTypeChecked()

      // Make sure the index is in range and wasNativeTypeChecked is
      // still valid.
      let token = _checkSubscript(
        index, wasNativeTypeChecked: wasNativeTypeChecked)

      return _getElement(
        index, wasNativeTypeChecked: wasNativeTypeChecked,
        matchingSubscriptCheck: token)
    }
    _modify {
      _makeMutableAndUnique() // makes the array native, too
      _checkSubscript_native(index)
      let address = _buffer.subscriptBaseAddress + index
      yield &address.pointee
    }
  }
  @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> {
    get {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      return ArraySlice(_buffer: _buffer[bounds])
    }
    set(rhs) {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      // If the replacement buffer has same identity, and the ranges match,
      // then this was a pinned in-place modification, nothing further needed.
      if self[bounds]._buffer.identity != rhs._buffer.identity
      || bounds != rhs.startIndex..<rhs.endIndex {
        self.replaceSubrange(bounds, with: rhs)
      }
    }
  }
  @inlinable public var count: Int {
    get {
    return _getCount()
  }
  }
  public typealias SubSequence = Swift.ArraySlice<Element>
}
extension ArraySlice : ExpressibleByArrayLiteral {
  @inlinable public init(arrayLiteral elements: Element...) {
    self.init(_buffer: ContiguousArray(elements)._buffer)
  }
  public typealias ArrayLiteralElement = Element
}
extension ArraySlice : RangeReplaceableCollection {
  @inlinable @_semantics("array.init") public init() {
    _buffer = _Buffer()
  }
  @inlinable public init<S>(_ s: S) where Element == S.Element, S : Swift.Sequence {

    self.init(_buffer: s._copyToContiguousArray()._buffer)
  }
  @inlinable @_semantics("array.init") public init(repeating repeatedValue: Element, count: Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = ArraySlice._allocateUninitialized(count)
    for _ in 0..<count {
      p.initialize(to: repeatedValue)
      p += 1
    }
  }
  @usableFromInline
  @inline(never) internal static func _allocateBufferUninitialized(minimumCapacity: Int) -> _Buffer
  @inlinable internal init(_uninitializedCount count: Int) {
    _precondition(count >= 0, "Can't construct ArraySlice with count < 0")
    // Note: Sinking this constructor into an else branch below causes an extra
    // Retain/Release.
    _buffer = _Buffer()
    if count > 0 {
      // Creating a buffer instead of calling reserveCapacity saves doing an
      // unnecessary uniqueness check. We disable inlining here to curb code
      // growth.
      _buffer = ArraySlice._allocateBufferUninitialized(minimumCapacity: count)
      _buffer.count = count
    }
    // Can't store count here because the buffer might be pointing to the
    // shared empty array.
  }
  @inlinable @_semantics("array.uninitialized") internal static func _allocateUninitialized(_ count: Int) -> (ArraySlice, UnsafeMutablePointer<Element>) {
    let result = ArraySlice(_uninitializedCount: count)
    return (result, result._buffer.firstElementAddress)
  }
  @inlinable @_semantics("array.mutate_unknown") mutating public func reserveCapacity(_ minimumCapacity: Int) {
    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: minimumCapacity) == nil {

      let newBuffer = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: count, minimumCapacity: minimumCapacity)

      _buffer._copyContents(
        subRange: _buffer.indices,
        initializing: newBuffer.firstElementAddress)
      _buffer = _Buffer(
        _buffer: newBuffer, shiftedToStartIndex: _buffer.startIndex)
    }
    _internalInvariant(capacity >= minimumCapacity)
  }
  @inline(never) @inlinable mutating internal func _copyToNewBuffer(oldCount: Int) {
    let newCount = oldCount + 1
    var newBuffer = _buffer._forceCreateUniqueMutableBuffer(
      countForNewBuffer: oldCount, minNewCapacity: newCount)
    _buffer._arrayOutOfPlaceUpdate(
      &newBuffer, oldCount, 0)
  }
  @inlinable @_semantics("array.make_mutable") mutating internal func _makeUniqueAndReserveCapacityIfNotUnique() {
    if _slowPath(!_buffer.isMutableAndUniquelyReferenced()) {
      _copyToNewBuffer(oldCount: _buffer.count)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") mutating internal func _reserveCapacityAssumingUniqueBuffer(oldCount: Int) {
    // This is a performance optimization. This code used to be in an ||
    // statement in the _internalInvariant below.
    //
    //   _internalInvariant(_buffer.capacity == 0 ||
    //                _buffer.isMutableAndUniquelyReferenced())
    //
    // SR-6437
    let capacity = _buffer.capacity == 0

    // Due to make_mutable hoisting the situation can arise where we hoist
    // _makeMutableAndUnique out of loop and use it to replace
    // _makeUniqueAndReserveCapacityIfNotUnique that preceeds this call. If the
    // array was empty _makeMutableAndUnique does not replace the empty array
    // buffer by a unique buffer (it just replaces it by the empty array
    // singleton).
    // This specific case is okay because we will make the buffer unique in this
    // function because we request a capacity > 0 and therefore _copyToNewBuffer
    // will be called creating a new buffer.
    _internalInvariant(capacity ||
                 _buffer.isMutableAndUniquelyReferenced())

    if _slowPath(oldCount + 1 > _buffer.capacity) {
      _copyToNewBuffer(oldCount: oldCount)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") mutating internal func _appendElementAssumeUniqueAndCapacity(_ oldCount: Int, newElement: __owned Element) {
    _internalInvariant(_buffer.isMutableAndUniquelyReferenced())
    _internalInvariant(_buffer.capacity >= _buffer.count + 1)

    _buffer.count = oldCount + 1
    (_buffer.firstElementAddress + oldCount).initialize(to: newElement)
  }
  @inlinable @_semantics("array.append_element") mutating public func append(_ newElement: __owned Element) {
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _getCount()
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
  }
  @inlinable @_semantics("array.append_contentsOf") mutating public func append<S>(contentsOf newElements: __owned S) where Element == S.Element, S : Swift.Sequence {

    let newElementsCount = newElements.underestimatedCount
    reserveCapacityForAppend(newElementsCount: newElementsCount)

    let oldCount = self.count
    let startNewElements = _buffer.firstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements, 
                count: self.capacity - oldCount)

    let (remainder,writtenUpTo) = buf.initialize(from: newElements)
    
    // trap on underflow from the sequence's underestimate:
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    _precondition(newElementsCount <= writtenCount, 
      "newElements.underestimatedCount was an overestimate")
    // can't check for overflow as sequences can underestimate

    _buffer.count += writtenCount

    if writtenUpTo == buf.endIndex {
      // there may be elements that didn't fit in the existing buffer,
      // append them in slow sequence-only mode
      _buffer._arrayAppendSequence(IteratorSequence(remainder))
    }
  }
  @inlinable @_semantics("array.reserve_capacity_for_append") mutating internal func reserveCapacityForAppend(newElementsCount: Int) {
    let oldCount = self.count
    let oldCapacity = self.capacity
    let newCount = oldCount + newElementsCount

    // Ensure uniqueness, mutability, and sufficient storage.  Note that
    // for consistency, we need unique self even if newElements is empty.
    self.reserveCapacity(
      newCount > oldCapacity ?
      Swift.max(newCount, _growArrayCapacity(oldCapacity))
      : newCount)
  }
  @inlinable mutating public func _customRemoveLast() -> Element? {
    _precondition(count > 0, "Can't removeLast from an empty ArraySlice")
    // FIXME(performance): if `self` is uniquely referenced, we should remove
    // the element as shown below (this will deallocate the element and
    // decrease memory use).  If `self` is not uniquely referenced, the code
    // below will make a copy of the storage, which is wasteful.  Instead, we
    // should just shrink the view without allocating new storage.
    let i = endIndex
    // We don't check for overflow in `i - 1` because `i` is known to be
    // positive.
    let result = self[i &- 1]
    self.replaceSubrange((i &- 1)..<i, with: EmptyCollection())
    return result
  }
  @discardableResult
  @inlinable mutating public func remove(at index: Int) -> Element {
    let result = self[index]
    self.replaceSubrange(index..<(index + 1), with: EmptyCollection())
    return result
  }
  @inlinable mutating public func insert(_ newElement: __owned Element, at i: Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
  @inlinable mutating public func removeAll(keepingCapacity keepCapacity: Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
  }
  @inlinable mutating public func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable mutating public func withContiguousMutableStorageIfAvailable<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeBufferPointer {
      (bufferPointer) -> R in
      return try body(bufferPointer)
    }
  }
  @inlinable __consuming public func _copyToContiguousArray() -> ContiguousArray<Element> {
    if let n = _buffer.requestNativeBuffer() {
      return ContiguousArray(_buffer: n)
    }
    return _copyCollectionToContiguousArray(self)
  }
}
extension ArraySlice : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension ArraySlice : CustomStringConvertible, CustomDebugStringConvertible {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
}
extension ArraySlice {
  @usableFromInline
  @_transparent internal func _cPointerArgs() -> (AnyObject?, UnsafeRawPointer?) {
    let p = _baseAddressIfContiguous
    if _fastPath(p != nil || isEmpty) {
      return (_owner, UnsafeRawPointer(p))
    }
    let n = ContiguousArray(self._buffer)._buffer
    return (n.owner, UnsafeRawPointer(n.firstElementAddress))
  }
}
extension ArraySlice {
  @inlinable public func withUnsafeBufferPointer<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
  @_semantics("array.withUnsafeMutableBufferPointer") @inlinable @inline(__always) mutating public func withUnsafeMutableBufferPointer<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    let count = self.count
    // Ensure unique storage
    _buffer._outlinedMakeUniqueBuffer(bufferCount: count)

    // Ensure that body can't invalidate the storage or its bounds by
    // moving self into a temporary working array.
    // NOTE: The stack promotion optimization that keys of the
    // "array.withUnsafeMutableBufferPointer" semantics annotation relies on the
    // array buffer not being able to escape in the closure. It can do this
    // because we swap the array buffer in self with an empty buffer here. Any
    // escape via the address of self in the closure will therefore escape the
    // empty array.

    var work = ArraySlice()
    (work, self) = (self, work)

    // Create an UnsafeBufferPointer over work that we can pass to body
    let pointer = work._buffer.firstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    // Put the working array back before returning.
    defer {
      _precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "ArraySlice withUnsafeMutableBufferPointer: replacing the buffer is not allowed")

      (work, self) = (self, work)
    }

    // Invoke the body.
    return try body(&inoutBufferPointer)
  }
  @inlinable __consuming public func _copyContents(initializing buffer: UnsafeMutableBufferPointer<Element>) -> (Iterator, UnsafeMutableBufferPointer<Element>.Index) {

    guard !self.isEmpty else { return (makeIterator(),buffer.startIndex) }

    // It is not OK for there to be no pointer/not enough space, as this is
    // a precondition and Array never lies about its count.
    guard var p = buffer.baseAddress
      else { _preconditionFailure("Attempt to copy contents into nil buffer pointer") }
    _precondition(self.count <= buffer.count, 
      "Insufficient space allocated to copy array contents")

    if let s = _baseAddressIfContiguous {
      p.initialize(from: s, count: self.count)
      // Need a _fixLifetime bracketing the _baseAddressIfContiguous getter
      // and all uses of the pointer it returns:
      _fixLifetime(self._owner)
    } else {
      for x in self {
        p.initialize(to: x)
        p += 1
      }
    }

    var it = IndexingIterator(_elements: self)
    it._position = endIndex
    return (it,buffer.index(buffer.startIndex, offsetBy: self.count))
  }
}
extension ArraySlice {
  @inlinable @_semantics("array.mutate_unknown") mutating public func replaceSubrange<C>(_ subrange: Range<Int>, with newElements: __owned C) where Element == C.Element, C : Swift.Collection {
    _precondition(subrange.lowerBound >= _buffer.startIndex,
      "ArraySlice replace: subrange start is before the startIndex")

    _precondition(subrange.upperBound <= _buffer.endIndex,
      "ArraySlice replace: subrange extends past the end")

    let oldCount = _buffer.count
    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: oldCount + growth) != nil {

      _buffer.replaceSubrange(
        subrange, with: insertCount, elementsOf: newElements)
    } else {
      _buffer._arrayOutOfPlaceReplace(subrange, with: newElements, count: insertCount)
    }
  }
}
extension ArraySlice : Equatable where Element : Swift.Equatable {
  @inlinable public static func == (lhs: ArraySlice<Element>, rhs: ArraySlice<Element>) -> Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

    // Test referential equality.
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    var streamLHS = lhs.makeIterator()
    var streamRHS = rhs.makeIterator()

    var nextLHS = streamLHS.next()
    while nextLHS != nil {
      let nextRHS = streamRHS.next()
      if nextLHS != nextRHS {
        return false
      }
      nextLHS = streamLHS.next()
    }


    return true
  }
}
extension ArraySlice : Hashable where Element : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine(count) // discriminator
    for element in self {
      hasher.combine(element)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension ArraySlice {
  @inlinable mutating public func withUnsafeMutableBytes<R>(_ body: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeMutableBufferPointer {
      return try body(UnsafeMutableRawBufferPointer($0))
    }
  }
  @inlinable public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeBufferPointer {
      try body(UnsafeRawBufferPointer($0))
    }
  }
}
extension ArraySlice {
  @inlinable public init(_startIndex: Int) {
    self.init(
      _buffer: _Buffer(
        _buffer: ContiguousArray()._buffer,
        shiftedToStartIndex: _startIndex))
  }
}
@usableFromInline
internal protocol _ArrayProtocol : Swift.ExpressibleByArrayLiteral, Swift.RangeReplaceableCollection where Self.Indices == Swift.Range<Swift.Int> {
  var capacity: Int { get }
  var _owner: AnyObject? { get }
  var _baseAddressIfContiguous: UnsafeMutablePointer<Element>? { get }
  override mutating func reserveCapacity(_ minimumCapacity: Int)
  override mutating func insert(_ newElement: __owned Element, at i: Int)
  @discardableResult
  override mutating func remove(at index: Int) -> Element
  associatedtype _Buffer : Swift._ArrayBufferProtocol where Self.Element == Self._Buffer.Element
  init(_ buffer: _Buffer)
  var _buffer: _Buffer { get }
}
extension _ArrayProtocol {
  @inlinable __consuming public func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element] {
    return try _filter(isIncluded)
  }
}
extension Unicode {
  @_frozen public enum ASCII {
  }
}
extension Unicode.ASCII : Unicode.Encoding {
  public typealias CodeUnit = UInt8
  public typealias EncodedScalar = CollectionOfOne<CodeUnit>
  @inlinable public static var encodedReplacementCharacter: EncodedScalar {
    get {
    return EncodedScalar(0x1a) // U+001A SUBSTITUTE; best we can do for ASCII
  }
  }
  @_alwaysEmitIntoClient public static func isASCII(_ x: CodeUnit) -> Bool { return UTF8.isASCII(x) }
  @inline(__always) @inlinable public static func _isScalar(_ x: CodeUnit) -> Bool {
    return true
  }
  @inline(__always) @inlinable public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {
    return Unicode.Scalar(_unchecked: UInt32(
        source.first._unsafelyUnwrappedUnchecked))
  }
  @inline(__always) @inlinable public static func encode(_ source: Unicode.Scalar) -> EncodedScalar? {
    guard source.value < (1&<<7) else { return nil }
    return EncodedScalar(UInt8(truncatingIfNeeded: source.value))
  }
  @inline(__always) @inlinable public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> EncodedScalar? where FromEncoding : Swift._UnicodeEncoding {
    if _fastPath(FromEncoding.self == UTF16.self) {
      let c = _identityCast(content, to: UTF16.EncodedScalar.self)
      guard (c._storage & 0xFF80 == 0) else { return nil }
      return EncodedScalar(CodeUnit(c._storage & 0x7f))
    }
    else if _fastPath(FromEncoding.self == UTF8.self) {
      let c = _identityCast(content, to: UTF8.EncodedScalar.self)
      let first = c.first.unsafelyUnwrapped
      guard (first < 0x80) else { return nil }
      return EncodedScalar(CodeUnit(first))
    }
    return encode(FromEncoding.decode(content))
  }
  @_fixed_layout public struct Parser {
    @inlinable public init() { }
  }
  public typealias ForwardParser = Parser
  public typealias ReverseParser = Parser
}
extension Unicode.ASCII.Parser : Unicode.Parser {
  public typealias Encoding = Unicode.ASCII
  @inlinable mutating public func parseScalar<I>(from input: inout I) -> Unicode.ParseResult<Encoding.EncodedScalar> where I : Swift.IteratorProtocol, I.Element == Swift.Unicode.ASCII.Parser.Encoding.CodeUnit {
    let n = input.next()
    if _fastPath(n != nil), let x = n {
      guard _fastPath(Int8(truncatingIfNeeded: x) >= 0)
      else { return .error(length: 1) }
      return .valid(Unicode.ASCII.EncodedScalar(x))
    }
    return .emptyInput
  }
}
@_transparent public func assert(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = String(), file: StaticString = #file, line: UInt = #line) {
  // Only assert in debug mode.
  if _isDebugAssertConfiguration() {
    if !_branchHint(condition(), expected: true) {
      _assertionFailure("Assertion failed", message(), file: file, line: line,
        flags: _fatalErrorFlags())
    }
  }
}
@_transparent public func precondition(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = String(), file: StaticString = #file, line: UInt = #line) {
  // Only check in debug and release mode. In release mode just trap.
  if _isDebugAssertConfiguration() {
    if !_branchHint(condition(), expected: true) {
      _assertionFailure("Precondition failed", message(), file: file, line: line,
        flags: _fatalErrorFlags())
    }
  } else if _isReleaseAssertConfiguration() {
    let error = !condition()
    Builtin.condfail(error._value)
  }
}
@inlinable @inline(__always) public func assertionFailure(_ message: @autoclosure () -> String = String(), file: StaticString = #file, line: UInt = #line) {
  if _isDebugAssertConfiguration() {
    _assertionFailure("Fatal error", message(), file: file, line: line,
      flags: _fatalErrorFlags())
  }
  else if _isFastAssertConfiguration() {
    _conditionallyUnreachable()
  }
}
@_transparent public func preconditionFailure(_ message: @autoclosure () -> String = String(), file: StaticString = #file, line: UInt = #line) -> Never {
  // Only check in debug and release mode.  In release mode just trap.
  if _isDebugAssertConfiguration() {
    _assertionFailure("Fatal error", message(), file: file, line: line,
      flags: _fatalErrorFlags())
  } else if _isReleaseAssertConfiguration() {
    Builtin.int_trap()
  }
  _conditionallyUnreachable()
}
@_transparent public func fatalError(_ message: @autoclosure () -> String = String(), file: StaticString = #file, line: UInt = #line) -> Never {
  _assertionFailure("Fatal error", message(), file: file, line: line,
    flags: _fatalErrorFlags())
}
@usableFromInline
@_transparent internal func _precondition(_ condition: @autoclosure () -> Bool, _ message: StaticString = StaticString(), file: StaticString = #file, line: UInt = #line) {
  // Only check in debug and release mode. In release mode just trap.
  if _isDebugAssertConfiguration() {
    if !_branchHint(condition(), expected: true) {
      _fatalErrorMessage("Fatal error", message, file: file, line: line,
        flags: _fatalErrorFlags())
    }
  } else if _isReleaseAssertConfiguration() {
    let error = !condition()
    Builtin.condfail(error._value)
  }
}
@usableFromInline
@_transparent internal func _preconditionFailure(_ message: StaticString = StaticString(), file: StaticString = #file, line: UInt = #line) -> Never {
  _precondition(false, message, file: file, line: line)
  _conditionallyUnreachable()
}
@_transparent public func _overflowChecked<T>(_ args: (T, Bool), file: StaticString = #file, line: UInt = #line) -> T {
  let (result, error) = args
  if _isDebugAssertConfiguration() {
    if _branchHint(error, expected: false) {
      _fatalErrorMessage("Fatal error", "Overflow/underflow", 
        file: file, line: line, flags: _fatalErrorFlags())
    }
  } else {
    Builtin.condfail(error._value)
  }
  return result
}
@usableFromInline
@_transparent internal func _debugPrecondition(_ condition: @autoclosure () -> Bool, _ message: StaticString = StaticString(), file: StaticString = #file, line: UInt = #line) {
  // Only check in debug mode.
  if _slowPath(_isDebugAssertConfiguration()) {
    if !_branchHint(condition(), expected: true) {
      _fatalErrorMessage("Fatal error", message, file: file, line: line,
        flags: _fatalErrorFlags())
    }
  }
}
@usableFromInline
@_transparent internal func _debugPreconditionFailure(_ message: StaticString = StaticString(), file: StaticString = #file, line: UInt = #line) -> Never {
  if _slowPath(_isDebugAssertConfiguration()) {
    _precondition(false, message, file: file, line: line)
  }
  _conditionallyUnreachable()
}
@usableFromInline
@_transparent internal func _internalInvariant(_ condition: @autoclosure () -> Bool, _ message: StaticString = StaticString(), file: StaticString = #file, line: UInt = #line) {
}
@usableFromInline
@_transparent internal func _internalInvariantFailure(_ message: StaticString = StaticString(), file: StaticString = #file, line: UInt = #line) -> Never {
  _internalInvariant(false, message, file: file, line: line)
  _conditionallyUnreachable()
}
@_transparent public func _isDebugAssertConfiguration() -> Bool {
  // The values for the assert_configuration call are:
  // 0: Debug
  // 1: Release
  // 2: Fast
  return Int32(Builtin.assert_configuration()) == 0
}
@usableFromInline
@_transparent internal func _isReleaseAssertConfiguration() -> Bool {
  // The values for the assert_configuration call are:
  // 0: Debug
  // 1: Release
  // 2: Fast
  return Int32(Builtin.assert_configuration()) == 1
}
@_transparent public func _isFastAssertConfiguration() -> Bool {
  // The values for the assert_configuration call are:
  // 0: Debug
  // 1: Release
  // 2: Fast
  return Int32(Builtin.assert_configuration()) == 2
}
@_transparent public func _isStdlibInternalChecksEnabled() -> Bool {
  return false
}
@usableFromInline
@_transparent internal func _fatalErrorFlags() -> UInt32 {
  // The current flags are:
  // (1 << 0): Report backtrace on fatal error
  return _isDebugAssertConfiguration() ? 1 : 0
}
@usableFromInline
@inline(never) @_semantics("programtermination_point") internal func _assertionFailure(_ prefix: StaticString, _ message: StaticString, file: StaticString, line: UInt, flags: UInt32) -> Never
@usableFromInline
@inline(never) @_semantics("programtermination_point") internal func _assertionFailure(_ prefix: StaticString, _ message: String, file: StaticString, line: UInt, flags: UInt32) -> Never
@usableFromInline
@inline(never) @_semantics("programtermination_point") internal func _assertionFailure(_ prefix: StaticString, _ message: String, flags: UInt32) -> Never
@usableFromInline
@inline(never) @_semantics("programtermination_point") internal func _fatalErrorMessage(_ prefix: StaticString, _ message: StaticString, file: StaticString, line: UInt, flags: UInt32) -> Never
@_transparent public func _unimplementedInitializer(className: StaticString, initName: StaticString = #function, file: StaticString = #file, line: UInt = #line, column: UInt = #column) -> Never {
  // This function is marked @_transparent so that it is inlined into the caller
  // (the initializer stub), and, depending on the build configuration,
  // redundant parameter values (#file etc.) are eliminated, and don't leak
  // information about the user's source.

  if _isDebugAssertConfiguration() {
    className.withUTF8Buffer {
      (className) in
      initName.withUTF8Buffer {
        (initName) in
        file.withUTF8Buffer {
          (file) in
          _swift_stdlib_reportUnimplementedInitializerInFile(
            className.baseAddress!, CInt(className.count),
            initName.baseAddress!, CInt(initName.count),
            file.baseAddress!, CInt(file.count),
            UInt32(line), UInt32(column),
            /*flags:*/ 0)
        }
      }
    }
  } else {
    className.withUTF8Buffer {
      (className) in
      initName.withUTF8Buffer {
        (initName) in
        _swift_stdlib_reportUnimplementedInitializer(
          className.baseAddress!, CInt(className.count),
          initName.baseAddress!, CInt(initName.count),
          /*flags:*/ 0)
      }
    }
  }

  Builtin.int_trap()
}
public func _undefined<T>(_ message: @autoclosure () -> String = String(), file: StaticString = #file, line: UInt = #line) -> T
@usableFromInline
@inline(never) internal func _diagnoseUnexpectedEnumCaseValue<SwitchedValue, RawValue>(type: SwitchedValue.Type, rawValue: RawValue) -> Never
@usableFromInline
@inline(never) internal func _diagnoseUnexpectedEnumCase<SwitchedValue>(type: SwitchedValue.Type) -> Never
@available(swift, deprecated: 4.2, obsoleted: 5.0)
@_objcRuntimeName(_TtCs18__stdlib_AtomicInt) final public class _stdlib_AtomicInt {
  public init(_ value: Int = 0)
  final public func store(_ desired: Int)
  final public func load() -> Int
  @discardableResult
  final public func fetchAndAdd(_ operand: Int) -> Int
  final public func addAndFetch(_ operand: Int) -> Int
  @discardableResult
  final public func fetchAndAnd(_ operand: Int) -> Int
  final public func andAndFetch(_ operand: Int) -> Int
  @discardableResult
  final public func fetchAndOr(_ operand: Int) -> Int
  final public func orAndFetch(_ operand: Int) -> Int
  @discardableResult
  final public func fetchAndXor(_ operand: Int) -> Int
  final public func xorAndFetch(_ operand: Int) -> Int
  final public func compareExchange(expected: inout Int, desired: Int) -> Bool
  @objc deinit
}
@usableFromInline
internal func _swift_stdlib_atomicCompareExchangeStrongInt(object target: UnsafeMutablePointer<Int>, expected: UnsafeMutablePointer<Int>, desired: Int) -> Bool
public func _swift_stdlib_atomicLoadInt(object target: UnsafeMutablePointer<Int>) -> Int
@usableFromInline
internal func _swift_stdlib_atomicStoreInt(object target: UnsafeMutablePointer<Int>, desired: Int)
public func _swift_stdlib_atomicFetchAddInt(object target: UnsafeMutablePointer<Int>, operand: Int) -> Int
@usableFromInline
internal func _swift_stdlib_atomicFetchAddInt32(object target: UnsafeMutablePointer<Int32>, operand: Int32) -> Int32
@usableFromInline
internal func _swift_stdlib_atomicFetchAddInt64(object target: UnsafeMutablePointer<Int64>, operand: Int64) -> Int64
public func _swift_stdlib_atomicFetchAndInt(object target: UnsafeMutablePointer<Int>, operand: Int) -> Int
@usableFromInline
internal func _swift_stdlib_atomicFetchAndInt32(object target: UnsafeMutablePointer<Int32>, operand: Int32) -> Int32
@usableFromInline
internal func _swift_stdlib_atomicFetchAndInt64(object target: UnsafeMutablePointer<Int64>, operand: Int64) -> Int64
public func _swift_stdlib_atomicFetchOrInt(object target: UnsafeMutablePointer<Int>, operand: Int) -> Int
@usableFromInline
internal func _swift_stdlib_atomicFetchOrInt32(object target: UnsafeMutablePointer<Int32>, operand: Int32) -> Int32
@usableFromInline
internal func _swift_stdlib_atomicFetchOrInt64(object target: UnsafeMutablePointer<Int64>, operand: Int64) -> Int64
public func _swift_stdlib_atomicFetchXorInt(object target: UnsafeMutablePointer<Int>, operand: Int) -> Int
@usableFromInline
internal func _swift_stdlib_atomicFetchXorInt32(object target: UnsafeMutablePointer<Int32>, operand: Int32) -> Int32
@usableFromInline
internal func _swift_stdlib_atomicFetchXorInt64(object target: UnsafeMutablePointer<Int64>, operand: Int64) -> Int64
public protocol BidirectionalCollection : Swift.Collection where Self.Indices : Swift.BidirectionalCollection, Self.SubSequence : Swift.BidirectionalCollection {
  override associatedtype Element
  override associatedtype Index
  override associatedtype SubSequence
  override associatedtype Indices
  func index(before i: Index) -> Index
  func formIndex(before i: inout Index)
  override func index(after i: Index) -> Index
  override func formIndex(after i: inout Index)
  @_nonoverride func index(_ i: Index, offsetBy distance: Int) -> Index
  @_nonoverride func index(_ i: Index, offsetBy distance: Int, limitedBy limit: Index) -> Index?
  @_nonoverride func distance(from start: Index, to end: Index) -> Int
  override var indices: Indices { get }
  override subscript(bounds: Range<Index>) -> SubSequence { get }
  @_borrowed override subscript(position: Index) -> Element { get }
  override var startIndex: Index { get }
  override var endIndex: Index { get }
}
extension BidirectionalCollection {
  @inlinable @inline(__always) public func formIndex(before i: inout Index) {
    i = index(before: i)
  }
  @inlinable public func index(_ i: Index, offsetBy distance: Int) -> Index {
    return _index(i, offsetBy: distance)
  }
  @inlinable internal func _index(_ i: Index, offsetBy distance: Int) -> Index {
    if distance >= 0 {
      return _advanceForward(i, by: distance)
    }
    var i = i
    for _ in stride(from: 0, to: distance, by: -1) {
      formIndex(before: &i)
    }
    return i
  }
  @inlinable public func index(_ i: Index, offsetBy distance: Int, limitedBy limit: Index) -> Index? {
    return _index(i, offsetBy: distance, limitedBy: limit)
  }
  @inlinable internal func _index(_ i: Index, offsetBy distance: Int, limitedBy limit: Index) -> Index? {
    if distance >= 0 {
      return _advanceForward(i, by: distance, limitedBy: limit)
    }
    var i = i
    for _ in stride(from: 0, to: distance, by: -1) {
      if i == limit {
        return nil
      }
      formIndex(before: &i)
    }
    return i
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    return _distance(from: start, to: end)
  }
  @inlinable internal func _distance(from start: Index, to end: Index) -> Int {
    var start = start
    var count = 0

    if start < end {
      while start != end {
        count += 1
        formIndex(after: &start)
      }
    }
    else if start > end {
      while start != end {
        count -= 1
        formIndex(before: &start)
      }
    }

    return count
  }
}
extension BidirectionalCollection where Self == Self.SubSequence {
  @inlinable mutating public func popLast() -> Element? {
    guard !isEmpty else { return nil }
    let element = last!
    self = self[startIndex..<index(before: endIndex)]
    return element
  }
  @discardableResult
  @inlinable mutating public func removeLast() -> Element {
    let element = last!
    self = self[startIndex..<index(before: endIndex)]
    return element
  }
  @inlinable mutating public func removeLast(_ k: Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    _precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    self = self[startIndex..<index(endIndex, offsetBy: -k)]
  }
}
extension BidirectionalCollection {
  @inlinable __consuming public func dropLast(_ k: Int) -> SubSequence {
    _precondition(
      k >= 0, "Can't drop a negative number of elements from a collection")
    let end = index(
      endIndex,
      offsetBy: -k,
      limitedBy: startIndex) ?? startIndex
    return self[startIndex..<end]
  }
  @inlinable __consuming public func suffix(_ maxLength: Int) -> SubSequence {
    _precondition(
      maxLength >= 0,
      "Can't take a suffix of negative length from a collection")
    let start = index(
      endIndex,
      offsetBy: -maxLength,
      limitedBy: startIndex) ?? startIndex
    return self[start..<endIndex]
  }
}
@usableFromInline
@_fixed_layout internal struct _UnsafeBitset {
  @usableFromInline
  internal let words: UnsafeMutablePointer<Word>
  @usableFromInline
  internal let wordCount: Int
  @inlinable @inline(__always) internal init(words: UnsafeMutablePointer<Word>, wordCount: Int) {
    self.words = words
    self.wordCount = wordCount
  }
}
extension _UnsafeBitset {
  @inlinable @inline(__always) internal static func word(for element: Int) -> Int {
    _internalInvariant(element >= 0)
    // Note: We perform on UInts to get faster unsigned math (shifts).
    let element = UInt(bitPattern: element)
    let capacity = UInt(bitPattern: Word.capacity)
    return Int(bitPattern: element / capacity)
  }
  @inlinable @inline(__always) internal static func bit(for element: Int) -> Int {
    _internalInvariant(element >= 0)
    // Note: We perform on UInts to get faster unsigned math (masking).
    let element = UInt(bitPattern: element)
    let capacity = UInt(bitPattern: Word.capacity)
    return Int(bitPattern: element % capacity)
  }
  @inlinable @inline(__always) internal static func split(_ element: Int) -> (word: Int, bit: Int) {
    return (word(for: element), bit(for: element))
  }
  @inlinable @inline(__always) internal static func join(word: Int, bit: Int) -> Int {
    _internalInvariant(bit >= 0 && bit < Word.capacity)
    return word &* Word.capacity &+ bit
  }
}
extension _UnsafeBitset {
  @inlinable @inline(__always) internal static func wordCount(forCapacity capacity: Int) -> Int {
    return word(for: capacity &+ Word.capacity &- 1)
  }
  @inlinable internal var capacity: Int {
    @inline(__always) get {
      return wordCount &* Word.capacity
    }
  }
  @inlinable @inline(__always) internal func isValid(_ element: Int) -> Bool {
    return element >= 0 && element <= capacity
  }
  @inlinable @inline(__always) internal func uncheckedContains(_ element: Int) -> Bool {
    _internalInvariant(isValid(element))
    let (word, bit) = _UnsafeBitset.split(element)
    return words[word].uncheckedContains(bit)
  }
  @discardableResult
  @inlinable @inline(__always) internal func uncheckedInsert(_ element: Int) -> Bool {
    _internalInvariant(isValid(element))
    let (word, bit) = _UnsafeBitset.split(element)
    return words[word].uncheckedInsert(bit)
  }
  @discardableResult
  @inlinable @inline(__always) internal func uncheckedRemove(_ element: Int) -> Bool {
    _internalInvariant(isValid(element))
    let (word, bit) = _UnsafeBitset.split(element)
    return words[word].uncheckedRemove(bit)
  }
  @inlinable @inline(__always) internal func clear() {
    words.assign(repeating: .empty, count: wordCount)
  }
}
extension _UnsafeBitset : Sequence {
  @usableFromInline
  internal typealias Element = Int
  @inlinable internal var count: Int {
    get {
    var count = 0
    for w in 0 ..< wordCount {
      count += words[w].count
    }
    return count
  }
  }
  @inlinable internal var underestimatedCount: Int {
    get {
    return count
  }
  }
  @inlinable internal func makeIterator() -> Iterator {
    return Iterator(self)
  }
  @usableFromInline
  @_fixed_layout internal struct Iterator : IteratorProtocol {
    @usableFromInline
    internal let bitset: _UnsafeBitset
    @usableFromInline
    internal var index: Int
    @usableFromInline
    internal var word: Word
    @inlinable internal init(_ bitset: _UnsafeBitset) {
      self.bitset = bitset
      self.index = 0
      self.word = bitset.wordCount > 0 ? bitset.words[0] : .empty
    }
    @inlinable mutating internal func next() -> Int? {
      if let bit = word.next() {
        return _UnsafeBitset.join(word: index, bit: bit)
      }
      while (index + 1) < bitset.wordCount {
        index += 1
        word = bitset.words[index]
        if let bit = word.next() {
          return _UnsafeBitset.join(word: index, bit: bit)
        }
      }
      return nil
    }
    @usableFromInline
    internal typealias Element = Swift.Int
  }
}
extension _UnsafeBitset {
  @usableFromInline
  @_fixed_layout internal struct Word {
    @usableFromInline
    internal var value: UInt
    @inlinable internal init(_ value: UInt) {
      self.value = value
    }
  }
}
extension _UnsafeBitset.Word {
  @inlinable internal static var capacity: Int {
    @inline(__always) get {
      return UInt.bitWidth
    }
  }
  @inlinable @inline(__always) internal func uncheckedContains(_ bit: Int) -> Bool {
    _internalInvariant(bit >= 0 && bit < UInt.bitWidth)
    return value & (1 &<< bit) != 0
  }
  @discardableResult
  @inlinable @inline(__always) mutating internal func uncheckedInsert(_ bit: Int) -> Bool {
    _internalInvariant(bit >= 0 && bit < UInt.bitWidth)
    let mask: UInt = 1 &<< bit
    let inserted = value & mask == 0
    value |= mask
    return inserted
  }
  @discardableResult
  @inlinable @inline(__always) mutating internal func uncheckedRemove(_ bit: Int) -> Bool {
    _internalInvariant(bit >= 0 && bit < UInt.bitWidth)
    let mask: UInt = 1 &<< bit
    let removed = value & mask != 0
    value &= ~mask
    return removed
  }
}
extension _UnsafeBitset.Word {
  @inlinable internal var minimum: Int? {
    @inline(__always) get {
      guard value != 0 else { return nil }
      return value.trailingZeroBitCount
    }
  }
  @inlinable internal var maximum: Int? {
    @inline(__always) get {
      guard value != 0 else { return nil }
      return _UnsafeBitset.Word.capacity &- 1 &- value.leadingZeroBitCount
    }
  }
  @inlinable internal var complement: _UnsafeBitset.Word {
    @inline(__always) get {
      return _UnsafeBitset.Word(~value)
    }
  }
  @inlinable @inline(__always) internal func subtracting(elementsBelow bit: Int) -> _UnsafeBitset.Word {
    _internalInvariant(bit >= 0 && bit < _UnsafeBitset.Word.capacity)
    let mask = UInt.max &<< bit
    return _UnsafeBitset.Word(value & mask)
  }
  @inlinable @inline(__always) internal func intersecting(elementsBelow bit: Int) -> _UnsafeBitset.Word {
    _internalInvariant(bit >= 0 && bit < _UnsafeBitset.Word.capacity)
    let mask: UInt = (1 as UInt &<< bit) &- 1
    return _UnsafeBitset.Word(value & mask)
  }
  @inlinable @inline(__always) internal func intersecting(elementsAbove bit: Int) -> _UnsafeBitset.Word {
    _internalInvariant(bit >= 0 && bit < _UnsafeBitset.Word.capacity)
    let mask = (UInt.max &<< bit) &<< 1
    return _UnsafeBitset.Word(value & mask)
  }
}
extension _UnsafeBitset.Word {
  @inlinable internal static var empty: _UnsafeBitset.Word {
    @inline(__always) get {
      return _UnsafeBitset.Word(0)
    }
  }
  @inlinable internal static var allBits: _UnsafeBitset.Word {
    @inline(__always) get {
      return _UnsafeBitset.Word(UInt.max)
    }
  }
}
extension _UnsafeBitset.Word : Sequence, IteratorProtocol {
  @inlinable internal var count: Int {
    get {
    return value.nonzeroBitCount
  }
  }
  @inlinable internal var underestimatedCount: Int {
    get {
    return count
  }
  }
  @inlinable internal var isEmpty: Bool {
    @inline(__always) get {
      return value == 0
    }
  }
  @inlinable mutating internal func next() -> Int? {
    guard value != 0 else { return nil }
    let bit = value.trailingZeroBitCount
    value &= value &- 1       // Clear lowest nonzero bit.
    return bit
  }
  @usableFromInline
  internal typealias Element = Swift.Int
  @usableFromInline
  internal typealias Iterator = Swift._UnsafeBitset.Word
}
@_fixed_layout public struct Bool {
  @usableFromInline
  internal var _value: Builtin.Int1
  @_transparent public init() {
    let zero: Int8 = 0
    self._value = Builtin.trunc_Int8_Int1(zero._value)
  }
  @usableFromInline
  @_transparent internal init(_ v: Builtin.Int1) { self._value = v }
  @inlinable public init(_ value: Bool) {
    self = value
  }
  @inlinable public static func random<T>(using generator: inout T) -> Bool where T : Swift.RandomNumberGenerator {
    return (generator.next() >> 17) & 1 == 0
  }
  @inlinable public static func random() -> Bool {
    var g = SystemRandomNumberGenerator()
    return Bool.random(using: &g)
  }
}
extension Bool : _ExpressibleByBuiltinBooleanLiteral, ExpressibleByBooleanLiteral {
  @_transparent public init(_builtinBooleanLiteral value: Builtin.Int1) {
    self._value = value
  }
  @_transparent public init(booleanLiteral value: Bool) {
    self = value
  }
  public typealias BooleanLiteralType = Swift.Bool
}
extension Bool : CustomStringConvertible {
  @inlinable public var description: String {
    get {
    return self ? "true" : "false"
  }
  }
}
extension Bool : Equatable {
  @_transparent public static func == (lhs: Bool, rhs: Bool) -> Bool {
    return Bool(Builtin.cmp_eq_Int1(lhs._value, rhs._value))
  }
}
extension Bool : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine((self ? 1 : 0) as UInt8)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Bool : LosslessStringConvertible {
  @inlinable public init?(_ description: String) {
    if description == "true" {
      self = true
    } else if description == "false" {
      self = false
    } else {
      return nil
    }
  }
}
extension Bool {
  @_transparent prefix public static func ! (a: Bool) -> Bool {
    return Bool(Builtin.xor_Int1(a._value, true._value))
  }
}
extension Bool {
  @_transparent @inline(__always) public static func && (lhs: Bool, rhs: @autoclosure () throws -> Bool) rethrows -> Bool {
    return lhs ? try rhs() : false
  }
  @_transparent @inline(__always) public static func || (lhs: Bool, rhs: @autoclosure () throws -> Bool) rethrows -> Bool {
    return lhs ? true : try rhs()
  }
}
extension Bool {
  @inlinable mutating public func toggle() {
    self = !self
  }
}
public protocol _ObjectiveCBridgeable {
  associatedtype _ObjectiveCType : AnyObject
  func _bridgeToObjectiveC() -> _ObjectiveCType
  static func _forceBridgeFromObjectiveC(_ source: _ObjectiveCType, result: inout Self?)
  @discardableResult
  static func _conditionallyBridgeFromObjectiveC(_ source: _ObjectiveCType, result: inout Self?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ source: _ObjectiveCType?) -> Self
}
public struct _BridgeableMetatype : _ObjectiveCBridgeable {
  public typealias _ObjectiveCType = AnyObject
  public func _bridgeToObjectiveC() -> AnyObject
  public static func _forceBridgeFromObjectiveC(_ source: AnyObject, result: inout _BridgeableMetatype?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: AnyObject, result: inout _BridgeableMetatype?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: AnyObject?) -> _BridgeableMetatype
}
@inlinable public func _bridgeAnythingToObjectiveC<T>(_ x: T) -> AnyObject {
  if _fastPath(_isClassOrObjCExistential(T.self)) {
    return unsafeBitCast(x, to: AnyObject.self)
  }
  return _bridgeAnythingNonVerbatimToObjectiveC(x)
}
@_silgen_name("")
public func _bridgeAnythingNonVerbatimToObjectiveC<T>(_ x: __owned T) -> AnyObject
public func _bridgeAnyObjectToAny(_ possiblyNullObject: AnyObject?) -> Any
@inlinable public func _forceBridgeFromObjectiveC<T>(_ x: AnyObject, _: T.Type) -> T {
  if _fastPath(_isClassOrObjCExistential(T.self)) {
    return x as! T
  }

  var result: T?
  _bridgeNonVerbatimFromObjectiveC(x, T.self, &result)
  return result!
}
@inlinable public func _forceBridgeFromObjectiveC_bridgeable<T>(_ x: T._ObjectiveCType, _: T.Type) -> T where T : Swift._ObjectiveCBridgeable {
  var result: T?
  T._forceBridgeFromObjectiveC(x, result: &result)
  return result!
}
@inlinable public func _conditionallyBridgeFromObjectiveC<T>(_ x: AnyObject, _: T.Type) -> T? {
  if _fastPath(_isClassOrObjCExistential(T.self)) {
    return x as? T
  }

  var result: T?
  _ = _bridgeNonVerbatimFromObjectiveCConditional(x, T.self, &result)
  return result
}
@inlinable public func _conditionallyBridgeFromObjectiveC_bridgeable<T>(_ x: T._ObjectiveCType, _: T.Type) -> T? where T : Swift._ObjectiveCBridgeable {
  var result: T?
  T._conditionallyBridgeFromObjectiveC (x, result: &result)
  return result
}
@_silgen_name("")
@usableFromInline
internal func _bridgeNonVerbatimFromObjectiveC<T>(_ x: AnyObject, _ nativeType: T.Type, _ result: inout T?)
@_silgen_name("")
public func _bridgeNonVerbatimFromObjectiveCConditional<T>(_ x: AnyObject, _ nativeType: T.Type, _ result: inout T?) -> Bool
public func _isBridgedToObjectiveC<T>(_: T.Type) -> Bool
@_silgen_name("")
public func _isBridgedNonVerbatimToObjectiveC<T>(_: T.Type) -> Bool
@inlinable public func _isBridgedVerbatimToObjectiveC<T>(_: T.Type) -> Bool {
  return _isClassOrObjCExistential(T.self)
}
@inlinable public func _getBridgedObjectiveCType<T>(_: T.Type) -> Any.Type? {
  if _fastPath(_isClassOrObjCExistential(T.self)) {
    return T.self
  }
  return _getBridgedNonVerbatimObjectiveCType(T.self)
}
@_silgen_name("")
public func _getBridgedNonVerbatimObjectiveCType<T>(_: T.Type) -> Any.Type?
@_fixed_layout public struct AutoreleasingUnsafeMutablePointer<Pointee> : _Pointer {
  public let _rawValue: Builtin.RawPointer
  @_transparent public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
  @inlinable public var pointee: Pointee {
    @_transparent _read {
      // We can do a strong load normally.
      yield UnsafePointer(self).pointee
    }
    @_transparent nonmutating set {
      // Autorelease the object reference.
      typealias OptionalAnyObject = AnyObject?
      let newAnyObject = unsafeBitCast(newValue, to: OptionalAnyObject.self)
      Builtin.retain(newAnyObject)
      Builtin.autorelease(newAnyObject)
      // Trivially assign it as an OpaquePointer; the pointer references an
      // autoreleasing slot, so retains/releases of the original value are
      // unneeded.
      typealias OptionalUnmanaged = Unmanaged<AnyObject>?
      UnsafeMutablePointer<Pointee>(_rawValue).withMemoryRebound(
        to: OptionalUnmanaged.self, capacity: 1) {
        if let newAnyObject = newAnyObject {
          $0.pointee = Unmanaged.passUnretained(newAnyObject)
        }
        else {
          $0.pointee = nil
        }
      }
    }
  }
  @inlinable public subscript(i: Int) -> Pointee {
    @_transparent _read {
      // We can do a strong load normally.
      yield ((UnsafePointer<Pointee>(self) + i).pointee)
    }
  }
  @_transparent public init<U>(_ from: UnsafeMutablePointer<U>) {		
   self._rawValue = from._rawValue		
  }
  @_transparent public init?<U>(_ from: UnsafeMutablePointer<U>?) {		
   guard let unwrapped = from else { return nil }		
   self.init(unwrapped)		
  }
  @usableFromInline
  @_transparent internal init<U>(_ from: UnsafePointer<U>) {
    self._rawValue = from._rawValue
  }
  @usableFromInline
  @_transparent internal init?<U>(_ from: UnsafePointer<U>?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
  public var hashValue: Swift.Int {
    get
  }
  public typealias Stride = Swift.Int
}
extension UnsafeMutableRawPointer {
  @_transparent public init<T>(_ other: AutoreleasingUnsafeMutablePointer<T>) {
    _rawValue = other._rawValue
  }
  @_transparent public init?<T>(_ other: AutoreleasingUnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped)
  }
}
extension UnsafeRawPointer {
  @_transparent public init<T>(_ other: AutoreleasingUnsafeMutablePointer<T>) {
    _rawValue = other._rawValue
  }
  @_transparent public init?<T>(_ other: AutoreleasingUnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped)
  }
}
@_transparent public func _getObjCTypeEncoding<T>(_ type: T.Type) -> UnsafePointer<Int8> {
  // This must be `@_transparent` because `Builtin.getObjCTypeEncoding` is
  // only supported by the compiler for concrete types that are representable
  // in ObjC.
  return UnsafePointer(Builtin.getObjCTypeEncoding(type))
}
@usableFromInline
@_fixed_layout internal struct _BridgeStorage<NativeClass> where NativeClass : AnyObject {
  @usableFromInline
  internal typealias Native = NativeClass
  @usableFromInline
  internal typealias ObjC = AnyObject
  @usableFromInline
  internal var rawValue: Builtin.BridgeObject
  @inlinable @inline(__always) internal init(native: Native, isFlagged flag: Bool) {
    // Note: Some platforms provide more than one spare bit, but the minimum is
    // a single bit.

    _internalInvariant(_usesNativeSwiftReferenceCounting(NativeClass.self))

    rawValue = _makeNativeBridgeObject(
      native,
      flag ? (1 as UInt) << _objectPointerLowSpareBitShift : 0)
  }
  @inlinable @inline(__always) internal init(objC: ObjC) {
    _internalInvariant(_usesNativeSwiftReferenceCounting(NativeClass.self))
    rawValue = _makeObjCBridgeObject(objC)
  }
  @inlinable @inline(__always) internal init(native: Native) {
    _internalInvariant(_usesNativeSwiftReferenceCounting(NativeClass.self))
    rawValue = Builtin.reinterpretCast(native)
  }
  @inlinable @inline(__always) internal init(taggedPayload: UInt) {
    rawValue = _bridgeObject(taggingPayload: taggedPayload)
  }
  @inlinable @inline(__always) mutating internal func isUniquelyReferencedNative() -> Bool {
    return _isUnique(&rawValue)
  }
  @inlinable internal var isNative: Bool {
    @inline(__always) get {
      let result = Builtin.classifyBridgeObject(rawValue)
      return !Bool(Builtin.or_Int1(result.isObjCObject,
                                   result.isObjCTaggedPointer))
    }
  }
  @inlinable internal static var flagMask: UInt {
    @inline(__always) get {
      return (1 as UInt) << _objectPointerLowSpareBitShift
    }
  }
  @inlinable internal var isUnflaggedNative: Bool {
    @inline(__always) get {
      return (_bitPattern(rawValue) &
        (_bridgeObjectTaggedPointerBits | _objCTaggedPointerBits |
          _objectPointerIsObjCBit | _BridgeStorage.flagMask)) == 0
    }
  }
  @inlinable internal var isObjC: Bool {
    @inline(__always) get {
      return !isNative
    }
  }
  @inlinable internal var nativeInstance: Native {
    @inline(__always) get {
      _internalInvariant(isNative)
      return Builtin.castReferenceFromBridgeObject(rawValue)
    }
  }
  @inlinable internal var unflaggedNativeInstance: Native {
    @inline(__always) get {
      _internalInvariant(isNative)
      _internalInvariant(_nonPointerBits(rawValue) == 0)
      return Builtin.reinterpretCast(rawValue)
    }
  }
  @inlinable @inline(__always) mutating internal func isUniquelyReferencedUnflaggedNative() -> Bool {
    _internalInvariant(isNative)
    return _isUnique_native(&rawValue)
  }
  @inlinable internal var objCInstance: ObjC {
    @inline(__always) get {
      _internalInvariant(isObjC)
      return Builtin.castReferenceFromBridgeObject(rawValue)
    }
  }
}
@inlinable @inline(__always) internal func _roundUpImpl(_ offset: UInt, toAlignment alignment: Int) -> UInt {
  _internalInvariant(alignment > 0)
  _internalInvariant(_isPowerOf2(alignment))
  // Note, given that offset is >= 0, and alignment > 0, we don't
  // need to underflow check the -1, as it can never underflow.
  let x = offset + UInt(bitPattern: alignment) &- 1
  // Note, as alignment is a power of 2, we'll use masking to efficiently
  // get the aligned value
  return x & ~(UInt(bitPattern: alignment) &- 1)
}
@inlinable internal func _roundUp(_ offset: UInt, toAlignment alignment: Int) -> UInt {
  return _roundUpImpl(offset, toAlignment: alignment)
}
@inlinable internal func _roundUp(_ offset: Int, toAlignment alignment: Int) -> Int {
  _internalInvariant(offset >= 0)
  return Int(_roundUpImpl(UInt(bitPattern: offset), toAlignment: alignment))
}
@_transparent public func _canBeClass<T>(_: T.Type) -> Int8 {
  return Int8(Builtin.canBeClass(T.self))
}
@inlinable @_transparent public func unsafeBitCast<T, U>(_ x: T, to type: U.Type) -> U {
  _precondition(MemoryLayout<T>.size == MemoryLayout<U>.size,
    "Can't unsafeBitCast between types of different sizes")
  return Builtin.reinterpretCast(x)
}
@_transparent public func _identityCast<T, U>(_ x: T, to expectedType: U.Type) -> U {
  _precondition(T.self == expectedType, "_identityCast to wrong type")
  return Builtin.reinterpretCast(x)
}
@usableFromInline
@_transparent internal func _reinterpretCastToAnyObject<T>(_ x: T) -> AnyObject {
  return unsafeBitCast(x, to: AnyObject.self)
}
@usableFromInline
@_transparent internal func == (lhs: Builtin.NativeObject, rhs: Builtin.NativeObject) -> Bool {
  return unsafeBitCast(lhs, to: Int.self) == unsafeBitCast(rhs, to: Int.self)
}
@usableFromInline
@_transparent internal func != (lhs: Builtin.NativeObject, rhs: Builtin.NativeObject) -> Bool {
  return !(lhs == rhs)
}
@usableFromInline
@_transparent internal func == (lhs: Builtin.RawPointer, rhs: Builtin.RawPointer) -> Bool {
  return unsafeBitCast(lhs, to: Int.self) == unsafeBitCast(rhs, to: Int.self)
}
@usableFromInline
@_transparent internal func != (lhs: Builtin.RawPointer, rhs: Builtin.RawPointer) -> Bool {
  return !(lhs == rhs)
}
@inlinable public func == (t0: Any.Type?, t1: Any.Type?) -> Bool {
  switch (t0, t1) {
  case (.none, .none): return true
  case let (.some(ty0), .some(ty1)):
    return Bool(Builtin.is_same_metatype(ty0, ty1))
  default: return false
  }
}
@inlinable public func != (t0: Any.Type?, t1: Any.Type?) -> Bool {
  return !(t0 == t1)
}
@usableFromInline
@_transparent internal func _unreachable(_ condition: Bool = true) {
  if condition {
    // FIXME: use a parameterized version of Builtin.unreachable when
    // <rdar://problem/16806232> is closed.
    Builtin.unreachable()
  }
}
@usableFromInline
@_transparent internal func _conditionallyUnreachable() -> Never {
  Builtin.conditionallyUnreachable()
}
@usableFromInline
@_silgen_name("_swift_isClassOrObjCExistentialType")
internal func _swift_isClassOrObjCExistentialType<T>(_ x: T.Type) -> Bool
@inlinable @inline(__always) internal func _isClassOrObjCExistential<T>(_ x: T.Type) -> Bool {

  switch _canBeClass(x) {
  // Is not a class.
  case 0:
    return false
  // Is a class.
  case 1:
    return true
  // Maybe a class.
  default:
    return _swift_isClassOrObjCExistentialType(x)
  }
}
@_transparent public func _unsafeReferenceCast<T, U>(_ x: T, to: U.Type) -> U {
  return Builtin.castReference(x)
}
@_transparent public func unsafeDowncast<T>(_ x: AnyObject, to type: T.Type) -> T where T : AnyObject {
  _debugPrecondition(x is T, "invalid unsafeDowncast")
  return Builtin.castReference(x)
}
@_transparent public func _unsafeUncheckedDowncast<T>(_ x: AnyObject, to type: T.Type) -> T where T : AnyObject {
  _internalInvariant(x is T, "invalid unsafeDowncast")
  return Builtin.castReference(x)
}
@inlinable @inline(__always) public func _getUnsafePointerToStoredProperties(_ x: AnyObject) -> UnsafeMutableRawPointer {
  let storedPropertyOffset = _roundUp(
    MemoryLayout<SwiftShims.HeapObject>.size,
    toAlignment: MemoryLayout<Optional<AnyObject>>.alignment)
  return UnsafeMutableRawPointer(Builtin.bridgeToRawPointer(x)) +
    storedPropertyOffset
}
@inlinable @inline(__always) internal func _minAllocationAlignment() -> Int {
  return _swift_MinAllocationAlignment
}
@usableFromInline
@_transparent @_semantics("branchhint") internal func _branchHint(_ actual: Bool, expected: Bool) -> Bool {
  return Bool(Builtin.int_expect_Int1(actual._value, expected._value))
}
@_transparent @_semantics("fastpath") public func _fastPath(_ x: Bool) -> Bool {
  return _branchHint(x, expected: true)
}
@_transparent @_semantics("slowpath") public func _slowPath(_ x: Bool) -> Bool {
  return _branchHint(x, expected: false)
}
@_transparent public func _onFastPath() {
  Builtin.onFastPath()
}
@usableFromInline
@_transparent internal func _uncheckedUnsafeAssume(_ condition: Bool) {
  _ = Builtin.assume_Int1(condition._value)
}
@usableFromInline
@_silgen_name("_swift_objcClassUsesNativeSwiftReferenceCounting")
internal func _usesNativeSwiftReferenceCounting(_ theClass: AnyClass) -> Bool
@usableFromInline
@_silgen_name("_swift_getSwiftClassInstanceExtents")
internal func getSwiftClassInstanceExtents(_ theClass: AnyClass) -> (negative: UInt, positive: UInt)
@usableFromInline
@_silgen_name("_swift_getObjCClassInstanceExtents")
internal func getObjCClassInstanceExtents(_ theClass: AnyClass) -> (negative: UInt, positive: UInt)
@inlinable @inline(__always) internal func _class_getInstancePositiveExtentSize(_ theClass: AnyClass) -> Int {
  return Int(getObjCClassInstanceExtents(theClass).positive)
}
@inlinable internal func _isValidAddress(_ address: UInt) -> Bool {
  // TODO: define (and use) ABI max valid pointer value
  return address >= _swift_abi_LeastValidPointerValue
}
@inlinable internal var _bridgeObjectTaggedPointerBits: UInt {
  @inline(__always) get { return UInt(_swift_BridgeObject_TaggedPointerBits) }
}
@inlinable internal var _objCTaggedPointerBits: UInt {
  @inline(__always) get { return UInt(_swift_abi_ObjCReservedBitsMask) }
}
@inlinable internal var _objectPointerSpareBits: UInt {
  @inline(__always) get {
      return UInt(_swift_abi_SwiftSpareBitsMask) & ~_bridgeObjectTaggedPointerBits
    }
}
@inlinable internal var _objectPointerLowSpareBitShift: UInt {
  @inline(__always) get {
      _internalInvariant(_swift_abi_ObjCReservedLowBits < 2,
        "num bits now differs from num-shift-amount, new platform?")
      return UInt(_swift_abi_ObjCReservedLowBits)
    }
}
@inlinable internal var _objectPointerIsObjCBit: UInt {
  @inline(__always) get { return 0x4000_0000_0000_0000 }
}
@inlinable @inline(__always) internal func _bitPattern(_ x: Builtin.BridgeObject) -> UInt {
  return UInt(Builtin.castBitPatternFromBridgeObject(x))
}
@inlinable @inline(__always) internal func _nonPointerBits(_ x: Builtin.BridgeObject) -> UInt {
  return _bitPattern(x) & _objectPointerSpareBits
}
@inlinable @inline(__always) internal func _isObjCTaggedPointer(_ x: AnyObject) -> Bool {
  return (Builtin.reinterpretCast(x) & _objCTaggedPointerBits) != 0
}
@inlinable @inline(__always) internal func _isObjCTaggedPointer(_ x: UInt) -> Bool {
  return (x & _objCTaggedPointerBits) != 0
}
@inlinable @inline(__always) public func _isTaggedObject(_ x: Builtin.BridgeObject) -> Bool {
  return _bitPattern(x) & _bridgeObjectTaggedPointerBits != 0
}
@inlinable @inline(__always) public func _isNativePointer(_ x: Builtin.BridgeObject) -> Bool {
  return (
    _bitPattern(x) & (_bridgeObjectTaggedPointerBits | _objectPointerIsObjCBit)
  ) == 0
}
@inlinable @inline(__always) public func _isNonTaggedObjCPointer(_ x: Builtin.BridgeObject) -> Bool {
  return !_isTaggedObject(x) && !_isNativePointer(x)
}
@inlinable @inline(__always) internal func _getNonTagBits(_ x: Builtin.BridgeObject) -> UInt {
  // Zero out the tag bits, and leave them all at the top.
  _internalInvariant(_isTaggedObject(x), "not tagged!")
  return (_bitPattern(x) & ~_bridgeObjectTaggedPointerBits)
    >> _objectPointerLowSpareBitShift
}
@inline(__always) @inlinable public func _bridgeObject(fromNative x: AnyObject) -> Builtin.BridgeObject {
  _internalInvariant(!_isObjCTaggedPointer(x))
  let object = Builtin.castToBridgeObject(x, 0._builtinWordValue)
  _internalInvariant(_isNativePointer(object))
  return object
}
@inline(__always) @inlinable public func _bridgeObject(fromNonTaggedObjC x: AnyObject) -> Builtin.BridgeObject {
  _internalInvariant(!_isObjCTaggedPointer(x))
  let object = _makeObjCBridgeObject(x)
  _internalInvariant(_isNonTaggedObjCPointer(object))
  return object
}
@inline(__always) @inlinable public func _bridgeObject(fromTagged x: UInt) -> Builtin.BridgeObject {
  _internalInvariant(x & _bridgeObjectTaggedPointerBits != 0)
  let object: Builtin.BridgeObject = Builtin.valueToBridgeObject(x._value)
  _internalInvariant(_isTaggedObject(object))
  return object
}
@inline(__always) @inlinable public func _bridgeObject(taggingPayload x: UInt) -> Builtin.BridgeObject {
  let shifted = x &<< _objectPointerLowSpareBitShift
  _internalInvariant(x == (shifted &>> _objectPointerLowSpareBitShift),
    "out-of-range: limited bit range requires some zero top bits")
  _internalInvariant(shifted & _bridgeObjectTaggedPointerBits == 0,
    "out-of-range: post-shift use of tag bits")
  return _bridgeObject(fromTagged: shifted | _bridgeObjectTaggedPointerBits)
}
@inline(__always) @inlinable public func _bridgeObject(toNative x: Builtin.BridgeObject) -> AnyObject {
  _internalInvariant(_isNativePointer(x))
  return Builtin.castReferenceFromBridgeObject(x)
}
@inline(__always) @inlinable public func _bridgeObject(toNonTaggedObjC x: Builtin.BridgeObject) -> AnyObject {
  _internalInvariant(_isNonTaggedObjCPointer(x))
  return Builtin.castReferenceFromBridgeObject(x)
}
@inline(__always) @inlinable public func _bridgeObject(toTagged x: Builtin.BridgeObject) -> UInt {
  _internalInvariant(_isTaggedObject(x))
  let bits = _bitPattern(x)
  _internalInvariant(bits & _bridgeObjectTaggedPointerBits != 0)
  return bits
}
@inline(__always) @inlinable public func _bridgeObject(toTagPayload x: Builtin.BridgeObject) -> UInt {
  return _getNonTagBits(x)
}
@inline(__always) @inlinable public func _bridgeObject(fromNativeObject x: Builtin.NativeObject) -> Builtin.BridgeObject {
  return _bridgeObject(fromNative: _nativeObject(toNative: x))
}
@inlinable @inline(__always) public func _nativeObject(fromNative x: AnyObject) -> Builtin.NativeObject {
  _internalInvariant(!_isObjCTaggedPointer(x))
  let native = Builtin.unsafeCastToNativeObject(x)
  // _internalInvariant(native == Builtin.castToNativeObject(x))
  return native
}
@inlinable @inline(__always) public func _nativeObject(fromBridge x: Builtin.BridgeObject) -> Builtin.NativeObject {
  return _nativeObject(fromNative: _bridgeObject(toNative: x))
}
@inlinable @inline(__always) public func _nativeObject(toNative x: Builtin.NativeObject) -> AnyObject {
  return Builtin.castFromNativeObject(x)
}
extension ManagedBufferPointer {
  @inline(__always) @inlinable public init(_nativeObject buffer: Builtin.NativeObject) {
    self._nativeBuffer = buffer
  }
}
@inlinable @inline(__always) internal func _makeNativeBridgeObject(_ nativeObject: AnyObject, _ bits: UInt) -> Builtin.BridgeObject {
  _internalInvariant(
    (bits & _objectPointerIsObjCBit) == 0,
    "BridgeObject is treated as non-native when ObjC bit is set"
  )
  return _makeBridgeObject(nativeObject, bits)
}
@inlinable @inline(__always) public func _makeObjCBridgeObject(_ objCObject: AnyObject) -> Builtin.BridgeObject {
  return _makeBridgeObject(
    objCObject,
    _isObjCTaggedPointer(objCObject) ? 0 : _objectPointerIsObjCBit)
}
@inlinable @inline(__always) internal func _makeBridgeObject(_ object: AnyObject, _ bits: UInt) -> Builtin.BridgeObject {
  _internalInvariant(!_isObjCTaggedPointer(object) || bits == 0,
    "Tagged pointers cannot be combined with bits")

  _internalInvariant(
    _isObjCTaggedPointer(object)
    || _usesNativeSwiftReferenceCounting(type(of: object))
    || bits == _objectPointerIsObjCBit,
    "All spare bits must be set in non-native, non-tagged bridge objects"
  )

  _internalInvariant(
    bits & _objectPointerSpareBits == bits,
    "Can't store non-spare bits into Builtin.BridgeObject")

  return Builtin.castToBridgeObject(
    object, bits._builtinWordValue
  )
}
public func _getSuperclass(_ t: AnyClass) -> AnyClass?
@inlinable @inline(__always) public func _getSuperclass(_ t: Any.Type) -> AnyClass? {
  return (t as? AnyClass).flatMap { _getSuperclass($0) }
}
@usableFromInline
@_transparent internal func _isUnique<T>(_ object: inout T) -> Bool {
  return Bool(Builtin.isUnique(&object))
}
@_transparent public func _isUnique_native<T>(_ object: inout T) -> Bool {
  // This could be a bridge object, single payload enum, or plain old
  // reference. Any case it's non pointer bits must be zero, so
  // force cast it to BridgeObject and check the spare bits.
  _internalInvariant(
    (_bitPattern(Builtin.reinterpretCast(object)) & _objectPointerSpareBits)
    == 0)
  _internalInvariant(_usesNativeSwiftReferenceCounting(
      type(of: Builtin.reinterpretCast(object) as AnyObject)))
  return Bool(Builtin.isUnique_native(&object))
}
@_transparent public func _isPOD<T>(_ type: T.Type) -> Bool {
  return Bool(Builtin.ispod(type))
}
@_transparent public func _isBitwiseTakable<T>(_ type: T.Type) -> Bool {
  return Bool(Builtin.isbitwisetakable(type))
}
@_transparent public func _isOptional<T>(_ type: T.Type) -> Bool {
  return Bool(Builtin.isOptional(type))
}
@inlinable internal func _unsafeDowncastToAnyObject(fromAny any: Any) -> AnyObject {
  _internalInvariant(type(of: any) is AnyObject.Type
               || type(of: any) is AnyObject.Protocol,
               "Any expected to contain object reference")
  // Ideally we would do something like this:
  //
  // func open<T>(object: T) -> AnyObject {
  //   return unsafeBitCast(object, to: AnyObject.self)
  // }
  // return _openExistential(any, do: open)
  //
  // Unfortunately, class constrained protocol existentials conform to AnyObject
  // but are not word-sized.  As a result, we cannot currently perform the
  // `unsafeBitCast` on them just yet.  When they are word-sized, it would be
  // possible to efficiently grab the object reference out of the inline
  // storage.
  return any as AnyObject
}
@inlinable @inline(__always) public func _trueAfterDiagnostics() -> Builtin.Int1 {
  return true._value
}
@_transparent @_semantics("typechecker.type(of:)") public func type<T, Metatype>(of value: T) -> Metatype {
  // This implementation is never used, since calls to `Swift.type(of:)` are
  // resolved as a special case by the type checker.
  Builtin.staticReport(_trueAfterDiagnostics(), true._value,
    ("internal consistency error: 'type(of:)' operation failed to resolve"
     as StaticString).utf8Start._rawValue)
  Builtin.unreachable()
}
@_transparent @_semantics("typechecker.withoutActuallyEscaping(_:do:)") public func withoutActuallyEscaping<ClosureType, ResultType>(_ closure: ClosureType, do body: (_ escapingClosure: ClosureType) throws -> ResultType) rethrows -> ResultType {
  // This implementation is never used, since calls to
  // `Swift.withoutActuallyEscaping(_:do:)` are resolved as a special case by
  // the type checker.
  Builtin.staticReport(_trueAfterDiagnostics(), true._value,
    ("internal consistency error: 'withoutActuallyEscaping(_:do:)' operation failed to resolve"
     as StaticString).utf8Start._rawValue)
  Builtin.unreachable()
}
@_transparent @_semantics("typechecker._openExistential(_:do:)") public func _openExistential<ExistentialType, ContainedType, ResultType>(_ existential: ExistentialType, do body: (_ escapingClosure: ContainedType) throws -> ResultType) rethrows -> ResultType {
  // This implementation is never used, since calls to
  // `Swift._openExistential(_:do:)` are resolved as a special case by
  // the type checker.
  Builtin.staticReport(_trueAfterDiagnostics(), true._value,
    ("internal consistency error: '_openExistential(_:do:)' operation failed to resolve"
     as StaticString).utf8Start._rawValue)
  Builtin.unreachable()
}
@_transparent public func _cos(_ x: Float) -> Float {
  return Float(Builtin.int_cos_FPIEEE32(x._value))
}
@_transparent public func _cos(_ x: Double) -> Double {
  return Double(Builtin.int_cos_FPIEEE64(x._value))
}
@_transparent public func _cos(_ x: Float80) -> Float80 {
  return Float80(Builtin.int_cos_FPIEEE80(x._value))
}
@_transparent public func _sin(_ x: Float) -> Float {
  return Float(Builtin.int_sin_FPIEEE32(x._value))
}
@_transparent public func _sin(_ x: Double) -> Double {
  return Double(Builtin.int_sin_FPIEEE64(x._value))
}
@_transparent public func _sin(_ x: Float80) -> Float80 {
  return Float80(Builtin.int_sin_FPIEEE80(x._value))
}
@_transparent public func _exp(_ x: Float) -> Float {
  return Float(Builtin.int_exp_FPIEEE32(x._value))
}
@_transparent public func _exp(_ x: Double) -> Double {
  return Double(Builtin.int_exp_FPIEEE64(x._value))
}
@_transparent public func _exp(_ x: Float80) -> Float80 {
  return Float80(Builtin.int_exp_FPIEEE80(x._value))
}
@_transparent public func _exp2(_ x: Float) -> Float {
  return Float(Builtin.int_exp2_FPIEEE32(x._value))
}
@_transparent public func _exp2(_ x: Double) -> Double {
  return Double(Builtin.int_exp2_FPIEEE64(x._value))
}
@_transparent public func _exp2(_ x: Float80) -> Float80 {
  return Float80(Builtin.int_exp2_FPIEEE80(x._value))
}
@_transparent public func _log(_ x: Float) -> Float {
  return Float(Builtin.int_log_FPIEEE32(x._value))
}
@_transparent public func _log(_ x: Double) -> Double {
  return Double(Builtin.int_log_FPIEEE64(x._value))
}
@_transparent public func _log(_ x: Float80) -> Float80 {
  return Float80(Builtin.int_log_FPIEEE80(x._value))
}
@_transparent public func _log10(_ x: Float) -> Float {
  return Float(Builtin.int_log10_FPIEEE32(x._value))
}
@_transparent public func _log10(_ x: Double) -> Double {
  return Double(Builtin.int_log10_FPIEEE64(x._value))
}
@_transparent public func _log10(_ x: Float80) -> Float80 {
  return Float80(Builtin.int_log10_FPIEEE80(x._value))
}
@_transparent public func _log2(_ x: Float) -> Float {
  return Float(Builtin.int_log2_FPIEEE32(x._value))
}
@_transparent public func _log2(_ x: Double) -> Double {
  return Double(Builtin.int_log2_FPIEEE64(x._value))
}
@_transparent public func _log2(_ x: Float80) -> Float80 {
  return Float80(Builtin.int_log2_FPIEEE80(x._value))
}
@_transparent public func _nearbyint(_ x: Float) -> Float {
  return Float(Builtin.int_nearbyint_FPIEEE32(x._value))
}
@_transparent public func _nearbyint(_ x: Double) -> Double {
  return Double(Builtin.int_nearbyint_FPIEEE64(x._value))
}
@_transparent public func _nearbyint(_ x: Float80) -> Float80 {
  return Float80(Builtin.int_nearbyint_FPIEEE80(x._value))
}
@_transparent public func _rint(_ x: Float) -> Float {
  return Float(Builtin.int_rint_FPIEEE32(x._value))
}
@_transparent public func _rint(_ x: Double) -> Double {
  return Double(Builtin.int_rint_FPIEEE64(x._value))
}
@_transparent public func _rint(_ x: Float80) -> Float80 {
  return Float80(Builtin.int_rint_FPIEEE80(x._value))
}
@_fixed_layout public struct Character {
  @usableFromInline
  internal var _str: String
  @inlinable @inline(__always) internal init(unchecked str: String) {
    self._str = str
    _invariantCheck()
  }
}
extension Character {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension Character {
  public typealias UTF8View = String.UTF8View
  @inlinable public var utf8: UTF8View {
    get { return _str.utf8 }
  }
  public typealias UTF16View = String.UTF16View
  @inlinable public var utf16: UTF16View {
    get { return _str.utf16 }
  }
  public typealias UnicodeScalarView = String.UnicodeScalarView
  @inlinable public var unicodeScalars: UnicodeScalarView {
    get { return _str.unicodeScalars }
  }
}
extension Character : _ExpressibleByBuiltinExtendedGraphemeClusterLiteral, ExpressibleByExtendedGraphemeClusterLiteral {
  @inlinable @inline(__always) public init(_ content: Unicode.Scalar) {
    self.init(unchecked: String(content))
  }
  @inlinable @inline(__always) @_effects(readonly) public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self.init(Unicode.Scalar(_builtinUnicodeScalarLiteral: value))
  }
  @inlinable @inline(__always) @_effects(readonly) public init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    self.init(unchecked: String(
      _builtinExtendedGraphemeClusterLiteral: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII))
  }
  @inlinable @inline(__always) public init(extendedGraphemeClusterLiteral value: Character) {
    self.init(unchecked: value._str)
  }
  @inlinable @inline(__always) public init(_ s: String) {
    _precondition(!s.isEmpty,
      "Can't form a Character from an empty String")
    _debugPrecondition(s.index(after: s.startIndex) == s.endIndex,
      "Can't form a Character from a String containing more than one extended grapheme cluster")

    if _fastPath(s._guts._object.isPreferredRepresentation) {
      self.init(unchecked: s)
      return
    }
    self.init(unchecked: String._copying(s))
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.Character
  public typealias UnicodeScalarLiteralType = Swift.Character
}
extension Character : CustomStringConvertible {
  @inlinable public var description: String {
    get {
   return _str
 }
  }
}
extension Character : LosslessStringConvertible {
}
extension Character : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension String {
  @inlinable @inline(__always) public init(_ c: Character) {
    self.init(c._str._guts)
  }
}
extension Character : Equatable {
  @inlinable @inline(__always) @_effects(readonly) public static func == (lhs: Character, rhs: Character) -> Bool {
    return lhs._str == rhs._str
  }
}
extension Character : Comparable {
  @inlinable @inline(__always) @_effects(readonly) public static func < (lhs: Character, rhs: Character) -> Bool {
    return lhs._str < rhs._str
  }
}
extension Character : Hashable {
  @_effects(releasenone) public func hash(into hasher: inout Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Character {
  @usableFromInline
  internal var _isSmall: Bool {
    get
  }
}
@usableFromInline
@_fixed_layout internal struct _CocoaArrayWrapper : RandomAccessCollection {
  @usableFromInline
  internal typealias Indices = Range<Int>
  @usableFromInline
  internal var buffer: AnyObject
  @usableFromInline
  @_transparent internal init(_ buffer: AnyObject) {
    self.buffer = buffer
  }
  @inlinable internal var startIndex: Int {
    get {
    return 0
  }
  }
  @usableFromInline
  internal var endIndex: Int {
    get
  }
  @usableFromInline
  internal subscript(i: Int) -> AnyObject {
    get
  }
  @usableFromInline
  internal subscript(bounds: Range<Int>) -> _SliceBuffer<AnyObject> {
    get
  }
  @usableFromInline
  __consuming internal func _copyContents(subRange bounds: Range<Int>, initializing target: UnsafeMutablePointer<AnyObject>) -> UnsafeMutablePointer<AnyObject>
  @usableFromInline
  internal typealias Element = Swift.AnyObject
  @usableFromInline
  internal typealias Index = Swift.Int
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Swift._CocoaArrayWrapper>
  @usableFromInline
  internal typealias SubSequence = Swift._SliceBuffer<Swift.AnyObject>
}
public protocol Encodable {
  func encode(to encoder: Encoder) throws
}
public protocol Decodable {
  init(from decoder: Decoder) throws
}
public typealias Codable = Encodable & Decodable
public protocol CodingKey : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible {
  var stringValue: String { get }
  init?(stringValue: String)
  var intValue: Int? { get }
  init?(intValue: Int)
}
extension CodingKey {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
}
public protocol Encoder {
  var codingPath: [CodingKey] { get }
  var userInfo: [CodingUserInfoKey : Any] { get }
  func container<Key>(keyedBy type: Key.Type) -> KeyedEncodingContainer<Key> where Key : Swift.CodingKey
  func unkeyedContainer() -> UnkeyedEncodingContainer
  func singleValueContainer() -> SingleValueEncodingContainer
}
public protocol Decoder {
  var codingPath: [CodingKey] { get }
  var userInfo: [CodingUserInfoKey : Any] { get }
  func container<Key>(keyedBy type: Key.Type) throws -> KeyedDecodingContainer<Key> where Key : Swift.CodingKey
  func unkeyedContainer() throws -> UnkeyedDecodingContainer
  func singleValueContainer() throws -> SingleValueDecodingContainer
}
public protocol KeyedEncodingContainerProtocol {
  associatedtype Key : Swift.CodingKey
  var codingPath: [CodingKey] { get }
  mutating func encodeNil(forKey key: Key) throws
  mutating func encode(_ value: Bool, forKey key: Key) throws
  mutating func encode(_ value: String, forKey key: Key) throws
  mutating func encode(_ value: Double, forKey key: Key) throws
  mutating func encode(_ value: Float, forKey key: Key) throws
  mutating func encode(_ value: Int, forKey key: Key) throws
  mutating func encode(_ value: Int8, forKey key: Key) throws
  mutating func encode(_ value: Int16, forKey key: Key) throws
  mutating func encode(_ value: Int32, forKey key: Key) throws
  mutating func encode(_ value: Int64, forKey key: Key) throws
  mutating func encode(_ value: UInt, forKey key: Key) throws
  mutating func encode(_ value: UInt8, forKey key: Key) throws
  mutating func encode(_ value: UInt16, forKey key: Key) throws
  mutating func encode(_ value: UInt32, forKey key: Key) throws
  mutating func encode(_ value: UInt64, forKey key: Key) throws
  mutating func encode<T>(_ value: T, forKey key: Key) throws where T : Swift.Encodable
  mutating func encodeConditional<T>(_ object: T, forKey key: Key) throws where T : AnyObject, T : Swift.Encodable
  mutating func encodeIfPresent(_ value: Bool?, forKey key: Key) throws
  mutating func encodeIfPresent(_ value: String?, forKey key: Key) throws
  mutating func encodeIfPresent(_ value: Double?, forKey key: Key) throws
  mutating func encodeIfPresent(_ value: Float?, forKey key: Key) throws
  mutating func encodeIfPresent(_ value: Int?, forKey key: Key) throws
  mutating func encodeIfPresent(_ value: Int8?, forKey key: Key) throws
  mutating func encodeIfPresent(_ value: Int16?, forKey key: Key) throws
  mutating func encodeIfPresent(_ value: Int32?, forKey key: Key) throws
  mutating func encodeIfPresent(_ value: Int64?, forKey key: Key) throws
  mutating func encodeIfPresent(_ value: UInt?, forKey key: Key) throws
  mutating func encodeIfPresent(_ value: UInt8?, forKey key: Key) throws
  mutating func encodeIfPresent(_ value: UInt16?, forKey key: Key) throws
  mutating func encodeIfPresent(_ value: UInt32?, forKey key: Key) throws
  mutating func encodeIfPresent(_ value: UInt64?, forKey key: Key) throws
  mutating func encodeIfPresent<T>(_ value: T?, forKey key: Key) throws where T : Swift.Encodable
  mutating func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type, forKey key: Key) -> KeyedEncodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  mutating func nestedUnkeyedContainer(forKey key: Key) -> UnkeyedEncodingContainer
  mutating func superEncoder() -> Encoder
  mutating func superEncoder(forKey key: Key) -> Encoder
}
public struct KeyedEncodingContainer<K> : KeyedEncodingContainerProtocol where K : Swift.CodingKey {
  public typealias Key = K
  public init<Container>(_ container: Container) where K == Container.Key, Container : Swift.KeyedEncodingContainerProtocol
  public var codingPath: [CodingKey] {
    get
  }
  mutating public func encodeNil(forKey key: Key) throws
  mutating public func encode(_ value: Bool, forKey key: Key) throws
  mutating public func encode(_ value: String, forKey key: Key) throws
  mutating public func encode(_ value: Double, forKey key: Key) throws
  mutating public func encode(_ value: Float, forKey key: Key) throws
  mutating public func encode(_ value: Int, forKey key: Key) throws
  mutating public func encode(_ value: Int8, forKey key: Key) throws
  mutating public func encode(_ value: Int16, forKey key: Key) throws
  mutating public func encode(_ value: Int32, forKey key: Key) throws
  mutating public func encode(_ value: Int64, forKey key: Key) throws
  mutating public func encode(_ value: UInt, forKey key: Key) throws
  mutating public func encode(_ value: UInt8, forKey key: Key) throws
  mutating public func encode(_ value: UInt16, forKey key: Key) throws
  mutating public func encode(_ value: UInt32, forKey key: Key) throws
  mutating public func encode(_ value: UInt64, forKey key: Key) throws
  mutating public func encode<T>(_ value: T, forKey key: Key) throws where T : Swift.Encodable
  mutating public func encodeConditional<T>(_ object: T, forKey key: Key) throws where T : AnyObject, T : Swift.Encodable
  mutating public func encodeIfPresent(_ value: Bool?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: String?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: Double?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: Float?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: Int?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: Int8?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: Int16?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: Int32?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: Int64?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: UInt?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: UInt8?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: UInt16?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: UInt32?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: UInt64?, forKey key: Key) throws
  mutating public func encodeIfPresent<T>(_ value: T?, forKey key: Key) throws where T : Swift.Encodable
  mutating public func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type, forKey key: Key) -> KeyedEncodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  mutating public func nestedUnkeyedContainer(forKey key: Key) -> UnkeyedEncodingContainer
  mutating public func superEncoder() -> Encoder
  mutating public func superEncoder(forKey key: Key) -> Encoder
}
public protocol KeyedDecodingContainerProtocol {
  associatedtype Key : Swift.CodingKey
  var codingPath: [CodingKey] { get }
  var allKeys: [Key] { get }
  func contains(_ key: Key) -> Bool
  func decodeNil(forKey key: Key) throws -> Bool
  func decode(_ type: Bool.Type, forKey key: Key) throws -> Bool
  func decode(_ type: String.Type, forKey key: Key) throws -> String
  func decode(_ type: Double.Type, forKey key: Key) throws -> Double
  func decode(_ type: Float.Type, forKey key: Key) throws -> Float
  func decode(_ type: Int.Type, forKey key: Key) throws -> Int
  func decode(_ type: Int8.Type, forKey key: Key) throws -> Int8
  func decode(_ type: Int16.Type, forKey key: Key) throws -> Int16
  func decode(_ type: Int32.Type, forKey key: Key) throws -> Int32
  func decode(_ type: Int64.Type, forKey key: Key) throws -> Int64
  func decode(_ type: UInt.Type, forKey key: Key) throws -> UInt
  func decode(_ type: UInt8.Type, forKey key: Key) throws -> UInt8
  func decode(_ type: UInt16.Type, forKey key: Key) throws -> UInt16
  func decode(_ type: UInt32.Type, forKey key: Key) throws -> UInt32
  func decode(_ type: UInt64.Type, forKey key: Key) throws -> UInt64
  func decode<T>(_ type: T.Type, forKey key: Key) throws -> T where T : Swift.Decodable
  func decodeIfPresent(_ type: Bool.Type, forKey key: Key) throws -> Bool?
  func decodeIfPresent(_ type: String.Type, forKey key: Key) throws -> String?
  func decodeIfPresent(_ type: Double.Type, forKey key: Key) throws -> Double?
  func decodeIfPresent(_ type: Float.Type, forKey key: Key) throws -> Float?
  func decodeIfPresent(_ type: Int.Type, forKey key: Key) throws -> Int?
  func decodeIfPresent(_ type: Int8.Type, forKey key: Key) throws -> Int8?
  func decodeIfPresent(_ type: Int16.Type, forKey key: Key) throws -> Int16?
  func decodeIfPresent(_ type: Int32.Type, forKey key: Key) throws -> Int32?
  func decodeIfPresent(_ type: Int64.Type, forKey key: Key) throws -> Int64?
  func decodeIfPresent(_ type: UInt.Type, forKey key: Key) throws -> UInt?
  func decodeIfPresent(_ type: UInt8.Type, forKey key: Key) throws -> UInt8?
  func decodeIfPresent(_ type: UInt16.Type, forKey key: Key) throws -> UInt16?
  func decodeIfPresent(_ type: UInt32.Type, forKey key: Key) throws -> UInt32?
  func decodeIfPresent(_ type: UInt64.Type, forKey key: Key) throws -> UInt64?
  func decodeIfPresent<T>(_ type: T.Type, forKey key: Key) throws -> T? where T : Swift.Decodable
  func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: Key) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  func nestedUnkeyedContainer(forKey key: Key) throws -> UnkeyedDecodingContainer
  func superDecoder() throws -> Decoder
  func superDecoder(forKey key: Key) throws -> Decoder
}
public struct KeyedDecodingContainer<K> : KeyedDecodingContainerProtocol where K : Swift.CodingKey {
  public typealias Key = K
  public init<Container>(_ container: Container) where K == Container.Key, Container : Swift.KeyedDecodingContainerProtocol
  public var codingPath: [CodingKey] {
    get
  }
  public var allKeys: [Key] {
    get
  }
  public func contains(_ key: Key) -> Bool
  public func decodeNil(forKey key: Key) throws -> Bool
  public func decode(_ type: Bool.Type, forKey key: Key) throws -> Bool
  public func decode(_ type: String.Type, forKey key: Key) throws -> String
  public func decode(_ type: Double.Type, forKey key: Key) throws -> Double
  public func decode(_ type: Float.Type, forKey key: Key) throws -> Float
  public func decode(_ type: Int.Type, forKey key: Key) throws -> Int
  public func decode(_ type: Int8.Type, forKey key: Key) throws -> Int8
  public func decode(_ type: Int16.Type, forKey key: Key) throws -> Int16
  public func decode(_ type: Int32.Type, forKey key: Key) throws -> Int32
  public func decode(_ type: Int64.Type, forKey key: Key) throws -> Int64
  public func decode(_ type: UInt.Type, forKey key: Key) throws -> UInt
  public func decode(_ type: UInt8.Type, forKey key: Key) throws -> UInt8
  public func decode(_ type: UInt16.Type, forKey key: Key) throws -> UInt16
  public func decode(_ type: UInt32.Type, forKey key: Key) throws -> UInt32
  public func decode(_ type: UInt64.Type, forKey key: Key) throws -> UInt64
  public func decode<T>(_ type: T.Type, forKey key: Key) throws -> T where T : Swift.Decodable
  public func decodeIfPresent(_ type: Bool.Type, forKey key: Key) throws -> Bool?
  public func decodeIfPresent(_ type: String.Type, forKey key: Key) throws -> String?
  public func decodeIfPresent(_ type: Double.Type, forKey key: Key) throws -> Double?
  public func decodeIfPresent(_ type: Float.Type, forKey key: Key) throws -> Float?
  public func decodeIfPresent(_ type: Int.Type, forKey key: Key) throws -> Int?
  public func decodeIfPresent(_ type: Int8.Type, forKey key: Key) throws -> Int8?
  public func decodeIfPresent(_ type: Int16.Type, forKey key: Key) throws -> Int16?
  public func decodeIfPresent(_ type: Int32.Type, forKey key: Key) throws -> Int32?
  public func decodeIfPresent(_ type: Int64.Type, forKey key: Key) throws -> Int64?
  public func decodeIfPresent(_ type: UInt.Type, forKey key: Key) throws -> UInt?
  public func decodeIfPresent(_ type: UInt8.Type, forKey key: Key) throws -> UInt8?
  public func decodeIfPresent(_ type: UInt16.Type, forKey key: Key) throws -> UInt16?
  public func decodeIfPresent(_ type: UInt32.Type, forKey key: Key) throws -> UInt32?
  public func decodeIfPresent(_ type: UInt64.Type, forKey key: Key) throws -> UInt64?
  public func decodeIfPresent<T>(_ type: T.Type, forKey key: Key) throws -> T? where T : Swift.Decodable
  public func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: Key) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  public func nestedUnkeyedContainer(forKey key: Key) throws -> UnkeyedDecodingContainer
  public func superDecoder() throws -> Decoder
  public func superDecoder(forKey key: Key) throws -> Decoder
}
public protocol UnkeyedEncodingContainer {
  var codingPath: [CodingKey] { get }
  var count: Int { get }
  mutating func encodeNil() throws
  mutating func encode(_ value: Bool) throws
  mutating func encode(_ value: String) throws
  mutating func encode(_ value: Double) throws
  mutating func encode(_ value: Float) throws
  mutating func encode(_ value: Int) throws
  mutating func encode(_ value: Int8) throws
  mutating func encode(_ value: Int16) throws
  mutating func encode(_ value: Int32) throws
  mutating func encode(_ value: Int64) throws
  mutating func encode(_ value: UInt) throws
  mutating func encode(_ value: UInt8) throws
  mutating func encode(_ value: UInt16) throws
  mutating func encode(_ value: UInt32) throws
  mutating func encode(_ value: UInt64) throws
  mutating func encode<T>(_ value: T) throws where T : Swift.Encodable
  mutating func encodeConditional<T>(_ object: T) throws where T : AnyObject, T : Swift.Encodable
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Bool
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.String
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Double
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Float
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int8
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int16
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int32
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int64
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt8
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt16
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt32
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt64
  mutating func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element : Swift.Encodable
  mutating func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type) -> KeyedEncodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  mutating func nestedUnkeyedContainer() -> UnkeyedEncodingContainer
  mutating func superEncoder() -> Encoder
}
public protocol UnkeyedDecodingContainer {
  var codingPath: [CodingKey] { get }
  var count: Int? { get }
  var isAtEnd: Bool { get }
  var currentIndex: Int { get }
  mutating func decodeNil() throws -> Bool
  mutating func decode(_ type: Bool.Type) throws -> Bool
  mutating func decode(_ type: String.Type) throws -> String
  mutating func decode(_ type: Double.Type) throws -> Double
  mutating func decode(_ type: Float.Type) throws -> Float
  mutating func decode(_ type: Int.Type) throws -> Int
  mutating func decode(_ type: Int8.Type) throws -> Int8
  mutating func decode(_ type: Int16.Type) throws -> Int16
  mutating func decode(_ type: Int32.Type) throws -> Int32
  mutating func decode(_ type: Int64.Type) throws -> Int64
  mutating func decode(_ type: UInt.Type) throws -> UInt
  mutating func decode(_ type: UInt8.Type) throws -> UInt8
  mutating func decode(_ type: UInt16.Type) throws -> UInt16
  mutating func decode(_ type: UInt32.Type) throws -> UInt32
  mutating func decode(_ type: UInt64.Type) throws -> UInt64
  mutating func decode<T>(_ type: T.Type) throws -> T where T : Swift.Decodable
  mutating func decodeIfPresent(_ type: Bool.Type) throws -> Bool?
  mutating func decodeIfPresent(_ type: String.Type) throws -> String?
  mutating func decodeIfPresent(_ type: Double.Type) throws -> Double?
  mutating func decodeIfPresent(_ type: Float.Type) throws -> Float?
  mutating func decodeIfPresent(_ type: Int.Type) throws -> Int?
  mutating func decodeIfPresent(_ type: Int8.Type) throws -> Int8?
  mutating func decodeIfPresent(_ type: Int16.Type) throws -> Int16?
  mutating func decodeIfPresent(_ type: Int32.Type) throws -> Int32?
  mutating func decodeIfPresent(_ type: Int64.Type) throws -> Int64?
  mutating func decodeIfPresent(_ type: UInt.Type) throws -> UInt?
  mutating func decodeIfPresent(_ type: UInt8.Type) throws -> UInt8?
  mutating func decodeIfPresent(_ type: UInt16.Type) throws -> UInt16?
  mutating func decodeIfPresent(_ type: UInt32.Type) throws -> UInt32?
  mutating func decodeIfPresent(_ type: UInt64.Type) throws -> UInt64?
  mutating func decodeIfPresent<T>(_ type: T.Type) throws -> T? where T : Swift.Decodable
  mutating func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : Swift.CodingKey
  mutating func nestedUnkeyedContainer() throws -> UnkeyedDecodingContainer
  mutating func superDecoder() throws -> Decoder
}
public protocol SingleValueEncodingContainer {
  var codingPath: [CodingKey] { get }
  mutating func encodeNil() throws
  mutating func encode(_ value: Bool) throws
  mutating func encode(_ value: String) throws
  mutating func encode(_ value: Double) throws
  mutating func encode(_ value: Float) throws
  mutating func encode(_ value: Int) throws
  mutating func encode(_ value: Int8) throws
  mutating func encode(_ value: Int16) throws
  mutating func encode(_ value: Int32) throws
  mutating func encode(_ value: Int64) throws
  mutating func encode(_ value: UInt) throws
  mutating func encode(_ value: UInt8) throws
  mutating func encode(_ value: UInt16) throws
  mutating func encode(_ value: UInt32) throws
  mutating func encode(_ value: UInt64) throws
  mutating func encode<T>(_ value: T) throws where T : Swift.Encodable
}
public protocol SingleValueDecodingContainer {
  var codingPath: [CodingKey] { get }
  func decodeNil() -> Bool
  func decode(_ type: Bool.Type) throws -> Bool
  func decode(_ type: String.Type) throws -> String
  func decode(_ type: Double.Type) throws -> Double
  func decode(_ type: Float.Type) throws -> Float
  func decode(_ type: Int.Type) throws -> Int
  func decode(_ type: Int8.Type) throws -> Int8
  func decode(_ type: Int16.Type) throws -> Int16
  func decode(_ type: Int32.Type) throws -> Int32
  func decode(_ type: Int64.Type) throws -> Int64
  func decode(_ type: UInt.Type) throws -> UInt
  func decode(_ type: UInt8.Type) throws -> UInt8
  func decode(_ type: UInt16.Type) throws -> UInt16
  func decode(_ type: UInt32.Type) throws -> UInt32
  func decode(_ type: UInt64.Type) throws -> UInt64
  func decode<T>(_ type: T.Type) throws -> T where T : Swift.Decodable
}
public struct CodingUserInfoKey : RawRepresentable, Equatable, Hashable {
  public typealias RawValue = String
  public let rawValue: String
  public init?(rawValue: String)
  public static func == (lhs: CodingUserInfoKey, rhs: CodingUserInfoKey) -> Bool
  public var hashValue: Int {
    get
  }
  public func hash(into hasher: inout Hasher)
}
public enum EncodingError : Error {
  public struct Context {
    public let codingPath: [CodingKey]
    public let debugDescription: String
    public let underlyingError: Error?
    public init(codingPath: [CodingKey], debugDescription: String, underlyingError: Error? = nil)
  }
  case invalidValue(Any, Context)
  public var _domain: String {
    get
  }
  public var _code: Int {
    get
  }
  public var _userInfo: AnyObject? {
    get
  }
}
public enum DecodingError : Error {
  public struct Context {
    public let codingPath: [CodingKey]
    public let debugDescription: String
    public let underlyingError: Error?
    public init(codingPath: [CodingKey], debugDescription: String, underlyingError: Error? = nil)
  }
  case typeMismatch(Any.Type, Context)
  case valueNotFound(Any.Type, Context)
  case keyNotFound(CodingKey, Context)
  case dataCorrupted(Context)
  public var _domain: String {
    get
  }
  public var _code: Int {
    get
  }
  public var _userInfo: AnyObject? {
    get
  }
}
extension DecodingError {
  public static func dataCorruptedError<C>(forKey key: C.Key, in container: C, debugDescription: String) -> DecodingError where C : Swift.KeyedDecodingContainerProtocol
  public static func dataCorruptedError(in container: UnkeyedDecodingContainer, debugDescription: String) -> DecodingError
  public static func dataCorruptedError(in container: SingleValueDecodingContainer, debugDescription: String) -> DecodingError
}
extension Bool : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Bool {
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Bool {
  public init(from decoder: Decoder) throws
}
extension String : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.String {
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.String {
  public init(from decoder: Decoder) throws
}
extension Double : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Double {
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Double {
  public init(from decoder: Decoder) throws
}
extension Float : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Float {
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Float {
  public init(from decoder: Decoder) throws
}
extension Int : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Int {
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Int {
  public init(from decoder: Decoder) throws
}
extension Int8 : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Int8 {
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Int8 {
  public init(from decoder: Decoder) throws
}
extension Int16 : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Int16 {
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Int16 {
  public init(from decoder: Decoder) throws
}
extension Int32 : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Int32 {
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Int32 {
  public init(from decoder: Decoder) throws
}
extension Int64 : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.Int64 {
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.Int64 {
  public init(from decoder: Decoder) throws
}
extension UInt : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.UInt {
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.UInt {
  public init(from decoder: Decoder) throws
}
extension UInt8 : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.UInt8 {
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.UInt8 {
  public init(from decoder: Decoder) throws
}
extension UInt16 : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.UInt16 {
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.UInt16 {
  public init(from decoder: Decoder) throws
}
extension UInt32 : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.UInt32 {
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.UInt32 {
  public init(from decoder: Decoder) throws
}
extension UInt64 : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Encodable, Self.RawValue == Swift.UInt64 {
  public func encode(to encoder: Encoder) throws
}
extension RawRepresentable where Self : Swift.Decodable, Self.RawValue == Swift.UInt64 {
  public init(from decoder: Decoder) throws
}
extension Optional : Encodable where Wrapped : Swift.Encodable {
  public func encode(to encoder: Encoder) throws
}
extension Optional : Decodable where Wrapped : Swift.Decodable {
  public init(from decoder: Decoder) throws
}
extension Array : Encodable where Element : Swift.Encodable {
  public func encode(to encoder: Encoder) throws
}
extension Array : Decodable where Element : Swift.Decodable {
  public init(from decoder: Decoder) throws
}
extension ContiguousArray : Encodable where Element : Swift.Encodable {
  public func encode(to encoder: Encoder) throws
}
extension ContiguousArray : Decodable where Element : Swift.Decodable {
  public init(from decoder: Decoder) throws
}
extension Set : Encodable where Element : Swift.Encodable {
  public func encode(to encoder: Encoder) throws
}
extension Set : Decodable where Element : Swift.Decodable {
  public init(from decoder: Decoder) throws
}
extension Dictionary : Encodable where Key : Swift.Encodable, Value : Swift.Encodable {
  public func encode(to encoder: Encoder) throws
}
extension Dictionary : Decodable where Key : Swift.Decodable, Value : Swift.Decodable {
  public init(from decoder: Decoder) throws
}
extension KeyedEncodingContainerProtocol {
  mutating public func encodeConditional<T>(_ object: T, forKey key: Key) throws where T : AnyObject, T : Swift.Encodable
}
extension KeyedEncodingContainerProtocol {
  mutating public func encodeIfPresent(_ value: Bool?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: String?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: Double?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: Float?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: Int?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: Int8?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: Int16?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: Int32?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: Int64?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: UInt?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: UInt8?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: UInt16?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: UInt32?, forKey key: Key) throws
  mutating public func encodeIfPresent(_ value: UInt64?, forKey key: Key) throws
  mutating public func encodeIfPresent<T>(_ value: T?, forKey key: Key) throws where T : Swift.Encodable
}
extension KeyedDecodingContainerProtocol {
  public func decodeIfPresent(_ type: Bool.Type, forKey key: Key) throws -> Bool?
  public func decodeIfPresent(_ type: String.Type, forKey key: Key) throws -> String?
  public func decodeIfPresent(_ type: Double.Type, forKey key: Key) throws -> Double?
  public func decodeIfPresent(_ type: Float.Type, forKey key: Key) throws -> Float?
  public func decodeIfPresent(_ type: Int.Type, forKey key: Key) throws -> Int?
  public func decodeIfPresent(_ type: Int8.Type, forKey key: Key) throws -> Int8?
  public func decodeIfPresent(_ type: Int16.Type, forKey key: Key) throws -> Int16?
  public func decodeIfPresent(_ type: Int32.Type, forKey key: Key) throws -> Int32?
  public func decodeIfPresent(_ type: Int64.Type, forKey key: Key) throws -> Int64?
  public func decodeIfPresent(_ type: UInt.Type, forKey key: Key) throws -> UInt?
  public func decodeIfPresent(_ type: UInt8.Type, forKey key: Key) throws -> UInt8?
  public func decodeIfPresent(_ type: UInt16.Type, forKey key: Key) throws -> UInt16?
  public func decodeIfPresent(_ type: UInt32.Type, forKey key: Key) throws -> UInt32?
  public func decodeIfPresent(_ type: UInt64.Type, forKey key: Key) throws -> UInt64?
  public func decodeIfPresent<T>(_ type: T.Type, forKey key: Key) throws -> T? where T : Swift.Decodable
}
extension UnkeyedEncodingContainer {
  mutating public func encodeConditional<T>(_ object: T) throws where T : AnyObject, T : Swift.Encodable
  mutating public func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Bool
  mutating public func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.String
  mutating public func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Double
  mutating public func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Float
  mutating public func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int
  mutating public func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int8
  mutating public func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int16
  mutating public func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int32
  mutating public func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.Int64
  mutating public func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt
  mutating public func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt8
  mutating public func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt16
  mutating public func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt32
  mutating public func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element == Swift.UInt64
  mutating public func encode<T>(contentsOf sequence: T) throws where T : Swift.Sequence, T.Element : Swift.Encodable
}
extension UnkeyedDecodingContainer {
  mutating public func decodeIfPresent(_ type: Bool.Type) throws -> Bool?
  mutating public func decodeIfPresent(_ type: String.Type) throws -> String?
  mutating public func decodeIfPresent(_ type: Double.Type) throws -> Double?
  mutating public func decodeIfPresent(_ type: Float.Type) throws -> Float?
  mutating public func decodeIfPresent(_ type: Int.Type) throws -> Int?
  mutating public func decodeIfPresent(_ type: Int8.Type) throws -> Int8?
  mutating public func decodeIfPresent(_ type: Int16.Type) throws -> Int16?
  mutating public func decodeIfPresent(_ type: Int32.Type) throws -> Int32?
  mutating public func decodeIfPresent(_ type: Int64.Type) throws -> Int64?
  mutating public func decodeIfPresent(_ type: UInt.Type) throws -> UInt?
  mutating public func decodeIfPresent(_ type: UInt8.Type) throws -> UInt8?
  mutating public func decodeIfPresent(_ type: UInt16.Type) throws -> UInt16?
  mutating public func decodeIfPresent(_ type: UInt32.Type) throws -> UInt32?
  mutating public func decodeIfPresent(_ type: UInt64.Type) throws -> UInt64?
  mutating public func decodeIfPresent<T>(_ type: T.Type) throws -> T? where T : Swift.Decodable
}
@_fixed_layout public struct IndexingIterator<Elements> where Elements : Swift.Collection {
  @usableFromInline
  internal let _elements: Elements
  @usableFromInline
  internal var _position: Elements.Index
  @inlinable @inline(__always) public init(_elements: Elements) {
    self._elements = _elements
    self._position = _elements.startIndex
  }
  @inlinable @inline(__always) public init(_elements: Elements, _position: Elements.Index) {
    self._elements = _elements
    self._position = _position
  }
}
extension IndexingIterator : IteratorProtocol, Sequence {
  public typealias Element = Elements.Element
  public typealias Iterator = IndexingIterator<Elements>
  public typealias SubSequence = AnySequence<Element>
  @inlinable @inline(__always) mutating public func next() -> Elements.Element? {
    if _position == _elements.endIndex { return nil }
    let element = _elements[_position]
    _elements.formIndex(after: &_position)
    return element
  }
}
public protocol Collection : Swift.Sequence {
  @available(*, deprecated, message: "all index distances are now of type Int")
  typealias IndexDistance = Int
  override associatedtype Element
  associatedtype Index : Swift.Comparable where Self.Index == Self.Indices.Element, Self.Indices.Element == Self.Indices.Index, Self.Indices.Index == Self.SubSequence.Index, Self.SubSequence.Index == Self.Indices.Indices.Element, Self.Indices.Indices.Element == Self.Indices.Indices.Index, Self.Indices.Indices.Index == Self.SubSequence.Indices.Element, Self.SubSequence.Indices.Element == Self.SubSequence.Indices.Index, Self.SubSequence.Indices.Index == Self.SubSequence.Indices.Indices.Element, Self.SubSequence.Indices.Indices.Element == Self.SubSequence.Indices.Indices.Index
  var startIndex: Index { get }
  var endIndex: Index { get }
  associatedtype Iterator = Swift.IndexingIterator<Self>
  override __consuming func makeIterator() -> Iterator
  associatedtype SubSequence : Swift.Collection = Swift.Slice<Self> where Self.Element == Self.SubSequence.Element, Self.SubSequence == Self.SubSequence.SubSequence
  @_borrowed subscript(position: Index) -> Element { get }
  subscript(bounds: Range<Index>) -> SubSequence { get }
  associatedtype Indices : Swift.Collection = Swift.DefaultIndices<Self> where Self.Indices == Self.Indices.SubSequence
  var indices: Indices { get }
  var isEmpty: Bool { get }
  var count: Int { get }
  func _customIndexOfEquatableElement(_ element: Element) -> Index??
  func _customLastIndexOfEquatableElement(_ element: Element) -> Index??
  func index(_ i: Index, offsetBy distance: Int) -> Index
  func index(_ i: Index, offsetBy distance: Int, limitedBy limit: Index) -> Index?
  func distance(from start: Index, to end: Index) -> Int
  func _failEarlyRangeCheck(_ index: Index, bounds: Range<Index>)
  func _failEarlyRangeCheck(_ index: Index, bounds: ClosedRange<Index>)
  func _failEarlyRangeCheck(_ range: Range<Index>, bounds: Range<Index>)
  func index(after i: Index) -> Index
  func formIndex(after i: inout Index)
}
extension Collection {
  @inlinable @inline(__always) public func formIndex(after i: inout Index) {
    i = index(after: i)
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Index, bounds: Range<Index>) {
    // FIXME: swift-3-indexing-model: tests.
    _precondition(
      bounds.lowerBound <= index,
      "Out of bounds: index < startIndex")
    _precondition(
      index < bounds.upperBound,
      "Out of bounds: index >= endIndex")
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Index, bounds: ClosedRange<Index>) {
    // FIXME: swift-3-indexing-model: tests.
    _precondition(
      bounds.lowerBound <= index,
      "Out of bounds: index < startIndex")
    _precondition(
      index <= bounds.upperBound,
      "Out of bounds: index > endIndex")
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Range<Index>, bounds: Range<Index>) {
    // FIXME: swift-3-indexing-model: tests.
    _precondition(
      bounds.lowerBound <= range.lowerBound,
      "Out of bounds: range begins before startIndex")
    _precondition(
      range.lowerBound <= bounds.upperBound,
      "Out of bounds: range ends after endIndex")
    _precondition(
      bounds.lowerBound <= range.upperBound,
      "Out of bounds: range ends before bounds.lowerBound")
    _precondition(
      range.upperBound <= bounds.upperBound,
      "Out of bounds: range begins after bounds.upperBound")
  }
  @inlinable public func index(_ i: Index, offsetBy distance: Int) -> Index {
    return self._advanceForward(i, by: distance)
  }
  @inlinable public func index(_ i: Index, offsetBy distance: Int, limitedBy limit: Index) -> Index? {
    return self._advanceForward(i, by: distance, limitedBy: limit)
  }
  @inlinable public func formIndex(_ i: inout Index, offsetBy distance: Int) {
    i = index(i, offsetBy: distance)
  }
  @inlinable public func formIndex(_ i: inout Index, offsetBy distance: Int, limitedBy limit: Index) -> Bool {
    if let advancedIndex = index(i, offsetBy: distance, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    _precondition(start <= end,
      "Only BidirectionalCollections can have end come before start")

    var start = start
    var count = 0
    while start != end {
      count = count + 1
      formIndex(after: &start)
    }
    return count
  }
  @inlinable public func randomElement<T>(using generator: inout T) -> Element? where T : Swift.RandomNumberGenerator {
    guard !isEmpty else { return nil }
    let random = Int.random(in: 0 ..< count, using: &generator)
    let idx = index(startIndex, offsetBy: random)
    return self[idx]
  }
  @inlinable public func randomElement() -> Element? {
    var g = SystemRandomNumberGenerator()
    return randomElement(using: &g)
  }
  @inlinable @inline(__always) internal func _advanceForward(_ i: Index, by n: Int) -> Index {
    _precondition(n >= 0,
      "Only BidirectionalCollections can be advanced by a negative amount")

    var i = i
    for _ in stride(from: 0, to: n, by: 1) {
      formIndex(after: &i)
    }
    return i
  }
  @inlinable @inline(__always) internal func _advanceForward(_ i: Index, by n: Int, limitedBy limit: Index) -> Index? {
    _precondition(n >= 0,
      "Only BidirectionalCollections can be advanced by a negative amount")

    var i = i
    for _ in stride(from: 0, to: n, by: 1) {
      if i == limit {
        return nil
      }
      formIndex(after: &i)
    }
    return i
  }
}
extension Collection where Self.Iterator == Swift.IndexingIterator<Self> {
  @inlinable @inline(__always) __consuming public func makeIterator() -> IndexingIterator<Self> {
    return IndexingIterator(_elements: self)
  }
}
extension Collection where Self.SubSequence == Swift.Slice<Self> {
  @inlinable public subscript(bounds: Range<Index>) -> Slice<Self> {
    get {
    _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
    return Slice(base: self, bounds: bounds)
  }
  }
}
extension Collection where Self == Self.SubSequence {
  @inlinable mutating public func popFirst() -> Element? {
    // TODO: swift-3-indexing-model - review the following
    guard !isEmpty else { return nil }
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
}
extension Collection {
  @inlinable public var isEmpty: Bool {
    get {
    return startIndex == endIndex
  }
  }
  @inlinable public var first: Element? {
    get {
    let start = startIndex
    if start != endIndex { return self[start] }
    else { return nil }
  }
  }
  @inlinable public var underestimatedCount: Int {
    get {
    // TODO: swift-3-indexing-model - review the following
    return count
  }
  }
  @inlinable public var count: Int {
    get {
    return distance(from: startIndex, to: endIndex)
  }
  }
  @inlinable @inline(__always) public func _customIndexOfEquatableElement(_: Element) -> Index?? {
    return nil
  }
  @inlinable @inline(__always) public func _customLastIndexOfEquatableElement(_ element: Element) -> Index?? {
    return nil
  }
}
extension Collection {
  @inlinable public func map<T>(_ transform: (Element) throws -> T) rethrows -> [T] {
    // TODO: swift-3-indexing-model - review the following
    let n = self.count
    if n == 0 {
      return []
    }

    var result = ContiguousArray<T>()
    result.reserveCapacity(n)

    var i = self.startIndex

    for _ in 0..<n {
      result.append(try transform(self[i]))
      formIndex(after: &i)
    }

    _expectEnd(of: self, is: i)
    return Array(result)
  }
  @inlinable __consuming public func dropFirst(_ k: Int = 1) -> SubSequence {
    _precondition(k >= 0, "Can't drop a negative number of elements from a collection")
    let start = index(startIndex, offsetBy: k, limitedBy: endIndex) ?? endIndex
    return self[start..<endIndex]
  }
  @inlinable __consuming public func dropLast(_ k: Int = 1) -> SubSequence {
    _precondition(
      k >= 0, "Can't drop a negative number of elements from a collection")
    let amount = Swift.max(0, count - k)
    let end = index(startIndex,
      offsetBy: amount, limitedBy: endIndex) ?? endIndex
    return self[startIndex..<end]
  }
  @inlinable __consuming public func drop(while predicate: (Element) throws -> Bool) rethrows -> SubSequence {
    var start = startIndex
    while try start != endIndex && predicate(self[start]) {
      formIndex(after: &start)
    } 
    return self[start..<endIndex]
  }
  @inlinable __consuming public func prefix(_ maxLength: Int) -> SubSequence {
    _precondition(
      maxLength >= 0,
      "Can't take a prefix of negative length from a collection")
    let end = index(startIndex,
      offsetBy: maxLength, limitedBy: endIndex) ?? endIndex
    return self[startIndex..<end]
  }
  @inlinable __consuming public func prefix(while predicate: (Element) throws -> Bool) rethrows -> SubSequence {
    var end = startIndex
    while try end != endIndex && predicate(self[end]) {
      formIndex(after: &end)
    }
    return self[startIndex..<end]
  }
  @inlinable __consuming public func suffix(_ maxLength: Int) -> SubSequence {
    _precondition(
      maxLength >= 0,
      "Can't take a suffix of negative length from a collection")
    let amount = Swift.max(0, count - maxLength)
    let start = index(startIndex,
      offsetBy: amount, limitedBy: endIndex) ?? endIndex
    return self[start..<endIndex]
  }
  @inlinable __consuming public func prefix(upTo end: Index) -> SubSequence {
    return self[startIndex..<end]
  }
  @inlinable __consuming public func suffix(from start: Index) -> SubSequence {
    return self[start..<endIndex]
  }
  @inlinable __consuming public func prefix(through position: Index) -> SubSequence {
    return prefix(upTo: index(after: position))
  }
  @inlinable __consuming public func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (Element) throws -> Bool) rethrows -> [SubSequence] {
    // TODO: swift-3-indexing-model - review the following
    _precondition(maxSplits >= 0, "Must take zero or more splits")

    var result: [SubSequence] = []
    var subSequenceStart: Index = startIndex

    func appendSubsequence(end: Index) -> Bool {
      if subSequenceStart == end && omittingEmptySubsequences {
        return false
      }
      result.append(self[subSequenceStart..<end])
      return true
    }

    if maxSplits == 0 || isEmpty {
      _ = appendSubsequence(end: endIndex)
      return result
    }

    var subSequenceEnd = subSequenceStart
    let cachedEndIndex = endIndex
    while subSequenceEnd != cachedEndIndex {
      if try isSeparator(self[subSequenceEnd]) {
        let didAppend = appendSubsequence(end: subSequenceEnd)
        formIndex(after: &subSequenceEnd)
        subSequenceStart = subSequenceEnd
        if didAppend && result.count == maxSplits {
          break
        }
        continue
      }
      formIndex(after: &subSequenceEnd)
    }

    if subSequenceStart != cachedEndIndex || !omittingEmptySubsequences {
      result.append(self[subSequenceStart..<cachedEndIndex])
    }

    return result
  }
}
extension Collection where Self.Element : Swift.Equatable {
  @inlinable __consuming public func split(separator: Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [SubSequence] {
    // TODO: swift-3-indexing-model - review the following
    return split(
      maxSplits: maxSplits,
      omittingEmptySubsequences: omittingEmptySubsequences,
      whereSeparator: { $0 == separator })
  }
}
extension Collection where Self == Self.SubSequence {
  @discardableResult
  @inlinable mutating public func removeFirst() -> Element {
    // TODO: swift-3-indexing-model - review the following
    _precondition(!isEmpty, "Can't remove items from an empty collection")
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
  @inlinable mutating public func removeFirst(_ k: Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    _precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    self = self[index(startIndex, offsetBy: k)..<endIndex]
  }
}
extension BidirectionalCollection {
  @inlinable public var last: Element? {
    get {
    return isEmpty ? nil : self[index(before: endIndex)]
  }
  }
}
extension Collection where Self.Element : Swift.Equatable {
  @inlinable public func firstIndex(of element: Element) -> Index? {
    if let result = _customIndexOfEquatableElement(element) {
      return result
    }

    var i = self.startIndex
    while i != self.endIndex {
      if self[i] == element {
        return i
      }
      self.formIndex(after: &i)
    }
    return nil
  }
}
extension Collection {
  @inlinable public func firstIndex(where predicate: (Element) throws -> Bool) rethrows -> Index? {
    var i = self.startIndex
    while i != self.endIndex {
      if try predicate(self[i]) {
        return i
      }
      self.formIndex(after: &i)
    }
    return nil
  }
}
extension BidirectionalCollection {
  @inlinable public func last(where predicate: (Element) throws -> Bool) rethrows -> Element? {
    return try lastIndex(where: predicate).map { self[$0] }
  }
  @inlinable public func lastIndex(where predicate: (Element) throws -> Bool) rethrows -> Index? {
    var i = endIndex
    while i != startIndex {
      formIndex(before: &i)
      if try predicate(self[i]) {
        return i
      }
    }
    return nil
  }
}
extension BidirectionalCollection where Self.Element : Swift.Equatable {
  @inlinable public func lastIndex(of element: Element) -> Index? {
    if let result = _customLastIndexOfEquatableElement(element) {
      return result
    }
    return lastIndex(where: { $0 == element })
  }
}
extension MutableCollection {
  @inlinable mutating public func partition(by belongsInSecondPartition: (Element) throws -> Bool) rethrows -> Index {
    return try _halfStablePartition(isSuffixElement: belongsInSecondPartition)
  }
  @inlinable mutating internal func _halfStablePartition(isSuffixElement: (Element) throws -> Bool) rethrows -> Index {
    guard var i = try firstIndex(where: isSuffixElement)
    else { return endIndex }
    
    var j = index(after: i)
    while j != endIndex {
      if try !isSuffixElement(self[j]) { swapAt(i, j); formIndex(after: &i) }
      formIndex(after: &j)
    }
    return i
  }
}
extension MutableCollection where Self : Swift.BidirectionalCollection {
  @inlinable mutating public func partition(by belongsInSecondPartition: (Element) throws -> Bool) rethrows -> Index {
    let maybeOffset = try _withUnsafeMutableBufferPointerIfSupported {
      (bufferPointer) -> Int in
      let unsafeBufferPivot = try bufferPointer._partitionImpl(
        by: belongsInSecondPartition)
      return unsafeBufferPivot - bufferPointer.startIndex
    }
    if let offset = maybeOffset {
      return index(startIndex, offsetBy: offset)
    } else {
      return try _partitionImpl(by: belongsInSecondPartition)
    }
  }
  @usableFromInline
  mutating internal func _partitionImpl(by belongsInSecondPartition: (Element) throws -> Bool) rethrows -> Index
}
extension Sequence {
  @inlinable public func shuffled<T>(using generator: inout T) -> [Element] where T : Swift.RandomNumberGenerator {
    var result = ContiguousArray(self)
    result.shuffle(using: &generator)
    return Array(result)
  }
  @inlinable public func shuffled() -> [Element] {
    var g = SystemRandomNumberGenerator()
    return shuffled(using: &g)
  }
}
extension MutableCollection where Self : Swift.RandomAccessCollection {
  @inlinable mutating public func shuffle<T>(using generator: inout T) where T : Swift.RandomNumberGenerator {
    guard count > 1 else { return }
    var amount = count
    var currentIndex = startIndex
    while amount > 1 {
      let random = Int.random(in: 0 ..< amount, using: &generator)
      amount -= 1
      swapAt(
        currentIndex,
        index(currentIndex, offsetBy: random)
      )
      formIndex(after: &currentIndex)
    }
  }
  @inlinable mutating public func shuffle() {
    var g = SystemRandomNumberGenerator()
    shuffle(using: &g)
  }
}
public protocol Comparable : Swift.Equatable {
  static func < (lhs: Self, rhs: Self) -> Bool
  static func <= (lhs: Self, rhs: Self) -> Bool
  static func >= (lhs: Self, rhs: Self) -> Bool
  static func > (lhs: Self, rhs: Self) -> Bool
}
extension Comparable {
  @inlinable public static func > (lhs: Self, rhs: Self) -> Bool {
    return rhs < lhs
  }
  @inlinable public static func <= (lhs: Self, rhs: Self) -> Bool {
    return !(rhs < lhs)
  }
  @inlinable public static func >= (lhs: Self, rhs: Self) -> Bool {
    return !(lhs < rhs)
  }
}
public protocol RawRepresentable {
  associatedtype RawValue
  init?(rawValue: RawValue)
  var rawValue: RawValue { get }
}
@inlinable public func == <T>(lhs: T, rhs: T) -> Bool where T : Swift.RawRepresentable, T.RawValue : Swift.Equatable {
  return lhs.rawValue == rhs.rawValue
}
@inlinable public func != <T>(lhs: T, rhs: T) -> Bool where T : Swift.RawRepresentable, T.RawValue : Swift.Equatable {
  return lhs.rawValue != rhs.rawValue
}
@inlinable public func != <T>(lhs: T, rhs: T) -> Bool where T : Swift.Equatable, T : Swift.RawRepresentable, T.RawValue : Swift.Equatable {
  return lhs.rawValue != rhs.rawValue
}
extension RawRepresentable where Self : Swift.Hashable, Self.RawValue : Swift.Hashable {
  @inlinable public var hashValue: Int {
    get {
    return rawValue.hashValue
  }
  }
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine(rawValue)
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
    return rawValue._rawHashValue(seed: seed)
  }
}
public protocol CaseIterable {
  associatedtype AllCases : Swift.Collection where Self == Self.AllCases.Element
  static var allCases: AllCases { get }
}
public protocol ExpressibleByNilLiteral {
  init(nilLiteral: ())
}
public protocol _ExpressibleByBuiltinIntegerLiteral {
  init(_builtinIntegerLiteral value: Builtin.IntLiteral)
}
public protocol ExpressibleByIntegerLiteral {
  associatedtype IntegerLiteralType : Swift._ExpressibleByBuiltinIntegerLiteral
  init(integerLiteral value: IntegerLiteralType)
}
public protocol _ExpressibleByBuiltinFloatLiteral {
  init(_builtinFloatLiteral value: _MaxBuiltinFloatType)
}
public protocol ExpressibleByFloatLiteral {
  associatedtype FloatLiteralType : Swift._ExpressibleByBuiltinFloatLiteral
  init(floatLiteral value: FloatLiteralType)
}
public protocol _ExpressibleByBuiltinBooleanLiteral {
  init(_builtinBooleanLiteral value: Builtin.Int1)
}
public protocol ExpressibleByBooleanLiteral {
  associatedtype BooleanLiteralType : Swift._ExpressibleByBuiltinBooleanLiteral
  init(booleanLiteral value: BooleanLiteralType)
}
public protocol _ExpressibleByBuiltinUnicodeScalarLiteral {
  init(_builtinUnicodeScalarLiteral value: Builtin.Int32)
}
public protocol ExpressibleByUnicodeScalarLiteral {
  associatedtype UnicodeScalarLiteralType : Swift._ExpressibleByBuiltinUnicodeScalarLiteral
  init(unicodeScalarLiteral value: UnicodeScalarLiteralType)
}
public protocol _ExpressibleByBuiltinExtendedGraphemeClusterLiteral : Swift._ExpressibleByBuiltinUnicodeScalarLiteral {
  init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1)
}
public protocol ExpressibleByExtendedGraphemeClusterLiteral : Swift.ExpressibleByUnicodeScalarLiteral {
  associatedtype ExtendedGraphemeClusterLiteralType : Swift._ExpressibleByBuiltinExtendedGraphemeClusterLiteral
  init(extendedGraphemeClusterLiteral value: ExtendedGraphemeClusterLiteralType)
}
extension ExpressibleByExtendedGraphemeClusterLiteral where Self.ExtendedGraphemeClusterLiteralType == Self.UnicodeScalarLiteralType {
  @_transparent public init(unicodeScalarLiteral value: ExtendedGraphemeClusterLiteralType) {
    self.init(extendedGraphemeClusterLiteral: value)
  }
}
public protocol _ExpressibleByBuiltinStringLiteral : Swift._ExpressibleByBuiltinExtendedGraphemeClusterLiteral {
  init(_builtinStringLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1)
}
public protocol ExpressibleByStringLiteral : Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  associatedtype StringLiteralType : Swift._ExpressibleByBuiltinStringLiteral
  init(stringLiteral value: StringLiteralType)
}
extension ExpressibleByStringLiteral where Self.ExtendedGraphemeClusterLiteralType == Self.StringLiteralType {
  @_transparent public init(extendedGraphemeClusterLiteral value: StringLiteralType) {
    self.init(stringLiteral: value)
  }
}
public protocol ExpressibleByArrayLiteral {
  associatedtype ArrayLiteralElement
  init(arrayLiteral elements: ArrayLiteralElement...)
}
public protocol ExpressibleByDictionaryLiteral {
  associatedtype Key
  associatedtype Value
  init(dictionaryLiteral elements: (Key, Value)...)
}
public protocol ExpressibleByStringInterpolation : Swift.ExpressibleByStringLiteral {
  associatedtype StringInterpolation : Swift.StringInterpolationProtocol = Swift.DefaultStringInterpolation where Self.StringLiteralType == Self.StringInterpolation.StringLiteralType
  init(stringInterpolation: StringInterpolation)
}
extension ExpressibleByStringInterpolation where Self.StringInterpolation == Swift.DefaultStringInterpolation {
  public init(stringInterpolation: DefaultStringInterpolation)
}
public protocol StringInterpolationProtocol {
  associatedtype StringLiteralType : Swift._ExpressibleByBuiltinStringLiteral
  init(literalCapacity: Int, interpolationCount: Int)
  mutating func appendLiteral(_ literal: StringLiteralType)
}
public protocol _ExpressibleByColorLiteral {
  init(_colorLiteralRed red: Float, green: Float, blue: Float, alpha: Float)
}
public protocol _ExpressibleByImageLiteral {
  init(imageLiteralResourceName path: String)
}
public protocol _ExpressibleByFileReferenceLiteral {
  init(fileReferenceLiteralResourceName path: String)
}
public protocol _DestructorSafeContainer {
}
@_fixed_layout public struct ContiguousArray<Element> : _DestructorSafeContainer {
  @usableFromInline
  internal typealias _Buffer = _ContiguousArrayBuffer<Element>
  @usableFromInline
  internal var _buffer: _Buffer
  @inlinable internal init(_buffer: _Buffer) {
    self._buffer = _buffer
  }
}
extension ContiguousArray {
  @inlinable @_semantics("array.get_count") internal func _getCount() -> Int {
    return _buffer.count
  }
  @inlinable @_semantics("array.get_capacity") internal func _getCapacity() -> Int {
    return _buffer.capacity
  }
  @inlinable @_semantics("array.make_mutable") mutating internal func _makeMutableAndUnique() {
    if _slowPath(!_buffer.isMutableAndUniquelyReferenced()) {
      _buffer = _Buffer(copying: _buffer)
    }
  }
  @inlinable @inline(__always) internal func _checkSubscript_native(_ index: Int) {
    _buffer._checkValidSubscript(index)
  }
  @inlinable @_semantics("array.check_index") internal func _checkIndex(_ index: Int) {
    _precondition(index <= endIndex, "ContiguousArray index is out of range")
    _precondition(index >= startIndex, "Negative ContiguousArray index is out of range")
  }
  @inlinable @_semantics("array.get_element_address") internal func _getElementAddress(_ index: Int) -> UnsafeMutablePointer<Element> {
    return _buffer.subscriptBaseAddress + index
  }
}
extension ContiguousArray : _ArrayProtocol {
  @inlinable public var capacity: Int {
    get {
    return _getCapacity()
  }
  }
  @inlinable public var _owner: AnyObject? {
    get {
    return _buffer.owner
  }
  }
  @inlinable public var _baseAddressIfContiguous: UnsafeMutablePointer<Element>? {
    @inline(__always) get { return _buffer.firstElementAddressIfContiguous }
  }
  @inlinable internal var _baseAddress: UnsafeMutablePointer<Element> {
    get {
    return _buffer.firstElementAddress
  }
  }
}
extension ContiguousArray : RandomAccessCollection, MutableCollection {
  public typealias Index = Int
  public typealias Indices = Range<Int>
  public typealias Iterator = IndexingIterator<ContiguousArray>
  @inlinable public var startIndex: Int {
    get {
    return 0
  }
  }
  public var endIndex: Int {
    @inlinable get {
      return _getCount()
    }
  }
  @inlinable public func index(after i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + 1
  }
  @inlinable public func formIndex(after i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i += 1
  }
  @inlinable public func index(before i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i - 1
  }
  @inlinable public func formIndex(before i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i -= 1
  }
  @inlinable public func index(_ i: Int, offsetBy distance: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + distance
  }
  @inlinable public func index(_ i: Int, offsetBy distance: Int, limitedBy limit: Int) -> Int? {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    let l = limit - i
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return i + distance
  }
  @inlinable public func distance(from start: Int, to end: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return end - start
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Int, bounds: Range<Int>) {
    // NOTE: This method is a no-op for performance reasons.
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Range<Int>, bounds: Range<Int>) {
    // NOTE: This method is a no-op for performance reasons.
  }
  @inlinable public subscript(index: Int) -> Element {
    get {
      _checkSubscript_native(index)
      return _buffer.getElement(index)
    }
    _modify {
      _makeMutableAndUnique()
      _checkSubscript_native(index)
      let address = _buffer.subscriptBaseAddress + index
      yield &address.pointee
    }
  }
  @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> {
    get {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      return ArraySlice(_buffer: _buffer[bounds])
    }
    set(rhs) {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      // If the replacement buffer has same identity, and the ranges match,
      // then this was a pinned in-place modification, nothing further needed.
      if self[bounds]._buffer.identity != rhs._buffer.identity
      || bounds != rhs.startIndex..<rhs.endIndex {
        self.replaceSubrange(bounds, with: rhs)
      }
    }
  }
  @inlinable public var count: Int {
    get {
    return _getCount()
  }
  }
}
extension ContiguousArray : ExpressibleByArrayLiteral {
  @inlinable public init(arrayLiteral elements: Element...) {
    self.init(_buffer: ContiguousArray(elements)._buffer)
  }
  public typealias ArrayLiteralElement = Element
}
extension ContiguousArray : RangeReplaceableCollection {
  @inlinable @_semantics("array.init") public init() {
    _buffer = _Buffer()
  }
  @inlinable public init<S>(_ s: S) where Element == S.Element, S : Swift.Sequence {
    self.init(_buffer: s._copyToContiguousArray()._buffer)
  }
  @inlinable @_semantics("array.init") public init(repeating repeatedValue: Element, count: Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = ContiguousArray._allocateUninitialized(count)
    for _ in 0..<count {
      p.initialize(to: repeatedValue)
      p += 1
    }
  }
  @usableFromInline
  @inline(never) internal static func _allocateBufferUninitialized(minimumCapacity: Int) -> _Buffer
  @inlinable internal init(_uninitializedCount count: Int) {
    _precondition(count >= 0, "Can't construct ContiguousArray with count < 0")
    // Note: Sinking this constructor into an else branch below causes an extra
    // Retain/Release.
    _buffer = _Buffer()
    if count > 0 {
      // Creating a buffer instead of calling reserveCapacity saves doing an
      // unnecessary uniqueness check. We disable inlining here to curb code
      // growth.
      _buffer = ContiguousArray._allocateBufferUninitialized(minimumCapacity: count)
      _buffer.count = count
    }
    // Can't store count here because the buffer might be pointing to the
    // shared empty array.
  }
  @inlinable @_semantics("array.uninitialized") internal static func _allocateUninitialized(_ count: Int) -> (ContiguousArray, UnsafeMutablePointer<Element>) {
    let result = ContiguousArray(_uninitializedCount: count)
    return (result, result._buffer.firstElementAddress)
  }
  @inlinable @_semantics("array.mutate_unknown") mutating public func reserveCapacity(_ minimumCapacity: Int) {
    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: minimumCapacity) == nil {

      let newBuffer = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: count, minimumCapacity: minimumCapacity)

      _buffer._copyContents(
        subRange: _buffer.indices,
        initializing: newBuffer.firstElementAddress)
      _buffer = _Buffer(
        _buffer: newBuffer, shiftedToStartIndex: _buffer.startIndex)
    }
    _internalInvariant(capacity >= minimumCapacity)
  }
  @inline(never) @inlinable mutating internal func _copyToNewBuffer(oldCount: Int) {
    let newCount = oldCount + 1
    var newBuffer = _buffer._forceCreateUniqueMutableBuffer(
      countForNewBuffer: oldCount, minNewCapacity: newCount)
    _buffer._arrayOutOfPlaceUpdate(
      &newBuffer, oldCount, 0)
  }
  @inlinable @_semantics("array.make_mutable") mutating internal func _makeUniqueAndReserveCapacityIfNotUnique() {
    if _slowPath(!_buffer.isMutableAndUniquelyReferenced()) {
      _copyToNewBuffer(oldCount: _buffer.count)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") mutating internal func _reserveCapacityAssumingUniqueBuffer(oldCount: Int) {
    // This is a performance optimization. This code used to be in an ||
    // statement in the _internalInvariant below.
    //
    //   _internalInvariant(_buffer.capacity == 0 ||
    //                _buffer.isMutableAndUniquelyReferenced())
    //
    // SR-6437
    let capacity = _buffer.capacity == 0

    // Due to make_mutable hoisting the situation can arise where we hoist
    // _makeMutableAndUnique out of loop and use it to replace
    // _makeUniqueAndReserveCapacityIfNotUnique that preceeds this call. If the
    // array was empty _makeMutableAndUnique does not replace the empty array
    // buffer by a unique buffer (it just replaces it by the empty array
    // singleton).
    // This specific case is okay because we will make the buffer unique in this
    // function because we request a capacity > 0 and therefore _copyToNewBuffer
    // will be called creating a new buffer.
    _internalInvariant(capacity ||
                 _buffer.isMutableAndUniquelyReferenced())

    if _slowPath(oldCount + 1 > _buffer.capacity) {
      _copyToNewBuffer(oldCount: oldCount)
    }
  }
  @inlinable @_semantics("array.mutate_unknown") mutating internal func _appendElementAssumeUniqueAndCapacity(_ oldCount: Int, newElement: __owned Element) {
    _internalInvariant(_buffer.isMutableAndUniquelyReferenced())
    _internalInvariant(_buffer.capacity >= _buffer.count + 1)

    _buffer.count = oldCount + 1
    (_buffer.firstElementAddress + oldCount).initialize(to: newElement)
  }
  @inlinable @_semantics("array.append_element") mutating public func append(_ newElement: __owned Element) {
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _getCount()
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
  }
  @inlinable @_semantics("array.append_contentsOf") mutating public func append<S>(contentsOf newElements: __owned S) where Element == S.Element, S : Swift.Sequence {

    let newElementsCount = newElements.underestimatedCount
    reserveCapacityForAppend(newElementsCount: newElementsCount)

    let oldCount = self.count
    let startNewElements = _buffer.firstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements, 
                count: self.capacity - oldCount)

    let (remainder,writtenUpTo) = buf.initialize(from: newElements)
    
    // trap on underflow from the sequence's underestimate:
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    _precondition(newElementsCount <= writtenCount, 
      "newElements.underestimatedCount was an overestimate")
    // can't check for overflow as sequences can underestimate

    _buffer.count += writtenCount

    if writtenUpTo == buf.endIndex {
      // there may be elements that didn't fit in the existing buffer,
      // append them in slow sequence-only mode
      _buffer._arrayAppendSequence(IteratorSequence(remainder))
    }
  }
  @inlinable @_semantics("array.reserve_capacity_for_append") mutating internal func reserveCapacityForAppend(newElementsCount: Int) {
    let oldCount = self.count
    let oldCapacity = self.capacity
    let newCount = oldCount + newElementsCount

    // Ensure uniqueness, mutability, and sufficient storage.  Note that
    // for consistency, we need unique self even if newElements is empty.
    self.reserveCapacity(
      newCount > oldCapacity ?
      Swift.max(newCount, _growArrayCapacity(oldCapacity))
      : newCount)
  }
  @inlinable mutating public func _customRemoveLast() -> Element? {
    let newCount = _getCount() - 1
    _precondition(newCount >= 0, "Can't removeLast from an empty ContiguousArray")
    _makeUniqueAndReserveCapacityIfNotUnique()
    let pointer = (_buffer.firstElementAddress + newCount)
    let element = pointer.move()
    _buffer.count = newCount
    return element
  }
  @discardableResult
  @inlinable mutating public func remove(at index: Int) -> Element {
    _precondition(index < endIndex, "Index out of range")
    _precondition(index >= startIndex, "Index out of range")
    _makeUniqueAndReserveCapacityIfNotUnique()
    let newCount = _getCount() - 1
    let pointer = (_buffer.firstElementAddress + index)
    let result = pointer.move()
    pointer.moveInitialize(from: pointer + 1, count: newCount - index)
    _buffer.count = newCount
    return result
  }
  @inlinable mutating public func insert(_ newElement: __owned Element, at i: Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
  @inlinable mutating public func removeAll(keepingCapacity keepCapacity: Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
  }
  @inlinable mutating public func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable mutating public func withContiguousMutableStorageIfAvailable<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try withUnsafeBufferPointer {
      (bufferPointer) -> R in
      return try body(bufferPointer)
    }
  }
  @inlinable __consuming public func _copyToContiguousArray() -> ContiguousArray<Element> {
    if let n = _buffer.requestNativeBuffer() {
      return ContiguousArray(_buffer: n)
    }
    return _copyCollectionToContiguousArray(self)
  }
  public typealias SubSequence = Swift.ArraySlice<Element>
}
extension ContiguousArray : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension ContiguousArray : CustomStringConvertible, CustomDebugStringConvertible {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
}
extension ContiguousArray {
  @usableFromInline
  @_transparent internal func _cPointerArgs() -> (AnyObject?, UnsafeRawPointer?) {
    let p = _baseAddressIfContiguous
    if _fastPath(p != nil || isEmpty) {
      return (_owner, UnsafeRawPointer(p))
    }
    let n = ContiguousArray(self._buffer)._buffer
    return (n.owner, UnsafeRawPointer(n.firstElementAddress))
  }
}
extension ContiguousArray {
  @_alwaysEmitIntoClient @inlinable public init(unsafeUninitializedCapacity: Int, initializingWith initializer: (_ buffer: inout UnsafeMutableBufferPointer<Element>, _ initializedCount: inout Int) throws -> Void) rethrows {
    self = try ContiguousArray(Array(
      _unsafeUninitializedCapacity: unsafeUninitializedCapacity,
      initializingWith: initializer))
  }
  @inlinable public func withUnsafeBufferPointer<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
  @_semantics("array.withUnsafeMutableBufferPointer") @inlinable @inline(__always) mutating public func withUnsafeMutableBufferPointer<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    let count = self.count
    // Ensure unique storage
    _buffer._outlinedMakeUniqueBuffer(bufferCount: count)

    // Ensure that body can't invalidate the storage or its bounds by
    // moving self into a temporary working array.
    // NOTE: The stack promotion optimization that keys of the
    // "array.withUnsafeMutableBufferPointer" semantics annotation relies on the
    // array buffer not being able to escape in the closure. It can do this
    // because we swap the array buffer in self with an empty buffer here. Any
    // escape via the address of self in the closure will therefore escape the
    // empty array.

    var work = ContiguousArray()
    (work, self) = (self, work)

    // Create an UnsafeBufferPointer over work that we can pass to body
    let pointer = work._buffer.firstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    // Put the working array back before returning.
    defer {
      _precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "ContiguousArray withUnsafeMutableBufferPointer: replacing the buffer is not allowed")

      (work, self) = (self, work)
    }

    // Invoke the body.
    return try body(&inoutBufferPointer)
  }
  @inlinable __consuming public func _copyContents(initializing buffer: UnsafeMutableBufferPointer<Element>) -> (Iterator, UnsafeMutableBufferPointer<Element>.Index) {

    guard !self.isEmpty else { return (makeIterator(),buffer.startIndex) }

    // It is not OK for there to be no pointer/not enough space, as this is
    // a precondition and Array never lies about its count.
    guard var p = buffer.baseAddress
      else { _preconditionFailure("Attempt to copy contents into nil buffer pointer") }
    _precondition(self.count <= buffer.count, 
      "Insufficient space allocated to copy array contents")

    if let s = _baseAddressIfContiguous {
      p.initialize(from: s, count: self.count)
      // Need a _fixLifetime bracketing the _baseAddressIfContiguous getter
      // and all uses of the pointer it returns:
      _fixLifetime(self._owner)
    } else {
      for x in self {
        p.initialize(to: x)
        p += 1
      }
    }

    var it = IndexingIterator(_elements: self)
    it._position = endIndex
    return (it,buffer.index(buffer.startIndex, offsetBy: self.count))
  }
}
extension ContiguousArray {
  @inlinable @_semantics("array.mutate_unknown") mutating public func replaceSubrange<C>(_ subrange: Range<Int>, with newElements: __owned C) where Element == C.Element, C : Swift.Collection {
    _precondition(subrange.lowerBound >= self._buffer.startIndex,
      "ContiguousArray replace: subrange start is negative")

    _precondition(subrange.upperBound <= _buffer.endIndex,
      "ContiguousArray replace: subrange extends past the end")

    let oldCount = _buffer.count
    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: oldCount + growth) != nil {

      _buffer.replaceSubrange(
        subrange, with: insertCount, elementsOf: newElements)
    } else {
      _buffer._arrayOutOfPlaceReplace(subrange, with: newElements, count: insertCount)
    }
  }
}
extension ContiguousArray : Equatable where Element : Swift.Equatable {
  @inlinable public static func == (lhs: ContiguousArray<Element>, rhs: ContiguousArray<Element>) -> Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

    // Test referential equality.
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    _internalInvariant(lhs.startIndex == 0 && rhs.startIndex == 0)
    _internalInvariant(lhs.endIndex == lhsCount && rhs.endIndex == lhsCount)

    // We know that lhs.count == rhs.count, compare element wise.
    for idx in 0..<lhsCount {
      if lhs[idx] != rhs[idx] {
        return false
      }
    }

    return true
  }
}
extension ContiguousArray : Hashable where Element : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine(count) // discriminator
    for element in self {
      hasher.combine(element)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension ContiguousArray {
  @inlinable mutating public func withUnsafeMutableBytes<R>(_ body: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeMutableBufferPointer {
      return try body(UnsafeMutableRawBufferPointer($0))
    }
  }
  @inlinable public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    return try self.withUnsafeBufferPointer {
      try body(UnsafeRawBufferPointer($0))
    }
  }
}
@usableFromInline
internal protocol _HasContiguousBytes {
  func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
  var _providesContiguousBytesNoCopy: Bool { get }
}
extension _HasContiguousBytes {
  @inlinable internal var _providesContiguousBytesNoCopy: Bool {
    @inline(__always) get { return true }
  }
}
extension Array : _HasContiguousBytes {
  @inlinable internal var _providesContiguousBytesNoCopy: Bool {
    @inline(__always) get {
      return _buffer._isNative
    }
  }
}
extension ContiguousArray : _HasContiguousBytes {
}
extension UnsafeBufferPointer : _HasContiguousBytes {
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    let ptr = UnsafeRawPointer(self.baseAddress)
    let len = self.count &* MemoryLayout<Element>.stride
    return try body(UnsafeRawBufferPointer(start: ptr, count: len))
  }
}
extension UnsafeMutableBufferPointer : _HasContiguousBytes {
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    let ptr = UnsafeRawPointer(self.baseAddress)
    let len = self.count &* MemoryLayout<Element>.stride
    return try body(UnsafeRawBufferPointer(start: ptr, count: len))
  }
}
extension UnsafeRawBufferPointer : _HasContiguousBytes {
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    return try body(self)
  }
}
extension UnsafeMutableRawBufferPointer : _HasContiguousBytes {
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    return try body(UnsafeRawBufferPointer(self))
  }
}
extension String : _HasContiguousBytes {
  @inlinable internal var _providesContiguousBytesNoCopy: Bool {
    @inline(__always) get { return self._guts.isFastUTF8 }
  }
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    var copy = self
    return try copy.withUTF8 { return try body(UnsafeRawBufferPointer($0)) }
  }
}
extension Substring : _HasContiguousBytes {
  @inlinable internal var _providesContiguousBytesNoCopy: Bool {
    @inline(__always) get { return self._wholeGuts.isFastUTF8 }
  }
  @inlinable @inline(__always) internal func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
    var copy = self
    return try copy.withUTF8 { return try body(UnsafeRawBufferPointer($0)) }
  }
}
@_fixed_layout public struct ClosedRange<Bound> where Bound : Swift.Comparable {
  public let lowerBound: Bound
  public let upperBound: Bound
  @inlinable public init(uncheckedBounds bounds: (lower: Bound, upper: Bound)) {
    self.lowerBound = bounds.lower
    self.upperBound = bounds.upper
  }
}
extension ClosedRange {
  @inlinable public var isEmpty: Bool {
    get {
    return false
  }
  }
}
extension ClosedRange : RangeExpression {
  @inlinable public func relative<C>(to collection: C) -> Range<Bound> where Bound == C.Index, C : Swift.Collection {
    return Range(
      uncheckedBounds: (
        lower: lowerBound, upper: collection.index(after: self.upperBound)))
  }
  @inlinable public func contains(_ element: Bound) -> Bool {
    return element >= self.lowerBound && element <= self.upperBound
  }
}
extension ClosedRange : Sequence where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public typealias Element = Bound
  public typealias Iterator = IndexingIterator<ClosedRange<Bound>>
}
extension ClosedRange where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  @_frozen public enum Index {
    case pastEnd
    case inRange(Bound)
  }
}
extension ClosedRange.Index : Comparable {
  @inlinable public static func == (lhs: ClosedRange<Bound>.Index, rhs: ClosedRange<Bound>.Index) -> Bool {
    switch (lhs, rhs) {
    case (.inRange(let l), .inRange(let r)):
      return l == r
    case (.pastEnd, .pastEnd):
      return true
    default:
      return false
    }
  }
  @inlinable public static func < (lhs: ClosedRange<Bound>.Index, rhs: ClosedRange<Bound>.Index) -> Bool {
    switch (lhs, rhs) {
    case (.inRange(let l), .inRange(let r)):
      return l < r
    case (.inRange, .pastEnd):
      return true
    default:
      return false
    }
  }
}
extension ClosedRange.Index : Hashable where Bound : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    switch self {
    case .inRange(let value):
      hasher.combine(0 as Int8)
      hasher.combine(value)
    case .pastEnd:
      hasher.combine(1 as Int8)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension ClosedRange : Collection, BidirectionalCollection, RandomAccessCollection where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public typealias SubSequence = Slice<ClosedRange<Bound>>
  @inlinable public var startIndex: Index {
    get {
    return .inRange(lowerBound)
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return .pastEnd
  }
  }
  @inlinable public func index(after i: Index) -> Index {
    switch i {
    case .inRange(let x):
      return x == upperBound
        ? .pastEnd
        : .inRange(x.advanced(by: 1))
    case .pastEnd: 
      _preconditionFailure("Incrementing past end index")
    }
  }
  @inlinable public func index(before i: Index) -> Index {
    switch i {
    case .inRange(let x):
      _precondition(x > lowerBound, "Incrementing past start index")
      return .inRange(x.advanced(by: -1))
    case .pastEnd: 
      _precondition(upperBound >= lowerBound, "Incrementing past start index")
      return .inRange(upperBound)
    }
  }
  @inlinable public func index(_ i: Index, offsetBy distance: Int) -> Index {
    switch i {
    case .inRange(let x):
      let d = x.distance(to: upperBound)
      if distance <= d {
        let newPosition = x.advanced(by: numericCast(distance))
        _precondition(newPosition >= lowerBound,
          "Advancing past start index")
        return .inRange(newPosition)
      }
      if d - -1 == distance { return .pastEnd }
      _preconditionFailure("Advancing past end index")
    case .pastEnd:
      if distance == 0 {
        return i
      } 
      if distance < 0 {
        return index(.inRange(upperBound), offsetBy: numericCast(distance + 1))
      }
      _preconditionFailure("Advancing past end index")
    }
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    switch (start, end) {
    case let (.inRange(left), .inRange(right)):
      // in range <--> in range
      return numericCast(left.distance(to: right))
    case let (.inRange(left), .pastEnd):
      // in range --> end
      return numericCast(1 + left.distance(to: upperBound))
    case let (.pastEnd, .inRange(right)):
      // in range <-- end
      return numericCast(upperBound.distance(to: right) - 1)
    case (.pastEnd, .pastEnd):
      // end <--> end
      return 0
    }
  }
  @inlinable public subscript(position: Index) -> Bound {
    get {
    // FIXME: swift-3-indexing-model: range checks and tests.
    switch position {
    case .inRange(let x): return x
    case .pastEnd: _preconditionFailure("Index out of range")
    }
  }
  }
  @inlinable public subscript(bounds: Range<Index>) -> Slice<ClosedRange<Bound>> {
    get {
    return Slice(base: self, bounds: bounds)
  }
  }
  @inlinable public func _customContainsEquatableElement(_ element: Bound) -> Bool? {
    return lowerBound <= element && element <= upperBound
  }
  @inlinable public func _customIndexOfEquatableElement(_ element: Bound) -> Index?? {
    return lowerBound <= element && element <= upperBound
              ? .inRange(element) : nil
  }
  @inlinable public func _customLastIndexOfEquatableElement(_ element: Bound) -> Index?? {
    // The first and last elements are the same because each element is unique.
    return _customIndexOfEquatableElement(element)
  }
  public typealias Indices = Swift.DefaultIndices<Swift.ClosedRange<Bound>>
}
extension Comparable {
  @_transparent public static func ... (minimum: Self, maximum: Self) -> ClosedRange<Self> {
    _precondition(
      minimum <= maximum, "Can't form Range with upperBound < lowerBound")
    return ClosedRange(uncheckedBounds: (lower: minimum, upper: maximum))
  }
}
extension ClosedRange : Equatable {
  @inlinable public static func == (lhs: ClosedRange<Bound>, rhs: ClosedRange<Bound>) -> Bool {
    return lhs.lowerBound == rhs.lowerBound && lhs.upperBound == rhs.upperBound
  }
}
extension ClosedRange : Hashable where Bound : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine(lowerBound)
    hasher.combine(upperBound)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension ClosedRange : CustomStringConvertible {
  @inlinable public var description: String {
    get {
    return "\(lowerBound)...\(upperBound)"
  }
  }
}
extension ClosedRange : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension ClosedRange : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension ClosedRange {
  @inlinable @inline(__always) public func clamped(to limits: ClosedRange) -> ClosedRange {
    let lower =         
      limits.lowerBound > self.lowerBound ? limits.lowerBound
          : limits.upperBound < self.lowerBound ? limits.upperBound
          : self.lowerBound
    let upper =
      limits.upperBound < self.upperBound ? limits.upperBound
          : limits.lowerBound > self.upperBound ? limits.lowerBound
          : self.upperBound
    return ClosedRange(uncheckedBounds: (lower: lower, upper: upper))
  }
}
extension ClosedRange where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  @inlinable public init(_ other: Range<Bound>) {
    _precondition(!other.isEmpty, "Can't form an empty closed range")
    let upperBound = other.upperBound.advanced(by: -1)
    self.init(uncheckedBounds: (lower: other.lowerBound, upper: upperBound))
  }
}
extension ClosedRange {
  @inlinable public func overlaps(_ other: ClosedRange<Bound>) -> Bool {
    return self.contains(other.lowerBound) || other.contains(lowerBound)
  }
  @inlinable public func overlaps(_ other: Range<Bound>) -> Bool {
    return other.overlaps(self)
  }
}
public typealias CountableClosedRange<Bound> = ClosedRange<Bound> where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger
extension ClosedRange : Decodable where Bound : Swift.Decodable {
  public init(from decoder: Decoder) throws
}
extension ClosedRange : Encodable where Bound : Swift.Encodable {
  public func encode(to encoder: Encoder) throws
}
@objc @usableFromInline
@_fixed_layout @_objc_non_lazy_realization final internal class __EmptyArrayStorage : __ContiguousArrayStorageBase {
  @inlinable @nonobjc internal init(_doNotCallMe: ()) {
    _internalInvariantFailure("creating instance of __EmptyArrayStorage")
  }
  @inlinable override final internal func canStoreElements(ofDynamicType _: Any.Type) -> Bool {
    return false
  }
  @inlinable override final internal var staticElementType: Any.Type {
    get {
    return Void.self
  }
  }
  @inlinable override internal init(_doNotCallMeBase: ())
  @objc @usableFromInline
  deinit
}
@inlinable internal var _emptyArrayStorage: __EmptyArrayStorage {
  get {
  return Builtin.bridgeFromRawPointer(
    Builtin.addressof(&_swiftEmptyArrayStorage))
}
}
@usableFromInline
@_fixed_layout final internal class _ContiguousArrayStorage<Element> : __ContiguousArrayStorageBase {
  @objc @inlinable deinit {
    _elementPointer.deinitialize(count: countAndCapacity.count)
    _fixLifetime(self)
  }
  @inlinable override final internal func canStoreElements(ofDynamicType proposedElementType: Any.Type) -> Bool {
    return proposedElementType is Element.Type
  }
  @inlinable override final internal var staticElementType: Any.Type {
    get {
    return Element.self
  }
  }
  @inlinable final internal var _elementPointer: UnsafeMutablePointer<Element> {
    get {
    return UnsafeMutablePointer(Builtin.projectTailElems(self, Element.self))
  }
  }
  @inlinable override internal init(_doNotCallMeBase: ())
}
@usableFromInline
@_fixed_layout internal struct _ContiguousArrayBuffer<Element> : _ArrayBufferProtocol {
  @inlinable internal init(_uninitializedCount uninitializedCount: Int, minimumCapacity: Int) {
    let realMinimumCapacity = Swift.max(uninitializedCount, minimumCapacity)
    if realMinimumCapacity == 0 {
      self = _ContiguousArrayBuffer<Element>()
    }
    else {
      _storage = Builtin.allocWithTailElems_1(
         _ContiguousArrayStorage<Element>.self,
         realMinimumCapacity._builtinWordValue, Element.self)

      let storageAddr = UnsafeMutableRawPointer(Builtin.bridgeToRawPointer(_storage))
      let endAddr = storageAddr + _swift_stdlib_malloc_size(storageAddr)
      let realCapacity = endAddr.assumingMemoryBound(to: Element.self) - firstElementAddress

      _initStorageHeader(
        count: uninitializedCount, capacity: realCapacity)
    }
  }
  @inlinable internal init(count: Int, storage: _ContiguousArrayStorage<Element>) {
    _storage = storage

    _initStorageHeader(count: count, capacity: count)
  }
  @inlinable internal init(_ storage: __ContiguousArrayStorageBase) {
    _storage = storage
  }
  @inlinable internal func _initStorageHeader(count: Int, capacity: Int) {
    let verbatim = _isBridgedVerbatimToObjectiveC(Element.self)

    // We can initialize by assignment because _ArrayBody is a trivial type,
    // i.e. contains no references.
    _storage.countAndCapacity = _ArrayBody(
      count: count,
      capacity: capacity,
      elementTypeIsBridgedVerbatim: verbatim)
  }
  @inlinable internal var arrayPropertyIsNativeTypeChecked: Bool {
    get {
    return true
  }
  }
  @inlinable internal var firstElementAddress: UnsafeMutablePointer<Element> {
    get {
    return UnsafeMutablePointer(Builtin.projectTailElems(_storage,
                                                         Element.self))
  }
  }
  @inlinable internal var firstElementAddressIfContiguous: UnsafeMutablePointer<Element>? {
    get {
    return firstElementAddress
  }
  }
  @inlinable internal func withUnsafeBufferPointer<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(UnsafeBufferPointer(start: firstElementAddress,
      count: count))
  }
  @inlinable mutating internal func withUnsafeMutableBufferPointer<R>(_ body: (UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(
      UnsafeMutableBufferPointer(start: firstElementAddress, count: count))
  }
  @inlinable internal init() {
    _storage = _emptyArrayStorage
  }
  @inlinable internal init(_buffer buffer: _ContiguousArrayBuffer, shiftedToStartIndex: Int) {
    _internalInvariant(shiftedToStartIndex == 0, "shiftedToStartIndex must be 0")
    self = buffer
  }
  @inlinable mutating internal func requestUniqueMutableBackingBuffer(minimumCapacity: Int) -> _ContiguousArrayBuffer<Element>? {
    if _fastPath(isUniquelyReferenced() && capacity >= minimumCapacity) {
      return self
    }
    return nil
  }
  @inlinable mutating internal func isMutableAndUniquelyReferenced() -> Bool {
    return isUniquelyReferenced()
  }
  @inlinable internal func requestNativeBuffer() -> _ContiguousArrayBuffer<Element>? {
    return self
  }
  @inlinable @inline(__always) internal func getElement(_ i: Int) -> Element {
    _internalInvariant(i >= 0 && i < count, "Array index out of range")
    return firstElementAddress[i]
  }
  @inlinable internal subscript(i: Int) -> Element {
    @inline(__always) get {
      return getElement(i)
    }
    @inline(__always) nonmutating set {
      _internalInvariant(i >= 0 && i < count, "Array index out of range")

      // FIXME: Manually swap because it makes the ARC optimizer happy.  See
      // <rdar://problem/16831852> check retain/release order
      // firstElementAddress[i] = newValue
      var nv = newValue
      let tmp = nv
      nv = firstElementAddress[i]
      firstElementAddress[i] = tmp
    }
  }
  @inlinable internal var count: Int {
    get {
      return _storage.countAndCapacity.count
    }
    nonmutating set {
      _internalInvariant(newValue >= 0)

      _internalInvariant(
        newValue <= capacity,
        "Can't grow an array buffer past its capacity")

      _storage.countAndCapacity.count = newValue
    }
  }
  @inlinable @inline(__always) internal func _checkValidSubscript(_ index: Int) {
    _precondition(
      (index >= 0) && (index < count),
      "Index out of range"
    )
  }
  @inlinable internal var capacity: Int {
    get {
    return _storage.countAndCapacity.capacity
  }
  }
  @discardableResult
  @inlinable __consuming internal func _copyContents(subRange bounds: Range<Int>, initializing target: UnsafeMutablePointer<Element>) -> UnsafeMutablePointer<Element> {
    _internalInvariant(bounds.lowerBound >= 0)
    _internalInvariant(bounds.upperBound >= bounds.lowerBound)
    _internalInvariant(bounds.upperBound <= count)

    let initializedCount = bounds.upperBound - bounds.lowerBound
    target.initialize(
      from: firstElementAddress + bounds.lowerBound, count: initializedCount)
    _fixLifetime(owner)
    return target + initializedCount
  }
  __consuming public func _copyContents(initializing buffer: UnsafeMutableBufferPointer<Element>) -> (Iterator, UnsafeMutableBufferPointer<Element>.Index)
  @inlinable internal subscript(bounds: Range<Int>) -> _SliceBuffer<Element> {
    get {
      return _SliceBuffer(
        owner: _storage,
        subscriptBaseAddress: subscriptBaseAddress,
        indices: bounds,
        hasNativeBuffer: true)
    }
    set {
      fatalError("not implemented")
    }
  }
  @inlinable mutating internal func isUniquelyReferenced() -> Bool {
    return _isUnique(&_storage)
  }
  @inlinable __consuming internal func _asCocoaArray() -> AnyObject {
    if count == 0 {
      return _emptyArrayStorage
    }
    if _isBridgedVerbatimToObjectiveC(Element.self) {
      return _storage
    }
    return __SwiftDeferredNSArray(_nativeStorage: _storage)
  }
  @inlinable internal var owner: AnyObject {
    get {
    return _storage
  }
  }
  @inlinable internal var nativeOwner: AnyObject {
    get {
    return _storage
  }
  }
  @inlinable internal var identity: UnsafeRawPointer {
    get {
    return UnsafeRawPointer(firstElementAddress)
  }
  }
  @inlinable internal func canStoreElements(ofDynamicType proposedElementType: Any.Type) -> Bool {
    return _storage.canStoreElements(ofDynamicType: proposedElementType)
  }
  @inlinable internal func storesOnlyElementsOfType<U>(_: U.Type) -> Bool {
    _internalInvariant(_isClassOrObjCExistential(U.self))

    if _fastPath(_storage.staticElementType is U.Type) {
      // Done in O(1)
      return true
    }

    // Check the elements
    for x in self {
      if !(x is U) {
        return false
      }
    }
    return true
  }
  @usableFromInline
  internal var _storage: __ContiguousArrayStorageBase
}
@inlinable internal func += <Element, C>(lhs: inout _ContiguousArrayBuffer<Element>, rhs: __owned C) where Element == C.Element, C : Swift.Collection {

  let oldCount = lhs.count
  let newCount = oldCount + numericCast(rhs.count)

  let buf: UnsafeMutableBufferPointer<Element>
  
  if _fastPath(newCount <= lhs.capacity) {
    buf = UnsafeMutableBufferPointer(start: lhs.firstElementAddress + oldCount, count: numericCast(rhs.count))
    lhs.count = newCount
  }
  else {
    var newLHS = _ContiguousArrayBuffer<Element>(
      _uninitializedCount: newCount,
      minimumCapacity: _growArrayCapacity(lhs.capacity))

    newLHS.firstElementAddress.moveInitialize(
      from: lhs.firstElementAddress, count: oldCount)
    lhs.count = 0
    (lhs, newLHS) = (newLHS, lhs)
    buf = UnsafeMutableBufferPointer(start: lhs.firstElementAddress + oldCount, count: numericCast(rhs.count))
  }

  var (remainders,writtenUpTo) = buf.initialize(from: rhs)

  // ensure that exactly rhs.count elements were written
  _precondition(remainders.next() == nil, "rhs underreported its count")
  _precondition(writtenUpTo == buf.endIndex, "rhs overreported its count")    
}
extension _ContiguousArrayBuffer : RandomAccessCollection {
  @inlinable internal var startIndex: Int {
    get {
    return 0
  }
  }
  @inlinable internal var endIndex: Int {
    get {
    return count
  }
  }
  @usableFromInline
  internal typealias Indices = Range<Int>
  @usableFromInline
  internal typealias Index = Swift.Int
  @usableFromInline
  internal typealias SubSequence = Swift._SliceBuffer<Element>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Swift._ContiguousArrayBuffer<Element>>
}
extension Sequence {
  @inlinable __consuming public func _copyToContiguousArray() -> ContiguousArray<Element> {
    return _copySequenceToContiguousArray(self)
  }
}
@inlinable internal func _copySequenceToContiguousArray<S>(_ source: S) -> ContiguousArray<S.Element> where S : Swift.Sequence {
  let initialCapacity = source.underestimatedCount
  var builder =
    _UnsafePartiallyInitializedContiguousArrayBuffer<S.Element>(
      initialCapacity: initialCapacity)

  var iterator = source.makeIterator()

  // FIXME(performance): use _copyContents(initializing:).

  // Add elements up to the initial capacity without checking for regrowth.
  for _ in 0..<initialCapacity {
    builder.addWithExistingCapacity(iterator.next()!)
  }

  // Add remaining elements, if any.
  while let element = iterator.next() {
    builder.add(element)
  }

  return builder.finish()
}
extension Collection {
  @inlinable __consuming public func _copyToContiguousArray() -> ContiguousArray<Element> {
    return _copyCollectionToContiguousArray(self)
  }
}
extension _ContiguousArrayBuffer {
  @inlinable __consuming internal func _copyToContiguousArray() -> ContiguousArray<Element> {
    return ContiguousArray(_buffer: self)
  }
}
@inlinable internal func _copyCollectionToContiguousArray<C>(_ source: C) -> ContiguousArray<C.Element> where C : Swift.Collection {
  let count: Int = numericCast(source.count)
  if count == 0 {
    return ContiguousArray()
  }

  let result = _ContiguousArrayBuffer<C.Element>(
    _uninitializedCount: count,
    minimumCapacity: 0)

  let p = UnsafeMutableBufferPointer(start: result.firstElementAddress, count: count)
  var (itr, end) = source._copyContents(initializing: p)

  _debugPrecondition(itr.next() == nil,
    "invalid Collection: more than 'count' elements in collection")
  // We also have to check the evil shrink case in release builds, because
  // it can result in uninitialized array elements and therefore undefined
  // behavior.
  _precondition(end == p.endIndex,
    "invalid Collection: less than 'count' elements in collection")

  return ContiguousArray(_buffer: result)
}
@usableFromInline
@_fixed_layout internal struct _UnsafePartiallyInitializedContiguousArrayBuffer<Element> {
  @usableFromInline
  internal var result: _ContiguousArrayBuffer<Element>
  @usableFromInline
  internal var p: UnsafeMutablePointer<Element>
  @usableFromInline
  internal var remainingCapacity: Int
  @inlinable @inline(__always) internal init(initialCapacity: Int) {
    if initialCapacity == 0 {
      result = _ContiguousArrayBuffer()
    } else {
      result = _ContiguousArrayBuffer(
        _uninitializedCount: initialCapacity,
        minimumCapacity: 0)
    }

    p = result.firstElementAddress
    remainingCapacity = result.capacity
  }
  @inlinable @inline(__always) mutating internal func add(_ element: Element) {
    if remainingCapacity == 0 {
      // Reallocate.
      let newCapacity = max(_growArrayCapacity(result.capacity), 1)
      var newResult = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: newCapacity, minimumCapacity: 0)
      p = newResult.firstElementAddress + result.capacity
      remainingCapacity = newResult.capacity - result.capacity
      if !result.isEmpty {
        // This check prevents a data race writting to _swiftEmptyArrayStorage
        // Since count is always 0 there, this code does nothing anyway
        newResult.firstElementAddress.moveInitialize(
          from: result.firstElementAddress, count: result.capacity)
        result.count = 0
      }
      (result, newResult) = (newResult, result)
    }
    addWithExistingCapacity(element)
  }
  @inlinable @inline(__always) mutating internal func addWithExistingCapacity(_ element: Element) {
    _internalInvariant(remainingCapacity > 0,
      "_UnsafePartiallyInitializedContiguousArrayBuffer has no more capacity")
    remainingCapacity -= 1

    p.initialize(to: element)
    p += 1
  }
  @inlinable @inline(__always) mutating internal func finish() -> ContiguousArray<Element> {
    // Adjust the initialized count of the buffer.
    result.count = result.capacity - remainingCapacity

    return finishWithOriginalCount()
  }
  @inlinable @inline(__always) mutating internal func finishWithOriginalCount() -> ContiguousArray<Element> {
    _internalInvariant(remainingCapacity == result.capacity - result.count,
      "_UnsafePartiallyInitializedContiguousArrayBuffer has incorrect count")
    var finalResult = _ContiguousArrayBuffer<Element>()
    (finalResult, result) = (result, finalResult)
    remainingCapacity = 0
    return ContiguousArray(_buffer: finalResult)
  }
}
extension String {
  public init(cString: UnsafePointer<CChar>)
  public init(cString: UnsafePointer<UInt8>)
  public init?(validatingUTF8 cString: UnsafePointer<CChar>)
  @_specialize(exported: false, kind: full, where Encoding == Swift.Unicode.UTF8)
  @_specialize(exported: false, kind: full, where Encoding == Swift.Unicode.UTF16)
  @inlinable public static func decodeCString<Encoding>(_ cString: UnsafePointer<Encoding.CodeUnit>?, as encoding: Encoding.Type, repairingInvalidCodeUnits isRepairing: Bool = true) -> (result: String, repairsMade: Bool)? where Encoding : Swift._UnicodeEncoding {
    guard let cPtr = cString else { return nil }

    if _fastPath(encoding == Unicode.UTF8.self) {
      let ptr = UnsafeRawPointer(cPtr).assumingMemoryBound(to: UInt8.self)
      let len = UTF8._nullCodeUnitOffset(in: ptr)
      let codeUnits = UnsafeBufferPointer(start: ptr, count: len)
      if isRepairing {
        return String._fromUTF8Repairing(codeUnits)
      } else {
        guard let str = String._tryFromUTF8(codeUnits) else { return nil }
        return (str, false)
      }
    }

    var end = cPtr
    while end.pointee != 0 { end += 1 }
    let len = end - cPtr
    let codeUnits = UnsafeBufferPointer(start: cPtr, count: len)
    return String._fromCodeUnits(
      codeUnits, encoding: encoding, repair: isRepairing)
  }
  @_specialize(exported: false, kind: full, where Encoding == Swift.Unicode.UTF8)
  @_specialize(exported: false, kind: full, where Encoding == Swift.Unicode.UTF16)
  @inlinable public init<Encoding>(decodingCString ptr: UnsafePointer<Encoding.CodeUnit>, as sourceEncoding: Encoding.Type) where Encoding : Swift._UnicodeEncoding {
    self = String.decodeCString(ptr, as: sourceEncoding)!.0
  }
}
extension UnsafePointer where Pointee == Swift.UInt8 {
  @inlinable internal var _asCChar: UnsafePointer<CChar> {
    @inline(__always) get {
      return UnsafeRawPointer(self).assumingMemoryBound(to: CChar.self)
    }
  }
}
extension UnsafePointer where Pointee == Swift.CChar {
  @inlinable internal var _asUInt8: UnsafePointer<UInt8> {
    @inline(__always) get {
      return UnsafeRawPointer(self).assumingMemoryBound(to: UInt8.self)
    }
  }
}
public typealias CChar = Int8
public typealias CUnsignedChar = UInt8
public typealias CUnsignedShort = UInt16
public typealias CUnsignedInt = UInt32
public typealias CUnsignedLong = UInt
public typealias CUnsignedLongLong = UInt64
public typealias CSignedChar = Int8
public typealias CShort = Int16
public typealias CInt = Int32
public typealias CLong = Int
public typealias CLongLong = Int64
public typealias CFloat = Float
public typealias CDouble = Double
public typealias CLongDouble = Float80
public typealias CWideChar = Unicode.Scalar
public typealias CChar16 = UInt16
public typealias CChar32 = Unicode.Scalar
public typealias CBool = Bool
@_fixed_layout public struct OpaquePointer {
  @usableFromInline
  internal var _rawValue: Builtin.RawPointer
  @usableFromInline
  @_transparent internal init(_ v: Builtin.RawPointer) {
    self._rawValue = v
  }
  @_transparent public init?(bitPattern: Int) {
    if bitPattern == 0 { return nil }
    self._rawValue = Builtin.inttoptr_Word(bitPattern._builtinWordValue)
  }
  @_transparent public init?(bitPattern: UInt) {
    if bitPattern == 0 { return nil }
    self._rawValue = Builtin.inttoptr_Word(bitPattern._builtinWordValue)
  }
  @_transparent public init<T>(_ from: UnsafePointer<T>) {
    self._rawValue = from._rawValue
  }
  @_transparent public init?<T>(_ from: UnsafePointer<T>?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
  @_transparent public init<T>(_ from: UnsafeMutablePointer<T>) {
    self._rawValue = from._rawValue
  }
  @_transparent public init?<T>(_ from: UnsafeMutablePointer<T>?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
}
extension OpaquePointer : Equatable {
  @inlinable public static func == (lhs: OpaquePointer, rhs: OpaquePointer) -> Bool {
    return Bool(Builtin.cmp_eq_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}
extension OpaquePointer : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine(Int(Builtin.ptrtoint_Word(_rawValue)))
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension OpaquePointer : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension Int {
  @inlinable public init(bitPattern pointer: OpaquePointer?) {
    self.init(bitPattern: UnsafeRawPointer(pointer))
  }
}
extension UInt {
  @inlinable public init(bitPattern pointer: OpaquePointer?) {
    self.init(bitPattern: UnsafeRawPointer(pointer))
  }
}
@_fixed_layout public struct CVaListPointer {
  @usableFromInline
  internal var _value: UnsafeMutableRawPointer
  @inlinable public init(_fromUnsafeMutablePointer from: UnsafeMutableRawPointer) {
    _value = from
  }
}
extension CVaListPointer : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
@inlinable internal func _memcpy(dest destination: UnsafeMutableRawPointer, src: UnsafeRawPointer, size: UInt) {
  let dest = destination._rawValue
  let src = src._rawValue
  let size = UInt64(size)._value
  Builtin.int_memcpy_RawPointer_RawPointer_Int64(
    dest, src, size,
    /*volatile:*/ false._value)
}
@inlinable internal func _memmove(dest destination: UnsafeMutableRawPointer, src: UnsafeRawPointer, size: UInt) {
  let dest = destination._rawValue
  let src = src._rawValue
  let size = UInt64(size)._value
  Builtin.int_memmove_RawPointer_RawPointer_Int64(
    dest, src, size,
    /*volatile:*/ false._value)
}
@_frozen public enum _DebuggerSupport {
  public static func stringForPrintObject(_ value: Any) -> String
}
public func _stringForPrintObject(_ value: Any) -> String
public func _debuggerTestingCheckExpect(_: String, _: String)
@_silgen_name("swift_retainCount")
public func _getRetainCount(_ Value: AnyObject) -> UInt
@_silgen_name("swift_unownedRetainCount")
public func _getUnownedRetainCount(_ Value: AnyObject) -> UInt
@_silgen_name("swift_weakRetainCount")
public func _getWeakRetainCount(_ Value: AnyObject) -> UInt
@_fixed_layout public struct Dictionary<Key, Value> where Key : Swift.Hashable {
  public typealias Element = (key: Key, value: Value)
  @usableFromInline
  internal var _variant: _Variant
  @inlinable internal init(_native: __owned _NativeDictionary<Key, Value>) {
    _variant = _Variant(native: _native)
  }
  @inlinable internal init(_cocoa: __owned __CocoaDictionary) {
    _variant = _Variant(cocoa: _cocoa)
  }
  @inlinable public init(_immutableCocoaDictionary: __owned AnyObject) {
    _internalInvariant(
      _isBridgedVerbatimToObjectiveC(Key.self) &&
      _isBridgedVerbatimToObjectiveC(Value.self),
      """
      Dictionary can be backed by NSDictionary buffer only when both Key \
      and Value are bridged verbatim to Objective-C
      """)
    self.init(_cocoa: __CocoaDictionary(_immutableCocoaDictionary))
  }
  @inlinable public init() {
    self.init(_native: _NativeDictionary())
  }
  public init(minimumCapacity: Int)
  @inlinable public init<S>(uniqueKeysWithValues keysAndValues: __owned S) where S : Swift.Sequence, S.Element == (Key, Value) {
    if let d = keysAndValues as? Dictionary<Key, Value> {
      self = d
      return
    }
    var native = _NativeDictionary<Key, Value>(
      capacity: keysAndValues.underestimatedCount)
    // '_MergeError.keyCollision' is caught and handled with an appropriate
    // error message one level down, inside native.merge(_:...). We throw an
    // error instead of calling fatalError() directly because we want the
    // message to include the duplicate key, and the closure only has access to
    // the conflicting values.
    try! native.merge(
      keysAndValues,
      isUnique: true,
      uniquingKeysWith: { _, _ in throw _MergeError.keyCollision })
    self.init(_native: native)
  }
  @inlinable public init<S>(_ keysAndValues: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
    var native = _NativeDictionary<Key, Value>(
      capacity: keysAndValues.underestimatedCount)
    try native.merge(keysAndValues, isUnique: true, uniquingKeysWith: combine)
    self.init(_native: native)
  }
  @inlinable public init<S>(grouping values: __owned S, by keyForValue: (S.Element) throws -> Key) rethrows where Value == [S.Element], S : Swift.Sequence {
    try self.init(_native: _NativeDictionary(grouping: values, by: keyForValue))
  }
}
extension Dictionary : Sequence {
  @inlinable @inline(__always) __consuming public func makeIterator() -> Iterator {
    return _variant.makeIterator()
  }
}
extension Dictionary {
  @available(swift 4.0)
  @inlinable __consuming public func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Key : Value] {
    // FIXME(performance): Try building a bitset of elements to keep, so that we
    // eliminate rehashings during insertion.
    var result = _NativeDictionary<Key, Value>()
    for element in self {
      if try isIncluded(element) {
        result.insertNew(key: element.key, value: element.value)
      }
    }
    return Dictionary(_native: result)
  }
}
extension Dictionary : Collection {
  public typealias SubSequence = Slice<Dictionary>
  @inlinable public var startIndex: Index {
    get {
    return _variant.startIndex
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return _variant.endIndex
  }
  }
  @inlinable public func index(after i: Index) -> Index {
    return _variant.index(after: i)
  }
  @inlinable public func formIndex(after i: inout Index) {
    _variant.formIndex(after: &i)
  }
  @inlinable @inline(__always) public func index(forKey key: Key) -> Index? {
    // Complexity: amortized O(1) for native dictionary, O(*n*) when wrapping an
    // NSDictionary.
    return _variant.index(forKey: key)
  }
  @inlinable public subscript(position: Index) -> Element {
    get {
    return _variant.lookup(position)
  }
  }
  @inlinable public var count: Int {
    get {
    return _variant.count
  }
  }
  @inlinable public var isEmpty: Bool {
    get {
    return count == 0
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.Dictionary<Key, Value>>
}
extension Dictionary {
  @inlinable public subscript(key: Key) -> Value? {
    get {
      return _variant.lookup(key)
    }
    set(newValue) {
      if let x = newValue {
        _variant.setValue(x, forKey: key)
      } else {
        removeValue(forKey: key)
      }
    }
    _modify {
      defer { _fixLifetime(self) }
      yield &_variant[key]
    }
  }
}
extension Dictionary : ExpressibleByDictionaryLiteral {
  @inlinable @_effects(readonly) @_semantics("optimize.sil.specialize.generic.size.never") public init(dictionaryLiteral elements: (Key, Value)...) {
    let native = _NativeDictionary<Key, Value>(capacity: elements.count)
    for (key, value) in elements {
      let (bucket, found) = native.find(key)
      _precondition(!found, "Dictionary literal contains duplicate keys")
      native._insert(at: bucket, key: key, value: value)
    }
    self.init(_native: native)
  }
}
extension Dictionary {
  @inlinable public subscript(key: Key, default defaultValue: @autoclosure () -> Value) -> Value {
    @inline(__always) get {
      return _variant.lookup(key) ?? defaultValue()
    }
    @inline(__always) _modify {
      let (bucket, found) = _variant.mutatingFind(key)
      let native = _variant.asNative
      if !found {
        let value = defaultValue()
        native._insert(at: bucket, key: key, value: value)
      }
      let address = native._values + bucket.offset
      defer { _fixLifetime(self) }
      yield &address.pointee
    }
  }
  @inlinable public func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> Dictionary<Key, T> {
    return try Dictionary<Key, T>(_native: _variant.mapValues(transform))
  }
  @inlinable public func compactMapValues<T>(_ transform: (Value) throws -> T?) rethrows -> Dictionary<Key, T> {
    let result: _NativeDictionary<Key, T> =
      try self.reduce(into: _NativeDictionary<Key, T>()) { (result, element) in
      if let value = try transform(element.value) {
        result.insertNew(key: element.key, value: value)
      }
    }
    return Dictionary<Key, T>(_native: result)
  }
  @discardableResult
  @inlinable mutating public func updateValue(_ value: __owned Value, forKey key: Key) -> Value? {
    return _variant.updateValue(value, forKey: key)
  }
  @inlinable mutating public func merge<S>(_ other: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
    try _variant.merge(other, uniquingKeysWith: combine)
  }
  @inlinable mutating public func merge(_ other: __owned [Key : Value], uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows {
    try _variant.merge(
      other.lazy.map { ($0, $1) }, uniquingKeysWith: combine)
  }
  @inlinable __consuming public func merging<S>(_ other: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> [Key : Value] where S : Swift.Sequence, S.Element == (Key, Value) {
    var result = self
    try result._variant.merge(other, uniquingKeysWith: combine)
    return result
  }
  @inlinable __consuming public func merging(_ other: __owned [Key : Value], uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> [Key : Value] {
    var result = self
    try result.merge(other, uniquingKeysWith: combine)
    return result
  }
  @discardableResult
  @inlinable mutating public func remove(at index: Index) -> Element {
    return _variant.remove(at: index)
  }
  @discardableResult
  @inlinable mutating public func removeValue(forKey key: Key) -> Value? {
    return _variant.removeValue(forKey: key)
  }
  @inlinable mutating public func removeAll(keepingCapacity keepCapacity: Bool = false) {
    // The 'will not decrease' part in the documentation comment is worded very
    // carefully.  The capacity can increase if we replace Cocoa dictionary with
    // native dictionary.
    _variant.removeAll(keepingCapacity: keepCapacity)
  }
}
extension Dictionary {
  @available(swift 4.0)
  @inlinable public var keys: Keys {
    get {
      return Keys(_dictionary: self)
    }
  }
  @available(swift 4.0)
  @inlinable public var values: Values {
    get {
      return Values(_dictionary: self)
    }
    _modify {
      var values = Values(_variant: _Variant(dummy: ()))
      swap(&values._variant, &_variant)
      defer { self._variant = values._variant }
      yield &values
    }
  }
  @_fixed_layout public struct Keys : Collection, Equatable, CustomStringConvertible, CustomDebugStringConvertible {
    public typealias Element = Key
    public typealias SubSequence = Slice<Dictionary.Keys>
    @usableFromInline
    internal var _variant: Dictionary<Key, Value>._Variant
    @inlinable internal init(_dictionary: __owned Dictionary) {
      self._variant = _dictionary._variant
    }
    @inlinable public var startIndex: Index {
      get {
      return _variant.startIndex
    }
    }
    @inlinable public var endIndex: Index {
      get {
      return _variant.endIndex
    }
    }
    @inlinable public func index(after i: Index) -> Index {
      return _variant.index(after: i)
    }
    @inlinable public func formIndex(after i: inout Index) {
      _variant.formIndex(after: &i)
    }
    @inlinable public subscript(position: Index) -> Element {
      get {
      return _variant.key(at: position)
    }
    }
    @inlinable public var count: Int {
      get {
      return _variant.count
    }
    }
    @inlinable public var isEmpty: Bool {
      get {
      return count == 0
    }
    }
    @inlinable @inline(__always) public func _customContainsEquatableElement(_ element: Element) -> Bool? {
      return _variant.contains(element)
    }
    @inlinable @inline(__always) public func _customIndexOfEquatableElement(_ element: Element) -> Index?? {
      return Optional(_variant.index(forKey: element))
    }
    @inlinable @inline(__always) public func _customLastIndexOfEquatableElement(_ element: Element) -> Index?? {
      // The first and last elements are the same because each element is unique.
      return _customIndexOfEquatableElement(element)
    }
    @inlinable public static func == (lhs: Keys, rhs: Keys) -> Bool {
      // Equal if the two dictionaries share storage.
      if
        lhs._variant.isNative,
        rhs._variant.isNative,
        lhs._variant.asNative._storage === rhs._variant.asNative._storage
      {
        return true
      }
      if
        !lhs._variant.isNative,
        !rhs._variant.isNative,
        lhs._variant.asCocoa.object === rhs._variant.asCocoa.object
      {
        return true
      }

      // Not equal if the dictionaries are different sizes.
      if lhs.count != rhs.count {
        return false
      }

      // Perform unordered comparison of keys.
      for key in lhs {
        if !rhs.contains(key) {
          return false
        }
      }

      return true
    }
    public var description: String {
      get
    }
    public var debugDescription: String {
      get
    }
    public typealias Index = Swift.Dictionary<Key, Value>.Index
    public typealias Indices = Swift.DefaultIndices<Swift.Dictionary<Key, Value>.Keys>
  }
  @_fixed_layout public struct Values : MutableCollection, CustomStringConvertible, CustomDebugStringConvertible {
    public typealias Element = Value
    @usableFromInline
    internal var _variant: Dictionary<Key, Value>._Variant
    @inlinable internal init(_variant: __owned Dictionary<Key, Value>._Variant) {
      self._variant = _variant
    }
    @inlinable internal init(_dictionary: __owned Dictionary) {
      self._variant = _dictionary._variant
    }
    @inlinable public var startIndex: Index {
      get {
      return _variant.startIndex
    }
    }
    @inlinable public var endIndex: Index {
      get {
      return _variant.endIndex
    }
    }
    @inlinable public func index(after i: Index) -> Index {
      return _variant.index(after: i)
    }
    @inlinable public func formIndex(after i: inout Index) {
      _variant.formIndex(after: &i)
    }
    @inlinable public subscript(position: Index) -> Element {
      get {
        return _variant.value(at: position)
      }
      _modify {
        let native = _variant.ensureUniqueNative()
        let bucket = native.validatedBucket(for: position)
        let address = native._values + bucket.offset
        defer { _fixLifetime(self) }
        yield &address.pointee
      }
    }
    @inlinable public var count: Int {
      get {
      return _variant.count
    }
    }
    @inlinable public var isEmpty: Bool {
      get {
      return count == 0
    }
    }
    public var description: String {
      get
    }
    public var debugDescription: String {
      get
    }
    @inlinable mutating public func swapAt(_ i: Index, _ j: Index) {
      guard i != j else { return }
      if !_variant.isNative {
        _variant = .init(native: _NativeDictionary(_variant.asCocoa))
      }
      let isUnique = _variant.isUniquelyReferenced()
      let native = _variant.asNative
      let a = native.validatedBucket(for: i)
      let b = native.validatedBucket(for: j)
      _variant.asNative.swapValuesAt(a, b, isUnique: isUnique)
    }
    public typealias Index = Swift.Dictionary<Key, Value>.Index
    public typealias SubSequence = Swift.Slice<Swift.Dictionary<Key, Value>.Values>
    public typealias Indices = Swift.DefaultIndices<Swift.Dictionary<Key, Value>.Values>
  }
}
extension Dictionary.Keys {
  @_fixed_layout public struct Iterator : IteratorProtocol {
    @usableFromInline
    internal var _base: Dictionary<Key, Value>.Iterator
    @inlinable @inline(__always) internal init(_ base: Dictionary<Key, Value>.Iterator) {
      self._base = base
    }
    @inlinable @inline(__always) mutating public func next() -> Key? {
      if case .cocoa(let cocoa) = _base._variant {
        _base._cocoaPath()
        guard let cocoaKey = cocoa.nextKey() else { return nil }
        return _forceBridgeFromObjectiveC(cocoaKey, Key.self)
      }
      return _base._asNative.nextKey()
    }
    public typealias Element = Key
  }
  @inlinable @inline(__always) __consuming public func makeIterator() -> Iterator {
    return Iterator(_variant.makeIterator())
  }
}
extension Dictionary.Values {
  @_fixed_layout public struct Iterator : IteratorProtocol {
    @usableFromInline
    internal var _base: Dictionary<Key, Value>.Iterator
    @inlinable @inline(__always) internal init(_ base: Dictionary<Key, Value>.Iterator) {
      self._base = base
    }
    @inlinable @inline(__always) mutating public func next() -> Value? {
      if case .cocoa(let cocoa) = _base._variant {
        _base._cocoaPath()
        guard let (_, cocoaValue) = cocoa.next() else { return nil }
        return _forceBridgeFromObjectiveC(cocoaValue, Value.self)
      }
      return _base._asNative.nextValue()
    }
    public typealias Element = Value
  }
  @inlinable @inline(__always) __consuming public func makeIterator() -> Iterator {
    return Iterator(_variant.makeIterator())
  }
}
extension Dictionary : Equatable where Value : Swift.Equatable {
  @inlinable public static func == (lhs: [Key : Value], rhs: [Key : Value]) -> Bool {
    switch (lhs._variant.isNative, rhs._variant.isNative) {
    case (true, true):
      return lhs._variant.asNative.isEqual(to: rhs._variant.asNative)
    case (false, false):
      return lhs._variant.asCocoa.isEqual(to: rhs._variant.asCocoa)
    case (true, false):
      return lhs._variant.asNative.isEqual(to: rhs._variant.asCocoa)
    case (false, true):
      return rhs._variant.asNative.isEqual(to: lhs._variant.asCocoa)
    }
  }
}
extension Dictionary : Hashable where Value : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    var commutativeHash = 0
    for (k, v) in self {
      // Note that we use a copy of our own hasher here. This makes hash values
      // dependent on its state, eliminating static collision patterns.
      var elementHasher = hasher
      elementHasher.combine(k)
      elementHasher.combine(v)
      commutativeHash ^= elementHasher._finalize()
    }
    hasher.combine(commutativeHash)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Dictionary : _HasCustomAnyHashableRepresentation where Value : Swift.Hashable {
  __consuming public func _toCustomAnyHashable() -> AnyHashable?
}
extension Dictionary : CustomStringConvertible, CustomDebugStringConvertible {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
}
@usableFromInline
@_frozen internal enum _MergeError : Error {
  case keyCollision
  @usableFromInline
  internal static func == (a: Swift._MergeError, b: Swift._MergeError) -> Swift.Bool
  @usableFromInline
  internal var hashValue: Swift.Int {
    @usableFromInline
    get
  }
  @usableFromInline
  internal func hash(into hasher: inout Swift.Hasher)
}
extension Dictionary {
  @_fixed_layout public struct Index {
    @usableFromInline
    @_frozen internal enum _Variant {
      case native(_HashTable.Index)
      case cocoa(__CocoaDictionary.Index)
    }
    @usableFromInline
    internal var _variant: _Variant
    @inlinable @inline(__always) internal init(_variant: __owned _Variant) {
      self._variant = _variant
    }
    @inlinable @inline(__always) internal init(_native index: _HashTable.Index) {
      self.init(_variant: .native(index))
    }
    @inlinable @inline(__always) internal init(_cocoa index: __owned __CocoaDictionary.Index) {
      self.init(_variant: .cocoa(index))
    }
  }
}
extension Dictionary.Index {
  @usableFromInline
  @_transparent internal var _guaranteedNative: Bool {
    get {
    return _canBeClass(Key.self) == 0 || _canBeClass(Value.self) == 0
  }
  }
  @usableFromInline
  @_transparent internal func _cocoaPath() {
    if _guaranteedNative {
      _conditionallyUnreachable()
    }
  }
  @inlinable @inline(__always) mutating internal func _isUniquelyReferenced() -> Bool {
    defer { _fixLifetime(self) }
    var handle = _asCocoa.handleBitPattern
    return handle == 0 || _isUnique_native(&handle)
  }
  @usableFromInline
  @_transparent internal var _isNative: Bool {
    get {
    switch _variant {
    case .native:
      return true
    case .cocoa:
      _cocoaPath()
      return false
    }
  }
  }
  @usableFromInline
  @_transparent internal var _asNative: _HashTable.Index {
    get {
    switch _variant {
    case .native(let nativeIndex):
      return nativeIndex
    case .cocoa:
      _preconditionFailure(
        "Attempting to access Dictionary elements using an invalid index")
    }
  }
  }
  @usableFromInline
  internal var _asCocoa: __CocoaDictionary.Index {
    @_transparent get {
      switch _variant {
      case .native:
        _preconditionFailure(
          "Attempting to access Dictionary elements using an invalid index")
      case .cocoa(let cocoaIndex):
        return cocoaIndex
      }
    }
    _modify
  }
}
extension Dictionary.Index : Equatable {
  @inlinable public static func == (lhs: Dictionary<Key, Value>.Index, rhs: Dictionary<Key, Value>.Index) -> Bool {
    switch (lhs._variant, rhs._variant) {
    case (.native(let lhsNative), .native(let rhsNative)):
      return lhsNative == rhsNative
    case (.cocoa(let lhsCocoa), .cocoa(let rhsCocoa)):
      lhs._cocoaPath()
      return lhsCocoa == rhsCocoa
    default:
      _preconditionFailure("Comparing indexes from different dictionaries")
    }
  }
}
extension Dictionary.Index : Comparable {
  @inlinable public static func < (lhs: Dictionary<Key, Value>.Index, rhs: Dictionary<Key, Value>.Index) -> Bool {
    switch (lhs._variant, rhs._variant) {
    case (.native(let lhsNative), .native(let rhsNative)):
      return lhsNative < rhsNative
    case (.cocoa(let lhsCocoa), .cocoa(let rhsCocoa)):
      lhs._cocoaPath()
      return lhsCocoa < rhsCocoa
    default:
      _preconditionFailure("Comparing indexes from different dictionaries")
    }
  }
}
extension Dictionary.Index : Hashable {
  public func hash(into hasher: inout Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Dictionary {
  @_fixed_layout public struct Iterator {
    @usableFromInline
    @_frozen internal enum _Variant {
      case native(_NativeDictionary<Key, Value>.Iterator)
      case cocoa(__CocoaDictionary.Iterator)
    }
    @usableFromInline
    internal var _variant: _Variant
    @inlinable internal init(_variant: __owned _Variant) {
      self._variant = _variant
    }
    @inlinable internal init(_native: __owned _NativeDictionary<Key, Value>.Iterator) {
      self.init(_variant: .native(_native))
    }
    @inlinable internal init(_cocoa: __owned __CocoaDictionary.Iterator) {
      self.init(_variant: .cocoa(_cocoa))
    }
  }
}
extension Dictionary.Iterator {
  @usableFromInline
  @_transparent internal var _guaranteedNative: Bool {
    get {
    return _canBeClass(Key.self) == 0 || _canBeClass(Value.self) == 0
  }
  }
  @usableFromInline
  @_transparent internal func _cocoaPath() {
    if _guaranteedNative {
      _conditionallyUnreachable()
    }
  }
  @usableFromInline
  @_transparent internal var _isNative: Bool {
    get {
    switch _variant {
    case .native:
      return true
    case .cocoa:
      _cocoaPath()
      return false
    }
  }
  }
  @usableFromInline
  @_transparent internal var _asNative: _NativeDictionary<Key, Value>.Iterator {
    get {
      switch _variant {
      case .native(let nativeIterator):
        return nativeIterator
      case .cocoa:
        _internalInvariantFailure("internal error: does not contain a native index")
      }
    }
    set {
      self._variant = .native(newValue)
    }
  }
  @usableFromInline
  @_transparent internal var _asCocoa: __CocoaDictionary.Iterator {
    get {
      switch _variant {
      case .native:
        _internalInvariantFailure("internal error: does not contain a Cocoa index")
      case .cocoa(let cocoa):
        return cocoa
      }
    }
  }
}
extension Dictionary.Iterator : IteratorProtocol {
  @inlinable @inline(__always) mutating public func next() -> (key: Key, value: Value)? {
    guard _isNative else {
      if let (cocoaKey, cocoaValue) = _asCocoa.next() {
        let nativeKey = _forceBridgeFromObjectiveC(cocoaKey, Key.self)
        let nativeValue = _forceBridgeFromObjectiveC(cocoaValue, Value.self)
        return (nativeKey, nativeValue)
      }
      return nil
    }
    return _asNative.next()
  }
  public typealias Element = (key: Key, value: Value)
}
extension Dictionary.Iterator : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Dictionary : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Dictionary {
  @inlinable mutating public func popFirst() -> Element? {
    guard !isEmpty else { return nil }
    return remove(at: startIndex)
  }
  @inlinable public var capacity: Int {
    get {
    return _variant.capacity
  }
  }
  mutating public func reserveCapacity(_ minimumCapacity: Int)
}
public typealias DictionaryIndex<Key, Value> = Dictionary<Key, Value>.Index where Key : Swift.Hashable
public typealias DictionaryIterator<Key, Value> = Dictionary<Key, Value>.Iterator where Key : Swift.Hashable
extension _NativeDictionary {
  @usableFromInline
  __consuming internal func bridged() -> AnyObject
}
@usableFromInline
@_fixed_layout internal struct __CocoaDictionary {
  @usableFromInline
  internal let object: AnyObject
  @inlinable internal init(_ object: __owned AnyObject) {
    self.object = object
  }
}
extension __CocoaDictionary {
  @usableFromInline
  internal func isEqual(to other: __CocoaDictionary) -> Bool
}
extension __CocoaDictionary {
  @usableFromInline
  internal typealias Key = AnyObject
  @usableFromInline
  internal typealias Value = AnyObject
  @usableFromInline
  internal var startIndex: Index {
    @_effects(releasenone) get
  }
  @usableFromInline
  internal var endIndex: Index {
    @_effects(releasenone) get
  }
  @usableFromInline
  @_effects(releasenone) internal func index(after index: Index) -> Index
  @usableFromInline
  internal func formIndex(after index: inout Index, isUnique: Bool)
  @usableFromInline
  @_effects(releasenone) internal func index(forKey key: Key) -> Index?
  @usableFromInline
  internal var count: Int {
    get
  }
  @usableFromInline
  internal func contains(_ key: Key) -> Bool
  @usableFromInline
  internal func lookup(_ key: Key) -> Value?
  @usableFromInline
  @_effects(releasenone) internal func lookup(_ index: Index) -> (key: Key, value: Value)
  @usableFromInline
  @_effects(releasenone) internal func key(at index: Index) -> Key
  @usableFromInline
  @_effects(releasenone) internal func value(at index: Index) -> Value
}
extension __CocoaDictionary {
  @inlinable internal func mapValues<Key, Value, T>(_ transform: (Value) throws -> T) rethrows -> _NativeDictionary<Key, T> where Key : Swift.Hashable {
    var result = _NativeDictionary<Key, T>(capacity: self.count)
    for (cocoaKey, cocoaValue) in self {
      let key = _forceBridgeFromObjectiveC(cocoaKey, Key.self)
      let value = _forceBridgeFromObjectiveC(cocoaValue, Value.self)
      try result.insertNew(key: key, value: transform(value))
    }
    return result
  }
}
extension __CocoaDictionary {
  @usableFromInline
  @_fixed_layout internal struct Index {
    internal var _storage: Builtin.BridgeObject
    internal var _offset: Int
  }
}
extension __CocoaDictionary.Index {
  @usableFromInline
  internal var handleBitPattern: UInt {
    @_effects(readonly) get
  }
  @usableFromInline
  internal var dictionary: __CocoaDictionary {
    @_effects(releasenone) get
  }
}
extension __CocoaDictionary.Index {
  @usableFromInline
  @nonobjc internal var key: AnyObject {
    @_effects(readonly) get
  }
  @usableFromInline
  @nonobjc internal var age: Int32 {
    @_effects(readonly) get
  }
}
extension __CocoaDictionary.Index : Equatable {
  @usableFromInline
  @_effects(readonly) internal static func == (lhs: __CocoaDictionary.Index, rhs: __CocoaDictionary.Index) -> Bool
}
extension __CocoaDictionary.Index : Comparable {
  @usableFromInline
  @_effects(readonly) internal static func < (lhs: __CocoaDictionary.Index, rhs: __CocoaDictionary.Index) -> Bool
}
extension __CocoaDictionary : Sequence {
  @usableFromInline
  final internal class Iterator {
    @objc @usableFromInline
    deinit
  }
  @usableFromInline
  @_effects(releasenone) __consuming internal func makeIterator() -> Iterator
  @usableFromInline
  internal typealias Element = Swift.__CocoaDictionary.Iterator.Element
}
extension __CocoaDictionary.Iterator : IteratorProtocol {
  @usableFromInline
  internal typealias Element = (key: AnyObject, value: AnyObject)
  @usableFromInline
  final internal func nextKey() -> AnyObject?
  @usableFromInline
  final internal func next() -> Element?
}
extension Dictionary {
  @inlinable __consuming public func _bridgeToObjectiveCImpl() -> AnyObject {
    guard _variant.isNative else {
      return _variant.asCocoa.object
    }
    return _variant.asNative.bridged()
  }
  public static func _bridgeFromObjectiveCAdoptingNativeStorageOf(_ s: __owned AnyObject) -> Dictionary<Key, Value>?
}
@_fixed_layout public struct _DictionaryBuilder<Key, Value> where Key : Swift.Hashable {
  @usableFromInline
  internal var _target: _NativeDictionary<Key, Value>
  @usableFromInline
  internal let _requestedCount: Int
  @inlinable public init(count: Int) {
    _target = _NativeDictionary(capacity: count)
    _requestedCount = count
  }
  @inlinable mutating public func add(key newKey: Key, value: Value) {
    _precondition(_target.count < _requestedCount,
      "Can't add more members than promised")
    _target._unsafeInsertNew(key: newKey, value: value)
  }
  @inlinable __consuming public func take() -> Dictionary<Key, Value> {
    _precondition(_target.count == _requestedCount,
      "The number of members added does not match the promised count")
    return Dictionary(_native: _target)
  }
}
extension Dictionary {
  @_alwaysEmitIntoClient public init(_unsafeUninitializedCapacity capacity: Int, allowingDuplicates: Bool, initializingWith initializer: (_ keys: UnsafeMutableBufferPointer<Key>, _ values: UnsafeMutableBufferPointer<Value>) -> Int) {
    self.init(_native: _NativeDictionary(
        _unsafeUninitializedCapacity: capacity,
        allowingDuplicates: allowingDuplicates,
        initializingWith: initializer))
  }
}
extension _NativeDictionary {
  @_alwaysEmitIntoClient internal init(_unsafeUninitializedCapacity capacity: Int, allowingDuplicates: Bool, initializingWith initializer: (_ keys: UnsafeMutableBufferPointer<Key>, _ values: UnsafeMutableBufferPointer<Value>) -> Int) {
    self.init(capacity: capacity)
    let initializedCount = initializer(
      UnsafeMutableBufferPointer(start: _keys, count: capacity),
      UnsafeMutableBufferPointer(start: _values, count: capacity))
    _precondition(initializedCount >= 0 && initializedCount <= capacity)
    _storage._count = initializedCount

    // Hash initialized elements and move each of them into their correct
    // buckets.
    //
    // - We have some number of unprocessed elements at the start of the
    //   key/value buffers -- buckets up to and including `bucket`. Everything
    //   in this region is either unprocessed or in use. There are no
    //   uninitialized entries in it.
    //
    // - Everything after `bucket` is either uninitialized or in use. This
    //   region works exactly like regular dictionary storage.
    //
    // - "in use" is tracked by the bitmap in `hashTable`, the same way it would
    //   be for a working Dictionary.
    //
    // Each iteration of the loop below processes an unprocessed element, and/or
    // reduces the size of the unprocessed region, while ensuring the above
    // invariants.
    var bucket = _HashTable.Bucket(offset: initializedCount - 1)
    while bucket.offset >= 0 {
      if hashTable._isOccupied(bucket) {
        // We've moved an element here in a previous iteration.
        bucket.offset -= 1
        continue
      }
      // Find the target bucket for this entry and mark it as in use.
      let target: Bucket
      if _isDebugAssertConfiguration() || allowingDuplicates {
        let (b, found) = find(_keys[bucket.offset])
        if found {
          _internalInvariant(b != bucket)
          _precondition(allowingDuplicates, "Duplicate keys found")
          // Discard duplicate entry.
          uncheckedDestroy(at: bucket)
          _storage._count -= 1
          bucket.offset -= 1
          continue
        }
        hashTable.insert(b)
        target = b
      } else {
        let hashValue = self.hashValue(for: _keys[bucket.offset])
        target = hashTable.insertNew(hashValue: hashValue)
      }

      if target > bucket {
        // The target is outside the unprocessed region.  We can simply move the
        // entry, leaving behind an uninitialized bucket.
        moveEntry(from: bucket, to: target)
        // Restore invariants by lowering the region boundary.
        bucket.offset -= 1
      } else if target == bucket {
        // Already in place.
        bucket.offset -= 1
      } else {
        // The target bucket is also in the unprocessed region. Swap the current
        // item into place, then try again with the swapped-in value, so that we
        // don't lose it.
        swapEntry(target, with: bucket)
      }
    }
    // When there are no more unprocessed entries, we're left with a valid
    // Dictionary.
  }
}
extension Dictionary {
  @_alwaysEmitIntoClient @inlinable @inline(__always) internal init?<C>(_mapping source: C, allowingDuplicates: Bool, transform: (C.Element) -> (key: Key, value: Value)?) where C : Swift.Collection {
    var target = _NativeDictionary<Key, Value>(capacity: source.count)
    if allowingDuplicates {
      for member in source {
        guard let (key, value) = transform(member) else { return nil }
        target._unsafeUpdate(key: key, value: value)
      }
    } else {
      for member in source {
        guard let (key, value) = transform(member) else { return nil }
        target._unsafeInsertNew(key: key, value: value)
      }
    }
    self.init(_native: target)
  }
}
@inlinable public func _dictionaryUpCast<DerivedKey, DerivedValue, BaseKey, BaseValue>(_ source: Dictionary<DerivedKey, DerivedValue>) -> Dictionary<BaseKey, BaseValue> where DerivedKey : Swift.Hashable, BaseKey : Swift.Hashable {
  return Dictionary(
    _mapping: source,
    // String and NSString have different concepts of equality, so
    // NSString-keyed Dictionaries may generate key collisions when "upcasted"
    // to String. See rdar://problem/35995647
    allowingDuplicates: (BaseKey.self == String.self)
  ) { k, v in
    (k as! BaseKey, v as! BaseValue)
  }!
}
@inlinable public func _dictionaryDownCast<BaseKey, BaseValue, DerivedKey, DerivedValue>(_ source: Dictionary<BaseKey, BaseValue>) -> Dictionary<DerivedKey, DerivedValue> where BaseKey : Swift.Hashable, DerivedKey : Swift.Hashable {

  if _isClassOrObjCExistential(BaseKey.self)
  && _isClassOrObjCExistential(BaseValue.self)
  && _isClassOrObjCExistential(DerivedKey.self)
  && _isClassOrObjCExistential(DerivedValue.self) {

    guard source._variant.isNative else {
      return Dictionary(
        _immutableCocoaDictionary: source._variant.asCocoa.object)
    }
    // Note: it is safe to treat the buffer as immutable here because
    // Dictionary will not mutate buffer with reference count greater than 1.
    return Dictionary(
      _immutableCocoaDictionary: source._variant.asNative.bridged())
  }

  // Note: We can't delegate this call to _dictionaryDownCastConditional,
  // because we rely on as! to generate nice runtime errors when the downcast
  // fails.

  return Dictionary(
    _mapping: source,
    // String and NSString have different concepts of equality, so
    // NSString-keyed Dictionaries may generate key collisions when downcasted
    // to String. See rdar://problem/35995647
    allowingDuplicates: (DerivedKey.self == String.self)
  ) { k, v in
    (k as! DerivedKey, v as! DerivedValue)
  }!
}
@inlinable public func _dictionaryDownCastConditional<BaseKey, BaseValue, DerivedKey, DerivedValue>(_ source: Dictionary<BaseKey, BaseValue>) -> Dictionary<DerivedKey, DerivedValue>? where BaseKey : Swift.Hashable, DerivedKey : Swift.Hashable {
  return Dictionary(
    _mapping: source,
    // String and NSString have different concepts of equality, so
    // NSString-keyed Dictionaries may generate key collisions when downcasted
    // to String. See rdar://problem/35995647
    allowingDuplicates: (DerivedKey.self == String.self)
  ) { k, v in
    guard
      let key = k as? DerivedKey,
      let value = v as? DerivedValue
    else {
      return nil
    }
    return (key, value)
  }
}
@objc @usableFromInline
@_fixed_layout @_objc_non_lazy_realization internal class __RawDictionaryStorage : __SwiftNativeNSDictionary {
  @usableFromInline
  @nonobjc final internal var _count: Int
  @usableFromInline
  @nonobjc final internal var _capacity: Int
  @usableFromInline
  @nonobjc final internal var _scale: Int8
  @usableFromInline
  @nonobjc final internal var _reservedScale: Int8
  @nonobjc final internal var _extra: Int16
  @usableFromInline
  @nonobjc final internal var _age: Int32
  @usableFromInline
  final internal var _seed: Int
  @usableFromInline
  @nonobjc final internal var _rawKeys: UnsafeMutableRawPointer
  @usableFromInline
  @nonobjc final internal var _rawValues: UnsafeMutableRawPointer
  @inlinable @nonobjc final internal var _bucketCount: Int {
    @inline(__always) get { return 1 &<< _scale }
  }
  @inlinable @nonobjc final internal var _metadata: UnsafeMutablePointer<_HashTable.Word> {
    @inline(__always) get {
      let address = Builtin.projectTailElems(self, _HashTable.Word.self)
      return UnsafeMutablePointer(address)
    }
  }
  @inlinable @nonobjc final internal var _hashTable: _HashTable {
    @inline(__always) get {
      return _HashTable(words: _metadata, bucketCount: _bucketCount)
    }
  }
  @objc @usableFromInline
  deinit
}
@objc @usableFromInline
@_fixed_layout internal class __EmptyDictionarySingleton : __RawDictionaryStorage {
  @objc @usableFromInline
  deinit
}
extension __EmptyDictionarySingleton {
}
extension __RawDictionaryStorage {
  @inlinable @nonobjc internal static var empty: __EmptyDictionarySingleton {
    get {
    return Builtin.bridgeFromRawPointer(
      Builtin.addressof(&_swiftEmptyDictionarySingleton))
  }
  }
}
@usableFromInline
final internal class _DictionaryStorage<Key, Value> : __RawDictionaryStorage where Key : Swift.Hashable {
  @objc deinit
  @inlinable final internal var _keys: UnsafeMutablePointer<Key> {
    @inline(__always) get {
      return self._rawKeys.assumingMemoryBound(to: Key.self)
    }
  }
  @inlinable final internal var _values: UnsafeMutablePointer<Value> {
    @inline(__always) get {
      return self._rawValues.assumingMemoryBound(to: Value.self)
    }
  }
}
extension _DictionaryStorage {
  @usableFromInline
  @_effects(releasenone) internal static func copy(original: __RawDictionaryStorage) -> _DictionaryStorage
  @usableFromInline
  @_effects(releasenone) internal static func resize(original: __RawDictionaryStorage, capacity: Int, move: Bool) -> _DictionaryStorage
  @usableFromInline
  @_effects(releasenone) internal static func allocate(capacity: Int) -> _DictionaryStorage
  @usableFromInline
  @_effects(releasenone) internal static func convert(_ cocoa: __CocoaDictionary, capacity: Int) -> _DictionaryStorage
}
extension Dictionary {
  @usableFromInline
  @_fixed_layout internal struct _Variant {
    @usableFromInline
    internal var object: _BridgeStorage<__RawDictionaryStorage>
    @inlinable @inline(__always) internal init(native: __owned _NativeDictionary<Key, Value>) {
      self.object = _BridgeStorage(native: native._storage)
    }
    @inlinable @inline(__always) internal init(dummy: Void) {
      self.object = _BridgeStorage(taggedPayload: 0)
    }
    @inlinable @inline(__always) internal init(cocoa: __owned __CocoaDictionary) {
      self.object = _BridgeStorage(objC: cocoa.object)
    }
  }
}
extension Dictionary._Variant {
  @usableFromInline
  @_transparent internal var guaranteedNative: Bool {
    get {
    return _canBeClass(Key.self) == 0 || _canBeClass(Value.self) == 0
  }
  }
  @inlinable mutating internal func isUniquelyReferenced() -> Bool {
    return object.isUniquelyReferencedUnflaggedNative()
  }
  @usableFromInline
  @_transparent internal var isNative: Bool {
    get {
    if guaranteedNative { return true }
    return object.isUnflaggedNative
  }
  }
  @usableFromInline
  @_transparent internal var asNative: _NativeDictionary<Key, Value> {
    get {
      return _NativeDictionary<Key, Value>(object.unflaggedNativeInstance)
    }
    set {
      self = .init(native: newValue)
    }
    _modify {
      var native = _NativeDictionary<Key, Value>(object.unflaggedNativeInstance)
      self = .init(dummy: ())
      defer { object = .init(native: native._storage) }
      yield &native
    }
  }
  @inlinable internal var asCocoa: __CocoaDictionary {
    get {
    return __CocoaDictionary(object.objCInstance)
  }
  }
  @inlinable internal var capacity: Int {
    get {
    guard isNative else {
      return asCocoa.count
    }
    return asNative.capacity
  }
  }
}
extension Dictionary._Variant {
  @usableFromInline
  internal typealias Element = (key: Key, value: Value)
  @usableFromInline
  internal typealias Index = Dictionary<Key, Value>.Index
  @inlinable internal var startIndex: Index {
    get {
    guard isNative else {
      return Index(_cocoa: asCocoa.startIndex)
    }
    return asNative.startIndex
  }
  }
  @inlinable internal var endIndex: Index {
    get {
    guard isNative else {
      return Index(_cocoa: asCocoa.endIndex)
    }
    return asNative.endIndex
  }
  }
  @inlinable internal func index(after index: Index) -> Index {
    guard isNative else {
      return Index(_cocoa: asCocoa.index(after: index._asCocoa))
    }
    return asNative.index(after: index)
  }
  @inlinable internal func formIndex(after index: inout Index) {
    guard isNative else {
      let isUnique = index._isUniquelyReferenced()
      asCocoa.formIndex(after: &index._asCocoa, isUnique: isUnique)
      return
    }
    index = asNative.index(after: index)
  }
  @inlinable @inline(__always) internal func index(forKey key: Key) -> Index? {
    guard isNative else {
      let cocoaKey = _bridgeAnythingToObjectiveC(key)
      guard let index = asCocoa.index(forKey: cocoaKey) else { return nil }
      return Index(_cocoa: index)
    }
    return asNative.index(forKey: key)
  }
  @inlinable internal var count: Int {
    @inline(__always) get {
      guard isNative else {
        return asCocoa.count
      }
      return asNative.count
    }
  }
  @inlinable @inline(__always) internal func contains(_ key: Key) -> Bool {
    guard isNative else {
      let cocoaKey = _bridgeAnythingToObjectiveC(key)
      return asCocoa.contains(cocoaKey)
    }
    return asNative.contains(key)
  }
  @inlinable @inline(__always) internal func lookup(_ key: Key) -> Value? {
    guard isNative else {
      let cocoaKey = _bridgeAnythingToObjectiveC(key)
      guard let cocoaValue = asCocoa.lookup(cocoaKey) else { return nil }
      return _forceBridgeFromObjectiveC(cocoaValue, Value.self)
    }
    return asNative.lookup(key)
  }
  @inlinable @inline(__always) internal func lookup(_ index: Index) -> (key: Key, value: Value) {
    guard isNative else {
      let (cocoaKey, cocoaValue) = asCocoa.lookup(index._asCocoa)
      let nativeKey = _forceBridgeFromObjectiveC(cocoaKey, Key.self)
      let nativeValue = _forceBridgeFromObjectiveC(cocoaValue, Value.self)
      return (nativeKey, nativeValue)
    }
    return asNative.lookup(index)
  }
  @inlinable @inline(__always) internal func key(at index: Index) -> Key {
    guard isNative else {
      let cocoaKey = asCocoa.key(at: index._asCocoa)
      return _forceBridgeFromObjectiveC(cocoaKey, Key.self)
    }
    return asNative.key(at: index)
  }
  @inlinable @inline(__always) internal func value(at index: Index) -> Value {
    guard isNative else {
      let cocoaValue = asCocoa.value(at: index._asCocoa)
      return _forceBridgeFromObjectiveC(cocoaValue, Value.self)
    }
    return asNative.value(at: index)
  }
}
extension Dictionary._Variant {
  @inlinable internal subscript(key: Key) -> Value? {
    @inline(__always) get {
      return lookup(key)
    }
    @inline(__always) _modify {
      guard isNative else {
        let cocoa = asCocoa
        var native = _NativeDictionary<Key, Value>(
          cocoa, capacity: cocoa.count + 1)
        self = .init(native: native)
        yield &native[key, isUnique: true]
        return
      }
      let isUnique = isUniquelyReferenced()
      yield &asNative[key, isUnique: isUnique]
    }
  }
}
extension Dictionary._Variant {
  @inlinable @inline(__always) mutating internal func mutatingFind(_ key: Key) -> (bucket: _NativeDictionary<Key, Value>.Bucket, found: Bool) {
    guard isNative else {
      let cocoa = asCocoa
      var native = _NativeDictionary<Key, Value>(
        cocoa, capacity: cocoa.count + 1)
      let result = native.mutatingFind(key, isUnique: true)
      self = .init(native: native)
      return result
    }
    let isUnique = isUniquelyReferenced()
    return asNative.mutatingFind(key, isUnique: isUnique)
  }
  @inlinable @inline(__always) mutating internal func ensureUniqueNative() -> _NativeDictionary<Key, Value> {
    guard isNative else {
      let native = _NativeDictionary<Key, Value>(asCocoa)
      self = .init(native: native)
      return native
    }
    let isUnique = isUniquelyReferenced()
    if !isUnique {
      asNative.copy()
    }
    return asNative
  }
  @inlinable mutating internal func updateValue(_ value: __owned Value, forKey key: Key) -> Value? {
    guard isNative else {
      // Make sure we have space for an extra element.
      let cocoa = asCocoa
      var native = _NativeDictionary<Key, Value>(
        cocoa,
        capacity: cocoa.count + 1)
      let result = native.updateValue(value, forKey: key, isUnique: true)
      self = .init(native: native)
      return result
    }
    let isUnique = self.isUniquelyReferenced()
    return asNative.updateValue(value, forKey: key, isUnique: isUnique)
  }
  @inlinable mutating internal func setValue(_ value: __owned Value, forKey key: Key) {
    if !isNative {
      // Make sure we have space for an extra element.
      let cocoa = asCocoa
      self = .init(native: _NativeDictionary<Key, Value>(
        cocoa,
        capacity: cocoa.count + 1))
    }
    let isUnique = self.isUniquelyReferenced()
    asNative.setValue(value, forKey: key, isUnique: isUnique)
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") mutating internal func remove(at index: Index) -> Element {
    // FIXME(performance): fuse data migration and element deletion into one
    // operation.
    let native = ensureUniqueNative()
    let bucket = native.validatedBucket(for: index)
    return asNative.uncheckedRemove(at: bucket, isUnique: true)
  }
  @inlinable mutating internal func removeValue(forKey key: Key) -> Value? {
    guard isNative else {
      let cocoaKey = _bridgeAnythingToObjectiveC(key)
      let cocoa = asCocoa
      guard cocoa.lookup(cocoaKey) != nil else { return nil }
      var native = _NativeDictionary<Key, Value>(cocoa)
      let (bucket, found) = native.find(key)
      _precondition(found, "Bridging did not preserve equality")
      let old = native.uncheckedRemove(at: bucket, isUnique: true).value
      self = .init(native: native)
      return old
    }
    let (bucket, found) = asNative.find(key)
    guard found else { return nil }
    let isUnique = isUniquelyReferenced()
    return asNative.uncheckedRemove(at: bucket, isUnique: isUnique).value
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") mutating internal func removeAll(keepingCapacity keepCapacity: Bool) {
    if !keepCapacity {
      self = .init(native: _NativeDictionary())
      return
    }
    guard count > 0 else { return }

    guard isNative else {
      self = .init(native: _NativeDictionary(capacity: asCocoa.count))
      return
    }
    let isUnique = isUniquelyReferenced()
    asNative.removeAll(isUnique: isUnique)
  }
}
extension Dictionary._Variant {
  @inlinable @inline(__always) __consuming internal func makeIterator() -> Dictionary<Key, Value>.Iterator {
    guard isNative else {
      return Dictionary.Iterator(_cocoa: asCocoa.makeIterator())
    }
    return Dictionary.Iterator(_native: asNative.makeIterator())
  }
}
extension Dictionary._Variant {
  @inlinable internal func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> _NativeDictionary<Key, T> {
    guard isNative else {
      return try asCocoa.mapValues(transform)
    }
    return try asNative.mapValues(transform)
  }
  @inlinable mutating internal func merge<S>(_ keysAndValues: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
    guard isNative else {
      var native = _NativeDictionary<Key, Value>(asCocoa)
      try native.merge(
        keysAndValues,
        isUnique: true,
        uniquingKeysWith: combine)
      self = .init(native: native)
      return
    }
    let isUnique = isUniquelyReferenced()
    try asNative.merge(
      keysAndValues,
      isUnique: isUnique,
      uniquingKeysWith: combine)
  }
}
@_fixed_layout public struct LazyDropWhileSequence<Base> where Base : Swift.Sequence {
  public typealias Element = Base.Element
  @inlinable internal init(_base: Base, predicate: @escaping (Element) -> Bool) {
    self._base = _base
    self._predicate = predicate
  }
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal let _predicate: (Element) -> Bool
}
extension LazyDropWhileSequence {
  @_fixed_layout public struct Iterator {
    public typealias Element = Base.Element
    @inlinable internal init(_base: Base.Iterator, predicate: @escaping (Element) -> Bool) {
      self._base = _base
      self._predicate = predicate
    }
    @usableFromInline
    internal var _predicateHasFailed: Swift.Bool = false
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal let _predicate: (Element) -> Bool
  }
}
extension LazyDropWhileSequence.Iterator : IteratorProtocol {
  @inlinable mutating public func next() -> Element? {
    // Once the predicate has failed for the first time, the base iterator
    // can be used for the rest of the elements.
    if _predicateHasFailed {
      return _base.next()
    }

    // Retrieve and discard elements from the base iterator until one fails
    // the predicate.
    while let nextElement = _base.next() {
      if !_predicate(nextElement) {
        _predicateHasFailed = true
        return nextElement
      }
    }
    return nil
  }
}
extension LazyDropWhileSequence : Sequence {
  @inlinable __consuming public func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator(), predicate: _predicate)
  }
}
extension LazyDropWhileSequence : LazySequenceProtocol {
  public typealias Elements = LazyDropWhileSequence
}
extension LazySequenceProtocol {
  @inlinable __consuming public func drop(while predicate: @escaping (Elements.Element) -> Bool) -> LazyDropWhileSequence<Self.Elements> {
    return LazyDropWhileSequence(_base: self.elements, predicate: predicate)
  }
}
public typealias LazyDropWhileCollection<T> = LazyDropWhileSequence<T> where T : Swift.Collection
extension LazyDropWhileSequence : Collection where Base : Swift.Collection {
  public typealias SubSequence = Slice<LazyDropWhileCollection<Base>>
  public typealias Index = Base.Index
  @inlinable public var startIndex: Index {
    get {
    var index = _base.startIndex
    while index != _base.endIndex && _predicate(_base[index]) {
      _base.formIndex(after: &index)
    }
    return index
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return _base.endIndex
  }
  }
  @inlinable public func index(after i: Index) -> Index {
    _precondition(i < _base.endIndex, "Can't advance past endIndex")
    return _base.index(after: i)
  }
  @inlinable public subscript(position: Index) -> Element {
    get {
    return _base[position]
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.LazyDropWhileSequence<Base>>
}
extension LazyDropWhileSequence : BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Index) -> Index {
    _precondition(i > startIndex, "Can't move before startIndex")
    return _base.index(before: i)
  }
}
extension LazyDropWhileSequence : LazyCollectionProtocol where Base : Swift.Collection {
}
@discardableResult
@_semantics("optimize.sil.specialize.generic.never") public func dump<T, TargetStream>(_ value: T, to target: inout TargetStream, name: String? = nil, indent: Int = 0, maxDepth: Int = .max, maxItems: Int = .max) -> T where TargetStream : Swift.TextOutputStream
@discardableResult
@_semantics("optimize.sil.specialize.generic.never") public func dump<T>(_ value: T, name: String? = nil, indent: Int = 0, maxDepth: Int = .max, maxItems: Int = .max) -> T
@_fixed_layout public struct EmptyCollection<Element> {
  @inlinable public init() {}
}
extension EmptyCollection {
  @_fixed_layout public struct Iterator {
    @inlinable public init() {}
  }
}
extension EmptyCollection.Iterator : IteratorProtocol, Sequence {
  @inlinable mutating public func next() -> Element? {
    return nil
  }
  public typealias Iterator = Swift.EmptyCollection<Element>.Iterator
}
extension EmptyCollection : Sequence {
  @inlinable public func makeIterator() -> Iterator {
    return Iterator()
  }
}
extension EmptyCollection : RandomAccessCollection, MutableCollection {
  public typealias Index = Int
  public typealias Indices = Range<Int>
  public typealias SubSequence = EmptyCollection<Element>
  @inlinable public var startIndex: Index {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return 0
  }
  }
  @inlinable public func index(after i: Index) -> Index {
    _preconditionFailure("EmptyCollection can't advance indices")
  }
  @inlinable public func index(before i: Index) -> Index {
    _preconditionFailure("EmptyCollection can't advance indices")
  }
  @inlinable public subscript(position: Index) -> Element {
    get {
      _preconditionFailure("Index out of range")
    }
    set {
      _preconditionFailure("Index out of range")
    }
  }
  @inlinable public subscript(bounds: Range<Index>) -> SubSequence {
    get {
      _debugPrecondition(bounds.lowerBound == 0 && bounds.upperBound == 0,
        "Index out of range")
      return self
    }
    set {
      _debugPrecondition(bounds.lowerBound == 0 && bounds.upperBound == 0,
        "Index out of range")
    }
  }
  @inlinable public var count: Int {
    get {
    return 0
  }
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int) -> Index {
    _debugPrecondition(i == startIndex && n == 0, "Index out of range")
    return i
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index? {
    _debugPrecondition(i == startIndex && limit == startIndex,
      "Index out of range")
    return n == 0 ? i : nil
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    _debugPrecondition(start == 0, "From must be startIndex (or endIndex)")
    _debugPrecondition(end == 0, "To must be endIndex (or startIndex)")
    return 0
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Index, bounds: Range<Index>) {
    _debugPrecondition(index == 0, "out of bounds")
    _debugPrecondition(bounds == indices, "invalid bounds for an empty collection")
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Range<Index>, bounds: Range<Index>) {
    _debugPrecondition(range == indices, "invalid range for an empty collection")
    _debugPrecondition(bounds == indices, "invalid bounds for an empty collection")
  }
}
extension EmptyCollection : Equatable {
  @inlinable public static func == (lhs: EmptyCollection<Element>, rhs: EmptyCollection<Element>) -> Bool {
    return true
  }
}
public protocol Equatable {
  static func == (lhs: Self, rhs: Self) -> Bool
}
extension Equatable {
  @_transparent public static func != (lhs: Self, rhs: Self) -> Bool {
    return !(lhs == rhs)
  }
}
@inlinable public func === (lhs: AnyObject?, rhs: AnyObject?) -> Bool {
  switch (lhs, rhs) {
  case let (l?, r?):
    return ObjectIdentifier(l) == ObjectIdentifier(r)
  case (nil, nil):
    return true
  default:
    return false
  }
}
@inlinable public func !== (lhs: AnyObject?, rhs: AnyObject?) -> Bool {
  return !(lhs === rhs)
}
public protocol Error {
  var _domain: String { get }
  var _code: Int { get }
  var _userInfo: AnyObject? { get }
  func _getEmbeddedNSError() -> AnyObject?
}
extension Error {
  public func _getEmbeddedNSError() -> AnyObject?
}
public func _getErrorEmbeddedNSError<T>(_ x: T) -> AnyObject? where T : Swift.Error
@_silgen_name("_swift_stdlib_bridgeErrorToNSError")
public func _bridgeErrorToNSError(_ error: __owned Error) -> AnyObject
@_silgen_name("swift_unexpectedError")
public func _unexpectedError(_ error: __owned Error, filenameStart: Builtin.RawPointer, filenameLength: Builtin.Word, filenameIsASCII: Builtin.Int1, line: Builtin.Word)
@_silgen_name("swift_errorInMain")
public func _errorInMain(_ error: Error)
@_silgen_name("_swift_stdlib_getDefaultErrorCode")
public func _getDefaultErrorCode<T>(_ error: T) -> Int where T : Swift.Error
extension Error {
  public var _code: Int {
    get
  }
  public var _domain: String {
    get
  }
  public var _userInfo: AnyObject? {
    get
  }
}
extension Error where Self : Swift.RawRepresentable, Self.RawValue : Swift.FixedWidthInteger {
  public var _code: Int {
    get
  }
}
@_fixed_layout public struct LazyFilterSequence<Base> where Base : Swift.Sequence {
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal let _predicate: (Base.Element) -> Bool
  @inlinable public init(_base base: Base, _ isIncluded: @escaping (Base.Element) -> Bool) {
    self._base = base
    self._predicate = isIncluded
  }
}
extension LazyFilterSequence {
  @_fixed_layout public struct Iterator {
    public var base: Base.Iterator {
      get
    }
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal let _predicate: (Base.Element) -> Bool
    @inlinable internal init(_base: Base.Iterator, _ isIncluded: @escaping (Base.Element) -> Bool) {
      self._base = _base
      self._predicate = isIncluded
    }
  }
}
extension LazyFilterSequence.Iterator : IteratorProtocol, Sequence {
  public typealias Element = Base.Element
  @inlinable mutating public func next() -> Element? {
    while let n = _base.next() {
      if _predicate(n) {
        return n
      }
    }
    return nil
  }
  public typealias Iterator = Swift.LazyFilterSequence<Base>.Iterator
}
extension LazyFilterSequence : Sequence {
  public typealias Element = Base.Element
  @inlinable __consuming public func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator(), _predicate)
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Bool? {
    // optimization to check the element first matches the predicate
    guard _predicate(element) else { return false }
    return _base._customContainsEquatableElement(element)
  }
}
extension LazyFilterSequence : LazySequenceProtocol {
  public typealias Elements = Swift.LazyFilterSequence<Base>
}
public typealias LazyFilterCollection<T> = LazyFilterSequence<T> where T : Swift.Collection
extension LazyFilterSequence : Collection where Base : Swift.Collection {
  public typealias SubSequence = LazyFilterCollection<Base.SubSequence>
  @inlinable public var underestimatedCount: Int {
    get { return 0 }
  }
  public typealias Index = Base.Index
  @inlinable public var startIndex: Index {
    get {
    var index = _base.startIndex
    while index != _base.endIndex && !_predicate(_base[index]) {
      _base.formIndex(after: &index)
    }
    return index
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return _base.endIndex
  }
  }
  @inlinable public func index(after i: Index) -> Index {
    var i = i
    formIndex(after: &i)
    return i
  }
  @inlinable public func formIndex(after i: inout Index) {
    // TODO: swift-3-indexing-model: _failEarlyRangeCheck i?
    var index = i
    _precondition(index != _base.endIndex, "Can't advance past endIndex")
    repeat {
      _base.formIndex(after: &index)
    } while index != _base.endIndex && !_predicate(_base[index])
    i = index
  }
  @inline(__always) @inlinable internal func _advanceIndex(_ i: inout Index, step: Int) {
    repeat {
      _base.formIndex(&i, offsetBy: step)
    } while i != _base.endIndex && !_predicate(_base[i])
  }
  @inline(__always) @inlinable internal func _ensureBidirectional(step: Int) {
    // FIXME: This seems to be the best way of checking whether _base is
    // forward only without adding an extra protocol requirement.
    // index(_:offsetBy:limitedBy:) is chosen becuase it is supposed to return
    // nil when the resulting index lands outside the collection boundaries,
    // and therefore likely does not trap in these cases.
    if step < 0 {
      _ = _base.index(
        _base.endIndex, offsetBy: step, limitedBy: _base.startIndex)
    }
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    // The following line makes sure that distance(from:to:) is invoked on the
    // _base at least once, to trigger a _precondition in forward only
    // collections.
    _ = _base.distance(from: start, to: end)
    var _start: Index
    let _end: Index
    let step: Int
    if start > end {
      _start = end
      _end = start
      step = -1
    }
    else {
      _start = start
      _end = end
      step = 1
    }
    var count = 0
    while _start != _end {
      count += step
      formIndex(after: &_start)
    }
    return count
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int) -> Index {
    var i = i
    let step = n.signum()
    // The following line makes sure that index(_:offsetBy:) is invoked on the
    // _base at least once, to trigger a _precondition in forward only
    // collections.
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(numericCast(n)) {
      _advanceIndex(&i, step: step)
    }
    return i
  }
  @inlinable public func formIndex(_ i: inout Index, offsetBy n: Int) {
    i = index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index? {
    var i = i
    let step = n.signum()
    // The following line makes sure that index(_:offsetBy:limitedBy:) is
    // invoked on the _base at least once, to trigger a _precondition in
    // forward only collections.
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(numericCast(n)) {
      if i == limit {
        return nil
      }
      _advanceIndex(&i, step: step)
    }
    return i
  }
  @inlinable public func formIndex(_ i: inout Index, offsetBy n: Int, limitedBy limit: Index) -> Bool {
    if let advancedIndex = index(i, offsetBy: n, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
  @inlinable public subscript(position: Index) -> Element {
    get {
    return _base[position]
  }
  }
  @inlinable public subscript(bounds: Range<Index>) -> SubSequence {
    get {
    return SubSequence(_base: _base[bounds], _predicate)
  }
  }
  @inlinable public func _customLastIndexOfEquatableElement(_ element: Element) -> Index?? {
    guard _predicate(element) else { return .some(nil) }
    return _base._customLastIndexOfEquatableElement(element)
  }
  public typealias Indices = Swift.DefaultIndices<Swift.LazyFilterSequence<Base>>
}
extension LazyFilterSequence : LazyCollectionProtocol where Base : Swift.Collection {
}
extension LazyFilterSequence : BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Index) -> Index {
    var i = i
    formIndex(before: &i)
    return i
  }
  @inlinable public func formIndex(before i: inout Index) {
    // TODO: swift-3-indexing-model: _failEarlyRangeCheck i?
    var index = i
    _precondition(index != _base.startIndex, "Can't retreat before startIndex")
    repeat {
      _base.formIndex(before: &index)
    } while !_predicate(_base[index])
    i = index
  }
}
extension LazySequenceProtocol {
  @inlinable __consuming public func filter(_ isIncluded: @escaping (Elements.Element) -> Bool) -> LazyFilterSequence<Self.Elements> {
    return LazyFilterSequence(_base: self.elements, isIncluded)
  }
}
extension LazyFilterSequence {
  @available(swift 5)
  __consuming public func filter(_ isIncluded: @escaping (Element) -> Bool) -> LazyFilterSequence<Base>
}
extension LazySequenceProtocol {
  @inlinable public func flatMap<SegmentOfResult>(_ transform: @escaping (Elements.Element) -> SegmentOfResult) -> LazySequence<FlattenSequence<LazyMapSequence<Elements, SegmentOfResult>>> where SegmentOfResult : Swift.Sequence {
    return self.map(transform).joined()
  }
  @inlinable public func compactMap<ElementOfResult>(_ transform: @escaping (Elements.Element) -> ElementOfResult?) -> LazyMapSequence<LazyFilterSequence<LazyMapSequence<Elements, ElementOfResult?>>, ElementOfResult> {
    return self.map(transform).filter { $0 != nil }.map { $0! }
  }
}
@_fixed_layout public struct FlattenSequence<Base> where Base : Swift.Sequence, Base.Element : Swift.Sequence {
  @usableFromInline
  internal var _base: Base
  @inlinable internal init(_base: Base) {
    self._base = _base
  }
}
extension FlattenSequence {
  @_fixed_layout public struct Iterator {
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal var _inner: Base.Element.Iterator?
    @inlinable internal init(_base: Base.Iterator) {
      self._base = _base
    }
  }
}
extension FlattenSequence.Iterator : IteratorProtocol {
  public typealias Element = Base.Element.Element
  @inlinable mutating public func next() -> Element? {
    repeat {
      if _fastPath(_inner != nil) {
        let ret = _inner!.next()
        if _fastPath(ret != nil) {
          return ret
        }
      }
      let s = _base.next()
      if _slowPath(s == nil) {
        return nil
      }
      _inner = s!.makeIterator()
    }
    while true
  }
}
extension FlattenSequence.Iterator : Sequence {
  public typealias Iterator = Swift.FlattenSequence<Base>.Iterator
}
extension FlattenSequence : Sequence {
  @inlinable __consuming public func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator())
  }
  public typealias Element = Base.Element.Element
}
extension Sequence where Self.Element : Swift.Sequence {
  @inlinable __consuming public func joined() -> FlattenSequence<Self> {
    return FlattenSequence(_base: self)
  }
}
extension LazySequenceProtocol where Self.Element : Swift.Sequence {
  @inlinable __consuming public func joined() -> LazySequence<FlattenSequence<Elements>> {
    return FlattenSequence(_base: elements).lazy
  }
}
public typealias FlattenCollection<T> = FlattenSequence<T> where T : Swift.Collection, T.Element : Swift.Collection
extension FlattenSequence where Base : Swift.Collection, Base.Element : Swift.Collection {
  @_fixed_layout public struct Index {
    @usableFromInline
    internal let _outer: Base.Index
    @usableFromInline
    internal let _inner: Base.Element.Index?
    @inlinable internal init(_ _outer: Base.Index, _ inner: Base.Element.Index?) {
      self._outer = _outer
      self._inner = inner
    }
  }
}
extension FlattenSequence.Index : Equatable {
  @inlinable public static func == (lhs: FlattenCollection<Base>.Index, rhs: FlattenCollection<Base>.Index) -> Bool {
    return lhs._outer == rhs._outer && lhs._inner == rhs._inner
  }
}
extension FlattenSequence.Index : Comparable {
  @inlinable public static func < (lhs: FlattenCollection<Base>.Index, rhs: FlattenCollection<Base>.Index) -> Bool {
    // FIXME: swift-3-indexing-model: tests.
    if lhs._outer != rhs._outer {
      return lhs._outer < rhs._outer
    }

    if let lhsInner = lhs._inner, let rhsInner = rhs._inner {
      return lhsInner < rhsInner
    }

    // When combined, the two conditions above guarantee that both
    // `_outer` indices are `_base.endIndex` and both `_inner` indices
    // are `nil`, since `_inner` is `nil` iff `_outer == base.endIndex`.
    _precondition(lhs._inner == nil && rhs._inner == nil)

    return false
  }
}
extension FlattenSequence.Index : Hashable where Base.Index : Swift.Hashable, Base.Element.Index : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine(_outer)
    hasher.combine(_inner)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension FlattenSequence : Collection where Base : Swift.Collection, Base.Element : Swift.Collection {
  @inlinable public var startIndex: Index {
    get {
    let end = _base.endIndex
    var outer = _base.startIndex
    while outer != end {
      let innerCollection = _base[outer]
      if !innerCollection.isEmpty {
        return Index(outer, innerCollection.startIndex)
      }
      _base.formIndex(after: &outer)
    }

    return endIndex
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return Index(_base.endIndex, nil)
  }
  }
  @inlinable internal func _index(after i: Index) -> Index {
    let innerCollection = _base[i._outer]
    let nextInner = innerCollection.index(after: i._inner!)
    if _fastPath(nextInner != innerCollection.endIndex) {
      return Index(i._outer, nextInner)
    }

    var nextOuter = _base.index(after: i._outer)
    while nextOuter != _base.endIndex {
      let nextInnerCollection = _base[nextOuter]
      if !nextInnerCollection.isEmpty {
        return Index(nextOuter, nextInnerCollection.startIndex)
      }
      _base.formIndex(after: &nextOuter)
    }

    return endIndex
  }
  @inlinable internal func _index(before i: Index) -> Index {
    var prevOuter = i._outer
    if prevOuter == _base.endIndex {
      prevOuter = _base.index(prevOuter, offsetBy: -1)
    }
    var prevInnerCollection = _base[prevOuter]
    var prevInner = i._inner ?? prevInnerCollection.endIndex

    while prevInner == prevInnerCollection.startIndex {
      prevOuter = _base.index(prevOuter, offsetBy: -1)
      prevInnerCollection = _base[prevOuter]
      prevInner = prevInnerCollection.endIndex
    }

    return Index(prevOuter, prevInnerCollection.index(prevInner, offsetBy: -1))
  }
  @inlinable public func index(after i: Index) -> Index {
    return _index(after: i)
  }
  @inlinable public func formIndex(after i: inout Index) {
    i = index(after: i)
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    // The following check makes sure that distance(from:to:) is invoked on the
    // _base at least once, to trigger a _precondition in forward only
    // collections.
    if end < start {
      _ = _base.distance(from: _base.endIndex, to: _base.startIndex)
    }
    var _start: Index
    let _end: Index
    let step: Int
    if start > end {
      _start = end
      _end = start
      step = -1
    }
    else {
      _start = start
      _end = end
      step = 1
    }
    var count = 0
    while _start != _end {
      count += step
      formIndex(after: &_start)
    }
    return count
  }
  @inline(__always) @inlinable internal func _advanceIndex(_ i: inout Index, step: Int) {
    _internalInvariant(-1...1 ~= step, "step should be within the -1...1 range")
    i = step < 0 ? _index(before: i) : _index(after: i)
  }
  @inline(__always) @inlinable internal func _ensureBidirectional(step: Int) {
    // FIXME: This seems to be the best way of checking whether _base is
    // forward only without adding an extra protocol requirement.
    // index(_:offsetBy:limitedBy:) is chosen becuase it is supposed to return
    // nil when the resulting index lands outside the collection boundaries,
    // and therefore likely does not trap in these cases.
    if step < 0 {
      _ = _base.index(
        _base.endIndex, offsetBy: step, limitedBy: _base.startIndex)
    }
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int) -> Index {
    var i = i
    let step = n.signum()
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(n) {
      _advanceIndex(&i, step: step)
    }
    return i
  }
  @inlinable public func formIndex(_ i: inout Index, offsetBy n: Int) {
    i = index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index? {
    var i = i
    let step = n.signum()
    // The following line makes sure that index(_:offsetBy:limitedBy:) is
    // invoked on the _base at least once, to trigger a _precondition in
    // forward only collections.
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(n) {
      if i == limit {
        return nil
      }
      _advanceIndex(&i, step: step)
    }
    return i
  }
  @inlinable public func formIndex(_ i: inout Index, offsetBy n: Int, limitedBy limit: Index) -> Bool {
    if let advancedIndex = index(i, offsetBy: n, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
  @inlinable public subscript(position: Index) -> Base.Element.Element {
    get {
    return _base[position._outer][position._inner!]
  }
  }
  @inlinable public subscript(bounds: Range<Index>) -> SubSequence {
    get {
    return Slice(base: self, bounds: bounds)
  }
  }
}
extension FlattenSequence : BidirectionalCollection where Base : Swift.BidirectionalCollection, Base.Element : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Index) -> Index {
    return _index(before: i)
  }
  @inlinable public func formIndex(before i: inout Index) {
    i = index(before: i)
  }
  public typealias SubSequence = Swift.Slice<Swift.FlattenSequence<Base>>
  public typealias Indices = Swift.DefaultIndices<Swift.FlattenSequence<Base>>
}
public protocol FloatingPoint : Swift.Hashable, Swift.SignedNumeric, Swift.Strideable where Self == Self.Magnitude {
  associatedtype Exponent : Swift.SignedInteger
  init(sign: FloatingPointSign, exponent: Exponent, significand: Self)
  init(signOf: Self, magnitudeOf: Self)
  init(_ value: Int)
  init<Source>(_ value: Source) where Source : Swift.BinaryInteger
  init?<Source>(exactly value: Source) where Source : Swift.BinaryInteger
  static var radix: Int { get }
  static var nan: Self { get }
  static var signalingNaN: Self { get }
  static var infinity: Self { get }
  static var greatestFiniteMagnitude: Self { get }
  static var pi: Self { get }
  var ulp: Self { get }
  static var ulpOfOne: Self { get }
  static var leastNormalMagnitude: Self { get }
  static var leastNonzeroMagnitude: Self { get }
  var sign: FloatingPointSign { get }
  var exponent: Exponent { get }
  var significand: Self { get }
  override static func + (lhs: Self, rhs: Self) -> Self
  override static func += (lhs: inout Self, rhs: Self)
  override prefix static func - (operand: Self) -> Self
  override mutating func negate()
  override static func - (lhs: Self, rhs: Self) -> Self
  override static func -= (lhs: inout Self, rhs: Self)
  override static func * (lhs: Self, rhs: Self) -> Self
  override static func *= (lhs: inout Self, rhs: Self)
  static func / (lhs: Self, rhs: Self) -> Self
  static func /= (lhs: inout Self, rhs: Self)
  func remainder(dividingBy other: Self) -> Self
  mutating func formRemainder(dividingBy other: Self)
  func truncatingRemainder(dividingBy other: Self) -> Self
  mutating func formTruncatingRemainder(dividingBy other: Self)
  func squareRoot() -> Self
  mutating func formSquareRoot()
  func addingProduct(_ lhs: Self, _ rhs: Self) -> Self
  mutating func addProduct(_ lhs: Self, _ rhs: Self)
  static func minimum(_ x: Self, _ y: Self) -> Self
  static func maximum(_ x: Self, _ y: Self) -> Self
  static func minimumMagnitude(_ x: Self, _ y: Self) -> Self
  static func maximumMagnitude(_ x: Self, _ y: Self) -> Self
  func rounded(_ rule: FloatingPointRoundingRule) -> Self
  mutating func round(_ rule: FloatingPointRoundingRule)
  var nextUp: Self { get }
  var nextDown: Self { get }
  func isEqual(to other: Self) -> Bool
  func isLess(than other: Self) -> Bool
  func isLessThanOrEqualTo(_ other: Self) -> Bool
  func isTotallyOrdered(belowOrEqualTo other: Self) -> Bool
  var isNormal: Bool { get }
  var isFinite: Bool { get }
  var isZero: Bool { get }
  var isSubnormal: Bool { get }
  var isInfinite: Bool { get }
  var isNaN: Bool { get }
  var isSignalingNaN: Bool { get }
  var floatingPointClass: FloatingPointClassification { get }
  var isCanonical: Bool { get }
}
@_frozen public enum FloatingPointSign : Int {
  case plus
  case minus
  @inlinable public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .plus
    case 1: self = .minus
    default: return nil
    }
  }
  @inlinable public var rawValue: Int {
    get {
    switch self {
    case .plus: return 0
    case .minus: return 1
    }
  }
  }
  @_transparent @inlinable public static func == (a: FloatingPointSign, b: FloatingPointSign) -> Bool {
    return a.rawValue == b.rawValue
  }
  @inlinable public var hashValue: Int {
    get { return rawValue.hashValue }
  }
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine(rawValue)
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
    return rawValue._rawHashValue(seed: seed)
  }
  public typealias RawValue = Swift.Int
}
@_frozen public enum FloatingPointClassification {
  case signalingNaN
  case quietNaN
  case negativeInfinity
  case negativeNormal
  case negativeSubnormal
  case negativeZero
  case positiveZero
  case positiveSubnormal
  case positiveNormal
  case positiveInfinity
  public static func == (a: Swift.FloatingPointClassification, b: Swift.FloatingPointClassification) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum FloatingPointRoundingRule {
  case toNearestOrAwayFromZero
  case toNearestOrEven
  case up
  case down
  case towardZero
  case awayFromZero
  public static func == (a: Swift.FloatingPointRoundingRule, b: Swift.FloatingPointRoundingRule) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension FloatingPoint {
  @_transparent public static func == (lhs: Self, rhs: Self) -> Bool {
    return lhs.isEqual(to: rhs)
  }
  @_transparent public static func < (lhs: Self, rhs: Self) -> Bool {
    return lhs.isLess(than: rhs)
  }
  @_transparent public static func <= (lhs: Self, rhs: Self) -> Bool {
    return lhs.isLessThanOrEqualTo(rhs)
  }
  @_transparent public static func > (lhs: Self, rhs: Self) -> Bool {
    return rhs.isLess(than: lhs)
  }
  @_transparent public static func >= (lhs: Self, rhs: Self) -> Bool {
    return rhs.isLessThanOrEqualTo(lhs)
  }
}
public protocol BinaryFloatingPoint : Swift.ExpressibleByFloatLiteral, Swift.FloatingPoint {
  associatedtype RawSignificand : Swift.UnsignedInteger
  associatedtype RawExponent : Swift.UnsignedInteger
  init(sign: FloatingPointSign, exponentBitPattern: RawExponent, significandBitPattern: RawSignificand)
  init(_ value: Float)
  init(_ value: Double)
  init(_ value: Float80)
  init<Source>(_ value: Source) where Source : Swift.BinaryFloatingPoint
  init?<Source>(exactly value: Source) where Source : Swift.BinaryFloatingPoint
  static var exponentBitCount: Int { get }
  static var significandBitCount: Int { get }
  var exponentBitPattern: RawExponent { get }
  var significandBitPattern: RawSignificand { get }
  var binade: Self { get }
  var significandWidth: Int { get }
}
extension FloatingPoint {
  @inlinable public static var ulpOfOne: Self {
    get {
    return (1 as Self).ulp
  }
  }
  @_transparent public func rounded(_ rule: FloatingPointRoundingRule) -> Self {
    var lhs = self
    lhs.round(rule)
    return lhs
  }
  @_transparent public func rounded() -> Self {
    return rounded(.toNearestOrAwayFromZero)
  }
  @_transparent mutating public func round() {
    round(.toNearestOrAwayFromZero)
  }
  @inlinable public var nextDown: Self {
    @inline(__always) get {
      return -(-self).nextUp
    }
  }
  @inlinable @inline(__always) public func truncatingRemainder(dividingBy other: Self) -> Self {
    var lhs = self
    lhs.formTruncatingRemainder(dividingBy: other)
    return lhs
  }
  @inlinable @inline(__always) public func remainder(dividingBy other: Self) -> Self {
    var lhs = self
    lhs.formRemainder(dividingBy: other)
    return lhs
  }
  @_transparent public func squareRoot() -> Self {
    var lhs = self
    lhs.formSquareRoot( )
    return lhs
  }
  @_transparent public func addingProduct(_ lhs: Self, _ rhs: Self) -> Self {
    var addend = self
    addend.addProduct(lhs, rhs)
    return addend
  }
  @inlinable public static func minimum(_ x: Self, _ y: Self) -> Self {
    if x.isSignalingNaN || y.isSignalingNaN {
      //  Produce a quiet NaN matching platform arithmetic behavior.
      return x + y
    }
    if x <= y || y.isNaN { return x }
    return y
  }
  @inlinable public static func maximum(_ x: Self, _ y: Self) -> Self {
    if x.isSignalingNaN || y.isSignalingNaN {
      //  Produce a quiet NaN matching platform arithmetic behavior.
      return x + y
    }
    if x > y || y.isNaN { return x }
    return y
  }
  @inlinable public static func minimumMagnitude(_ x: Self, _ y: Self) -> Self {
    if x.isSignalingNaN || y.isSignalingNaN {
      //  Produce a quiet NaN matching platform arithmetic behavior.
      return x + y
    }
    if x.magnitude <= y.magnitude || y.isNaN { return x }
    return y
  }
  @inlinable public static func maximumMagnitude(_ x: Self, _ y: Self) -> Self {
    if x.isSignalingNaN || y.isSignalingNaN {
      //  Produce a quiet NaN matching platform arithmetic behavior.
      return x + y
    }
    if x.magnitude > y.magnitude || y.isNaN { return x }
    return y
  }
  @inlinable public var floatingPointClass: FloatingPointClassification {
    get {
    if isSignalingNaN { return .signalingNaN }
    if isNaN { return .quietNaN }
    if isInfinite { return sign == .minus ? .negativeInfinity : .positiveInfinity }
    if isNormal { return sign == .minus ? .negativeNormal : .positiveNormal }
    if isSubnormal { return sign == .minus ? .negativeSubnormal : .positiveSubnormal }
    return sign == .minus ? .negativeZero : .positiveZero
  }
  }
}
extension BinaryFloatingPoint {
  public static var radix: Int {
    get
  }
  @inlinable public init(signOf: Self, magnitudeOf: Self) {
    self.init(sign: signOf.sign,
      exponentBitPattern: magnitudeOf.exponentBitPattern,
      significandBitPattern: magnitudeOf.significandBitPattern)
  }
  @inlinable public static func _convert<Source>(from source: Source) -> (value: Self, exact: Bool) where Source : Swift.BinaryFloatingPoint {
    guard _fastPath(!source.isZero) else {
      return (source.sign == .minus ? -0.0 : 0, true)
    }

    guard _fastPath(source.isFinite) else {
      if source.isInfinite {
        return (source.sign == .minus ? -.infinity : .infinity, true)
      }
      // IEEE 754 requires that any NaN payload be propagated, if possible.
      let payload_ =
        source.significandBitPattern &
          ~(Source.nan.significandBitPattern |
            Source.signalingNaN.significandBitPattern)
      let mask =
        Self.greatestFiniteMagnitude.significandBitPattern &
          ~(Self.nan.significandBitPattern |
            Self.signalingNaN.significandBitPattern)
      let payload = Self.RawSignificand(truncatingIfNeeded: payload_) & mask
      // Although .signalingNaN.exponentBitPattern == .nan.exponentBitPattern,
      // we do not *need* to rely on this relation, and therefore we do not.
      let value = source.isSignalingNaN
        ? Self(
          sign: source.sign,
          exponentBitPattern: Self.signalingNaN.exponentBitPattern,
          significandBitPattern: payload |
            Self.signalingNaN.significandBitPattern)
        : Self(
          sign: source.sign,
          exponentBitPattern: Self.nan.exponentBitPattern,
          significandBitPattern: payload | Self.nan.significandBitPattern)
      // We define exactness by equality after roundtripping; since NaN is never
      // equal to itself, it can never be converted exactly.
      return (value, false)
    }

    let exponent = source.exponent
    var exemplar = Self.leastNormalMagnitude
    let exponentBitPattern: Self.RawExponent
    let leadingBitIndex: Int
    let shift: Int
    let significandBitPattern: Self.RawSignificand

    if exponent < exemplar.exponent {
      // The floating-point result is either zero or subnormal.
      exemplar = Self.leastNonzeroMagnitude
      let minExponent = exemplar.exponent
      if exponent + 1 < minExponent {
        return (source.sign == .minus ? -0.0 : 0, false)
      }
      if _slowPath(exponent + 1 == minExponent) {
        // Although the most significant bit (MSB) of a subnormal source
        // significand is explicit, Swift BinaryFloatingPoint APIs actually
        // omit any explicit MSB from the count represented in
        // significandWidth. For instance:
        //
        //   Double.leastNonzeroMagnitude.significandWidth == 0
        //
        // Therefore, we do not need to adjust our work here for a subnormal
        // source.
        return source.significandWidth == 0
          ? (source.sign == .minus ? -0.0 : 0, false)
          : (source.sign == .minus ? -exemplar : exemplar, false)
      }

      exponentBitPattern = 0 as Self.RawExponent
      leadingBitIndex = Int(Self.Exponent(exponent) - minExponent)
      shift =
        leadingBitIndex &-
        (source.significandWidth &+
          source.significandBitPattern.trailingZeroBitCount)
      let leadingBit = source.isNormal
        ? (1 as Self.RawSignificand) << leadingBitIndex
        : 0
      significandBitPattern = leadingBit | (shift >= 0
        ? Self.RawSignificand(source.significandBitPattern) << shift
        : Self.RawSignificand(source.significandBitPattern >> -shift))
    } else {
      // The floating-point result is either normal or infinite.
      exemplar = Self.greatestFiniteMagnitude
      if exponent > exemplar.exponent {
        return (source.sign == .minus ? -.infinity : .infinity, false)
      }

      exponentBitPattern = exponent < 0
        ? (1 as Self).exponentBitPattern - Self.RawExponent(-exponent)
        : (1 as Self).exponentBitPattern + Self.RawExponent(exponent)
      leadingBitIndex = exemplar.significandWidth
      shift =
        leadingBitIndex &-
          (source.significandWidth &+
            source.significandBitPattern.trailingZeroBitCount)
      let sourceLeadingBit = source.isSubnormal
        ? (1 as Source.RawSignificand) <<
          (source.significandWidth &+
            source.significandBitPattern.trailingZeroBitCount)
        : 0
      significandBitPattern = shift >= 0
        ? Self.RawSignificand(
          sourceLeadingBit ^ source.significandBitPattern) << shift
        : Self.RawSignificand(
          (sourceLeadingBit ^ source.significandBitPattern) >> -shift)
    }

    let value = Self(
      sign: source.sign,
      exponentBitPattern: exponentBitPattern,
      significandBitPattern: significandBitPattern)

    if source.significandWidth <= leadingBitIndex {
      return (value, true)
    }
    // We promise to round to the closest representation, and if two
    // representable values are equally close, the value with more trailing
    // zeros in its significand bit pattern. Therefore, we must take a look at
    // the bits that we've just truncated.
    let ulp = (1 as Source.RawSignificand) << -shift
    let truncatedBits = source.significandBitPattern & (ulp - 1)
    if truncatedBits < ulp / 2 {
      return (value, false)
    }
    let rounded = source.sign == .minus ? value.nextDown : value.nextUp
    guard _fastPath(
      truncatedBits != ulp / 2 ||
        exponentBitPattern.trailingZeroBitCount <
          rounded.exponentBitPattern.trailingZeroBitCount) else {
      return (value, false)
    }
    return (rounded, false)
  }
  @inlinable public init<Source>(_ value: Source) where Source : Swift.BinaryFloatingPoint {
    self = Self._convert(from: value).value
  }
  @inlinable public init?<Source>(exactly value: Source) where Source : Swift.BinaryFloatingPoint {
    let (value_, exact) = Self._convert(from: value)
    guard exact else { return nil }
    self = value_
  }
  @inlinable public func isTotallyOrdered(belowOrEqualTo other: Self) -> Bool {
    // Quick return when possible.
    if self < other { return true }
    if other > self { return false }
    // Self and other are either equal or unordered.
    // Every negative-signed value (even NaN) is less than every positive-
    // signed value, so if the signs do not match, we simply return the
    // sign bit of self.
    if sign != other.sign { return sign == .minus }
    // Sign bits match; look at exponents.
    if exponentBitPattern > other.exponentBitPattern { return sign == .minus }
    if exponentBitPattern < other.exponentBitPattern { return sign == .plus }
    // Signs and exponents match, look at significands.
    if significandBitPattern > other.significandBitPattern {
      return sign == .minus
    }
    if significandBitPattern < other.significandBitPattern {
      return sign == .plus
    }
    //  Sign, exponent, and significand all match.
    return true
  }
}
extension BinaryFloatingPoint where Self.RawSignificand : Swift.FixedWidthInteger {
  @inlinable public static func _convert<Source>(from source: Source) -> (value: Self, exact: Bool) where Source : Swift.BinaryInteger {
    //  Useful constants:
    let exponentBias = (1 as Self).exponentBitPattern
    let significandMask = ((1 as RawSignificand) << Self.significandBitCount) &- 1
    //  Zero is really extra simple, and saves us from trying to normalize a
    //  value that cannot be normalized.
    if _fastPath(source == 0) { return (0, true) }
    //  We now have a non-zero value; convert it to a strictly positive value
    //  by taking the magnitude.
    let magnitude = source.magnitude
    var exponent = magnitude._binaryLogarithm()
    //  If the exponent would be larger than the largest representable
    //  exponent, the result is just an infinity of the appropriate sign.
    guard exponent <= Self.greatestFiniteMagnitude.exponent else {
      return (Source.isSigned && source < 0 ? -.infinity : .infinity, false)
    }
    //  If exponent <= significandBitCount, we don't need to round it to
    //  construct the significand; we just need to left-shift it into place;
    //  the result is always exact as we've accounted for exponent-too-large
    //  already and no rounding can occur.
    if exponent <= Self.significandBitCount {
      let shift = Self.significandBitCount &- exponent
      let significand = RawSignificand(magnitude) &<< shift
      let value = Self(
        sign: Source.isSigned && source < 0 ? .minus : .plus,
        exponentBitPattern: exponentBias + RawExponent(exponent),
        significandBitPattern: significand
      )
      return (value, true)
    }
    //  exponent > significandBitCount, so we need to do a rounding right
    //  shift, and adjust exponent if needed
    let shift = exponent &- Self.significandBitCount
    let halfway = (1 as Source.Magnitude) << (shift - 1)
    let mask = 2 * halfway - 1
    let fraction = magnitude & mask
    var significand = RawSignificand(truncatingIfNeeded: magnitude >> shift) & significandMask
    if fraction > halfway || (fraction == halfway && significand & 1 == 1) {
      var carry = false
      (significand, carry) = significand.addingReportingOverflow(1)
      if carry || significand > significandMask {
        exponent += 1
        guard exponent <= Self.greatestFiniteMagnitude.exponent else {
          return (Source.isSigned && source < 0 ? -.infinity : .infinity, false)
        }
      }
    }
    return (Self(
      sign: Source.isSigned && source < 0 ? .minus : .plus,
      exponentBitPattern: exponentBias + RawExponent(exponent),
      significandBitPattern: significand
    ), fraction == 0)
  }
  @inlinable public init<Source>(_ value: Source) where Source : Swift.BinaryInteger {
    self = Self._convert(from: value).value
  }
  @inlinable public init?<Source>(exactly value: Source) where Source : Swift.BinaryInteger {
    let (value_, exact) = Self._convert(from: value)
    guard exact else { return nil }
    self = value_
  }
  @inlinable public static func random<T>(in range: Range<Self>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    _precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )
    let delta = range.upperBound - range.lowerBound
    //  TODO: this still isn't quite right, because the computation of delta
    //  can overflow (e.g. if .upperBound = .maximumFiniteMagnitude and
    //  .lowerBound = -.upperBound); this should be re-written with an
    //  algorithm that handles that case correctly, but this precondition
    //  is an acceptable short-term fix.
    _precondition(
      delta.isFinite,
      "There is no uniform distribution on an infinite range"
    )
    let rand: Self.RawSignificand
    if Self.RawSignificand.bitWidth == Self.significandBitCount + 1 {
      rand = generator.next()
    } else {
      let significandCount = Self.significandBitCount + 1
      let maxSignificand: Self.RawSignificand = 1 << significandCount
      // Rather than use .next(upperBound:), which has to work with arbitrary
      // upper bounds, and therefore does extra work to avoid bias, we can take
      // a shortcut because we know that maxSignificand is a power of two.
      rand = generator.next() & (maxSignificand - 1)
    }
    let unitRandom = Self.init(rand) * (Self.ulpOfOne / 2)
    let randFloat = delta * unitRandom + range.lowerBound
    if randFloat == range.upperBound {
      return Self.random(in: range, using: &generator)
    }
    return randFloat
  }
  @inlinable public static func random(in range: Range<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
  @inlinable public static func random<T>(in range: ClosedRange<Self>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    _precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )
    let delta = range.upperBound - range.lowerBound
    //  TODO: this still isn't quite right, because the computation of delta
    //  can overflow (e.g. if .upperBound = .maximumFiniteMagnitude and
    //  .lowerBound = -.upperBound); this should be re-written with an
    //  algorithm that handles that case correctly, but this precondition
    //  is an acceptable short-term fix.
    _precondition(
      delta.isFinite,
      "There is no uniform distribution on an infinite range"
    )
    let rand: Self.RawSignificand
    if Self.RawSignificand.bitWidth == Self.significandBitCount + 1 {
      rand = generator.next()
      let tmp: UInt8 = generator.next() & 1
      if rand == Self.RawSignificand.max && tmp == 1 {
        return range.upperBound
      }
    } else {
      let significandCount = Self.significandBitCount + 1
      let maxSignificand: Self.RawSignificand = 1 << significandCount
      rand = generator.next(upperBound: maxSignificand + 1)
      if rand == maxSignificand {
        return range.upperBound
      }
    }
    let unitRandom = Self.init(rand) * (Self.ulpOfOne / 2)
    let randFloat = delta * unitRandom + range.lowerBound
    return randFloat
  }
  @inlinable public static func random(in range: ClosedRange<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}
@inlinable internal func _isspace_clocale(_ u: UTF16.CodeUnit) -> Bool {
  return "\t\n\u{b}\u{c}\r ".utf16.contains(u)
}
extension Float : LosslessStringConvertible {
  @inlinable public init?<S>(_ text: S) where S : Swift.StringProtocol {
    let u16 = text.utf16

    let (result, n) : (Float, Int) = text.withCString { chars in
      var result: Float = 0
      let endPtr = withUnsafeMutablePointer(to: &result) {
        _swift_stdlib_strtof_clocale(chars, $0)
      }
      return (result, endPtr == nil ? 0 : endPtr! - chars)
    }

    if n == 0 || n != u16.count
    || u16.contains(where: { $0 > 127 || _isspace_clocale($0) }) {
      return nil
    }
    self = result
  }
}
extension Double : LosslessStringConvertible {
  @inlinable public init?<S>(_ text: S) where S : Swift.StringProtocol {
    let u16 = text.utf16

    let (result, n) : (Double, Int) = text.withCString { chars in
      var result: Double = 0
      let endPtr = withUnsafeMutablePointer(to: &result) {
        _swift_stdlib_strtod_clocale(chars, $0)
      }
      return (result, endPtr == nil ? 0 : endPtr! - chars)
    }

    if n == 0 || n != u16.count
    || u16.contains(where: { $0 > 127 || _isspace_clocale($0) }) {
      return nil
    }
    self = result
  }
}
extension Float80 : LosslessStringConvertible {
  @inlinable public init?<S>(_ text: S) where S : Swift.StringProtocol {
    let u16 = text.utf16

    let (result, n) : (Float80, Int) = text.withCString { chars in
      var result: Float80 = 0
      let endPtr = withUnsafeMutablePointer(to: &result) {
        _swift_stdlib_strtold_clocale(chars, $0)
      }
      return (result, endPtr == nil ? 0 : endPtr! - chars)
    }

    if n == 0 || n != u16.count
    || u16.contains(where: { $0 > 127 || _isspace_clocale($0) }) {
      return nil
    }
    self = result
  }
}
@_fixed_layout public struct Float {
  public var _value: Builtin.FPIEEE32
  @_transparent public init() {
    let zero: Int64 = 0
    self._value = Builtin.sitofp_Int64_FPIEEE32(zero._value)
  }
  @_transparent public init(_ _value: Builtin.FPIEEE32) {
    self._value = _value
  }
}
extension Float : CustomStringConvertible {
  public var description: String {
    get
  }
}
extension Float : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension Float : TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
extension Float : BinaryFloatingPoint {
  public typealias Magnitude = Float
  public typealias Exponent = Int
  public typealias RawSignificand = UInt32
  @inlinable public static var exponentBitCount: Int {
    get {
    return 8
  }
  }
  @inlinable public static var significandBitCount: Int {
    get {
    return 23
  }
  }
  @inlinable internal static var _infinityExponent: UInt {
    @inline(__always) get { return 1 &<< UInt(exponentBitCount) - 1 }
  }
  @inlinable internal static var _exponentBias: UInt {
    @inline(__always) get { return _infinityExponent &>> 1 }
  }
  @inlinable internal static var _significandMask: UInt32 {
    @inline(__always) get {
      return 1 &<< UInt32(significandBitCount) - 1
    }
  }
  @inlinable internal static var _quietNaNMask: UInt32 {
    @inline(__always) get {
      return 1 &<< UInt32(significandBitCount - 1)
    }
  }
  @inlinable public var bitPattern: UInt32 {
    get {
    return UInt32(Builtin.bitcast_FPIEEE32_Int32(_value))
  }
  }
  @inlinable public init(bitPattern: UInt32) {
    self.init(Builtin.bitcast_Int32_FPIEEE32(bitPattern._value))
  }
  @inlinable public var sign: FloatingPointSign {
    get {
    let shift = Float.significandBitCount + Float.exponentBitCount
    return FloatingPointSign(rawValue: Int(bitPattern &>> UInt32(shift)))!
  }
  }
  @available(*, unavailable, renamed: "sign")
  public var isSignMinus: Bool {
    get
  }
  @inlinable public var exponentBitPattern: UInt {
    get {
    return UInt(bitPattern &>> UInt32(Float.significandBitCount)) &
      Float._infinityExponent
  }
  }
  @inlinable public var significandBitPattern: UInt32 {
    get {
    return UInt32(bitPattern) & Float._significandMask
  }
  }
  @inlinable public init(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt32) {
    let signShift = Float.significandBitCount + Float.exponentBitCount
    let sign = UInt32(sign == .minus ? 1 : 0)
    let exponent = UInt32(
      exponentBitPattern & Float._infinityExponent)
    let significand = UInt32(
      significandBitPattern & Float._significandMask)
    self.init(bitPattern:
      sign &<< UInt32(signShift) |
      exponent &<< UInt32(Float.significandBitCount) |
      significand)
  }
  @inlinable public var isCanonical: Bool {
    get {
    return true
  }
  }
  @inlinable public static var infinity: Float {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 490)
    return Float(bitPattern: 0b0_11111111_00000000000000000000000)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 504)
  }
  }
  @inlinable public static var nan: Float {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 529)
    return Float(bitPattern: 0b0_11111111_10000000000000000000000)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 541)
  }
  }
  @inlinable public static var signalingNaN: Float {
    get {
    return Float(nan: 0, signaling: true)
  }
  }
  @available(*, unavailable, renamed: "nan")
  public static var quietNaN: Float {
    get
  }
  @inlinable public static var greatestFiniteMagnitude: Float {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 577)
    return 0x1.fffffep127
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 587)
  }
  }
  @inlinable public static var pi: Float {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 601)
    // Note: this is not the correctly rounded (to nearest) value of pi,
    // because pi would round *up* in Float precision, which can result
    // in angles in the wrong quadrant if users aren't careful.  This is
    // not a problem for Double or Float80, as pi rounds down in both of
    // those formats.
    return 0x1.921fb4p1
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 612)
  }
  }
  @inlinable public var ulp: Float {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 636)
    guard _fastPath(isFinite) else { return .nan }
    if _fastPath(isNormal) {
      let bitPattern_ = bitPattern & Float.infinity.bitPattern
      return Float(bitPattern: bitPattern_) * 0x1p-23
    }
    // On arm, flush subnormal values to 0.
    return .leastNormalMagnitude * 0x1p-23
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 665)
  }
  }
  @inlinable public static var leastNormalMagnitude: Float {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 679)
    return 0x1p-126
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 689)
  }
  }
  @inlinable public static var leastNonzeroMagnitude: Float {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 703)
    return 0x1p-149
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 713)
  }
  }
  @inlinable public static var ulpOfOne: Float {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 724)
    return 0x1p-23
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 730)
  }
  }
  @inlinable public var exponent: Int {
    get {
    if !isFinite { return .max }
    if isZero { return .min }
    let provisional = Int(exponentBitPattern) - Int(Float._exponentBias)
    if isNormal { return provisional }
    let shift =
      Float.significandBitCount - significandBitPattern._binaryLogarithm()
    return provisional + 1 - shift
  }
  }
  @inlinable public var significand: Float {
    get {
    if isNaN { return self }
    if isNormal {
      return Float(sign: .plus,
        exponentBitPattern: Float._exponentBias,
        significandBitPattern: significandBitPattern)
    }
    if isSubnormal {
      let shift =
        Float.significandBitCount - significandBitPattern._binaryLogarithm()
      return Float(sign: .plus,
        exponentBitPattern: Float._exponentBias,
        significandBitPattern: significandBitPattern &<< shift)
    }
    // zero or infinity.
    return Float(sign: .plus,
      exponentBitPattern: exponentBitPattern,
      significandBitPattern: 0)
  }
  }
  @inlinable public init(sign: FloatingPointSign, exponent: Int, significand: Float) {
    var result = significand
    if sign == .minus { result = -result }
    if significand.isFinite && !significand.isZero {
      var clamped = exponent
      let leastNormalExponent = 1 - Int(Float._exponentBias)
      let greatestFiniteExponent = Int(Float._exponentBias)
      if clamped < leastNormalExponent {
        clamped = max(clamped, 3*leastNormalExponent)
        while clamped < leastNormalExponent {
          result  *= Float.leastNormalMagnitude
          clamped -= leastNormalExponent
        }
      }
      else if clamped > greatestFiniteExponent {
        clamped = min(clamped, 3*greatestFiniteExponent)
        let step = Float(sign: .plus,
          exponentBitPattern: Float._infinityExponent - 1,
          significandBitPattern: 0)
        while clamped > greatestFiniteExponent {
          result  *= step
          clamped -= greatestFiniteExponent
        }
      }
      let scale = Float(sign: .plus,
        exponentBitPattern: UInt(Int(Float._exponentBias) + clamped),
        significandBitPattern: 0)
      result = result * scale
    }
    self = result
  }
  @inlinable public init(nan payload: RawSignificand, signaling: Bool) {
    // We use significandBitCount - 2 bits for NaN payload.
    _precondition(payload < (Float._quietNaNMask &>> 1),
      "NaN payload is not encodable.")
    var significand = payload
    significand |= Float._quietNaNMask &>> (signaling ? 1 : 0)
    self.init(sign: .plus,
              exponentBitPattern: Float._infinityExponent,
              significandBitPattern: significand)
  }
  @inlinable public var nextUp: Float {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 936)
    // Silence signaling NaNs, map -0 to +0.
    let x = self + 0
    if _fastPath(x < .infinity) {
      let increment = Int32(bitPattern: x.bitPattern) &>> 31 | 1
      let bitPattern_ = x.bitPattern &+ UInt32(bitPattern: increment)
      return Float(bitPattern: bitPattern_)
    }
    return x
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 974)
  }
  }
  @_transparent mutating public func round(_ rule: FloatingPointRoundingRule) {
    switch rule {
    case .toNearestOrAwayFromZero:
      _value = Builtin.int_round_FPIEEE32(_value)
    case .toNearestOrEven:
      _value = Builtin.int_rint_FPIEEE32(_value)
    case .towardZero:
      _value = Builtin.int_trunc_FPIEEE32(_value)
    case .awayFromZero:
      if sign == .minus {
        _value = Builtin.int_floor_FPIEEE32(_value)
      }
      else {
        _value = Builtin.int_ceil_FPIEEE32(_value)
      }
    case .up:
      _value = Builtin.int_ceil_FPIEEE32(_value)
    case .down:
      _value = Builtin.int_floor_FPIEEE32(_value)
    @unknown default:
      self._roundSlowPath(rule)
    }
  }
  @usableFromInline
  mutating internal func _roundSlowPath(_ rule: FloatingPointRoundingRule)
  @_transparent mutating public func negate() {
    _value = Builtin.fneg_FPIEEE32(self._value)
  }
  @_transparent public static func += (lhs: inout Float, rhs: Float) {
    lhs._value = Builtin.fadd_FPIEEE32(lhs._value, rhs._value)
  }
  @_transparent public static func -= (lhs: inout Float, rhs: Float) {
    lhs._value = Builtin.fsub_FPIEEE32(lhs._value, rhs._value)
  }
  @_transparent public static func *= (lhs: inout Float, rhs: Float) {
    lhs._value = Builtin.fmul_FPIEEE32(lhs._value, rhs._value)
  }
  @_transparent public static func /= (lhs: inout Float, rhs: Float) {
    lhs._value = Builtin.fdiv_FPIEEE32(lhs._value, rhs._value)
  }
  @inlinable @inline(__always) mutating public func formRemainder(dividingBy other: Float) {
    self = _stdlib_remainderf(self, other)
  }
  @inlinable @inline(__always) mutating public func formTruncatingRemainder(dividingBy other: Float) {
    _value = Builtin.frem_FPIEEE32(self._value, other._value)
  }
  @_transparent mutating public func formSquareRoot() {
    self = _stdlib_squareRootf(self)
  }
  @_transparent mutating public func addProduct(_ lhs: Float, _ rhs: Float) {
    _value = Builtin.int_fma_FPIEEE32(lhs._value, rhs._value, _value)
  }
  @_transparent public func isEqual(to other: Float) -> Bool {
    return Bool(Builtin.fcmp_oeq_FPIEEE32(self._value, other._value))
  }
  @_transparent public func isLess(than other: Float) -> Bool {
    return Bool(Builtin.fcmp_olt_FPIEEE32(self._value, other._value))
  }
  @_transparent public func isLessThanOrEqualTo(_ other: Float) -> Bool {
    return Bool(Builtin.fcmp_ole_FPIEEE32(self._value, other._value))
  }
  @inlinable public var isNormal: Bool {
    @inline(__always) get {
      return exponentBitPattern > 0 && isFinite
    }
  }
  @inlinable public var isFinite: Bool {
    @inline(__always) get {
      return exponentBitPattern < Float._infinityExponent
    }
  }
  @inlinable public var isZero: Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern == 0
    }
  }
  @inlinable public var isSubnormal: Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern != 0
    }
  }
  @inlinable public var isInfinite: Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern == 0
    }
  }
  @inlinable public var isNaN: Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern != 0
    }
  }
  @inlinable public var isSignalingNaN: Bool {
    @inline(__always) get {
      return isNaN && (significandBitPattern & Float._quietNaNMask) == 0
    }
  }
  @inlinable public var binade: Float {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1394)
    guard _fastPath(isFinite) else { return .nan }
    if _slowPath(isSubnormal) {
      let bitPattern_ =
        (self * 0x1p23).bitPattern
          & (-Float.infinity).bitPattern
      return Float(bitPattern: bitPattern_) * 0x1p-23
    }
    return Float(bitPattern: bitPattern & (-Float.infinity).bitPattern)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1416)
  }
  }
  @inlinable public var significandWidth: Int {
    get {
    let trailingZeroBits = significandBitPattern.trailingZeroBitCount
    if isNormal {
      guard significandBitPattern != 0 else { return 0 }
      return Float.significandBitCount &- trailingZeroBits
    }
    if isSubnormal {
      let leadingZeroBits = significandBitPattern.leadingZeroBitCount
      return UInt32.bitWidth &- (trailingZeroBits &+ leadingZeroBits &+ 1)
    }
    return -1
  }
  }
  @inlinable @inline(__always) public init(floatLiteral value: Float) {
    self = value
  }
  public typealias FloatLiteralType = Swift.Float
  public typealias RawExponent = Swift.UInt
}
extension Float : _ExpressibleByBuiltinIntegerLiteral, ExpressibleByIntegerLiteral {
  @_transparent public init(_builtinIntegerLiteral value: Builtin.IntLiteral) {
    self = Float(Builtin.itofp_with_overflow_IntLiteral_FPIEEE32(value))
  }
  @_transparent public init(integerLiteral value: Int64) {
    self = Float(Builtin.sitofp_Int64_FPIEEE32(value._value))
  }
  public typealias IntegerLiteralType = Swift.Int64
}
extension Float : _ExpressibleByBuiltinFloatLiteral {
  @_transparent public init(_builtinFloatLiteral value: Builtin.FPIEEE80) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1504)
    self = Float(Builtin.fptrunc_FPIEEE80_FPIEEE32(value))
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1509)
  }
}
extension Float : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    var v = self
    if isZero {
      // To satisfy the axiom that equality implies hash equality, we need to
      // finesse the hash value of -0.0 to match +0.0.
      v = 0
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1553)
    hasher.combine(v.bitPattern)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1555)
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
    // To satisfy the axiom that equality implies hash equality, we need to
    // finesse the hash value of -0.0 to match +0.0.
    let v = isZero ? 0 : self
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1570)
    return Hasher._hash(seed: seed, bytes: UInt64(v.bitPattern), count: 4)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1572)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Float : _HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> AnyHashable?
}
extension Float {
  @inlinable public var magnitude: Float {
    @inline(__always) get {
      return Float(Builtin.int_fabs_FPIEEE32(_value))
    }
  }
}
extension Float {
  @_transparent prefix public static func - (x: Float) -> Float {
    return Float(Builtin.fneg_FPIEEE32(x._value))
  }
}
extension Float {
  @_transparent public init(_ v: Int) {
    _value = Builtin.sitofp_Int64_FPIEEE32(v._value)
  }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryInteger {
    if value.bitWidth <= 64 {
      if Source.isSigned {
        let asInt = Int(truncatingIfNeeded: value)
        _value = Builtin.sitofp_Int64_FPIEEE32(asInt._value)
      } else {
        let asUInt = Int(truncatingIfNeeded: value)
        _value = Builtin.uitofp_Int64_FPIEEE32(asUInt._value)
      }
    } else {
      self = Float._convert(from: value).value
    }
  }
  @inlinable @inline(__always) public init(_ other: Float) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1691)
    _value = other._value
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1693)
  }
  @inlinable @inline(__always) public init?(exactly other: Float) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Float(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Double) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1687)
    _value = Builtin.fptrunc_FPIEEE64_FPIEEE32(other._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1693)
  }
  @inlinable @inline(__always) public init?(exactly other: Double) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Double(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Float80) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1687)
    _value = Builtin.fptrunc_FPIEEE80_FPIEEE32(other._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1693)
  }
  @inlinable @inline(__always) public init?(exactly other: Float80) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Float80(self) != other {
      return nil
    }
  }
}
extension Float {
  @_transparent public static func + (lhs: Float, rhs: Float) -> Float {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Float, rhs: Float) -> Float {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Float, rhs: Float) -> Float {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Float, rhs: Float) -> Float {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
}
extension Float : Strideable {
  @_transparent public func distance(to other: Float) -> Float {
    return other - self
  }
  @_transparent public func advanced(by amount: Float) -> Float {
    return self + amount
  }
  public typealias Stride = Swift.Float
}
@_fixed_layout public struct Double {
  public var _value: Builtin.FPIEEE64
  @_transparent public init() {
    let zero: Int64 = 0
    self._value = Builtin.sitofp_Int64_FPIEEE64(zero._value)
  }
  @_transparent public init(_ _value: Builtin.FPIEEE64) {
    self._value = _value
  }
}
extension Double : CustomStringConvertible {
  public var description: String {
    get
  }
}
extension Double : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension Double : TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
extension Double : BinaryFloatingPoint {
  public typealias Magnitude = Double
  public typealias Exponent = Int
  public typealias RawSignificand = UInt64
  @inlinable public static var exponentBitCount: Int {
    get {
    return 11
  }
  }
  @inlinable public static var significandBitCount: Int {
    get {
    return 52
  }
  }
  @inlinable internal static var _infinityExponent: UInt {
    @inline(__always) get { return 1 &<< UInt(exponentBitCount) - 1 }
  }
  @inlinable internal static var _exponentBias: UInt {
    @inline(__always) get { return _infinityExponent &>> 1 }
  }
  @inlinable internal static var _significandMask: UInt64 {
    @inline(__always) get {
      return 1 &<< UInt64(significandBitCount) - 1
    }
  }
  @inlinable internal static var _quietNaNMask: UInt64 {
    @inline(__always) get {
      return 1 &<< UInt64(significandBitCount - 1)
    }
  }
  @inlinable public var bitPattern: UInt64 {
    get {
    return UInt64(Builtin.bitcast_FPIEEE64_Int64(_value))
  }
  }
  @inlinable public init(bitPattern: UInt64) {
    self.init(Builtin.bitcast_Int64_FPIEEE64(bitPattern._value))
  }
  @inlinable public var sign: FloatingPointSign {
    get {
    let shift = Double.significandBitCount + Double.exponentBitCount
    return FloatingPointSign(rawValue: Int(bitPattern &>> UInt64(shift)))!
  }
  }
  @available(*, unavailable, renamed: "sign")
  public var isSignMinus: Bool {
    get
  }
  @inlinable public var exponentBitPattern: UInt {
    get {
    return UInt(bitPattern &>> UInt64(Double.significandBitCount)) &
      Double._infinityExponent
  }
  }
  @inlinable public var significandBitPattern: UInt64 {
    get {
    return UInt64(bitPattern) & Double._significandMask
  }
  }
  @inlinable public init(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64) {
    let signShift = Double.significandBitCount + Double.exponentBitCount
    let sign = UInt64(sign == .minus ? 1 : 0)
    let exponent = UInt64(
      exponentBitPattern & Double._infinityExponent)
    let significand = UInt64(
      significandBitPattern & Double._significandMask)
    self.init(bitPattern:
      sign &<< UInt64(signShift) |
      exponent &<< UInt64(Double.significandBitCount) |
      significand)
  }
  @inlinable public var isCanonical: Bool {
    get {
    return true
  }
  }
  @inlinable public static var infinity: Double {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 492)
    return Double(
      bitPattern: 0b0_11111111111_0000000000000000000000000000000000000000000000000000)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 504)
  }
  }
  @inlinable public static var nan: Double {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 531)
    return Double(
      bitPattern: 0b0_11111111111_1000000000000000000000000000000000000000000000000000)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 541)
  }
  }
  @inlinable public static var signalingNaN: Double {
    get {
    return Double(nan: 0, signaling: true)
  }
  }
  @available(*, unavailable, renamed: "nan")
  public static var quietNaN: Double {
    get
  }
  @inlinable public static var greatestFiniteMagnitude: Double {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 579)
    return 0x1.fffffffffffffp1023
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 587)
  }
  }
  @inlinable public static var pi: Double {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 608)
    return 0x1.921fb54442d18p1
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 612)
  }
  }
  @inlinable public var ulp: Double {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 636)
    guard _fastPath(isFinite) else { return .nan }
    if _fastPath(isNormal) {
      let bitPattern_ = bitPattern & Double.infinity.bitPattern
      return Double(bitPattern: bitPattern_) * 0x1p-52
    }
    // On arm, flush subnormal values to 0.
    return .leastNormalMagnitude * 0x1p-52
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 665)
  }
  }
  @inlinable public static var leastNormalMagnitude: Double {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 681)
    return 0x1p-1022
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 689)
  }
  }
  @inlinable public static var leastNonzeroMagnitude: Double {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 705)
    return 0x1p-1074
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 713)
  }
  }
  @inlinable public static var ulpOfOne: Double {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 726)
    return 0x1p-52
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 730)
  }
  }
  @inlinable public var exponent: Int {
    get {
    if !isFinite { return .max }
    if isZero { return .min }
    let provisional = Int(exponentBitPattern) - Int(Double._exponentBias)
    if isNormal { return provisional }
    let shift =
      Double.significandBitCount - significandBitPattern._binaryLogarithm()
    return provisional + 1 - shift
  }
  }
  @inlinable public var significand: Double {
    get {
    if isNaN { return self }
    if isNormal {
      return Double(sign: .plus,
        exponentBitPattern: Double._exponentBias,
        significandBitPattern: significandBitPattern)
    }
    if isSubnormal {
      let shift =
        Double.significandBitCount - significandBitPattern._binaryLogarithm()
      return Double(sign: .plus,
        exponentBitPattern: Double._exponentBias,
        significandBitPattern: significandBitPattern &<< shift)
    }
    // zero or infinity.
    return Double(sign: .plus,
      exponentBitPattern: exponentBitPattern,
      significandBitPattern: 0)
  }
  }
  @inlinable public init(sign: FloatingPointSign, exponent: Int, significand: Double) {
    var result = significand
    if sign == .minus { result = -result }
    if significand.isFinite && !significand.isZero {
      var clamped = exponent
      let leastNormalExponent = 1 - Int(Double._exponentBias)
      let greatestFiniteExponent = Int(Double._exponentBias)
      if clamped < leastNormalExponent {
        clamped = max(clamped, 3*leastNormalExponent)
        while clamped < leastNormalExponent {
          result  *= Double.leastNormalMagnitude
          clamped -= leastNormalExponent
        }
      }
      else if clamped > greatestFiniteExponent {
        clamped = min(clamped, 3*greatestFiniteExponent)
        let step = Double(sign: .plus,
          exponentBitPattern: Double._infinityExponent - 1,
          significandBitPattern: 0)
        while clamped > greatestFiniteExponent {
          result  *= step
          clamped -= greatestFiniteExponent
        }
      }
      let scale = Double(sign: .plus,
        exponentBitPattern: UInt(Int(Double._exponentBias) + clamped),
        significandBitPattern: 0)
      result = result * scale
    }
    self = result
  }
  @inlinable public init(nan payload: RawSignificand, signaling: Bool) {
    // We use significandBitCount - 2 bits for NaN payload.
    _precondition(payload < (Double._quietNaNMask &>> 1),
      "NaN payload is not encodable.")
    var significand = payload
    significand |= Double._quietNaNMask &>> (signaling ? 1 : 0)
    self.init(sign: .plus,
              exponentBitPattern: Double._infinityExponent,
              significandBitPattern: significand)
  }
  @inlinable public var nextUp: Double {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 936)
    // Silence signaling NaNs, map -0 to +0.
    let x = self + 0
    if _fastPath(x < .infinity) {
      let increment = Int64(bitPattern: x.bitPattern) &>> 63 | 1
      let bitPattern_ = x.bitPattern &+ UInt64(bitPattern: increment)
      return Double(bitPattern: bitPattern_)
    }
    return x
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 974)
  }
  }
  @_transparent mutating public func round(_ rule: FloatingPointRoundingRule) {
    switch rule {
    case .toNearestOrAwayFromZero:
      _value = Builtin.int_round_FPIEEE64(_value)
    case .toNearestOrEven:
      _value = Builtin.int_rint_FPIEEE64(_value)
    case .towardZero:
      _value = Builtin.int_trunc_FPIEEE64(_value)
    case .awayFromZero:
      if sign == .minus {
        _value = Builtin.int_floor_FPIEEE64(_value)
      }
      else {
        _value = Builtin.int_ceil_FPIEEE64(_value)
      }
    case .up:
      _value = Builtin.int_ceil_FPIEEE64(_value)
    case .down:
      _value = Builtin.int_floor_FPIEEE64(_value)
    @unknown default:
      self._roundSlowPath(rule)
    }
  }
  @usableFromInline
  mutating internal func _roundSlowPath(_ rule: FloatingPointRoundingRule)
  @_transparent mutating public func negate() {
    _value = Builtin.fneg_FPIEEE64(self._value)
  }
  @_transparent public static func += (lhs: inout Double, rhs: Double) {
    lhs._value = Builtin.fadd_FPIEEE64(lhs._value, rhs._value)
  }
  @_transparent public static func -= (lhs: inout Double, rhs: Double) {
    lhs._value = Builtin.fsub_FPIEEE64(lhs._value, rhs._value)
  }
  @_transparent public static func *= (lhs: inout Double, rhs: Double) {
    lhs._value = Builtin.fmul_FPIEEE64(lhs._value, rhs._value)
  }
  @_transparent public static func /= (lhs: inout Double, rhs: Double) {
    lhs._value = Builtin.fdiv_FPIEEE64(lhs._value, rhs._value)
  }
  @inlinable @inline(__always) mutating public func formRemainder(dividingBy other: Double) {
    self = _stdlib_remainder(self, other)
  }
  @inlinable @inline(__always) mutating public func formTruncatingRemainder(dividingBy other: Double) {
    _value = Builtin.frem_FPIEEE64(self._value, other._value)
  }
  @_transparent mutating public func formSquareRoot() {
    self = _stdlib_squareRoot(self)
  }
  @_transparent mutating public func addProduct(_ lhs: Double, _ rhs: Double) {
    _value = Builtin.int_fma_FPIEEE64(lhs._value, rhs._value, _value)
  }
  @_transparent public func isEqual(to other: Double) -> Bool {
    return Bool(Builtin.fcmp_oeq_FPIEEE64(self._value, other._value))
  }
  @_transparent public func isLess(than other: Double) -> Bool {
    return Bool(Builtin.fcmp_olt_FPIEEE64(self._value, other._value))
  }
  @_transparent public func isLessThanOrEqualTo(_ other: Double) -> Bool {
    return Bool(Builtin.fcmp_ole_FPIEEE64(self._value, other._value))
  }
  @inlinable public var isNormal: Bool {
    @inline(__always) get {
      return exponentBitPattern > 0 && isFinite
    }
  }
  @inlinable public var isFinite: Bool {
    @inline(__always) get {
      return exponentBitPattern < Double._infinityExponent
    }
  }
  @inlinable public var isZero: Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern == 0
    }
  }
  @inlinable public var isSubnormal: Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern != 0
    }
  }
  @inlinable public var isInfinite: Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern == 0
    }
  }
  @inlinable public var isNaN: Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern != 0
    }
  }
  @inlinable public var isSignalingNaN: Bool {
    @inline(__always) get {
      return isNaN && (significandBitPattern & Double._quietNaNMask) == 0
    }
  }
  @inlinable public var binade: Double {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1394)
    guard _fastPath(isFinite) else { return .nan }
    if _slowPath(isSubnormal) {
      let bitPattern_ =
        (self * 0x1p52).bitPattern
          & (-Double.infinity).bitPattern
      return Double(bitPattern: bitPattern_) * 0x1p-52
    }
    return Double(bitPattern: bitPattern & (-Double.infinity).bitPattern)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1416)
  }
  }
  @inlinable public var significandWidth: Int {
    get {
    let trailingZeroBits = significandBitPattern.trailingZeroBitCount
    if isNormal {
      guard significandBitPattern != 0 else { return 0 }
      return Double.significandBitCount &- trailingZeroBits
    }
    if isSubnormal {
      let leadingZeroBits = significandBitPattern.leadingZeroBitCount
      return UInt64.bitWidth &- (trailingZeroBits &+ leadingZeroBits &+ 1)
    }
    return -1
  }
  }
  @inlinable @inline(__always) public init(floatLiteral value: Double) {
    self = value
  }
  public typealias FloatLiteralType = Swift.Double
  public typealias RawExponent = Swift.UInt
}
extension Double : _ExpressibleByBuiltinIntegerLiteral, ExpressibleByIntegerLiteral {
  @_transparent public init(_builtinIntegerLiteral value: Builtin.IntLiteral) {
    self = Double(Builtin.itofp_with_overflow_IntLiteral_FPIEEE64(value))
  }
  @_transparent public init(integerLiteral value: Int64) {
    self = Double(Builtin.sitofp_Int64_FPIEEE64(value._value))
  }
  public typealias IntegerLiteralType = Swift.Int64
}
extension Double : _ExpressibleByBuiltinFloatLiteral {
  @_transparent public init(_builtinFloatLiteral value: Builtin.FPIEEE80) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1504)
    self = Double(Builtin.fptrunc_FPIEEE80_FPIEEE64(value))
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1509)
  }
}
extension Double : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    var v = self
    if isZero {
      // To satisfy the axiom that equality implies hash equality, we need to
      // finesse the hash value of -0.0 to match +0.0.
      v = 0
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1553)
    hasher.combine(v.bitPattern)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1555)
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
    // To satisfy the axiom that equality implies hash equality, we need to
    // finesse the hash value of -0.0 to match +0.0.
    let v = isZero ? 0 : self
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1568)
    return Hasher._hash(seed: seed, v.bitPattern)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1572)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Double : _HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> AnyHashable?
}
extension Double {
  @inlinable public var magnitude: Double {
    @inline(__always) get {
      return Double(Builtin.int_fabs_FPIEEE64(_value))
    }
  }
}
extension Double {
  @_transparent prefix public static func - (x: Double) -> Double {
    return Double(Builtin.fneg_FPIEEE64(x._value))
  }
}
extension Double {
  @_transparent public init(_ v: Int) {
    _value = Builtin.sitofp_Int64_FPIEEE64(v._value)
  }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryInteger {
    if value.bitWidth <= 64 {
      if Source.isSigned {
        let asInt = Int(truncatingIfNeeded: value)
        _value = Builtin.sitofp_Int64_FPIEEE64(asInt._value)
      } else {
        let asUInt = Int(truncatingIfNeeded: value)
        _value = Builtin.uitofp_Int64_FPIEEE64(asUInt._value)
      }
    } else {
      self = Double._convert(from: value).value
    }
  }
  @inlinable @inline(__always) public init(_ other: Float) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1689)
    _value = Builtin.fpext_FPIEEE32_FPIEEE64(other._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1693)
  }
  @inlinable @inline(__always) public init?(exactly other: Float) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Float(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Double) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1691)
    _value = other._value
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1693)
  }
  @inlinable @inline(__always) public init?(exactly other: Double) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Double(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Float80) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1687)
    _value = Builtin.fptrunc_FPIEEE80_FPIEEE64(other._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1693)
  }
  @inlinable @inline(__always) public init?(exactly other: Float80) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Float80(self) != other {
      return nil
    }
  }
}
extension Double {
  @_transparent public static func + (lhs: Double, rhs: Double) -> Double {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Double, rhs: Double) -> Double {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Double, rhs: Double) -> Double {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Double, rhs: Double) -> Double {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
}
extension Double : Strideable {
  @_transparent public func distance(to other: Double) -> Double {
    return other - self
  }
  @_transparent public func advanced(by amount: Double) -> Double {
    return self + amount
  }
  public typealias Stride = Swift.Double
}
@_fixed_layout public struct Float80 {
  public var _value: Builtin.FPIEEE80
  @_transparent public init() {
    let zero: Int64 = 0
    self._value = Builtin.sitofp_Int64_FPIEEE80(zero._value)
  }
  @_transparent public init(_ _value: Builtin.FPIEEE80) {
    self._value = _value
  }
}
extension Float80 : CustomStringConvertible {
  public var description: String {
    get
  }
}
extension Float80 : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension Float80 : TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
extension Float80 : BinaryFloatingPoint {
  public typealias Magnitude = Float80
  public typealias Exponent = Int
  public typealias RawSignificand = UInt64
  @inlinable public static var exponentBitCount: Int {
    get {
    return 15
  }
  }
  @inlinable public static var significandBitCount: Int {
    get {
    return 63
  }
  }
  @inlinable internal static var _infinityExponent: UInt {
    @inline(__always) get { return 1 &<< UInt(exponentBitCount) - 1 }
  }
  @inlinable internal static var _exponentBias: UInt {
    @inline(__always) get { return _infinityExponent &>> 1 }
  }
  @inlinable internal static var _significandMask: UInt64 {
    @inline(__always) get {
      return 1 &<< UInt64(significandBitCount) - 1
    }
  }
  @inlinable internal static var _quietNaNMask: UInt64 {
    @inline(__always) get {
      return 1 &<< UInt64(significandBitCount - 1)
    }
  }
  @usableFromInline
  @_fixed_layout internal struct _Representation {
    @usableFromInline
    internal var _storage: (UInt64, UInt16, UInt16, UInt16, UInt16)
    @usableFromInline
    @_transparent internal var explicitSignificand: UInt64 {
      get { return _storage.0 }
    }
    @usableFromInline
    @_transparent internal var signAndExponent: UInt16 {
      get { return _storage.1 }
    }
    @usableFromInline
    @_transparent internal var sign: FloatingPointSign {
      get {
      return FloatingPointSign(rawValue: Int(signAndExponent &>> 15))!
    }
    }
    @usableFromInline
    @_transparent internal var exponentBitPattern: UInt {
      get {
      return UInt(signAndExponent) & 0x7fff
    }
    }
    @usableFromInline
    @_transparent internal init(explicitSignificand: UInt64, signAndExponent: UInt16) {
      _storage = (explicitSignificand, signAndExponent, 0, 0, 0)
    }
  }
  @inlinable internal var _representation: _Representation {
    get {
    return unsafeBitCast(self, to: _Representation.self)
  }
  }
  @inlinable public var sign: FloatingPointSign {
    get {
    return _representation.sign
  }
  }
  @inlinable internal static var _explicitBitMask: UInt64 {
    @inline(__always) get { return 1 &<< 63 }
  }
  @inlinable public var exponentBitPattern: UInt {
    get {
    let provisional = _representation.exponentBitPattern
    if provisional == 0 {
      if _representation.explicitSignificand >= Float80._explicitBitMask {
        //  Pseudo-denormals have an exponent of 0 but the leading bit of the
        //  significand field is set.  These are noncanonical encodings of the
        //  same significand with an exponent of 1.
        return 1
      }
      //  Exponent is zero, leading bit of significand is clear, so this is
      //  a canonical zero or subnormal number.
      return 0
    }
    if _representation.explicitSignificand < Float80._explicitBitMask {
      //  If the exponent is not-zero but the leading bit of the significand
      //  is clear, then we have an invalid operand (unnormal, pseudo-inf, or
      //  pseudo-NaN).  All of these are noncanonical encodings of NaN.
      return Float80._infinityExponent
    }
    //  We have a canonical number, so the provisional exponent is correct.
    return provisional
  }
  }
  @inlinable public var significandBitPattern: UInt64 {
    get {
    if _representation.exponentBitPattern > 0 &&
      _representation.explicitSignificand < Float80._explicitBitMask {
        //  If the exponent is nonzero and the leading bit of the significand
        //  is clear, then we have an invalid operand (unnormal, pseudo-inf, or
        //  pseudo-NaN).  All of these are noncanonical encodings of qNaN.
        return _representation.explicitSignificand | Float80._quietNaNMask
    }
    //  Otherwise we always get the "right" significand by simply clearing the
    //  integral bit.
    return _representation.explicitSignificand & Float80._significandMask
  }
  }
  @inlinable public init(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64) {
    let signBit = UInt16(sign == .minus ? 0x8000 : 0)
    let exponent = UInt16(exponentBitPattern)
    var significand = significandBitPattern
    if exponent != 0 { significand |= Float80._explicitBitMask }
    let rep = _Representation(
      explicitSignificand: significand, signAndExponent: signBit|exponent)
    self = unsafeBitCast(rep, to: Float80.self)
  }
  @inlinable public var isCanonical: Bool {
    get {
    if exponentBitPattern == 0 {
      // If exponent field is zero, canonical numbers have the explicit
      // significand bit clear.
      return _representation.explicitSignificand < Float80._explicitBitMask
    }
    // If exponent is nonzero, canonical values have the explicit significand
    // bit set.
    return _representation.explicitSignificand >= Float80._explicitBitMask
  }
  }
  @inlinable public static var infinity: Float80 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 495)
    let rep = _Representation(
      explicitSignificand: Float80._explicitBitMask,
      signAndExponent: 0b0_111111111111111)
    return unsafeBitCast(rep, to: Float80.self)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 504)
  }
  }
  @inlinable public static var nan: Float80 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 534)
    let rep = _Representation(
      explicitSignificand: Float80._explicitBitMask | Float80._quietNaNMask,
      signAndExponent: 0b0_111111111111111)
    return unsafeBitCast(rep, to: Float80.self)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 541)
  }
  }
  @inlinable public static var signalingNaN: Float80 {
    get {
    return Float80(nan: 0, signaling: true)
  }
  }
  @available(*, unavailable, renamed: "nan")
  public static var quietNaN: Float80 {
    get
  }
  @inlinable public static var greatestFiniteMagnitude: Float80 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 581)
    return 0x1.fffffffffffffffep16383
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 587)
  }
  }
  @inlinable public static var pi: Float80 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 610)
    return 0x1.921fb54442d1846ap1
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 612)
  }
  }
  @inlinable public var ulp: Float80 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 644)
    guard _fastPath(isFinite) else { return .nan }
    if exponentBitPattern > UInt(Float80.significandBitCount) {
      // self is large enough that self.ulp is normal, so we just compute its
      // exponent and construct it with a significand of zero.
      let ulpExponent =
        exponentBitPattern - UInt(Float80.significandBitCount)
      return Float80(sign: .plus,
        exponentBitPattern: ulpExponent,
        significandBitPattern: 0)
    }
    if exponentBitPattern >= 1 {
      // self is normal but ulp is subnormal.
      let ulpShift = UInt64(exponentBitPattern - 1)
      return Float80(sign: .plus,
        exponentBitPattern: 0,
        significandBitPattern: 1 &<< ulpShift)
    }
    return Float80(sign: .plus,
      exponentBitPattern: 0,
      significandBitPattern: 1)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 665)
  }
  }
  @inlinable public static var leastNormalMagnitude: Float80 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 683)
    return 0x1p-16382
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 689)
  }
  }
  @inlinable public static var leastNonzeroMagnitude: Float80 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 707)
    return 0x1p-16445
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 713)
  }
  }
  @inlinable public static var ulpOfOne: Float80 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 728)
    return 0x1p-63
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 730)
  }
  }
  @inlinable public var exponent: Int {
    get {
    if !isFinite { return .max }
    if isZero { return .min }
    let provisional = Int(exponentBitPattern) - Int(Float80._exponentBias)
    if isNormal { return provisional }
    let shift =
      Float80.significandBitCount - significandBitPattern._binaryLogarithm()
    return provisional + 1 - shift
  }
  }
  @inlinable public var significand: Float80 {
    get {
    if isNaN { return self }
    if isNormal {
      return Float80(sign: .plus,
        exponentBitPattern: Float80._exponentBias,
        significandBitPattern: significandBitPattern)
    }
    if isSubnormal {
      let shift =
        Float80.significandBitCount - significandBitPattern._binaryLogarithm()
      return Float80(sign: .plus,
        exponentBitPattern: Float80._exponentBias,
        significandBitPattern: significandBitPattern &<< shift)
    }
    // zero or infinity.
    return Float80(sign: .plus,
      exponentBitPattern: exponentBitPattern,
      significandBitPattern: 0)
  }
  }
  @inlinable public init(sign: FloatingPointSign, exponent: Int, significand: Float80) {
    var result = significand
    if sign == .minus { result = -result }
    if significand.isFinite && !significand.isZero {
      var clamped = exponent
      let leastNormalExponent = 1 - Int(Float80._exponentBias)
      let greatestFiniteExponent = Int(Float80._exponentBias)
      if clamped < leastNormalExponent {
        clamped = max(clamped, 3*leastNormalExponent)
        while clamped < leastNormalExponent {
          result  *= Float80.leastNormalMagnitude
          clamped -= leastNormalExponent
        }
      }
      else if clamped > greatestFiniteExponent {
        clamped = min(clamped, 3*greatestFiniteExponent)
        let step = Float80(sign: .plus,
          exponentBitPattern: Float80._infinityExponent - 1,
          significandBitPattern: 0)
        while clamped > greatestFiniteExponent {
          result  *= step
          clamped -= greatestFiniteExponent
        }
      }
      let scale = Float80(sign: .plus,
        exponentBitPattern: UInt(Int(Float80._exponentBias) + clamped),
        significandBitPattern: 0)
      result = result * scale
    }
    self = result
  }
  @inlinable public init(nan payload: RawSignificand, signaling: Bool) {
    // We use significandBitCount - 2 bits for NaN payload.
    _precondition(payload < (Float80._quietNaNMask &>> 1),
      "NaN payload is not encodable.")
    var significand = payload
    significand |= Float80._quietNaNMask &>> (signaling ? 1 : 0)
    self.init(sign: .plus,
              exponentBitPattern: Float80._infinityExponent,
              significandBitPattern: significand)
  }
  @inlinable public var nextUp: Float80 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 950)
    if isNaN { /* Silence signaling NaNs. */ return self + 0 }
    if sign == .minus {
      if significandBitPattern == 0 {
        if exponentBitPattern == 0 {
          return .leastNonzeroMagnitude
        }
        return Float80(sign: .minus,
          exponentBitPattern: exponentBitPattern - 1,
          significandBitPattern: Float80._significandMask)
      }
      return Float80(sign: .minus,
        exponentBitPattern: exponentBitPattern,
        significandBitPattern: significandBitPattern - 1)
    }
    if isInfinite { return self }
    if significandBitPattern == Float80._significandMask {
      return Float80(sign: .plus,
        exponentBitPattern: exponentBitPattern + 1,
        significandBitPattern: 0)
    }
    return Float80(sign: .plus,
      exponentBitPattern: exponentBitPattern,
      significandBitPattern: significandBitPattern + 1)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 974)
  }
  }
  @_transparent mutating public func round(_ rule: FloatingPointRoundingRule) {
    switch rule {
    case .toNearestOrAwayFromZero:
      _value = Builtin.int_round_FPIEEE80(_value)
    case .toNearestOrEven:
      _value = Builtin.int_rint_FPIEEE80(_value)
    case .towardZero:
      _value = Builtin.int_trunc_FPIEEE80(_value)
    case .awayFromZero:
      if sign == .minus {
        _value = Builtin.int_floor_FPIEEE80(_value)
      }
      else {
        _value = Builtin.int_ceil_FPIEEE80(_value)
      }
    case .up:
      _value = Builtin.int_ceil_FPIEEE80(_value)
    case .down:
      _value = Builtin.int_floor_FPIEEE80(_value)
    @unknown default:
      self._roundSlowPath(rule)
    }
  }
  @usableFromInline
  mutating internal func _roundSlowPath(_ rule: FloatingPointRoundingRule)
  @_transparent mutating public func negate() {
    _value = Builtin.fneg_FPIEEE80(self._value)
  }
  @_transparent public static func += (lhs: inout Float80, rhs: Float80) {
    lhs._value = Builtin.fadd_FPIEEE80(lhs._value, rhs._value)
  }
  @_transparent public static func -= (lhs: inout Float80, rhs: Float80) {
    lhs._value = Builtin.fsub_FPIEEE80(lhs._value, rhs._value)
  }
  @_transparent public static func *= (lhs: inout Float80, rhs: Float80) {
    lhs._value = Builtin.fmul_FPIEEE80(lhs._value, rhs._value)
  }
  @_transparent public static func /= (lhs: inout Float80, rhs: Float80) {
    lhs._value = Builtin.fdiv_FPIEEE80(lhs._value, rhs._value)
  }
  @inlinable @inline(__always) mutating public func formRemainder(dividingBy other: Float80) {
    self = _stdlib_remainderl(self, other)
  }
  @inlinable @inline(__always) mutating public func formTruncatingRemainder(dividingBy other: Float80) {
    _value = Builtin.frem_FPIEEE80(self._value, other._value)
  }
  @_transparent mutating public func formSquareRoot() {
    self = _stdlib_squareRootl(self)
  }
  @_transparent mutating public func addProduct(_ lhs: Float80, _ rhs: Float80) {
    _value = Builtin.int_fma_FPIEEE80(lhs._value, rhs._value, _value)
  }
  @_transparent public func isEqual(to other: Float80) -> Bool {
    return Bool(Builtin.fcmp_oeq_FPIEEE80(self._value, other._value))
  }
  @_transparent public func isLess(than other: Float80) -> Bool {
    return Bool(Builtin.fcmp_olt_FPIEEE80(self._value, other._value))
  }
  @_transparent public func isLessThanOrEqualTo(_ other: Float80) -> Bool {
    return Bool(Builtin.fcmp_ole_FPIEEE80(self._value, other._value))
  }
  @inlinable public var isNormal: Bool {
    @inline(__always) get {
      return exponentBitPattern > 0 && isFinite
    }
  }
  @inlinable public var isFinite: Bool {
    @inline(__always) get {
      return exponentBitPattern < Float80._infinityExponent
    }
  }
  @inlinable public var isZero: Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern == 0
    }
  }
  @inlinable public var isSubnormal: Bool {
    @inline(__always) get {
      return exponentBitPattern == 0 && significandBitPattern != 0
    }
  }
  @inlinable public var isInfinite: Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern == 0
    }
  }
  @inlinable public var isNaN: Bool {
    @inline(__always) get {
      return !isFinite && significandBitPattern != 0
    }
  }
  @inlinable public var isSignalingNaN: Bool {
    @inline(__always) get {
      return isNaN && (significandBitPattern & Float80._quietNaNMask) == 0
    }
  }
  @inlinable public var binade: Float80 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1405)
    guard _fastPath(isFinite) else { return .nan }
    if exponentBitPattern != 0 {
      return Float80(sign: sign, exponentBitPattern: exponentBitPattern,
        significandBitPattern: 0)
    }
    if significandBitPattern == 0 { return self }
    // For subnormals, we isolate the leading significand bit.
    let index = significandBitPattern._binaryLogarithm()
    return Float80(sign: sign, exponentBitPattern: 0,
      significandBitPattern: 1 &<< index)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1416)
  }
  }
  @inlinable public var significandWidth: Int {
    get {
    let trailingZeroBits = significandBitPattern.trailingZeroBitCount
    if isNormal {
      guard significandBitPattern != 0 else { return 0 }
      return Float80.significandBitCount &- trailingZeroBits
    }
    if isSubnormal {
      let leadingZeroBits = significandBitPattern.leadingZeroBitCount
      return UInt64.bitWidth &- (trailingZeroBits &+ leadingZeroBits &+ 1)
    }
    return -1
  }
  }
  @inlinable @inline(__always) public init(floatLiteral value: Float80) {
    self = value
  }
  public typealias FloatLiteralType = Swift.Float80
  public typealias RawExponent = Swift.UInt
}
extension Float80 : _ExpressibleByBuiltinIntegerLiteral, ExpressibleByIntegerLiteral {
  @_transparent public init(_builtinIntegerLiteral value: Builtin.IntLiteral) {
    self = Float80(Builtin.itofp_with_overflow_IntLiteral_FPIEEE80(value))
  }
  @_transparent public init(integerLiteral value: Int64) {
    self = Float80(Builtin.sitofp_Int64_FPIEEE80(value._value))
  }
  public typealias IntegerLiteralType = Swift.Int64
}
extension Float80 : _ExpressibleByBuiltinFloatLiteral {
  @_transparent public init(_builtinFloatLiteral value: Builtin.FPIEEE80) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1502)
    self = Float80(value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1509)
  }
}
extension Float80 : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    var v = self
    if isZero {
      // To satisfy the axiom that equality implies hash equality, we need to
      // finesse the hash value of -0.0 to match +0.0.
      v = 0
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1550)
    hasher.combine(v._representation.signAndExponent)
    hasher.combine(v.significandBitPattern)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1555)
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
    // To satisfy the axiom that equality implies hash equality, we need to
    // finesse the hash value of -0.0 to match +0.0.
    let v = isZero ? 0 : self
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1563)
    var hasher = Hasher(_seed: seed)
    hasher.combine(v._representation.signAndExponent)
    hasher.combine(v.significandBitPattern)
    return hasher._finalize()
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1572)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Float80 : _HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> AnyHashable?
}
extension Float80 {
  @inlinable public var magnitude: Float80 {
    @inline(__always) get {
      return Float80(Builtin.int_fabs_FPIEEE80(_value))
    }
  }
}
extension Float80 {
  @_transparent prefix public static func - (x: Float80) -> Float80 {
    return Float80(Builtin.fneg_FPIEEE80(x._value))
  }
}
extension Float80 {
  @_transparent public init(_ v: Int) {
    _value = Builtin.sitofp_Int64_FPIEEE80(v._value)
  }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryInteger {
    if value.bitWidth <= 64 {
      if Source.isSigned {
        let asInt = Int(truncatingIfNeeded: value)
        _value = Builtin.sitofp_Int64_FPIEEE80(asInt._value)
      } else {
        let asUInt = Int(truncatingIfNeeded: value)
        _value = Builtin.uitofp_Int64_FPIEEE80(asUInt._value)
      }
    } else {
      self = Float80._convert(from: value).value
    }
  }
  @inlinable @inline(__always) public init(_ other: Float) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1689)
    _value = Builtin.fpext_FPIEEE32_FPIEEE80(other._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1693)
  }
  @inlinable @inline(__always) public init?(exactly other: Float) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Float(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Double) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1689)
    _value = Builtin.fpext_FPIEEE64_FPIEEE80(other._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1693)
  }
  @inlinable @inline(__always) public init?(exactly other: Double) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Double(self) != other {
      return nil
    }
  }
  @inlinable @inline(__always) public init(_ other: Float80) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1691)
    _value = other._value
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/FloatingPointTypes.swift.gyb", line: 1693)
  }
  @inlinable @inline(__always) public init?(exactly other: Float80) {
    self.init(other)
    // Converting the infinity value is considered value preserving.
    // In other cases, check that we can round-trip and get the same value.
    // NaN always fails.
    if Float80(self) != other {
      return nil
    }
  }
}
extension Float80 {
  @_transparent public static func + (lhs: Float80, rhs: Float80) -> Float80 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Float80, rhs: Float80) -> Float80 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Float80, rhs: Float80) -> Float80 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Float80, rhs: Float80) -> Float80 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
}
extension Float80 : Strideable {
  @_transparent public func distance(to other: Float80) -> Float80 {
    return other - self
  }
  @_transparent public func advanced(by amount: Float80) -> Float80 {
    return self + amount
  }
  public typealias Stride = Swift.Float80
}
@available(*, unavailable, message: "For floating point numbers use truncatingRemainder instead")
@_transparent public func % <T>(lhs: T, rhs: T) -> T where T : Swift.BinaryFloatingPoint {
  fatalError("% is not available.")
}
@available(*, unavailable, message: "For floating point numbers use formTruncatingRemainder instead")
@_transparent public func %= <T>(lhs: inout T, rhs: T) where T : Swift.BinaryFloatingPoint {
  fatalError("%= is not available.")
}
public protocol Hashable : Swift.Equatable {
  var hashValue: Int { get }
  func hash(into hasher: inout Hasher)
  func _rawHashValue(seed: Int) -> Int
}
extension Hashable {
  @inlinable @inline(__always) public func _rawHashValue(seed: Int) -> Int {
    var hasher = Hasher(_seed: seed)
    hasher.combine(self)
    return hasher._finalize()
  }
}
@inlinable @inline(__always) public func _hashValue<H>(for value: H) -> Int where H : Swift.Hashable {
  return value._rawHashValue(seed: 0)
}
public protocol _HasCustomAnyHashableRepresentation {
  __consuming func _toCustomAnyHashable() -> AnyHashable?
}
@usableFromInline
internal protocol _AnyHashableBox {
  var _canonicalBox: _AnyHashableBox { get }
  func _isEqual(to box: _AnyHashableBox) -> Bool?
  var _hashValue: Int { get }
  func _hash(into hasher: inout Hasher)
  func _rawHashValue(_seed: Int) -> Int
  var _base: Any { get }
  func _unbox<T>() -> T? where T : Swift.Hashable
  func _downCastConditional<T>(into result: UnsafeMutablePointer<T>) -> Bool
}
@_fixed_layout public struct AnyHashable {
  internal var _box: _AnyHashableBox
  public init<H>(_ base: H) where H : Swift.Hashable
  public var base: Any {
    get
  }
}
extension AnyHashable : Equatable {
  public static func == (lhs: AnyHashable, rhs: AnyHashable) -> Bool
}
extension AnyHashable : Hashable {
  public var hashValue: Int {
    get
  }
  public func hash(into hasher: inout Hasher)
  public func _rawHashValue(seed: Int) -> Int
}
extension AnyHashable : CustomStringConvertible {
  public var description: String {
    get
  }
}
extension AnyHashable : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension AnyHashable : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
@inlinable public func _convertToAnyHashable<H>(_ value: H) -> AnyHashable where H : Swift.Hashable {
  return AnyHashable(value)
}
extension Hasher {
  @usableFromInline
  @_fixed_layout internal struct _TailBuffer {
    internal var value: UInt64
  }
}
extension Hasher {
  @usableFromInline
  @_fixed_layout internal struct _Core {
    private var _buffer: _TailBuffer
    private var _state: Hasher._State
  }
}
@_fixed_layout public struct Hasher {
  internal var _core: _Core
  @_effects(releasenone) public init()
  @usableFromInline
  @_effects(releasenone) internal init(_seed: Int)
  @usableFromInline
  @_effects(releasenone) internal init(_rawSeed: (UInt64, UInt64))
  @inlinable internal static var _isDeterministic: Bool {
    @inline(__always) get {
      return _swift_stdlib_Hashing_parameters.deterministic
    }
  }
  @inlinable internal static var _executionSeed: (UInt64, UInt64) {
    @inline(__always) get {
      // The seed itself is defined in C++ code so that it is initialized during
      // static construction.  Almost every Swift program uses hash tables, so
      // initializing the seed during the startup seems to be the right
      // trade-off.
      return (
        _swift_stdlib_Hashing_parameters.seed0,
        _swift_stdlib_Hashing_parameters.seed1)
    }
  }
  @inlinable @inline(__always) mutating public func combine<H>(_ value: H) where H : Swift.Hashable {
    value.hash(into: &self)
  }
  @usableFromInline
  @_effects(releasenone) mutating internal func _combine(_ value: UInt)
  @usableFromInline
  @_effects(releasenone) mutating internal func _combine(_ value: UInt64)
  @usableFromInline
  @_effects(releasenone) mutating internal func _combine(_ value: UInt32)
  @usableFromInline
  @_effects(releasenone) mutating internal func _combine(_ value: UInt16)
  @usableFromInline
  @_effects(releasenone) mutating internal func _combine(_ value: UInt8)
  @usableFromInline
  @_effects(releasenone) mutating internal func _combine(bytes value: UInt64, count: Int)
  @_effects(releasenone) mutating public func combine(bytes: UnsafeRawBufferPointer)
  @usableFromInline
  @_effects(releasenone) mutating internal func _finalize() -> Int
  @_effects(releasenone) __consuming public func finalize() -> Int
  @usableFromInline
  @_effects(readnone) internal static func _hash(seed: Int, _ value: UInt64) -> Int
  @usableFromInline
  @_effects(readnone) internal static func _hash(seed: Int, _ value: UInt) -> Int
  @usableFromInline
  @_effects(readnone) internal static func _hash(seed: Int, bytes value: UInt64, count: Int) -> Int
  @usableFromInline
  @_effects(readnone) internal static func _hash(seed: Int, bytes: UnsafeRawBufferPointer) -> Int
}
@usableFromInline
@_transparent internal var _hashContainerDefaultMaxLoadFactorInverse: Double {
  get {
  return 1.0 / 0.75
}
}
@usableFromInline
internal protocol _HashTableDelegate {
  func hashValue(at bucket: _HashTable.Bucket) -> Int
  func moveEntry(from source: _HashTable.Bucket, to target: _HashTable.Bucket)
}
@usableFromInline
@_fixed_layout internal struct _HashTable {
  @usableFromInline
  internal typealias Word = _UnsafeBitset.Word
  @usableFromInline
  internal var words: UnsafeMutablePointer<Word>
  @usableFromInline
  internal let bucketMask: Int
  @inlinable @inline(__always) internal init(words: UnsafeMutablePointer<Word>, bucketCount: Int) {
    _internalInvariant(bucketCount > 0 && bucketCount & (bucketCount - 1) == 0,
      "bucketCount must be a power of two")
    self.words = words
    // The bucket count is a power of two, so subtracting 1 will never overflow
    // and get us a nice mask.
    self.bucketMask = bucketCount &- 1
  }
  @inlinable internal var bucketCount: Int {
    @inline(__always) get {
      return bucketMask &+ 1
    }
  }
  @inlinable internal var wordCount: Int {
    @inline(__always) get {
      return _UnsafeBitset.wordCount(forCapacity: bucketCount)
    }
  }
}
extension _HashTable {
  @usableFromInline
  @_fixed_layout internal struct Bucket {
    @usableFromInline
    internal var offset: Int
    @inlinable @inline(__always) internal init(offset: Int) {
      self.offset = offset
    }
    @inlinable @inline(__always) internal init(word: Int, bit: Int) {
      self.offset = _UnsafeBitset.join(word: word, bit: bit)
    }
    @inlinable internal var word: Int {
      @inline(__always) get {
        return _UnsafeBitset.word(for: offset)
      }
    }
    @inlinable internal var bit: Int {
      @inline(__always) get {
        return _UnsafeBitset.bit(for: offset)
      }
    }
  }
}
extension _HashTable.Bucket : Equatable {
  @inlinable @inline(__always) internal static func == (lhs: _HashTable.Bucket, rhs: _HashTable.Bucket) -> Bool {
    return lhs.offset == rhs.offset
  }
}
extension _HashTable.Bucket : Comparable {
  @inlinable @inline(__always) internal static func < (lhs: _HashTable.Bucket, rhs: _HashTable.Bucket) -> Bool {
    return lhs.offset < rhs.offset
  }
}
extension _HashTable {
  @usableFromInline
  @_fixed_layout internal struct Index {
    @usableFromInline
    internal let bucket: Bucket
    @usableFromInline
    internal let age: Int32
    @inlinable @inline(__always) internal init(bucket: Bucket, age: Int32) {
      self.bucket = bucket
      self.age = age
    }
  }
}
extension _HashTable.Index : Equatable {
  @inlinable @inline(__always) internal static func == (lhs: _HashTable.Index, rhs: _HashTable.Index) -> Bool {
    _precondition(lhs.age == rhs.age,
      "Can't compare indices belonging to different collections")
    return lhs.bucket == rhs.bucket
  }
}
extension _HashTable.Index : Comparable {
  @inlinable @inline(__always) internal static func < (lhs: _HashTable.Index, rhs: _HashTable.Index) -> Bool {
    _precondition(lhs.age == rhs.age,
      "Can't compare indices belonging to different collections")
    return lhs.bucket < rhs.bucket
  }
}
extension _HashTable : Sequence {
  @usableFromInline
  @_fixed_layout internal struct Iterator : IteratorProtocol {
    @usableFromInline
    internal let hashTable: _HashTable
    @usableFromInline
    internal var wordIndex: Int
    @usableFromInline
    internal var word: Word
    @inlinable @inline(__always) internal init(_ hashTable: _HashTable) {
      self.hashTable = hashTable
      self.wordIndex = 0
      self.word = hashTable.words[0]
      if hashTable.bucketCount < Word.capacity {
        self.word = self.word.intersecting(elementsBelow: hashTable.bucketCount)
      }
    }
    @inlinable @inline(__always) mutating internal func next() -> Bucket? {
      if let bit = word.next() {
        return Bucket(word: wordIndex, bit: bit)
      }
      while wordIndex + 1 < hashTable.wordCount {
        wordIndex += 1
        word = hashTable.words[wordIndex]
        if let bit = word.next() {
          return Bucket(word: wordIndex, bit: bit)
        }
      }
      return nil
    }
    @usableFromInline
    internal typealias Element = Swift._HashTable.Bucket
  }
  @inlinable @inline(__always) internal func makeIterator() -> Iterator {
    return Iterator(self)
  }
  @usableFromInline
  internal typealias Element = Swift._HashTable.Bucket
}
extension _HashTable {
  @inlinable @inline(__always) internal func isValid(_ bucket: Bucket) -> Bool {
    return bucket.offset >= 0 && bucket.offset < bucketCount
  }
  @inlinable @inline(__always) internal func _isOccupied(_ bucket: Bucket) -> Bool {
    _internalInvariant(isValid(bucket))
    return words[bucket.word].uncheckedContains(bucket.bit)
  }
  @inlinable @inline(__always) internal func isOccupied(_ bucket: Bucket) -> Bool {
    return isValid(bucket) && _isOccupied(bucket)
  }
  @inlinable @inline(__always) internal func checkOccupied(_ bucket: Bucket) {
    _precondition(isOccupied(bucket),
      "Attempting to access Collection elements using an invalid Index")
  }
  @inlinable @inline(__always) internal func _firstOccupiedBucket(fromWord word: Int) -> Bucket {
    _internalInvariant(word >= 0 && word <= wordCount)
    var word = word
    while word < wordCount {
      if let bit = words[word].minimum {
        return Bucket(word: word, bit: bit)
      }
      word += 1
    }
    return endBucket
  }
  @inlinable internal func occupiedBucket(after bucket: Bucket) -> Bucket {
    _internalInvariant(isValid(bucket))
    let word = bucket.word
    if let bit = words[word].intersecting(elementsAbove: bucket.bit).minimum {
      return Bucket(word: word, bit: bit)
    }
    return _firstOccupiedBucket(fromWord: word + 1)
  }
  @inlinable internal var startBucket: Bucket {
    get {
    return _firstOccupiedBucket(fromWord: 0)
  }
  }
  @inlinable internal var endBucket: Bucket {
    @inline(__always) get {
      return Bucket(offset: bucketCount)
    }
  }
}
extension _HashTable {
  @inlinable @inline(__always) internal func idealBucket(forHashValue hashValue: Int) -> Bucket {
    return Bucket(offset: hashValue & bucketMask)
  }
  @inlinable @inline(__always) internal func bucket(wrappedAfter bucket: Bucket) -> Bucket {
    // The bucket is less than bucketCount, which is power of two less than
    // Int.max. Therefore adding 1 does not overflow.
    return Bucket(offset: (bucket.offset &+ 1) & bucketMask)
  }
}
extension _HashTable {
  @inlinable internal func previousHole(before bucket: Bucket) -> Bucket {
    _internalInvariant(isValid(bucket))
    // Note that if we have only a single partial word, its out-of-bounds bits
    // are guaranteed to be all set, so the formula below gives correct results.
    var word = bucket.word
    if let bit =
      words[word]
        .complement
        .intersecting(elementsBelow: bucket.bit)
        .maximum {
      return Bucket(word: word, bit: bit)
    }
    var wrap = false
    while true {
      word -= 1
      if word < 0 {
        _precondition(!wrap, "Hash table has no holes")
        wrap = true
        word = wordCount - 1
      }
      if let bit = words[word].complement.maximum {
        return Bucket(word: word, bit: bit)
      }
    }
  }
  @inlinable internal func nextHole(atOrAfter bucket: Bucket) -> Bucket {
    _internalInvariant(isValid(bucket))
    // Note that if we have only a single partial word, its out-of-bounds bits
    // are guaranteed to be all set, so the formula below gives correct results.
    var word = bucket.word
    if let bit =
      words[word]
        .complement
        .subtracting(elementsBelow: bucket.bit)
        .minimum {
      return Bucket(word: word, bit: bit)
    }
    var wrap = false
    while true {
      word &+= 1
      if word == wordCount {
        _precondition(!wrap, "Hash table has no holes")
        wrap = true
        word = 0
      }
      if let bit = words[word].complement.minimum {
        return Bucket(word: word, bit: bit)
      }
    }
  }
}
extension _HashTable {
  @inlinable @inline(__always) @_effects(releasenone) internal func copyContents(of other: _HashTable) {
    _internalInvariant(bucketCount == other.bucketCount)
    self.words.assign(from: other.words, count: wordCount)
  }
  @inlinable @inline(__always) internal func insertNew(hashValue: Int) -> Bucket {
    let hole = nextHole(atOrAfter: idealBucket(forHashValue: hashValue))
    insert(hole)
    return hole
  }
  @inlinable @inline(__always) internal func insert(_ bucket: Bucket) {
    _internalInvariant(!isOccupied(bucket))
    words[bucket.word].uncheckedInsert(bucket.bit)
  }
  @inlinable @inline(__always) internal func clear() {
    if bucketCount < Word.capacity {
      // We have only a single partial word. Set all out of bounds bits, so that
      // `occupiedBucket(after:)` and `nextHole(atOrAfter:)` works correctly
      // without a special case.
      words[0] = Word.allBits.subtracting(elementsBelow: bucketCount)
    } else {
      words.assign(repeating: .empty, count: wordCount)
    }
  }
  @inline(__always) @inlinable internal func delete<D>(at bucket: Bucket, with delegate: D) where D : Swift._HashTableDelegate {
    _internalInvariant(isOccupied(bucket))

    // If we've put a hole in a chain of contiguous elements, some element after
    // the hole may belong where the new hole is.

    var hole = bucket
    var candidate = self.bucket(wrappedAfter: hole)

    guard _isOccupied(candidate) else {
      // Fast path: Don't get the first bucket when there's nothing to do.
      words[hole.word].uncheckedRemove(hole.bit)
      return
    }

    // Find the first bucket in the contiguous chain that contains the entry
    // we've just deleted.
    let start = self.bucket(wrappedAfter: previousHole(before: bucket))

    // Relocate out-of-place elements in the chain, repeating until we get to
    // the end of the chain.
    while _isOccupied(candidate) {
      let candidateHash = delegate.hashValue(at: candidate)
      let ideal = idealBucket(forHashValue: candidateHash)

      // Does this element belong between start and hole?  We need two
      // separate tests depending on whether [start, hole] wraps around the
      // end of the storage.
      let c0 = ideal >= start
      let c1 = ideal <= hole
      if start <= hole ? (c0 && c1) : (c0 || c1) {
        delegate.moveEntry(from: candidate, to: hole)
        hole = candidate
      }
      candidate = self.bucket(wrappedAfter: candidate)
    }

    words[hole.word].uncheckedRemove(hole.bit)
  }
}
@_fixed_layout public struct DefaultIndices<Elements> where Elements : Swift.Collection {
  @usableFromInline
  internal var _elements: Elements
  @usableFromInline
  internal var _startIndex: Elements.Index
  @usableFromInline
  internal var _endIndex: Elements.Index
  @inlinable internal init(_elements: Elements, startIndex: Elements.Index, endIndex: Elements.Index) {
    self._elements = _elements
    self._startIndex = startIndex
    self._endIndex = endIndex
  }
}
extension DefaultIndices : Collection {
  public typealias Index = Elements.Index
  public typealias Element = Elements.Index
  public typealias Indices = DefaultIndices<Elements>
  public typealias SubSequence = DefaultIndices<Elements>
  public typealias Iterator = IndexingIterator<DefaultIndices<Elements>>
  @inlinable public var startIndex: Index {
    get {
    return _startIndex
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return _endIndex
  }
  }
  @inlinable public subscript(i: Index) -> Elements.Index {
    get {
    // FIXME: swift-3-indexing-model: range check.
    return i
  }
  }
  @inlinable public subscript(bounds: Range<Index>) -> DefaultIndices<Elements> {
    get {
    // FIXME: swift-3-indexing-model: range check.
    return DefaultIndices(
      _elements: _elements,
      startIndex: bounds.lowerBound,
      endIndex: bounds.upperBound)
  }
  }
  @inlinable public func index(after i: Index) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _elements.index(after: i)
  }
  @inlinable public func formIndex(after i: inout Index) {
    // FIXME: swift-3-indexing-model: range check.
    _elements.formIndex(after: &i)
  }
  @inlinable public var indices: Indices {
    get {
    return self
  }
  }
}
extension DefaultIndices : BidirectionalCollection where Elements : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Index) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _elements.index(before: i)
  }
  @inlinable public func formIndex(before i: inout Index) {
    // FIXME: swift-3-indexing-model: range check.
    _elements.formIndex(before: &i)
  }
}
extension DefaultIndices : RandomAccessCollection where Elements : Swift.RandomAccessCollection {
}
extension Collection where Self.Indices == Swift.DefaultIndices<Self> {
  @inlinable public var indices: DefaultIndices<Self> {
    get {
    return DefaultIndices(
      _elements: self,
      startIndex: self.startIndex,
      endIndex: self.endIndex)
  }
  }
}
public func readLine(strippingNewline: Bool = true) -> String?
@inlinable internal func _ascii16(_ c: Unicode.Scalar) -> UTF16.CodeUnit {
  _internalInvariant(c.value >= 0 && c.value <= 0x7F, "not ASCII")
  return UTF16.CodeUnit(c.value)
}
@inlinable @inline(__always) internal func _asciiDigit<CodeUnit, Result>(codeUnit u_: CodeUnit, radix: Result) -> Result? where CodeUnit : Swift.UnsignedInteger, Result : Swift.BinaryInteger {
  let digit = _ascii16("0")..._ascii16("9")
  let lower = _ascii16("a")..._ascii16("z")
  let upper = _ascii16("A")..._ascii16("Z")

  let u = UInt16(truncatingIfNeeded: u_)
  let d: UInt16
  if _fastPath(digit ~= u) { d = u &- digit.lowerBound }
  else if _fastPath(upper ~= u) { d = u &- upper.lowerBound &+ 10 }
  else if _fastPath(lower ~= u) { d = u &- lower.lowerBound &+ 10 }
  else { return nil }
  guard _fastPath(d < radix) else { return nil }
  return Result(truncatingIfNeeded: d)
}
@inlinable @inline(__always) internal func _parseUnsignedASCII<Rest, Result>(first: Rest.Element, rest: inout Rest, radix: Result, positive: Bool) -> Result? where Rest : Swift.IteratorProtocol, Result : Swift.FixedWidthInteger, Rest.Element : Swift.UnsignedInteger {
  let r0 = _asciiDigit(codeUnit: first, radix: radix)
  guard _fastPath(r0 != nil), var result = r0 else { return nil }
  if !positive {
    let (result0, overflow0)
      = (0 as Result).subtractingReportingOverflow(result)
    guard _fastPath(!overflow0) else { return nil }
    result = result0
  }

  while let u = rest.next() {
    let d0 = _asciiDigit(codeUnit: u, radix: radix)
    guard _fastPath(d0 != nil), let d = d0 else { return nil }
    let (result1, overflow1) = result.multipliedReportingOverflow(by: radix)
    let (result2, overflow2) = positive
      ? result1.addingReportingOverflow(d)
      : result1.subtractingReportingOverflow(d)
    guard _fastPath(!overflow1 && !overflow2)
    else { return nil }
    result = result2
  }
  return result
}
@inlinable @inline(__always) internal func _parseASCII<CodeUnits, Result>(codeUnits: inout CodeUnits, radix: Result) -> Result? where CodeUnits : Swift.IteratorProtocol, Result : Swift.FixedWidthInteger, CodeUnits.Element : Swift.UnsignedInteger {
  let c0_ = codeUnits.next()
  guard _fastPath(c0_ != nil), let c0 = c0_ else { return nil }
  if _fastPath(c0 != _ascii16("+") && c0 != _ascii16("-")) {
    return _parseUnsignedASCII(
      first: c0, rest: &codeUnits, radix: radix, positive: true)
  }
  let c1_ = codeUnits.next()
  guard _fastPath(c1_ != nil), let c1 = c1_ else { return nil }
  if _fastPath(c0 == _ascii16("-")) {
    return _parseUnsignedASCII(
      first: c1, rest: &codeUnits, radix: radix, positive: false)
  }
  else {
    return _parseUnsignedASCII(
      first: c1, rest: &codeUnits, radix: radix, positive: true)
  }
}
extension FixedWidthInteger {
  @usableFromInline
  @_semantics("optimize.sil.specialize.generic.partial.never") @inline(never) internal static func _parseASCIISlowPath<CodeUnits, Result>(codeUnits: inout CodeUnits, radix: Result) -> Result? where CodeUnits : Swift.IteratorProtocol, Result : Swift.FixedWidthInteger, CodeUnits.Element : Swift.UnsignedInteger
  @inlinable @_semantics("optimize.sil.specialize.generic.partial.never") public init?<S>(_ text: S, radix: Int = 10) where S : Swift.StringProtocol {
    _precondition(2...36 ~= radix, "Radix not in range 2...36")

    if let str = text as? String, str._guts.isFastUTF8 {
      guard let ret = str._guts.withFastUTF8 ({ utf8 -> Self? in
        var iter = utf8.makeIterator()
        return _parseASCII(codeUnits: &iter, radix: Self(radix))
      }) else {
        return nil
      }
      self = ret
      return
    }

    // TODO(String performance): We can provide fast paths for common radices,
    // native UTF-8 storage, etc.

    var iter = text.utf8.makeIterator()
    guard let ret = Self._parseASCIISlowPath(
      codeUnits: &iter, radix: Self(radix)
    ) else { return nil }

    self = ret
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.partial.never") @inline(__always) public init?(_ description: String) {
    self.init(description, radix: 10)
  }
}
extension ExpressibleByIntegerLiteral where Self : Swift._ExpressibleByBuiltinIntegerLiteral {
  @_transparent public init(integerLiteral value: Self) {
    self = value
  }
}
public protocol AdditiveArithmetic : Swift.Equatable {
  static var zero: Self { get }
  static func + (lhs: Self, rhs: Self) -> Self
  static func += (lhs: inout Self, rhs: Self)
  static func - (lhs: Self, rhs: Self) -> Self
  static func -= (lhs: inout Self, rhs: Self)
}
extension AdditiveArithmetic where Self : Swift.ExpressibleByIntegerLiteral {
  public static var zero: Self {
    get
  }
}
public protocol Numeric : Swift.AdditiveArithmetic, Swift.ExpressibleByIntegerLiteral {
  init?<T>(exactly source: T) where T : Swift.BinaryInteger
  associatedtype Magnitude : Swift.Comparable, Swift.Numeric
  var magnitude: Magnitude { get }
  static func * (lhs: Self, rhs: Self) -> Self
  static func *= (lhs: inout Self, rhs: Self)
}
public protocol SignedNumeric : Swift.Numeric {
  prefix static func - (operand: Self) -> Self
  mutating func negate()
}
extension SignedNumeric {
  @_transparent prefix public static func - (operand: Self) -> Self {
    var result = operand
    result.negate()
    return result
  }
  @_transparent mutating public func negate() {
    self = 0 - self
  }
}
@inlinable public func abs<T>(_ x: T) -> T where T : Swift.Comparable, T : Swift.SignedNumeric {
  if T.self == T.Magnitude.self {
    return unsafeBitCast(x.magnitude, to: T.self)
  }

  return x < (0 as T) ? -x : x
}
extension AdditiveArithmetic {
  @_transparent prefix public static func + (x: Self) -> Self {
    return x
  }
}
public protocol BinaryInteger : Swift.CustomStringConvertible, Swift.Hashable, Swift.Numeric, Swift.Strideable where Self.Magnitude : Swift.BinaryInteger, Self.Magnitude == Self.Magnitude.Magnitude {
  static var isSigned: Bool { get }
  init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
  init<T>(_ source: T) where T : Swift.BinaryInteger
  init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
  init<T>(clamping source: T) where T : Swift.BinaryInteger
  associatedtype Words : Swift.RandomAccessCollection where Self.Words.Element == Swift.UInt, Self.Words.Index == Swift.Int
  var words: Words { get }
  var _lowWord: UInt { get }
  var bitWidth: Int { get }
  func _binaryLogarithm() -> Int
  var trailingZeroBitCount: Int { get }
  static func / (lhs: Self, rhs: Self) -> Self
  static func /= (lhs: inout Self, rhs: Self)
  static func % (lhs: Self, rhs: Self) -> Self
  static func %= (lhs: inout Self, rhs: Self)
  override static func + (lhs: Self, rhs: Self) -> Self
  override static func += (lhs: inout Self, rhs: Self)
  override static func - (lhs: Self, rhs: Self) -> Self
  override static func -= (lhs: inout Self, rhs: Self)
  override static func * (lhs: Self, rhs: Self) -> Self
  override static func *= (lhs: inout Self, rhs: Self)
  prefix static func ~ (x: Self) -> Self
  static func & (lhs: Self, rhs: Self) -> Self
  static func &= (lhs: inout Self, rhs: Self)
  static func | (lhs: Self, rhs: Self) -> Self
  static func |= (lhs: inout Self, rhs: Self)
  static func ^ (lhs: Self, rhs: Self) -> Self
  static func ^= (lhs: inout Self, rhs: Self)
  static func >> <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : Swift.BinaryInteger
  static func >>= <RHS>(lhs: inout Self, rhs: RHS) where RHS : Swift.BinaryInteger
  static func << <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : Swift.BinaryInteger
  static func <<= <RHS>(lhs: inout Self, rhs: RHS) where RHS : Swift.BinaryInteger
  func quotientAndRemainder(dividingBy rhs: Self) -> (quotient: Self, remainder: Self)
  func isMultiple(of other: Self) -> Bool
  func signum() -> Self
}
extension BinaryInteger {
  @_transparent public init() {
    self = 0
  }
  @inlinable public func signum() -> Self {
    return (self > (0 as Self) ? 1 : 0) - (self < (0 as Self) ? 1 : 0)
  }
  @_transparent public var _lowWord: UInt {
    get {
    var it = words.makeIterator()
    return it.next() ?? 0
  }
  }
  @inlinable public func _binaryLogarithm() -> Int {
    _precondition(self > (0 as Self))
    var (quotient, remainder) =
      (bitWidth &- 1).quotientAndRemainder(dividingBy: UInt.bitWidth)
    remainder = remainder &+ 1
    var word = UInt(truncatingIfNeeded: self >> (bitWidth &- remainder))
    // If, internally, a variable-width binary integer uses digits of greater
    // bit width than that of Magnitude.Words.Element (i.e., UInt), then it is
    // possible that `word` could be zero. Additionally, a signed variable-width
    // binary integer may have a leading word that is zero to store a clear sign
    // bit.
    while word == 0 {
      quotient = quotient &- 1
      remainder = remainder &+ UInt.bitWidth
      word = UInt(truncatingIfNeeded: self >> (bitWidth &- remainder))
    }
    // Note that the order of operations below is important to guarantee that
    // we won't overflow.
    return UInt.bitWidth &* quotient &+
        (UInt.bitWidth &- (word.leadingZeroBitCount &+ 1))
  }
  @inlinable public func quotientAndRemainder(dividingBy rhs: Self) -> (quotient: Self, remainder: Self) {
    return (self / rhs, self % rhs)
  }
  @inlinable public func isMultiple(of other: Self) -> Bool {
    // Nothing but zero is a multiple of zero.
    if other == 0 { return self == 0 }
    // Do the test in terms of magnitude, which guarantees there are no other
    // edge cases. If we write this as `self % other` instead, it could trap
    // for types that are not symmetric around zero.
    return self.magnitude % other.magnitude == 0
  }
  @_transparent public static func & (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func >> <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : Swift.BinaryInteger {
    var r = lhs
    r >>= rhs
    return r
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func << <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : Swift.BinaryInteger {
    var r = lhs
    r <<= rhs
    return r
  }
}
extension BinaryInteger {
  public var description: String {
    get
  }
}
extension BinaryInteger {
  @inlinable @inline(__always) public func distance(to other: Self) -> Int {
    if !Self.isSigned {
      if self > other {
        if let result = Int(exactly: self - other) {
          return -result
        }
      } else {
        if let result = Int(exactly: other - self) {
          return result
        }
      }
    } else {
      let isNegative = self < (0 as Self)
      if isNegative == (other < (0 as Self)) {
        if let result = Int(exactly: other - self) {
          return result
        }
      } else {
        if let result = Int(exactly: self.magnitude + other.magnitude) {
          return isNegative ? result : -result
        }
      }
    }
    _preconditionFailure("Distance is not representable in Int")
  }
  @inlinable @inline(__always) public func advanced(by n: Int) -> Self {
    if !Self.isSigned {
      return n < (0 as Int)
        ? self - Self(-n)
        : self + Self(n)
    }
    if (self < (0 as Self)) == (n < (0 as Self)) {
      return self + Self(n)
    }
    return self.magnitude < n.magnitude
      ? Self(Int(self) + n)
      : self + Self(n)
  }
}
extension BinaryInteger {
  @_transparent public static func == <Other>(lhs: Self, rhs: Other) -> Bool where Other : Swift.BinaryInteger {
    let lhsNegative = Self.isSigned && lhs < (0 as Self)
    let rhsNegative = Other.isSigned && rhs < (0 as Other)

    if lhsNegative != rhsNegative { return false }

    // Here we know the values are of the same sign.
    //
    // There are a few possible scenarios from here:
    //
    // 1. Both values are negative
    //  - If one value is strictly wider than the other, then it is safe to
    //    convert to the wider type.
    //  - If the values are of the same width, it does not matter which type we
    //    choose to convert to as the values are already negative, and thus
    //    include the sign bit if two's complement representation already.
    // 2. Both values are non-negative
    //  - If one value is strictly wider than the other, then it is safe to
    //    convert to the wider type.
    //  - If the values are of the same width, than signedness matters, as not
    //    unsigned types are 'wider' in a sense they don't need to 'waste' the
    //    sign bit. Therefore it is safe to convert to the unsigned type.

    if lhs.bitWidth < rhs.bitWidth {
      return Other(truncatingIfNeeded: lhs) == rhs
    }
    if lhs.bitWidth > rhs.bitWidth {
      return lhs == Self(truncatingIfNeeded: rhs)
    }

    if Self.isSigned {
      return Other(truncatingIfNeeded: lhs) == rhs
    }
    return lhs == Self(truncatingIfNeeded: rhs)
  }
  @_transparent public static func != <Other>(lhs: Self, rhs: Other) -> Bool where Other : Swift.BinaryInteger {
    return !(lhs == rhs)
  }
  @_transparent public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other : Swift.BinaryInteger {
    let lhsNegative = Self.isSigned && lhs < (0 as Self)
    let rhsNegative = Other.isSigned && rhs < (0 as Other)
    if lhsNegative != rhsNegative { return lhsNegative }

    if lhs == (0 as Self) && rhs == (0 as Other) { return false }

    // if we get here, lhs and rhs have the same sign. If they're negative,
    // then Self and Other are both signed types, and one of them can represent
    // values of the other type. Otherwise, lhs and rhs are positive, and one
    // of Self, Other may be signed and the other unsigned.

    let rhsAsSelf = Self(truncatingIfNeeded: rhs)
    let rhsAsSelfNegative = rhsAsSelf < (0 as Self)


    // Can we round-trip rhs through Other?
    if Other(truncatingIfNeeded: rhsAsSelf) == rhs &&
      // This additional check covers the `Int8.max < (128 as UInt8)` case.
      // Since the types are of the same width, init(truncatingIfNeeded:)
      // will result in a simple bitcast, so that rhsAsSelf would be -128, and
      // `lhs < rhsAsSelf` will return false.
      // We basically guard against that bitcast by requiring rhs and rhsAsSelf
      // to be the same sign.
      rhsNegative == rhsAsSelfNegative {
      return lhs < rhsAsSelf
    }

    return Other(truncatingIfNeeded: lhs) < rhs
  }
  @_transparent public static func <= <Other>(lhs: Self, rhs: Other) -> Bool where Other : Swift.BinaryInteger {
    return !(rhs < lhs)
  }
  @_transparent public static func >= <Other>(lhs: Self, rhs: Other) -> Bool where Other : Swift.BinaryInteger {
    return !(lhs < rhs)
  }
  @_transparent public static func > <Other>(lhs: Self, rhs: Other) -> Bool where Other : Swift.BinaryInteger {
    return rhs < lhs
  }
}
extension BinaryInteger {
  @_transparent public static func != (lhs: Self, rhs: Self) -> Bool {
    return !(lhs == rhs)
  }
  @_transparent public static func <= (lhs: Self, rhs: Self) -> Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Self, rhs: Self) -> Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Self, rhs: Self) -> Bool {
    return rhs < lhs
  }
}
public protocol FixedWidthInteger : Swift.BinaryInteger, Swift.LosslessStringConvertible where Self.Magnitude : Swift.FixedWidthInteger, Self.Magnitude : Swift.UnsignedInteger, Self.Stride : Swift.FixedWidthInteger, Self.Stride : Swift.SignedInteger {
  static var bitWidth: Int { get }
  static var max: Self { get }
  static var min: Self { get }
  func addingReportingOverflow(_ rhs: Self) -> (partialValue: Self, overflow: Bool)
  func subtractingReportingOverflow(_ rhs: Self) -> (partialValue: Self, overflow: Bool)
  func multipliedReportingOverflow(by rhs: Self) -> (partialValue: Self, overflow: Bool)
  func dividedReportingOverflow(by rhs: Self) -> (partialValue: Self, overflow: Bool)
  func remainderReportingOverflow(dividingBy rhs: Self) -> (partialValue: Self, overflow: Bool)
  func multipliedFullWidth(by other: Self) -> (high: Self, low: Self.Magnitude)
  func dividingFullWidth(_ dividend: (high: Self, low: Self.Magnitude)) -> (quotient: Self, remainder: Self)
  init(_truncatingBits bits: UInt)
  var nonzeroBitCount: Int { get }
  var leadingZeroBitCount: Int { get }
  init(bigEndian value: Self)
  init(littleEndian value: Self)
  var bigEndian: Self { get }
  var littleEndian: Self { get }
  var byteSwapped: Self { get }
  static func &>> (lhs: Self, rhs: Self) -> Self
  static func &>>= (lhs: inout Self, rhs: Self)
  static func &<< (lhs: Self, rhs: Self) -> Self
  static func &<<= (lhs: inout Self, rhs: Self)
}
extension FixedWidthInteger {
  @inlinable public var bitWidth: Int {
    get { return Self.bitWidth }
  }
  @inlinable public func _binaryLogarithm() -> Int {
    _precondition(self > (0 as Self))
    return Self.bitWidth &- (leadingZeroBitCount &+ 1)
  }
  @inlinable public init(littleEndian value: Self) {
    self = value
  }
  @inlinable public init(bigEndian value: Self) {
    self = value.byteSwapped
  }
  @inlinable public var littleEndian: Self {
    get {
    return self
  }
  }
  @inlinable public var bigEndian: Self {
    get {
    return byteSwapped
  }
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &>> (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &>> <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.BinaryInteger {
    return lhs &>> Self(truncatingIfNeeded: rhs)
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &>>= <Other>(lhs: inout Self, rhs: Other) where Other : Swift.BinaryInteger {
    lhs = lhs &>> rhs
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &<< (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &<< <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.BinaryInteger {
    return lhs &<< Self(truncatingIfNeeded: rhs)
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func &<<= <Other>(lhs: inout Self, rhs: Other) where Other : Swift.BinaryInteger {
    lhs = lhs &<< rhs
  }
}
extension FixedWidthInteger {
  @inlinable public static func random<T>(in range: Range<Self>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    _precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )

    // Compute delta, the distance between the lower and upper bounds. This
    // value may not representable by the type Bound if Bound is signed, but
    // is always representable as Bound.Magnitude.
    let delta = Magnitude(truncatingIfNeeded: range.upperBound &- range.lowerBound)
    // The mathematical result we want is lowerBound plus a random value in
    // 0 ..< delta. We need to be slightly careful about how we do this
    // arithmetic; the Bound type cannot generally represent the random value,
    // so we use a wrapping addition on Bound.Magnitude. This will often
    // overflow, but produces the correct bit pattern for the result when
    // converted back to Bound.
    return Self(truncatingIfNeeded:
      Magnitude(truncatingIfNeeded: range.lowerBound) &+
      generator.next(upperBound: delta)
    )
  }
  @inlinable public static func random(in range: Range<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
  @inlinable public static func random<T>(in range: ClosedRange<Self>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    _precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )

    // Compute delta, the distance between the lower and upper bounds. This
    // value may not representable by the type Bound if Bound is signed, but
    // is always representable as Bound.Magnitude.
    var delta = Magnitude(truncatingIfNeeded: range.upperBound &- range.lowerBound)
    // Subtle edge case: if the range is the whole set of representable values,
    // then adding one to delta to account for a closed range will overflow.
    // If we used &+ instead, the result would be zero, which isn't helpful,
    // so we actually need to handle this case separately.
    if delta == Magnitude.max {
      return Self(truncatingIfNeeded: generator.next() as Magnitude)
    }
    // Need to widen delta to account for the right-endpoint of a closed range.
    delta += 1
    // The mathematical result we want is lowerBound plus a random value in
    // 0 ..< delta. We need to be slightly careful about how we do this
    // arithmetic; the Bound type cannot generally represent the random value,
    // so we use a wrapping addition on Bound.Magnitude. This will often
    // overflow, but produces the correct bit pattern for the result when
    // converted back to Bound.
    return Self(truncatingIfNeeded:
      Magnitude(truncatingIfNeeded: range.lowerBound) &+
      generator.next(upperBound: delta)
    )
  }
  @inlinable public static func random(in range: ClosedRange<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}
extension FixedWidthInteger {
  @_transparent prefix public static func ~ (x: Self) -> Self {
    return 0 &- x &- 1
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func >> <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.BinaryInteger {
    var lhs = lhs
    _nonMaskingRightShiftGeneric(&lhs, rhs)
    return lhs
  }
  @_transparent @_semantics("optimize.sil.specialize.generic.partial.never") public static func >>= <Other>(lhs: inout Self, rhs: Other) where Other : Swift.BinaryInteger {
    _nonMaskingRightShiftGeneric(&lhs, rhs)
  }
  @_transparent public static func _nonMaskingRightShiftGeneric<Other>(_ lhs: inout Self, _ rhs: Other) where Other : Swift.BinaryInteger {
    let shift = rhs < -Self.bitWidth ? -Self.bitWidth
                : rhs > Self.bitWidth ? Self.bitWidth
                : Int(rhs)
    lhs = _nonMaskingRightShift(lhs, shift)
  }
  @_transparent public static func _nonMaskingRightShift(_ lhs: Self, _ rhs: Int) -> Self {
    let overshiftR = Self.isSigned ? lhs &>> (Self.bitWidth - 1) : 0
    let overshiftL: Self = 0
    if _fastPath(rhs >= 0) {
      if _fastPath(rhs < Self.bitWidth) {
        return lhs &>> Self(truncatingIfNeeded: rhs)
      }
      return overshiftR
    }

    if _slowPath(rhs <= -Self.bitWidth) {
      return overshiftL
    }
    return lhs &<< -rhs
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @_transparent public static func << <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.BinaryInteger {
    var lhs = lhs
    _nonMaskingLeftShiftGeneric(&lhs, rhs)
    return lhs
  }
  @_transparent @_semantics("optimize.sil.specialize.generic.partial.never") public static func <<= <Other>(lhs: inout Self, rhs: Other) where Other : Swift.BinaryInteger {
    _nonMaskingLeftShiftGeneric(&lhs, rhs)
  }
  @_transparent public static func _nonMaskingLeftShiftGeneric<Other>(_ lhs: inout Self, _ rhs: Other) where Other : Swift.BinaryInteger {
    let shift = rhs < -Self.bitWidth ? -Self.bitWidth
                : rhs > Self.bitWidth ? Self.bitWidth
                : Int(rhs)
    lhs = _nonMaskingLeftShift(lhs, shift)
  }
  @_transparent public static func _nonMaskingLeftShift(_ lhs: Self, _ rhs: Int) -> Self {
    let overshiftR = Self.isSigned ? lhs &>> (Self.bitWidth - 1) : 0
    let overshiftL: Self = 0
    if _fastPath(rhs >= 0) {
      if _fastPath(rhs < Self.bitWidth) {
        return lhs &<< Self(truncatingIfNeeded: rhs)
      }
      return overshiftL
    }

    if _slowPath(rhs <= -Self.bitWidth) {
      return overshiftR
    }
    return lhs &>> -rhs
  }
}
extension FixedWidthInteger {
  @inlinable @_semantics("optimize.sil.specialize.generic.partial.never") public static func _convert<Source>(from source: Source) -> (value: Self?, exact: Bool) where Source : Swift.BinaryFloatingPoint {
    guard _fastPath(!source.isZero) else { return (0, true) }
    guard _fastPath(source.isFinite) else { return (nil, false) }
    guard Self.isSigned || source > -1 else { return (nil, false) }
    let exponent = source.exponent
    if _slowPath(Self.bitWidth <= exponent) { return (nil, false) }
    let minBitWidth = source.significandWidth
    let isExact = (minBitWidth <= exponent)
    let bitPattern = source.significandBitPattern
    // `RawSignificand.bitWidth` is not available if `RawSignificand` does not
    // conform to `FixedWidthInteger`; we can compute this value as follows if
    // `source` is finite:
    let bitWidth = minBitWidth &+ bitPattern.trailingZeroBitCount
    let shift = exponent - Source.Exponent(bitWidth)
    // Use `Self.Magnitude` to prevent sign extension if `shift < 0`.
    let shiftedBitPattern = Self.Magnitude.bitWidth > bitWidth
      ? Self.Magnitude(truncatingIfNeeded: bitPattern) << shift
      : Self.Magnitude(truncatingIfNeeded: bitPattern << shift)
    if _slowPath(Self.isSigned && Self.bitWidth &- 1 == exponent) {
      return source < 0 && shiftedBitPattern == 0
        ? (Self.min, isExact)
        : (nil, false)
    }
    let magnitude = ((1 as Self.Magnitude) << exponent) | shiftedBitPattern
    return (
      Self.isSigned && source < 0 ? 0 &- Self(magnitude) : Self(magnitude),
      isExact)
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.partial.never") @inline(__always) public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint {
    guard let value = Self._convert(from: source).value else {
      fatalError("""
        \(T.self) value cannot be converted to \(Self.self) because it is \
        outside the representable range
        """)
    }
    self = value
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @inlinable public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint {
    let (temporary, exact) = Self._convert(from: source)
    guard exact, let value = temporary else {
      return nil
    }
    self = value
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.partial.never") public init<Other>(clamping source: Other) where Other : Swift.BinaryInteger {
    if _slowPath(source < Self.min) {
      self = Self.min
    }
    else if _slowPath(source > Self.max) {
      self = Self.max
    }
    else { self = Self(truncatingIfNeeded: source) }
  }
  @inlinable @inline(__always) public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger {
    if Self.bitWidth <= Int.bitWidth {
      self = Self(_truncatingBits: source._lowWord)
    }
    else {
      let neg = source < (0 as T)
      var result: Self = neg ? ~0 : 0
      var shift: Self = 0
      let width = Self(_truncatingBits: Self.bitWidth._lowWord)
      for word in source.words {
        guard shift < width else { break }
        // Masking shift is OK here because we have already ensured
        // that shift < Self.bitWidth. Not masking results in
        // infinite recursion.
        result ^= Self(_truncatingBits: neg ? ~word : word) &<< shift
        shift += Self(_truncatingBits: Int.bitWidth._lowWord)
      }
      self = result
    }
  }
  @_transparent public static var _highBitIndex: Self {
    get {
    return Self.init(_truncatingBits: UInt(Self.bitWidth._value) &- 1)
  }
  }
  @_transparent public static func &+ (lhs: Self, rhs: Self) -> Self {
    return lhs.addingReportingOverflow(rhs).partialValue
  }
  @_transparent public static func &+= (lhs: inout Self, rhs: Self) {
    lhs = lhs &+ rhs
  }
  @_transparent public static func &- (lhs: Self, rhs: Self) -> Self {
    return lhs.subtractingReportingOverflow(rhs).partialValue
  }
  @_transparent public static func &-= (lhs: inout Self, rhs: Self) {
    lhs = lhs &- rhs
  }
  @_transparent public static func &* (lhs: Self, rhs: Self) -> Self {
    return lhs.multipliedReportingOverflow(by: rhs).partialValue
  }
  @_transparent public static func &*= (lhs: inout Self, rhs: Self) {
    lhs = lhs &* rhs
  }
}
extension FixedWidthInteger {
  @inlinable public static func _random<R>(using generator: inout R) -> Self where R : Swift.RandomNumberGenerator {
    if bitWidth <= UInt64.bitWidth {
      return Self(truncatingIfNeeded: generator.next() as UInt64)
    }

    let (quotient, remainder) = bitWidth.quotientAndRemainder(
      dividingBy: UInt64.bitWidth
    )
    var tmp: Self = 0
    for i in 0 ..< quotient + remainder.signum() {
      let next: UInt64 = generator.next()
      tmp += Self(truncatingIfNeeded: next) &<< (UInt64.bitWidth * i)
    }
    return tmp
  }
}
public protocol UnsignedInteger : Swift.BinaryInteger {
}
extension UnsignedInteger {
  @inlinable public var magnitude: Self {
    @inline(__always) get { return self }
  }
  @inlinable public static var isSigned: Bool {
    @inline(__always) get { return false }
  }
}
extension UnsignedInteger where Self : Swift.FixedWidthInteger {
  @_semantics("optimize.sil.specialize.generic.partial.never") @inlinable @inline(__always) public init<T>(_ source: T) where T : Swift.BinaryInteger {
    // This check is potentially removable by the optimizer
    if T.isSigned {
      _precondition(source >= (0 as T), "Negative value is not representable")
    }
    // This check is potentially removable by the optimizer
    if source.bitWidth >= Self.bitWidth {
      _precondition(source <= Self.max,
        "Not enough bits to represent the passed value")
    }
    self.init(truncatingIfNeeded: source)
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @inlinable @inline(__always) public init?<T>(exactly source: T) where T : Swift.BinaryInteger {
    // This check is potentially removable by the optimizer
    if T.isSigned && source < (0 as T) {
      return nil
    }
    // The width check can be eliminated by the optimizer
    if source.bitWidth >= Self.bitWidth &&
       source > Self.max {
      return nil
    }
    self.init(truncatingIfNeeded: source)
  }
  @_transparent public static var max: Self {
    get { return ~0 }
  }
  @_transparent public static var min: Self {
    get { return 0 }
  }
}
public protocol SignedInteger : Swift.BinaryInteger, Swift.SignedNumeric {
  static func _maskingAdd(_ lhs: Self, _ rhs: Self) -> Self
  static func _maskingSubtract(_ lhs: Self, _ rhs: Self) -> Self
}
extension SignedInteger {
  @inlinable public static var isSigned: Bool {
    @inline(__always) get { return true }
  }
}
extension SignedInteger where Self : Swift.FixedWidthInteger {
  @_semantics("optimize.sil.specialize.generic.partial.never") @inlinable @inline(__always) public init<T>(_ source: T) where T : Swift.BinaryInteger {
    // This check is potentially removable by the optimizer
    if T.isSigned && source.bitWidth > Self.bitWidth {
      _precondition(source >= Self.min,
        "Not enough bits to represent a signed value")
    }
    // This check is potentially removable by the optimizer
    if (source.bitWidth > Self.bitWidth) ||
       (source.bitWidth == Self.bitWidth && !T.isSigned) {
      _precondition(source <= Self.max,
        "Not enough bits to represent the passed value")
    }
    self.init(truncatingIfNeeded: source)
  }
  @_semantics("optimize.sil.specialize.generic.partial.never") @inlinable @inline(__always) public init?<T>(exactly source: T) where T : Swift.BinaryInteger {
    // This check is potentially removable by the optimizer
    if T.isSigned && source.bitWidth > Self.bitWidth && source < Self.min {
      return nil
    }
    // The width check can be eliminated by the optimizer
    if (source.bitWidth > Self.bitWidth ||
        (source.bitWidth == Self.bitWidth && !T.isSigned)) &&
       source > Self.max {
      return nil
    }
    self.init(truncatingIfNeeded: source)
  }
  @_transparent public static var max: Self {
    get { return ~min }
  }
  @_transparent public static var min: Self {
    get {
    return (-1 as Self) &<< Self._highBitIndex
  }
  }
  @inlinable public func isMultiple(of other: Self) -> Bool {
    // Nothing but zero is a multiple of zero.
    if other == 0 { return self == 0 }
    // Special case to avoid overflow on .min / -1 for signed types.
    if other == -1 { return true }
    // Having handled those special cases, this is safe.
    return self % other == 0
  }
}
@inlinable public func numericCast<T, U>(_ x: T) -> U where T : Swift.BinaryInteger, U : Swift.BinaryInteger {
  return U(x)
}
extension SignedInteger {
  @_transparent public static func _maskingAdd(_ lhs: Self, _ rhs: Self) -> Self {
    fatalError("Should be overridden in a more specific type")
  }
  @_transparent public static func _maskingSubtract(_ lhs: Self, _ rhs: Self) -> Self {
    fatalError("Should be overridden in a more specific type")
  }
}
extension SignedInteger where Self : Swift.FixedWidthInteger {
  @_transparent public static func &+ (lhs: Self, rhs: Self) -> Self {
    return _maskingAdd(lhs, rhs)
  }
  @_transparent public static func _maskingAdd(_ lhs: Self, _ rhs: Self) -> Self {
    return lhs.addingReportingOverflow(rhs).partialValue
  }
  @_transparent public static func &- (lhs: Self, rhs: Self) -> Self {
    return _maskingSubtract(lhs, rhs)
  }
  @_transparent public static func _maskingSubtract(_ lhs: Self, _ rhs: Self) -> Self {
    return lhs.subtractingReportingOverflow(rhs).partialValue
  }
}
@_fixed_layout public struct UInt8 : FixedWidthInteger, UnsignedInteger, _ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = UInt8
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_u_checked_trunc_IntLiteral_Int8(x).0
  }
  @_transparent public init(bitPattern x: Int8) {
    _value = x._value
  }
  @_transparent public init(_ source: Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to UInt8 because it is either infinite or NaN")
    _precondition(source > -1.0,
      "Float value cannot be converted to UInt8 because the result would be less than UInt8.min")
    _precondition(source < 256.0,
      "Float value cannot be converted to UInt8 because the result would be greater than UInt8.max")
    self._value = Builtin.fptoui_FPIEEE32_Int8(source._value)
  }
  @_transparent public init?(exactly source: Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -1.0 && source < 256.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE32_Int8(source._value)
  }
  @_transparent public init(_ source: Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to UInt8 because it is either infinite or NaN")
    _precondition(source > -1.0,
      "Double value cannot be converted to UInt8 because the result would be less than UInt8.min")
    _precondition(source < 256.0,
      "Double value cannot be converted to UInt8 because the result would be greater than UInt8.max")
    self._value = Builtin.fptoui_FPIEEE64_Int8(source._value)
  }
  @_transparent public init?(exactly source: Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -1.0 && source < 256.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE64_Int8(source._value)
  }
  @_transparent public init(_ source: Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to UInt8 because it is either infinite or NaN")
    _precondition(source > -1.0,
      "Float80 value cannot be converted to UInt8 because the result would be less than UInt8.min")
    _precondition(source < 256.0,
      "Float80 value cannot be converted to UInt8 because the result would be greater than UInt8.max")
    self._value = Builtin.fptoui_FPIEEE80_Int8(source._value)
  }
  @_transparent public init?(exactly source: Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -1.0 && source < 256.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE80_Int8(source._value)
  }
  @_transparent public static func == (lhs: UInt8, rhs: UInt8) -> Bool {
    return Bool(Builtin.cmp_eq_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: UInt8, rhs: UInt8) -> Bool {
    return Bool(Builtin.cmp_ult_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout UInt8, rhs: UInt8) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.uadd_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt8(result)
  }
  @_transparent public static func -= (lhs: inout UInt8, rhs: UInt8) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.usub_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt8(result)
  }
  @_transparent public static func *= (lhs: inout UInt8, rhs: UInt8) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.umul_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt8(result)
  }
  @_transparent public static func /= (lhs: inout UInt8, rhs: UInt8) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1215)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt8)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    let (result, overflow) =
      (Builtin.udiv_Int8(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt8(result)
  }
  @_transparent public func dividedReportingOverflow(by other: UInt8) -> (partialValue: UInt8, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt8)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.udiv_Int8(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: UInt8) -> (partialValue: UInt8, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt8)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.urem_Int8(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func addingReportingOverflow(_ other: UInt8) -> (partialValue: UInt8, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.uadd_with_overflow_Int8(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: UInt8) -> (partialValue: UInt8, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.usub_with_overflow_Int8(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: UInt8) -> (partialValue: UInt8, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.umul_with_overflow_Int8(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout UInt8, rhs: UInt8) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt8)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1294)

    let (newStorage, _) = (
      Builtin.urem_Int8(lhs._value, rhs._value),
      false._value)
    lhs = UInt8(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int8) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout UInt8, rhs: UInt8) {
    lhs = UInt8(Builtin.and_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout UInt8, rhs: UInt8) {
    lhs = UInt8(Builtin.or_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout UInt8, rhs: UInt8) {
    lhs = UInt8(Builtin.xor_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout UInt8, rhs: UInt8) {
    let rhs_ = rhs & 7
    lhs = UInt8(
      Builtin.lshr_Int8(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout UInt8, rhs: UInt8) {
    let rhs_ = rhs & 7
    lhs = UInt8(
      Builtin.shl_Int8(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Int {
    get { return 8 }
  }
  @_transparent public var leadingZeroBitCount: Int {
    get {
    return Int(
      UInt8(
        Builtin.int_ctlz_Int8(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Int {
    get {
    return Int(
      UInt8(
        Builtin.int_cttz_Int8(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Int {
    get {
    return Int(
      UInt8(
        Builtin.int_ctpop_Int8(self._value)
      )._lowWord._value)
  }
  }
  @_fixed_layout public struct Words : RandomAccessCollection {
    public typealias Indices = Range<Int>
    public typealias SubSequence = Slice<UInt8.Words>
    @usableFromInline
    internal var _value: UInt8
    @inlinable public init(_ value: UInt8) {
      self._value = value
    }
    @inlinable public var count: Int {
      get {
      return (8 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Int {
      get { return count }
    }
    @inlinable public var indices: Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Int) -> Int { return i + 1 }
    @_transparent public func index(before i: Int) -> Int { return i - 1 }
    @inlinable public subscript(position: Int) -> UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> UInt8(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.UInt8.Words>
  }
  @_transparent public var words: Words {
    get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: UInt {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1447)
    return UInt(
      Builtin.zextOrBitCast_Int8_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: UInt) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1456)
    self.init(
      Builtin.truncOrBitCast_Int64_Int8(bits._value))
  }
  public typealias Magnitude = UInt8
  @inlinable public func multipliedFullWidth(by other: UInt8) -> (high: UInt8, low: UInt8.Magnitude) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1525)
    let lhs_ = Builtin.zext_Int8_Int16(self._value)
    let rhs_ = Builtin.zext_Int8_Int16(other._value)

    let res = Builtin.mul_Int16(lhs_, rhs_)
    let low = UInt8.Magnitude(Builtin.truncOrBitCast_Int16_Int8(res))
    let shift = Builtin.zextOrBitCast_Int8_Int16(UInt8(8)._value)
    let shifted = Builtin.ashr_Int16(res, shift)
    let high = UInt8(Builtin.truncOrBitCast_Int16_Int8(shifted))
    return (high: high, low: low)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1535)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: UInt8, low: UInt8.Magnitude)) -> (quotient: UInt8, remainder: UInt8) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1561)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.zext_Int8_Int16(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int16(UInt8(8)._value)
    let lhsHighShifted = Builtin.shl_Int16(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int8_Int16(dividend.low._value)
    let lhs_ = Builtin.or_Int16(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.zext_Int8_Int16(self._value)

    let quotient_ = Builtin.udiv_Int16(lhs_, rhs_)
    let remainder_ = Builtin.urem_Int16(lhs_, rhs_)

    let quotient = UInt8(
      Builtin.truncOrBitCast_Int16_Int8(quotient_))
    let remainder = UInt8(
      Builtin.truncOrBitCast_Int16_Int8(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1580)
  }
  @_transparent public var byteSwapped: UInt8 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1586)
    return self
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1590)
  }
  }
  public var _value: Builtin.Int8
  @inlinable @inline(__always) public func signum() -> UInt8 {
    let isPositive = UInt8(Builtin.zext_Int1_Int8(
      (self > (0 as UInt8))._value))
    return isPositive | (self &>> 7)
  }
  public typealias Stride = Swift.Int
}
extension UInt8 : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher._combine(UInt8(_value))
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1651)
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt8(_value)),
      count: 1)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1656)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension UInt8 : _HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> AnyHashable?
}
extension UInt8 {
  @_transparent public static func & (lhs: UInt8, rhs: UInt8) -> UInt8 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: UInt8, rhs: UInt8) -> UInt8 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: UInt8, rhs: UInt8) -> UInt8 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: UInt8, rhs: UInt8) -> UInt8 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: UInt8, rhs: UInt8) -> UInt8 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func / (lhs: UInt8, rhs: UInt8) -> UInt8 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: UInt8, rhs: UInt8) -> UInt8 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func + (lhs: UInt8, rhs: UInt8) -> UInt8 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: UInt8, rhs: UInt8) -> UInt8 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: UInt8, rhs: UInt8) -> UInt8 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: UInt8, rhs: UInt8) -> Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: UInt8, rhs: UInt8) -> Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: UInt8, rhs: UInt8) -> Bool {
    return rhs < lhs
  }
}
@_fixed_layout public struct Int8 : FixedWidthInteger, SignedInteger, _ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Int8
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_s_checked_trunc_IntLiteral_Int8(x).0
  }
  @_transparent public init(bitPattern x: UInt8) {
    _value = x._value
  }
  @_transparent public init(_ source: Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to Int8 because it is either infinite or NaN")
    _precondition(source > -129.0,
      "Float value cannot be converted to Int8 because the result would be less than Int8.min")
    _precondition(source < 128.0,
      "Float value cannot be converted to Int8 because the result would be greater than Int8.max")
    self._value = Builtin.fptosi_FPIEEE32_Int8(source._value)
  }
  @_transparent public init?(exactly source: Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -129.0 && source < 128.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE32_Int8(source._value)
  }
  @_transparent public init(_ source: Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to Int8 because it is either infinite or NaN")
    _precondition(source > -129.0,
      "Double value cannot be converted to Int8 because the result would be less than Int8.min")
    _precondition(source < 128.0,
      "Double value cannot be converted to Int8 because the result would be greater than Int8.max")
    self._value = Builtin.fptosi_FPIEEE64_Int8(source._value)
  }
  @_transparent public init?(exactly source: Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -129.0 && source < 128.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE64_Int8(source._value)
  }
  @_transparent public init(_ source: Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to Int8 because it is either infinite or NaN")
    _precondition(source > -129.0,
      "Float80 value cannot be converted to Int8 because the result would be less than Int8.min")
    _precondition(source < 128.0,
      "Float80 value cannot be converted to Int8 because the result would be greater than Int8.max")
    self._value = Builtin.fptosi_FPIEEE80_Int8(source._value)
  }
  @_transparent public init?(exactly source: Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -129.0 && source < 128.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE80_Int8(source._value)
  }
  @_transparent public static func == (lhs: Int8, rhs: Int8) -> Bool {
    return Bool(Builtin.cmp_eq_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Int8, rhs: Int8) -> Bool {
    return Bool(Builtin.cmp_slt_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Int8, rhs: Int8) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.sadd_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int8(result)
  }
  @_transparent public static func -= (lhs: inout Int8, rhs: Int8) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.ssub_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int8(result)
  }
  @_transparent public static func *= (lhs: inout Int8, rhs: Int8) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.smul_with_overflow_Int8(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int8(result)
  }
  @_transparent public static func /= (lhs: inout Int8, rhs: Int8) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1215)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int8)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1222)
    if _slowPath(
      lhs == Int8.min && rhs == (-1 as Int8)
    ) {
      _preconditionFailure(
        "Division results in an overflow")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    let (result, overflow) =
      (Builtin.sdiv_Int8(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int8(result)
  }
  @_transparent public func dividedReportingOverflow(by other: Int8) -> (partialValue: Int8, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int8)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1256)
    if _slowPath(self == Int8.min && other == (-1 as Int8)) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1258)
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.sdiv_Int8(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Int8) -> (partialValue: Int8, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int8)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1256)
    if _slowPath(self == Int8.min && other == (-1 as Int8)) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1258)
      return (partialValue: 0, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.srem_Int8(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func addingReportingOverflow(_ other: Int8) -> (partialValue: Int8, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.sadd_with_overflow_Int8(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Int8) -> (partialValue: Int8, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.ssub_with_overflow_Int8(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Int8) -> (partialValue: Int8, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.smul_with_overflow_Int8(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int8(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Int8, rhs: Int8) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int8)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1289)
    if _slowPath(lhs == Int8.min && rhs == (-1 as Int8)) {
      _preconditionFailure(
        "Division results in an overflow in remainder operation")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1294)

    let (newStorage, _) = (
      Builtin.srem_Int8(lhs._value, rhs._value),
      false._value)
    lhs = Int8(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int8) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Int8, rhs: Int8) {
    lhs = Int8(Builtin.and_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Int8, rhs: Int8) {
    lhs = Int8(Builtin.or_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Int8, rhs: Int8) {
    lhs = Int8(Builtin.xor_Int8(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Int8, rhs: Int8) {
    let rhs_ = rhs & 7
    lhs = Int8(
      Builtin.ashr_Int8(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Int8, rhs: Int8) {
    let rhs_ = rhs & 7
    lhs = Int8(
      Builtin.shl_Int8(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Int {
    get { return 8 }
  }
  @_transparent public var leadingZeroBitCount: Int {
    get {
    return Int(
      Int8(
        Builtin.int_ctlz_Int8(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Int {
    get {
    return Int(
      Int8(
        Builtin.int_cttz_Int8(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Int {
    get {
    return Int(
      Int8(
        Builtin.int_ctpop_Int8(self._value)
      )._lowWord._value)
  }
  }
  @_fixed_layout public struct Words : RandomAccessCollection {
    public typealias Indices = Range<Int>
    public typealias SubSequence = Slice<Int8.Words>
    @usableFromInline
    internal var _value: Int8
    @inlinable public init(_ value: Int8) {
      self._value = value
    }
    @inlinable public var count: Int {
      get {
      return (8 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Int {
      get { return count }
    }
    @inlinable public var indices: Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Int) -> Int { return i + 1 }
    @_transparent public func index(before i: Int) -> Int { return i - 1 }
    @inlinable public subscript(position: Int) -> UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> Int8(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.Int8.Words>
  }
  @_transparent public var words: Words {
    get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: UInt {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1447)
    return UInt(
      Builtin.sextOrBitCast_Int8_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: UInt) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1456)
    self.init(
      Builtin.truncOrBitCast_Int64_Int8(bits._value))
  }
  public typealias Magnitude = UInt8
  @_transparent public var magnitude: UInt8 {
    get {
    let base = UInt8(_value)
    return self < (0 as Int8) ? ~base &+ 1 : base
  }
  }
  @inlinable public func multipliedFullWidth(by other: Int8) -> (high: Int8, low: Int8.Magnitude) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1525)
    let lhs_ = Builtin.sext_Int8_Int16(self._value)
    let rhs_ = Builtin.sext_Int8_Int16(other._value)

    let res = Builtin.mul_Int16(lhs_, rhs_)
    let low = Int8.Magnitude(Builtin.truncOrBitCast_Int16_Int8(res))
    let shift = Builtin.zextOrBitCast_Int8_Int16(UInt8(8)._value)
    let shifted = Builtin.ashr_Int16(res, shift)
    let high = Int8(Builtin.truncOrBitCast_Int16_Int8(shifted))
    return (high: high, low: low)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1535)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Int8, low: Int8.Magnitude)) -> (quotient: Int8, remainder: Int8) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1561)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.sext_Int8_Int16(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int16(UInt8(8)._value)
    let lhsHighShifted = Builtin.shl_Int16(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int8_Int16(dividend.low._value)
    let lhs_ = Builtin.or_Int16(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.sext_Int8_Int16(self._value)

    let quotient_ = Builtin.sdiv_Int16(lhs_, rhs_)
    let remainder_ = Builtin.srem_Int16(lhs_, rhs_)

    let quotient = Int8(
      Builtin.truncOrBitCast_Int16_Int8(quotient_))
    let remainder = Int8(
      Builtin.truncOrBitCast_Int16_Int8(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1580)
  }
  @_transparent public var byteSwapped: Int8 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1586)
    return self
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1590)
  }
  }
  public var _value: Builtin.Int8
  @inlinable @inline(__always) public func signum() -> Int8 {
    let isPositive = Int8(Builtin.zext_Int1_Int8(
      (self > (0 as Int8))._value))
    return isPositive | (self &>> 7)
  }
  public typealias Stride = Swift.Int
}
extension Int8 : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher._combine(UInt8(_value))
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1651)
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt8(_value)),
      count: 1)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1656)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Int8 : _HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> AnyHashable?
}
extension Int8 {
  @_transparent public static func & (lhs: Int8, rhs: Int8) -> Int8 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Int8, rhs: Int8) -> Int8 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Int8, rhs: Int8) -> Int8 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Int8, rhs: Int8) -> Int8 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Int8, rhs: Int8) -> Int8 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Int8, rhs: Int8) -> Int8 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Int8, rhs: Int8) -> Int8 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Int8, rhs: Int8) -> Int8 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Int8, rhs: Int8) -> Int8 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Int8, rhs: Int8) -> Int8 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: Int8, rhs: Int8) -> Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Int8, rhs: Int8) -> Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Int8, rhs: Int8) -> Bool {
    return rhs < lhs
  }
}
@_transparent public func _assumeNonNegative(_ x: Int8) -> Int8 {
  _internalInvariant(x >= (0 as Int8))
  return Int8(Builtin.assumeNonNegative_Int8(x._value))
}
@_fixed_layout public struct UInt16 : FixedWidthInteger, UnsignedInteger, _ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = UInt16
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_u_checked_trunc_IntLiteral_Int16(x).0
  }
  @_transparent public init(bitPattern x: Int16) {
    _value = x._value
  }
  @_transparent public init(_ source: Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to UInt16 because it is either infinite or NaN")
    _precondition(source > -1.0,
      "Float value cannot be converted to UInt16 because the result would be less than UInt16.min")
    _precondition(source < 65536.0,
      "Float value cannot be converted to UInt16 because the result would be greater than UInt16.max")
    self._value = Builtin.fptoui_FPIEEE32_Int16(source._value)
  }
  @_transparent public init?(exactly source: Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -1.0 && source < 65536.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE32_Int16(source._value)
  }
  @_transparent public init(_ source: Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to UInt16 because it is either infinite or NaN")
    _precondition(source > -1.0,
      "Double value cannot be converted to UInt16 because the result would be less than UInt16.min")
    _precondition(source < 65536.0,
      "Double value cannot be converted to UInt16 because the result would be greater than UInt16.max")
    self._value = Builtin.fptoui_FPIEEE64_Int16(source._value)
  }
  @_transparent public init?(exactly source: Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -1.0 && source < 65536.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE64_Int16(source._value)
  }
  @_transparent public init(_ source: Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to UInt16 because it is either infinite or NaN")
    _precondition(source > -1.0,
      "Float80 value cannot be converted to UInt16 because the result would be less than UInt16.min")
    _precondition(source < 65536.0,
      "Float80 value cannot be converted to UInt16 because the result would be greater than UInt16.max")
    self._value = Builtin.fptoui_FPIEEE80_Int16(source._value)
  }
  @_transparent public init?(exactly source: Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -1.0 && source < 65536.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE80_Int16(source._value)
  }
  @_transparent public static func == (lhs: UInt16, rhs: UInt16) -> Bool {
    return Bool(Builtin.cmp_eq_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: UInt16, rhs: UInt16) -> Bool {
    return Bool(Builtin.cmp_ult_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout UInt16, rhs: UInt16) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.uadd_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt16(result)
  }
  @_transparent public static func -= (lhs: inout UInt16, rhs: UInt16) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.usub_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt16(result)
  }
  @_transparent public static func *= (lhs: inout UInt16, rhs: UInt16) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.umul_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt16(result)
  }
  @_transparent public static func /= (lhs: inout UInt16, rhs: UInt16) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1215)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt16)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    let (result, overflow) =
      (Builtin.udiv_Int16(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt16(result)
  }
  @_transparent public func dividedReportingOverflow(by other: UInt16) -> (partialValue: UInt16, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt16)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.udiv_Int16(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: UInt16) -> (partialValue: UInt16, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt16)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.urem_Int16(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func addingReportingOverflow(_ other: UInt16) -> (partialValue: UInt16, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.uadd_with_overflow_Int16(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: UInt16) -> (partialValue: UInt16, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.usub_with_overflow_Int16(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: UInt16) -> (partialValue: UInt16, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.umul_with_overflow_Int16(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout UInt16, rhs: UInt16) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt16)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1294)

    let (newStorage, _) = (
      Builtin.urem_Int16(lhs._value, rhs._value),
      false._value)
    lhs = UInt16(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int16) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout UInt16, rhs: UInt16) {
    lhs = UInt16(Builtin.and_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout UInt16, rhs: UInt16) {
    lhs = UInt16(Builtin.or_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout UInt16, rhs: UInt16) {
    lhs = UInt16(Builtin.xor_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout UInt16, rhs: UInt16) {
    let rhs_ = rhs & 15
    lhs = UInt16(
      Builtin.lshr_Int16(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout UInt16, rhs: UInt16) {
    let rhs_ = rhs & 15
    lhs = UInt16(
      Builtin.shl_Int16(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Int {
    get { return 16 }
  }
  @_transparent public var leadingZeroBitCount: Int {
    get {
    return Int(
      UInt16(
        Builtin.int_ctlz_Int16(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Int {
    get {
    return Int(
      UInt16(
        Builtin.int_cttz_Int16(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Int {
    get {
    return Int(
      UInt16(
        Builtin.int_ctpop_Int16(self._value)
      )._lowWord._value)
  }
  }
  @_fixed_layout public struct Words : RandomAccessCollection {
    public typealias Indices = Range<Int>
    public typealias SubSequence = Slice<UInt16.Words>
    @usableFromInline
    internal var _value: UInt16
    @inlinable public init(_ value: UInt16) {
      self._value = value
    }
    @inlinable public var count: Int {
      get {
      return (16 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Int {
      get { return count }
    }
    @inlinable public var indices: Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Int) -> Int { return i + 1 }
    @_transparent public func index(before i: Int) -> Int { return i - 1 }
    @inlinable public subscript(position: Int) -> UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> UInt16(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.UInt16.Words>
  }
  @_transparent public var words: Words {
    get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: UInt {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1447)
    return UInt(
      Builtin.zextOrBitCast_Int16_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: UInt) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1456)
    self.init(
      Builtin.truncOrBitCast_Int64_Int16(bits._value))
  }
  public typealias Magnitude = UInt16
  @inlinable public func multipliedFullWidth(by other: UInt16) -> (high: UInt16, low: UInt16.Magnitude) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1525)
    let lhs_ = Builtin.zext_Int16_Int32(self._value)
    let rhs_ = Builtin.zext_Int16_Int32(other._value)

    let res = Builtin.mul_Int32(lhs_, rhs_)
    let low = UInt16.Magnitude(Builtin.truncOrBitCast_Int32_Int16(res))
    let shift = Builtin.zextOrBitCast_Int8_Int32(UInt8(16)._value)
    let shifted = Builtin.ashr_Int32(res, shift)
    let high = UInt16(Builtin.truncOrBitCast_Int32_Int16(shifted))
    return (high: high, low: low)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1535)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: UInt16, low: UInt16.Magnitude)) -> (quotient: UInt16, remainder: UInt16) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1561)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.zext_Int16_Int32(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int32(UInt8(16)._value)
    let lhsHighShifted = Builtin.shl_Int32(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int16_Int32(dividend.low._value)
    let lhs_ = Builtin.or_Int32(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.zext_Int16_Int32(self._value)

    let quotient_ = Builtin.udiv_Int32(lhs_, rhs_)
    let remainder_ = Builtin.urem_Int32(lhs_, rhs_)

    let quotient = UInt16(
      Builtin.truncOrBitCast_Int32_Int16(quotient_))
    let remainder = UInt16(
      Builtin.truncOrBitCast_Int32_Int16(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1580)
  }
  @_transparent public var byteSwapped: UInt16 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1588)
    return UInt16(Builtin.int_bswap_Int16(_value))
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1590)
  }
  }
  public var _value: Builtin.Int16
  @inlinable @inline(__always) public func signum() -> UInt16 {
    let isPositive = UInt16(Builtin.zext_Int1_Int16(
      (self > (0 as UInt16))._value))
    return isPositive | (self &>> 15)
  }
  public typealias Stride = Swift.Int
}
extension UInt16 : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher._combine(UInt16(_value))
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1651)
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt16(_value)),
      count: 2)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1656)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension UInt16 : _HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> AnyHashable?
}
extension UInt16 {
  @_transparent public static func & (lhs: UInt16, rhs: UInt16) -> UInt16 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: UInt16, rhs: UInt16) -> UInt16 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: UInt16, rhs: UInt16) -> UInt16 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: UInt16, rhs: UInt16) -> UInt16 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: UInt16, rhs: UInt16) -> UInt16 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func / (lhs: UInt16, rhs: UInt16) -> UInt16 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: UInt16, rhs: UInt16) -> UInt16 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func + (lhs: UInt16, rhs: UInt16) -> UInt16 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: UInt16, rhs: UInt16) -> UInt16 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: UInt16, rhs: UInt16) -> UInt16 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: UInt16, rhs: UInt16) -> Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: UInt16, rhs: UInt16) -> Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: UInt16, rhs: UInt16) -> Bool {
    return rhs < lhs
  }
}
@_fixed_layout public struct Int16 : FixedWidthInteger, SignedInteger, _ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Int16
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_s_checked_trunc_IntLiteral_Int16(x).0
  }
  @_transparent public init(bitPattern x: UInt16) {
    _value = x._value
  }
  @_transparent public init(_ source: Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to Int16 because it is either infinite or NaN")
    _precondition(source > -32769.0,
      "Float value cannot be converted to Int16 because the result would be less than Int16.min")
    _precondition(source < 32768.0,
      "Float value cannot be converted to Int16 because the result would be greater than Int16.max")
    self._value = Builtin.fptosi_FPIEEE32_Int16(source._value)
  }
  @_transparent public init?(exactly source: Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -32769.0 && source < 32768.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE32_Int16(source._value)
  }
  @_transparent public init(_ source: Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to Int16 because it is either infinite or NaN")
    _precondition(source > -32769.0,
      "Double value cannot be converted to Int16 because the result would be less than Int16.min")
    _precondition(source < 32768.0,
      "Double value cannot be converted to Int16 because the result would be greater than Int16.max")
    self._value = Builtin.fptosi_FPIEEE64_Int16(source._value)
  }
  @_transparent public init?(exactly source: Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -32769.0 && source < 32768.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE64_Int16(source._value)
  }
  @_transparent public init(_ source: Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to Int16 because it is either infinite or NaN")
    _precondition(source > -32769.0,
      "Float80 value cannot be converted to Int16 because the result would be less than Int16.min")
    _precondition(source < 32768.0,
      "Float80 value cannot be converted to Int16 because the result would be greater than Int16.max")
    self._value = Builtin.fptosi_FPIEEE80_Int16(source._value)
  }
  @_transparent public init?(exactly source: Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -32769.0 && source < 32768.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE80_Int16(source._value)
  }
  @_transparent public static func == (lhs: Int16, rhs: Int16) -> Bool {
    return Bool(Builtin.cmp_eq_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Int16, rhs: Int16) -> Bool {
    return Bool(Builtin.cmp_slt_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Int16, rhs: Int16) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.sadd_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int16(result)
  }
  @_transparent public static func -= (lhs: inout Int16, rhs: Int16) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.ssub_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int16(result)
  }
  @_transparent public static func *= (lhs: inout Int16, rhs: Int16) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.smul_with_overflow_Int16(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int16(result)
  }
  @_transparent public static func /= (lhs: inout Int16, rhs: Int16) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1215)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int16)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1222)
    if _slowPath(
      lhs == Int16.min && rhs == (-1 as Int16)
    ) {
      _preconditionFailure(
        "Division results in an overflow")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    let (result, overflow) =
      (Builtin.sdiv_Int16(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int16(result)
  }
  @_transparent public func dividedReportingOverflow(by other: Int16) -> (partialValue: Int16, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int16)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1256)
    if _slowPath(self == Int16.min && other == (-1 as Int16)) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1258)
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.sdiv_Int16(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Int16) -> (partialValue: Int16, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int16)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1256)
    if _slowPath(self == Int16.min && other == (-1 as Int16)) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1258)
      return (partialValue: 0, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.srem_Int16(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func addingReportingOverflow(_ other: Int16) -> (partialValue: Int16, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.sadd_with_overflow_Int16(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Int16) -> (partialValue: Int16, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.ssub_with_overflow_Int16(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Int16) -> (partialValue: Int16, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.smul_with_overflow_Int16(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int16(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Int16, rhs: Int16) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int16)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1289)
    if _slowPath(lhs == Int16.min && rhs == (-1 as Int16)) {
      _preconditionFailure(
        "Division results in an overflow in remainder operation")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1294)

    let (newStorage, _) = (
      Builtin.srem_Int16(lhs._value, rhs._value),
      false._value)
    lhs = Int16(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int16) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Int16, rhs: Int16) {
    lhs = Int16(Builtin.and_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Int16, rhs: Int16) {
    lhs = Int16(Builtin.or_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Int16, rhs: Int16) {
    lhs = Int16(Builtin.xor_Int16(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Int16, rhs: Int16) {
    let rhs_ = rhs & 15
    lhs = Int16(
      Builtin.ashr_Int16(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Int16, rhs: Int16) {
    let rhs_ = rhs & 15
    lhs = Int16(
      Builtin.shl_Int16(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Int {
    get { return 16 }
  }
  @_transparent public var leadingZeroBitCount: Int {
    get {
    return Int(
      Int16(
        Builtin.int_ctlz_Int16(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Int {
    get {
    return Int(
      Int16(
        Builtin.int_cttz_Int16(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Int {
    get {
    return Int(
      Int16(
        Builtin.int_ctpop_Int16(self._value)
      )._lowWord._value)
  }
  }
  @_fixed_layout public struct Words : RandomAccessCollection {
    public typealias Indices = Range<Int>
    public typealias SubSequence = Slice<Int16.Words>
    @usableFromInline
    internal var _value: Int16
    @inlinable public init(_ value: Int16) {
      self._value = value
    }
    @inlinable public var count: Int {
      get {
      return (16 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Int {
      get { return count }
    }
    @inlinable public var indices: Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Int) -> Int { return i + 1 }
    @_transparent public func index(before i: Int) -> Int { return i - 1 }
    @inlinable public subscript(position: Int) -> UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> Int16(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.Int16.Words>
  }
  @_transparent public var words: Words {
    get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: UInt {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1447)
    return UInt(
      Builtin.sextOrBitCast_Int16_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: UInt) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1456)
    self.init(
      Builtin.truncOrBitCast_Int64_Int16(bits._value))
  }
  public typealias Magnitude = UInt16
  @_transparent public var magnitude: UInt16 {
    get {
    let base = UInt16(_value)
    return self < (0 as Int16) ? ~base &+ 1 : base
  }
  }
  @inlinable public func multipliedFullWidth(by other: Int16) -> (high: Int16, low: Int16.Magnitude) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1525)
    let lhs_ = Builtin.sext_Int16_Int32(self._value)
    let rhs_ = Builtin.sext_Int16_Int32(other._value)

    let res = Builtin.mul_Int32(lhs_, rhs_)
    let low = Int16.Magnitude(Builtin.truncOrBitCast_Int32_Int16(res))
    let shift = Builtin.zextOrBitCast_Int8_Int32(UInt8(16)._value)
    let shifted = Builtin.ashr_Int32(res, shift)
    let high = Int16(Builtin.truncOrBitCast_Int32_Int16(shifted))
    return (high: high, low: low)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1535)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Int16, low: Int16.Magnitude)) -> (quotient: Int16, remainder: Int16) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1561)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.sext_Int16_Int32(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int32(UInt8(16)._value)
    let lhsHighShifted = Builtin.shl_Int32(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int16_Int32(dividend.low._value)
    let lhs_ = Builtin.or_Int32(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.sext_Int16_Int32(self._value)

    let quotient_ = Builtin.sdiv_Int32(lhs_, rhs_)
    let remainder_ = Builtin.srem_Int32(lhs_, rhs_)

    let quotient = Int16(
      Builtin.truncOrBitCast_Int32_Int16(quotient_))
    let remainder = Int16(
      Builtin.truncOrBitCast_Int32_Int16(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1580)
  }
  @_transparent public var byteSwapped: Int16 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1588)
    return Int16(Builtin.int_bswap_Int16(_value))
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1590)
  }
  }
  public var _value: Builtin.Int16
  @inlinable @inline(__always) public func signum() -> Int16 {
    let isPositive = Int16(Builtin.zext_Int1_Int16(
      (self > (0 as Int16))._value))
    return isPositive | (self &>> 15)
  }
  public typealias Stride = Swift.Int
}
extension Int16 : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher._combine(UInt16(_value))
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1651)
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt16(_value)),
      count: 2)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1656)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Int16 : _HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> AnyHashable?
}
extension Int16 {
  @_transparent public static func & (lhs: Int16, rhs: Int16) -> Int16 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Int16, rhs: Int16) -> Int16 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Int16, rhs: Int16) -> Int16 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Int16, rhs: Int16) -> Int16 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Int16, rhs: Int16) -> Int16 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Int16, rhs: Int16) -> Int16 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Int16, rhs: Int16) -> Int16 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Int16, rhs: Int16) -> Int16 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Int16, rhs: Int16) -> Int16 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Int16, rhs: Int16) -> Int16 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: Int16, rhs: Int16) -> Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Int16, rhs: Int16) -> Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Int16, rhs: Int16) -> Bool {
    return rhs < lhs
  }
}
@_transparent public func _assumeNonNegative(_ x: Int16) -> Int16 {
  _internalInvariant(x >= (0 as Int16))
  return Int16(Builtin.assumeNonNegative_Int16(x._value))
}
@_fixed_layout public struct UInt32 : FixedWidthInteger, UnsignedInteger, _ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = UInt32
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_u_checked_trunc_IntLiteral_Int32(x).0
  }
  @_transparent public init(bitPattern x: Int32) {
    _value = x._value
  }
  @_transparent public init(_ source: Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to UInt32 because it is either infinite or NaN")
    _precondition(source > -1.0,
      "Float value cannot be converted to UInt32 because the result would be less than UInt32.min")
    _precondition(source < 4294967296.0,
      "Float value cannot be converted to UInt32 because the result would be greater than UInt32.max")
    self._value = Builtin.fptoui_FPIEEE32_Int32(source._value)
  }
  @_transparent public init?(exactly source: Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -1.0 && source < 4294967296.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE32_Int32(source._value)
  }
  @_transparent public init(_ source: Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to UInt32 because it is either infinite or NaN")
    _precondition(source > -1.0,
      "Double value cannot be converted to UInt32 because the result would be less than UInt32.min")
    _precondition(source < 4294967296.0,
      "Double value cannot be converted to UInt32 because the result would be greater than UInt32.max")
    self._value = Builtin.fptoui_FPIEEE64_Int32(source._value)
  }
  @_transparent public init?(exactly source: Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -1.0 && source < 4294967296.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE64_Int32(source._value)
  }
  @_transparent public init(_ source: Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to UInt32 because it is either infinite or NaN")
    _precondition(source > -1.0,
      "Float80 value cannot be converted to UInt32 because the result would be less than UInt32.min")
    _precondition(source < 4294967296.0,
      "Float80 value cannot be converted to UInt32 because the result would be greater than UInt32.max")
    self._value = Builtin.fptoui_FPIEEE80_Int32(source._value)
  }
  @_transparent public init?(exactly source: Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -1.0 && source < 4294967296.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE80_Int32(source._value)
  }
  @_transparent public static func == (lhs: UInt32, rhs: UInt32) -> Bool {
    return Bool(Builtin.cmp_eq_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: UInt32, rhs: UInt32) -> Bool {
    return Bool(Builtin.cmp_ult_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout UInt32, rhs: UInt32) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.uadd_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt32(result)
  }
  @_transparent public static func -= (lhs: inout UInt32, rhs: UInt32) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.usub_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt32(result)
  }
  @_transparent public static func *= (lhs: inout UInt32, rhs: UInt32) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.umul_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt32(result)
  }
  @_transparent public static func /= (lhs: inout UInt32, rhs: UInt32) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1215)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt32)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    let (result, overflow) =
      (Builtin.udiv_Int32(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt32(result)
  }
  @_transparent public func dividedReportingOverflow(by other: UInt32) -> (partialValue: UInt32, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt32)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.udiv_Int32(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: UInt32) -> (partialValue: UInt32, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt32)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.urem_Int32(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func addingReportingOverflow(_ other: UInt32) -> (partialValue: UInt32, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.uadd_with_overflow_Int32(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: UInt32) -> (partialValue: UInt32, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.usub_with_overflow_Int32(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: UInt32) -> (partialValue: UInt32, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.umul_with_overflow_Int32(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout UInt32, rhs: UInt32) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt32)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1294)

    let (newStorage, _) = (
      Builtin.urem_Int32(lhs._value, rhs._value),
      false._value)
    lhs = UInt32(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int32) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout UInt32, rhs: UInt32) {
    lhs = UInt32(Builtin.and_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout UInt32, rhs: UInt32) {
    lhs = UInt32(Builtin.or_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout UInt32, rhs: UInt32) {
    lhs = UInt32(Builtin.xor_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout UInt32, rhs: UInt32) {
    let rhs_ = rhs & 31
    lhs = UInt32(
      Builtin.lshr_Int32(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout UInt32, rhs: UInt32) {
    let rhs_ = rhs & 31
    lhs = UInt32(
      Builtin.shl_Int32(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Int {
    get { return 32 }
  }
  @_transparent public var leadingZeroBitCount: Int {
    get {
    return Int(
      UInt32(
        Builtin.int_ctlz_Int32(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Int {
    get {
    return Int(
      UInt32(
        Builtin.int_cttz_Int32(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Int {
    get {
    return Int(
      UInt32(
        Builtin.int_ctpop_Int32(self._value)
      )._lowWord._value)
  }
  }
  @_fixed_layout public struct Words : RandomAccessCollection {
    public typealias Indices = Range<Int>
    public typealias SubSequence = Slice<UInt32.Words>
    @usableFromInline
    internal var _value: UInt32
    @inlinable public init(_ value: UInt32) {
      self._value = value
    }
    @inlinable public var count: Int {
      get {
      return (32 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Int {
      get { return count }
    }
    @inlinable public var indices: Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Int) -> Int { return i + 1 }
    @_transparent public func index(before i: Int) -> Int { return i - 1 }
    @inlinable public subscript(position: Int) -> UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> UInt32(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.UInt32.Words>
  }
  @_transparent public var words: Words {
    get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: UInt {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1447)
    return UInt(
      Builtin.zextOrBitCast_Int32_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: UInt) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1456)
    self.init(
      Builtin.truncOrBitCast_Int64_Int32(bits._value))
  }
  public typealias Magnitude = UInt32
  @inlinable public func multipliedFullWidth(by other: UInt32) -> (high: UInt32, low: UInt32.Magnitude) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1525)
    let lhs_ = Builtin.zext_Int32_Int64(self._value)
    let rhs_ = Builtin.zext_Int32_Int64(other._value)

    let res = Builtin.mul_Int64(lhs_, rhs_)
    let low = UInt32.Magnitude(Builtin.truncOrBitCast_Int64_Int32(res))
    let shift = Builtin.zextOrBitCast_Int8_Int64(UInt8(32)._value)
    let shifted = Builtin.ashr_Int64(res, shift)
    let high = UInt32(Builtin.truncOrBitCast_Int64_Int32(shifted))
    return (high: high, low: low)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1535)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: UInt32, low: UInt32.Magnitude)) -> (quotient: UInt32, remainder: UInt32) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1561)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.zext_Int32_Int64(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int64(UInt8(32)._value)
    let lhsHighShifted = Builtin.shl_Int64(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int32_Int64(dividend.low._value)
    let lhs_ = Builtin.or_Int64(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.zext_Int32_Int64(self._value)

    let quotient_ = Builtin.udiv_Int64(lhs_, rhs_)
    let remainder_ = Builtin.urem_Int64(lhs_, rhs_)

    let quotient = UInt32(
      Builtin.truncOrBitCast_Int64_Int32(quotient_))
    let remainder = UInt32(
      Builtin.truncOrBitCast_Int64_Int32(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1580)
  }
  @_transparent public var byteSwapped: UInt32 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1588)
    return UInt32(Builtin.int_bswap_Int32(_value))
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1590)
  }
  }
  public var _value: Builtin.Int32
  @inlinable @inline(__always) public func signum() -> UInt32 {
    let isPositive = UInt32(Builtin.zext_Int1_Int32(
      (self > (0 as UInt32))._value))
    return isPositive | (self &>> 31)
  }
  public typealias Stride = Swift.Int
}
extension UInt32 : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher._combine(UInt32(_value))
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1651)
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt32(_value)),
      count: 4)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1656)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension UInt32 : _HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> AnyHashable?
}
extension UInt32 {
  @_transparent public static func & (lhs: UInt32, rhs: UInt32) -> UInt32 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: UInt32, rhs: UInt32) -> UInt32 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: UInt32, rhs: UInt32) -> UInt32 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: UInt32, rhs: UInt32) -> UInt32 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: UInt32, rhs: UInt32) -> UInt32 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func / (lhs: UInt32, rhs: UInt32) -> UInt32 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: UInt32, rhs: UInt32) -> UInt32 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func + (lhs: UInt32, rhs: UInt32) -> UInt32 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: UInt32, rhs: UInt32) -> UInt32 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: UInt32, rhs: UInt32) -> UInt32 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: UInt32, rhs: UInt32) -> Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: UInt32, rhs: UInt32) -> Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: UInt32, rhs: UInt32) -> Bool {
    return rhs < lhs
  }
}
@_fixed_layout public struct Int32 : FixedWidthInteger, SignedInteger, _ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Int32
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_s_checked_trunc_IntLiteral_Int32(x).0
  }
  @_transparent public init(bitPattern x: UInt32) {
    _value = x._value
  }
  @available(*, unavailable, message: "Please use Int32(bitPattern: UInt32) in combination with Float.bitPattern property.")
  public init(bitPattern x: Float)
  @_transparent public init(_ source: Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to Int32 because it is either infinite or NaN")
    _precondition(source > -2147483904.0,
      "Float value cannot be converted to Int32 because the result would be less than Int32.min")
    _precondition(source < 2147483648.0,
      "Float value cannot be converted to Int32 because the result would be greater than Int32.max")
    self._value = Builtin.fptosi_FPIEEE32_Int32(source._value)
  }
  @_transparent public init?(exactly source: Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -2147483904.0 && source < 2147483648.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE32_Int32(source._value)
  }
  @_transparent public init(_ source: Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to Int32 because it is either infinite or NaN")
    _precondition(source > -2147483649.0,
      "Double value cannot be converted to Int32 because the result would be less than Int32.min")
    _precondition(source < 2147483648.0,
      "Double value cannot be converted to Int32 because the result would be greater than Int32.max")
    self._value = Builtin.fptosi_FPIEEE64_Int32(source._value)
  }
  @_transparent public init?(exactly source: Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -2147483649.0 && source < 2147483648.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE64_Int32(source._value)
  }
  @_transparent public init(_ source: Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to Int32 because it is either infinite or NaN")
    _precondition(source > -2147483649.0,
      "Float80 value cannot be converted to Int32 because the result would be less than Int32.min")
    _precondition(source < 2147483648.0,
      "Float80 value cannot be converted to Int32 because the result would be greater than Int32.max")
    self._value = Builtin.fptosi_FPIEEE80_Int32(source._value)
  }
  @_transparent public init?(exactly source: Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -2147483649.0 && source < 2147483648.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE80_Int32(source._value)
  }
  @_transparent public static func == (lhs: Int32, rhs: Int32) -> Bool {
    return Bool(Builtin.cmp_eq_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Int32, rhs: Int32) -> Bool {
    return Bool(Builtin.cmp_slt_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Int32, rhs: Int32) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.sadd_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int32(result)
  }
  @_transparent public static func -= (lhs: inout Int32, rhs: Int32) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.ssub_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int32(result)
  }
  @_transparent public static func *= (lhs: inout Int32, rhs: Int32) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.smul_with_overflow_Int32(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int32(result)
  }
  @_transparent public static func /= (lhs: inout Int32, rhs: Int32) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1215)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int32)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1222)
    if _slowPath(
      lhs == Int32.min && rhs == (-1 as Int32)
    ) {
      _preconditionFailure(
        "Division results in an overflow")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    let (result, overflow) =
      (Builtin.sdiv_Int32(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int32(result)
  }
  @_transparent public func dividedReportingOverflow(by other: Int32) -> (partialValue: Int32, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int32)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1256)
    if _slowPath(self == Int32.min && other == (-1 as Int32)) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1258)
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.sdiv_Int32(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Int32) -> (partialValue: Int32, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int32)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1256)
    if _slowPath(self == Int32.min && other == (-1 as Int32)) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1258)
      return (partialValue: 0, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.srem_Int32(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func addingReportingOverflow(_ other: Int32) -> (partialValue: Int32, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.sadd_with_overflow_Int32(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Int32) -> (partialValue: Int32, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.ssub_with_overflow_Int32(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Int32) -> (partialValue: Int32, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.smul_with_overflow_Int32(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int32(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Int32, rhs: Int32) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int32)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1289)
    if _slowPath(lhs == Int32.min && rhs == (-1 as Int32)) {
      _preconditionFailure(
        "Division results in an overflow in remainder operation")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1294)

    let (newStorage, _) = (
      Builtin.srem_Int32(lhs._value, rhs._value),
      false._value)
    lhs = Int32(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int32) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Int32, rhs: Int32) {
    lhs = Int32(Builtin.and_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Int32, rhs: Int32) {
    lhs = Int32(Builtin.or_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Int32, rhs: Int32) {
    lhs = Int32(Builtin.xor_Int32(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Int32, rhs: Int32) {
    let rhs_ = rhs & 31
    lhs = Int32(
      Builtin.ashr_Int32(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Int32, rhs: Int32) {
    let rhs_ = rhs & 31
    lhs = Int32(
      Builtin.shl_Int32(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Int {
    get { return 32 }
  }
  @_transparent public var leadingZeroBitCount: Int {
    get {
    return Int(
      Int32(
        Builtin.int_ctlz_Int32(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Int {
    get {
    return Int(
      Int32(
        Builtin.int_cttz_Int32(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Int {
    get {
    return Int(
      Int32(
        Builtin.int_ctpop_Int32(self._value)
      )._lowWord._value)
  }
  }
  @_fixed_layout public struct Words : RandomAccessCollection {
    public typealias Indices = Range<Int>
    public typealias SubSequence = Slice<Int32.Words>
    @usableFromInline
    internal var _value: Int32
    @inlinable public init(_ value: Int32) {
      self._value = value
    }
    @inlinable public var count: Int {
      get {
      return (32 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Int {
      get { return count }
    }
    @inlinable public var indices: Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Int) -> Int { return i + 1 }
    @_transparent public func index(before i: Int) -> Int { return i - 1 }
    @inlinable public subscript(position: Int) -> UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> Int32(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.Int32.Words>
  }
  @_transparent public var words: Words {
    get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: UInt {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1447)
    return UInt(
      Builtin.sextOrBitCast_Int32_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: UInt) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1456)
    self.init(
      Builtin.truncOrBitCast_Int64_Int32(bits._value))
  }
  public typealias Magnitude = UInt32
  @_transparent public var magnitude: UInt32 {
    get {
    let base = UInt32(_value)
    return self < (0 as Int32) ? ~base &+ 1 : base
  }
  }
  @inlinable public func multipliedFullWidth(by other: Int32) -> (high: Int32, low: Int32.Magnitude) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1525)
    let lhs_ = Builtin.sext_Int32_Int64(self._value)
    let rhs_ = Builtin.sext_Int32_Int64(other._value)

    let res = Builtin.mul_Int64(lhs_, rhs_)
    let low = Int32.Magnitude(Builtin.truncOrBitCast_Int64_Int32(res))
    let shift = Builtin.zextOrBitCast_Int8_Int64(UInt8(32)._value)
    let shifted = Builtin.ashr_Int64(res, shift)
    let high = Int32(Builtin.truncOrBitCast_Int64_Int32(shifted))
    return (high: high, low: low)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1535)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Int32, low: Int32.Magnitude)) -> (quotient: Int32, remainder: Int32) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1561)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.sext_Int32_Int64(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int64(UInt8(32)._value)
    let lhsHighShifted = Builtin.shl_Int64(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int32_Int64(dividend.low._value)
    let lhs_ = Builtin.or_Int64(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.sext_Int32_Int64(self._value)

    let quotient_ = Builtin.sdiv_Int64(lhs_, rhs_)
    let remainder_ = Builtin.srem_Int64(lhs_, rhs_)

    let quotient = Int32(
      Builtin.truncOrBitCast_Int64_Int32(quotient_))
    let remainder = Int32(
      Builtin.truncOrBitCast_Int64_Int32(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1580)
  }
  @_transparent public var byteSwapped: Int32 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1588)
    return Int32(Builtin.int_bswap_Int32(_value))
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1590)
  }
  }
  public var _value: Builtin.Int32
  @inlinable @inline(__always) public func signum() -> Int32 {
    let isPositive = Int32(Builtin.zext_Int1_Int32(
      (self > (0 as Int32))._value))
    return isPositive | (self &>> 31)
  }
  public typealias Stride = Swift.Int
}
extension Int32 : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher._combine(UInt32(_value))
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1651)
    return Hasher._hash(
      seed: seed,
      bytes: UInt64(truncatingIfNeeded: UInt32(_value)),
      count: 4)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1656)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Int32 : _HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> AnyHashable?
}
extension Int32 {
  @_transparent public static func & (lhs: Int32, rhs: Int32) -> Int32 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Int32, rhs: Int32) -> Int32 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Int32, rhs: Int32) -> Int32 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Int32, rhs: Int32) -> Int32 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Int32, rhs: Int32) -> Int32 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Int32, rhs: Int32) -> Int32 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Int32, rhs: Int32) -> Int32 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Int32, rhs: Int32) -> Int32 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Int32, rhs: Int32) -> Int32 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Int32, rhs: Int32) -> Int32 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: Int32, rhs: Int32) -> Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Int32, rhs: Int32) -> Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Int32, rhs: Int32) -> Bool {
    return rhs < lhs
  }
}
@_transparent public func _assumeNonNegative(_ x: Int32) -> Int32 {
  _internalInvariant(x >= (0 as Int32))
  return Int32(Builtin.assumeNonNegative_Int32(x._value))
}
@_fixed_layout public struct UInt64 : FixedWidthInteger, UnsignedInteger, _ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = UInt64
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_u_checked_trunc_IntLiteral_Int64(x).0
  }
  @_transparent public init(bitPattern x: Int64) {
    _value = x._value
  }
  @_transparent public init(_ source: Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to UInt64 because it is either infinite or NaN")
    _precondition(source > -1.0,
      "Float value cannot be converted to UInt64 because the result would be less than UInt64.min")
    _precondition(source < 18446744073709551616.0,
      "Float value cannot be converted to UInt64 because the result would be greater than UInt64.max")
    self._value = Builtin.fptoui_FPIEEE32_Int64(source._value)
  }
  @_transparent public init?(exactly source: Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -1.0 && source < 18446744073709551616.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE32_Int64(source._value)
  }
  @_transparent public init(_ source: Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to UInt64 because it is either infinite or NaN")
    _precondition(source > -1.0,
      "Double value cannot be converted to UInt64 because the result would be less than UInt64.min")
    _precondition(source < 18446744073709551616.0,
      "Double value cannot be converted to UInt64 because the result would be greater than UInt64.max")
    self._value = Builtin.fptoui_FPIEEE64_Int64(source._value)
  }
  @_transparent public init?(exactly source: Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -1.0 && source < 18446744073709551616.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE64_Int64(source._value)
  }
  @_transparent public init(_ source: Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to UInt64 because it is either infinite or NaN")
    _precondition(source > -1.0,
      "Float80 value cannot be converted to UInt64 because the result would be less than UInt64.min")
    _precondition(source < 18446744073709551616.0,
      "Float80 value cannot be converted to UInt64 because the result would be greater than UInt64.max")
    self._value = Builtin.fptoui_FPIEEE80_Int64(source._value)
  }
  @_transparent public init?(exactly source: Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -1.0 && source < 18446744073709551616.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE80_Int64(source._value)
  }
  @_transparent public static func == (lhs: UInt64, rhs: UInt64) -> Bool {
    return Bool(Builtin.cmp_eq_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: UInt64, rhs: UInt64) -> Bool {
    return Bool(Builtin.cmp_ult_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout UInt64, rhs: UInt64) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.uadd_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt64(result)
  }
  @_transparent public static func -= (lhs: inout UInt64, rhs: UInt64) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.usub_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt64(result)
  }
  @_transparent public static func *= (lhs: inout UInt64, rhs: UInt64) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.umul_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt64(result)
  }
  @_transparent public static func /= (lhs: inout UInt64, rhs: UInt64) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1215)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt64)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    let (result, overflow) =
      (Builtin.udiv_Int64(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt64(result)
  }
  @_transparent public func dividedReportingOverflow(by other: UInt64) -> (partialValue: UInt64, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt64)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.udiv_Int64(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: UInt64) -> (partialValue: UInt64, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt64)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.urem_Int64(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func addingReportingOverflow(_ other: UInt64) -> (partialValue: UInt64, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.uadd_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: UInt64) -> (partialValue: UInt64, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.usub_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: UInt64) -> (partialValue: UInt64, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.umul_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout UInt64, rhs: UInt64) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt64)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1294)

    let (newStorage, _) = (
      Builtin.urem_Int64(lhs._value, rhs._value),
      false._value)
    lhs = UInt64(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int64) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout UInt64, rhs: UInt64) {
    lhs = UInt64(Builtin.and_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout UInt64, rhs: UInt64) {
    lhs = UInt64(Builtin.or_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout UInt64, rhs: UInt64) {
    lhs = UInt64(Builtin.xor_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout UInt64, rhs: UInt64) {
    let rhs_ = rhs & 63
    lhs = UInt64(
      Builtin.lshr_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout UInt64, rhs: UInt64) {
    let rhs_ = rhs & 63
    lhs = UInt64(
      Builtin.shl_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Int {
    get { return 64 }
  }
  @_transparent public var leadingZeroBitCount: Int {
    get {
    return Int(
      UInt64(
        Builtin.int_ctlz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Int {
    get {
    return Int(
      UInt64(
        Builtin.int_cttz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Int {
    get {
    return Int(
      UInt64(
        Builtin.int_ctpop_Int64(self._value)
      )._lowWord._value)
  }
  }
  @_fixed_layout public struct Words : RandomAccessCollection {
    public typealias Indices = Range<Int>
    public typealias SubSequence = Slice<UInt64.Words>
    @usableFromInline
    internal var _value: UInt64
    @inlinable public init(_ value: UInt64) {
      self._value = value
    }
    @inlinable public var count: Int {
      get {
      return (64 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Int {
      get { return count }
    }
    @inlinable public var indices: Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Int) -> Int { return i + 1 }
    @_transparent public func index(before i: Int) -> Int { return i - 1 }
    @inlinable public subscript(position: Int) -> UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> UInt64(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.UInt64.Words>
  }
  @_transparent public var words: Words {
    get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: UInt {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1447)
    return UInt(
      Builtin.zextOrBitCast_Int64_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: UInt) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1456)
    self.init(
      Builtin.truncOrBitCast_Int64_Int64(bits._value))
  }
  public typealias Magnitude = UInt64
  @inlinable public func multipliedFullWidth(by other: UInt64) -> (high: UInt64, low: UInt64.Magnitude) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1525)
    let lhs_ = Builtin.zext_Int64_Int128(self._value)
    let rhs_ = Builtin.zext_Int64_Int128(other._value)

    let res = Builtin.mul_Int128(lhs_, rhs_)
    let low = UInt64.Magnitude(Builtin.truncOrBitCast_Int128_Int64(res))
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let shifted = Builtin.ashr_Int128(res, shift)
    let high = UInt64(Builtin.truncOrBitCast_Int128_Int64(shifted))
    return (high: high, low: low)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1535)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: UInt64, low: UInt64.Magnitude)) -> (quotient: UInt64, remainder: UInt64) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1561)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.zext_Int64_Int128(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let lhsHighShifted = Builtin.shl_Int128(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int64_Int128(dividend.low._value)
    let lhs_ = Builtin.or_Int128(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.zext_Int64_Int128(self._value)

    let quotient_ = Builtin.udiv_Int128(lhs_, rhs_)
    let remainder_ = Builtin.urem_Int128(lhs_, rhs_)

    let quotient = UInt64(
      Builtin.truncOrBitCast_Int128_Int64(quotient_))
    let remainder = UInt64(
      Builtin.truncOrBitCast_Int128_Int64(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1580)
  }
  @_transparent public var byteSwapped: UInt64 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1588)
    return UInt64(Builtin.int_bswap_Int64(_value))
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1590)
  }
  }
  public var _value: Builtin.Int64
  @inlinable @inline(__always) public func signum() -> UInt64 {
    let isPositive = UInt64(Builtin.zext_Int1_Int64(
      (self > (0 as UInt64))._value))
    return isPositive | (self &>> 63)
  }
  public typealias Stride = Swift.Int
}
extension UInt64 : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher._combine(UInt64(_value))
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1647)
    return Hasher._hash(seed: seed, UInt64(_value))
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1656)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension UInt64 : _HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> AnyHashable?
}
extension UInt64 {
  @_transparent public static func & (lhs: UInt64, rhs: UInt64) -> UInt64 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: UInt64, rhs: UInt64) -> UInt64 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: UInt64, rhs: UInt64) -> UInt64 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: UInt64, rhs: UInt64) -> UInt64 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: UInt64, rhs: UInt64) -> UInt64 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func / (lhs: UInt64, rhs: UInt64) -> UInt64 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: UInt64, rhs: UInt64) -> UInt64 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func + (lhs: UInt64, rhs: UInt64) -> UInt64 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: UInt64, rhs: UInt64) -> UInt64 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: UInt64, rhs: UInt64) -> UInt64 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: UInt64, rhs: UInt64) -> Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: UInt64, rhs: UInt64) -> Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: UInt64, rhs: UInt64) -> Bool {
    return rhs < lhs
  }
}
@_fixed_layout public struct Int64 : FixedWidthInteger, SignedInteger, _ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Int64
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_s_checked_trunc_IntLiteral_Int64(x).0
  }
  @_transparent public init(bitPattern x: UInt64) {
    _value = x._value
  }
  @available(*, unavailable, message: "Please use Int64(bitPattern: UInt64) in combination with Double.bitPattern property.")
  public init(bitPattern x: Double)
  @_transparent public init(_ source: Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to Int64 because it is either infinite or NaN")
    _precondition(source > -9223373136366403584.0,
      "Float value cannot be converted to Int64 because the result would be less than Int64.min")
    _precondition(source < 9223372036854775808.0,
      "Float value cannot be converted to Int64 because the result would be greater than Int64.max")
    self._value = Builtin.fptosi_FPIEEE32_Int64(source._value)
  }
  @_transparent public init?(exactly source: Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -9223373136366403584.0 && source < 9223372036854775808.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE32_Int64(source._value)
  }
  @_transparent public init(_ source: Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to Int64 because it is either infinite or NaN")
    _precondition(source > -9223372036854777856.0,
      "Double value cannot be converted to Int64 because the result would be less than Int64.min")
    _precondition(source < 9223372036854775808.0,
      "Double value cannot be converted to Int64 because the result would be greater than Int64.max")
    self._value = Builtin.fptosi_FPIEEE64_Int64(source._value)
  }
  @_transparent public init?(exactly source: Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -9223372036854777856.0 && source < 9223372036854775808.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE64_Int64(source._value)
  }
  @_transparent public init(_ source: Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to Int64 because it is either infinite or NaN")
    _precondition(source > -9223372036854775809.0,
      "Float80 value cannot be converted to Int64 because the result would be less than Int64.min")
    _precondition(source < 9223372036854775808.0,
      "Float80 value cannot be converted to Int64 because the result would be greater than Int64.max")
    self._value = Builtin.fptosi_FPIEEE80_Int64(source._value)
  }
  @_transparent public init?(exactly source: Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -9223372036854775809.0 && source < 9223372036854775808.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE80_Int64(source._value)
  }
  @_transparent public static func == (lhs: Int64, rhs: Int64) -> Bool {
    return Bool(Builtin.cmp_eq_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Int64, rhs: Int64) -> Bool {
    return Bool(Builtin.cmp_slt_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Int64, rhs: Int64) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.sadd_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int64(result)
  }
  @_transparent public static func -= (lhs: inout Int64, rhs: Int64) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.ssub_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int64(result)
  }
  @_transparent public static func *= (lhs: inout Int64, rhs: Int64) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.smul_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int64(result)
  }
  @_transparent public static func /= (lhs: inout Int64, rhs: Int64) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1215)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int64)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1222)
    if _slowPath(
      lhs == Int64.min && rhs == (-1 as Int64)
    ) {
      _preconditionFailure(
        "Division results in an overflow")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    let (result, overflow) =
      (Builtin.sdiv_Int64(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int64(result)
  }
  @_transparent public func dividedReportingOverflow(by other: Int64) -> (partialValue: Int64, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int64)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1256)
    if _slowPath(self == Int64.min && other == (-1 as Int64)) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1258)
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.sdiv_Int64(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Int64) -> (partialValue: Int64, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int64)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1256)
    if _slowPath(self == Int64.min && other == (-1 as Int64)) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1258)
      return (partialValue: 0, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.srem_Int64(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func addingReportingOverflow(_ other: Int64) -> (partialValue: Int64, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.sadd_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Int64) -> (partialValue: Int64, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.ssub_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Int64) -> (partialValue: Int64, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.smul_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int64(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Int64, rhs: Int64) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int64)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1289)
    if _slowPath(lhs == Int64.min && rhs == (-1 as Int64)) {
      _preconditionFailure(
        "Division results in an overflow in remainder operation")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1294)

    let (newStorage, _) = (
      Builtin.srem_Int64(lhs._value, rhs._value),
      false._value)
    lhs = Int64(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int64) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Int64, rhs: Int64) {
    lhs = Int64(Builtin.and_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Int64, rhs: Int64) {
    lhs = Int64(Builtin.or_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Int64, rhs: Int64) {
    lhs = Int64(Builtin.xor_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Int64, rhs: Int64) {
    let rhs_ = rhs & 63
    lhs = Int64(
      Builtin.ashr_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Int64, rhs: Int64) {
    let rhs_ = rhs & 63
    lhs = Int64(
      Builtin.shl_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Int {
    get { return 64 }
  }
  @_transparent public var leadingZeroBitCount: Int {
    get {
    return Int(
      Int64(
        Builtin.int_ctlz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Int {
    get {
    return Int(
      Int64(
        Builtin.int_cttz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Int {
    get {
    return Int(
      Int64(
        Builtin.int_ctpop_Int64(self._value)
      )._lowWord._value)
  }
  }
  @_fixed_layout public struct Words : RandomAccessCollection {
    public typealias Indices = Range<Int>
    public typealias SubSequence = Slice<Int64.Words>
    @usableFromInline
    internal var _value: Int64
    @inlinable public init(_ value: Int64) {
      self._value = value
    }
    @inlinable public var count: Int {
      get {
      return (64 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Int {
      get { return count }
    }
    @inlinable public var indices: Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Int) -> Int { return i + 1 }
    @_transparent public func index(before i: Int) -> Int { return i - 1 }
    @inlinable public subscript(position: Int) -> UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> Int64(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.Int64.Words>
  }
  @_transparent public var words: Words {
    get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: UInt {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1447)
    return UInt(
      Builtin.sextOrBitCast_Int64_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: UInt) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1456)
    self.init(
      Builtin.truncOrBitCast_Int64_Int64(bits._value))
  }
  public typealias Magnitude = UInt64
  @_transparent public var magnitude: UInt64 {
    get {
    let base = UInt64(_value)
    return self < (0 as Int64) ? ~base &+ 1 : base
  }
  }
  @inlinable public func multipliedFullWidth(by other: Int64) -> (high: Int64, low: Int64.Magnitude) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1525)
    let lhs_ = Builtin.sext_Int64_Int128(self._value)
    let rhs_ = Builtin.sext_Int64_Int128(other._value)

    let res = Builtin.mul_Int128(lhs_, rhs_)
    let low = Int64.Magnitude(Builtin.truncOrBitCast_Int128_Int64(res))
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let shifted = Builtin.ashr_Int128(res, shift)
    let high = Int64(Builtin.truncOrBitCast_Int128_Int64(shifted))
    return (high: high, low: low)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1535)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Int64, low: Int64.Magnitude)) -> (quotient: Int64, remainder: Int64) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1561)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.sext_Int64_Int128(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let lhsHighShifted = Builtin.shl_Int128(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int64_Int128(dividend.low._value)
    let lhs_ = Builtin.or_Int128(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.sext_Int64_Int128(self._value)

    let quotient_ = Builtin.sdiv_Int128(lhs_, rhs_)
    let remainder_ = Builtin.srem_Int128(lhs_, rhs_)

    let quotient = Int64(
      Builtin.truncOrBitCast_Int128_Int64(quotient_))
    let remainder = Int64(
      Builtin.truncOrBitCast_Int128_Int64(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1580)
  }
  @_transparent public var byteSwapped: Int64 {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1588)
    return Int64(Builtin.int_bswap_Int64(_value))
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1590)
  }
  }
  public var _value: Builtin.Int64
  @inlinable @inline(__always) public func signum() -> Int64 {
    let isPositive = Int64(Builtin.zext_Int1_Int64(
      (self > (0 as Int64))._value))
    return isPositive | (self &>> 63)
  }
  public typealias Stride = Swift.Int
}
extension Int64 : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher._combine(UInt64(_value))
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1647)
    return Hasher._hash(seed: seed, UInt64(_value))
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1656)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Int64 : _HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> AnyHashable?
}
extension Int64 {
  @_transparent public static func & (lhs: Int64, rhs: Int64) -> Int64 {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Int64, rhs: Int64) -> Int64 {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Int64, rhs: Int64) -> Int64 {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Int64, rhs: Int64) -> Int64 {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Int64, rhs: Int64) -> Int64 {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Int64, rhs: Int64) -> Int64 {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Int64, rhs: Int64) -> Int64 {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Int64, rhs: Int64) -> Int64 {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Int64, rhs: Int64) -> Int64 {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Int64, rhs: Int64) -> Int64 {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: Int64, rhs: Int64) -> Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Int64, rhs: Int64) -> Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Int64, rhs: Int64) -> Bool {
    return rhs < lhs
  }
}
@_transparent public func _assumeNonNegative(_ x: Int64) -> Int64 {
  _internalInvariant(x >= (0 as Int64))
  return Int64(Builtin.assumeNonNegative_Int64(x._value))
}
@_fixed_layout public struct UInt : FixedWidthInteger, UnsignedInteger, _ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = UInt
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_u_checked_trunc_IntLiteral_Int64(x).0
  }
  @_transparent public init(bitPattern x: Int) {
    _value = x._value
  }
  @_transparent public init(_ source: Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to UInt because it is either infinite or NaN")
    _precondition(source > -1.0,
      "Float value cannot be converted to UInt because the result would be less than UInt.min")
    _precondition(source < 18446744073709551616.0,
      "Float value cannot be converted to UInt because the result would be greater than UInt.max")
    self._value = Builtin.fptoui_FPIEEE32_Int64(source._value)
  }
  @_transparent public init?(exactly source: Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -1.0 && source < 18446744073709551616.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE32_Int64(source._value)
  }
  @_transparent public init(_ source: Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to UInt because it is either infinite or NaN")
    _precondition(source > -1.0,
      "Double value cannot be converted to UInt because the result would be less than UInt.min")
    _precondition(source < 18446744073709551616.0,
      "Double value cannot be converted to UInt because the result would be greater than UInt.max")
    self._value = Builtin.fptoui_FPIEEE64_Int64(source._value)
  }
  @_transparent public init?(exactly source: Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -1.0 && source < 18446744073709551616.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE64_Int64(source._value)
  }
  @_transparent public init(_ source: Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to UInt because it is either infinite or NaN")
    _precondition(source > -1.0,
      "Float80 value cannot be converted to UInt because the result would be less than UInt.min")
    _precondition(source < 18446744073709551616.0,
      "Float80 value cannot be converted to UInt because the result would be greater than UInt.max")
    self._value = Builtin.fptoui_FPIEEE80_Int64(source._value)
  }
  @_transparent public init?(exactly source: Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -1.0 && source < 18446744073709551616.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptoui_FPIEEE80_Int64(source._value)
  }
  @_transparent public static func == (lhs: UInt, rhs: UInt) -> Bool {
    return Bool(Builtin.cmp_eq_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: UInt, rhs: UInt) -> Bool {
    return Bool(Builtin.cmp_ult_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout UInt, rhs: UInt) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.uadd_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt(result)
  }
  @_transparent public static func -= (lhs: inout UInt, rhs: UInt) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.usub_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt(result)
  }
  @_transparent public static func *= (lhs: inout UInt, rhs: UInt) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.umul_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt(result)
  }
  @_transparent public static func /= (lhs: inout UInt, rhs: UInt) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1215)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    let (result, overflow) =
      (Builtin.udiv_Int64(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = UInt(result)
  }
  @_transparent public func dividedReportingOverflow(by other: UInt) -> (partialValue: UInt, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.udiv_Int64(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: UInt) -> (partialValue: UInt, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as UInt)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.urem_Int64(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func addingReportingOverflow(_ other: UInt) -> (partialValue: UInt, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.uadd_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: UInt) -> (partialValue: UInt, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.usub_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: UInt) -> (partialValue: UInt, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.umul_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: UInt(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout UInt, rhs: UInt) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as UInt)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1294)

    let (newStorage, _) = (
      Builtin.urem_Int64(lhs._value, rhs._value),
      false._value)
    lhs = UInt(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int64) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout UInt, rhs: UInt) {
    lhs = UInt(Builtin.and_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout UInt, rhs: UInt) {
    lhs = UInt(Builtin.or_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout UInt, rhs: UInt) {
    lhs = UInt(Builtin.xor_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout UInt, rhs: UInt) {
    let rhs_ = rhs & 63
    lhs = UInt(
      Builtin.lshr_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout UInt, rhs: UInt) {
    let rhs_ = rhs & 63
    lhs = UInt(
      Builtin.shl_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Int {
    get { return 64 }
  }
  @_transparent public var leadingZeroBitCount: Int {
    get {
    return Int(
      UInt(
        Builtin.int_ctlz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Int {
    get {
    return Int(
      UInt(
        Builtin.int_cttz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Int {
    get {
    return Int(
      UInt(
        Builtin.int_ctpop_Int64(self._value)
      )._lowWord._value)
  }
  }
  @_fixed_layout public struct Words : RandomAccessCollection {
    public typealias Indices = Range<Int>
    public typealias SubSequence = Slice<UInt.Words>
    @usableFromInline
    internal var _value: UInt
    @inlinable public init(_ value: UInt) {
      self._value = value
    }
    @inlinable public var count: Int {
      get {
      return (64 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Int {
      get { return count }
    }
    @inlinable public var indices: Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Int) -> Int { return i + 1 }
    @_transparent public func index(before i: Int) -> Int { return i - 1 }
    @inlinable public subscript(position: Int) -> UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> UInt(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.UInt.Words>
  }
  @_transparent public var words: Words {
    get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: UInt {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1447)
    return UInt(
      Builtin.zextOrBitCast_Int64_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: UInt) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1456)
    self.init(
      Builtin.truncOrBitCast_Int64_Int64(bits._value))
  }
  public typealias Magnitude = UInt
  @inlinable public func multipliedFullWidth(by other: UInt) -> (high: UInt, low: UInt.Magnitude) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1525)
    let lhs_ = Builtin.zext_Int64_Int128(self._value)
    let rhs_ = Builtin.zext_Int64_Int128(other._value)

    let res = Builtin.mul_Int128(lhs_, rhs_)
    let low = UInt.Magnitude(Builtin.truncOrBitCast_Int128_Int64(res))
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let shifted = Builtin.ashr_Int128(res, shift)
    let high = UInt(Builtin.truncOrBitCast_Int128_Int64(shifted))
    return (high: high, low: low)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1535)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: UInt, low: UInt.Magnitude)) -> (quotient: UInt, remainder: UInt) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1561)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.zext_Int64_Int128(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let lhsHighShifted = Builtin.shl_Int128(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int64_Int128(dividend.low._value)
    let lhs_ = Builtin.or_Int128(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.zext_Int64_Int128(self._value)

    let quotient_ = Builtin.udiv_Int128(lhs_, rhs_)
    let remainder_ = Builtin.urem_Int128(lhs_, rhs_)

    let quotient = UInt(
      Builtin.truncOrBitCast_Int128_Int64(quotient_))
    let remainder = UInt(
      Builtin.truncOrBitCast_Int128_Int64(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1580)
  }
  @_transparent public var byteSwapped: UInt {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1588)
    return UInt(Builtin.int_bswap_Int64(_value))
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1590)
  }
  }
  public var _value: Builtin.Int64
  @_transparent public init(_ _v: Builtin.Word) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1603)
    self._value = Builtin.zextOrBitCast_Word_Int64(_v)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1605)
  }
  @_transparent public var _builtinWordValue: Builtin.Word {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1613)
    return Builtin.truncOrBitCast_Int64_Word(_value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1615)
  }
  }
  @inlinable @inline(__always) public func signum() -> UInt {
    let isPositive = UInt(Builtin.zext_Int1_Int64(
      (self > (0 as UInt))._value))
    return isPositive | (self &>> 63)
  }
  public typealias Stride = Swift.Int
}
extension UInt : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher._combine(UInt(_value))
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1647)
    return Hasher._hash(seed: seed, UInt64(_value))
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1656)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension UInt : _HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> AnyHashable?
}
extension UInt {
  @_transparent public static func & (lhs: UInt, rhs: UInt) -> UInt {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: UInt, rhs: UInt) -> UInt {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: UInt, rhs: UInt) -> UInt {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: UInt, rhs: UInt) -> UInt {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: UInt, rhs: UInt) -> UInt {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func / (lhs: UInt, rhs: UInt) -> UInt {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: UInt, rhs: UInt) -> UInt {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func + (lhs: UInt, rhs: UInt) -> UInt {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: UInt, rhs: UInt) -> UInt {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: UInt, rhs: UInt) -> UInt {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: UInt, rhs: UInt) -> Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: UInt, rhs: UInt) -> Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: UInt, rhs: UInt) -> Bool {
    return rhs < lhs
  }
}
@_fixed_layout public struct Int : FixedWidthInteger, SignedInteger, _ExpressibleByBuiltinIntegerLiteral {
  public typealias IntegerLiteralType = Int
  @_transparent public init(_builtinIntegerLiteral x: Builtin.IntLiteral) {
    _value = Builtin.s_to_s_checked_trunc_IntLiteral_Int64(x).0
  }
  @_transparent public init(bitPattern x: UInt) {
    _value = x._value
  }
  @_transparent public init(_ source: Float) {
    _precondition(source.isFinite,
      "Float value cannot be converted to Int because it is either infinite or NaN")
    _precondition(source > -9223373136366403584.0,
      "Float value cannot be converted to Int because the result would be less than Int.min")
    _precondition(source < 9223372036854775808.0,
      "Float value cannot be converted to Int because the result would be greater than Int.max")
    self._value = Builtin.fptosi_FPIEEE32_Int64(source._value)
  }
  @_transparent public init?(exactly source: Float) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -9223373136366403584.0 && source < 9223372036854775808.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE32_Int64(source._value)
  }
  @_transparent public init(_ source: Double) {
    _precondition(source.isFinite,
      "Double value cannot be converted to Int because it is either infinite or NaN")
    _precondition(source > -9223372036854777856.0,
      "Double value cannot be converted to Int because the result would be less than Int.min")
    _precondition(source < 9223372036854775808.0,
      "Double value cannot be converted to Int because the result would be greater than Int.max")
    self._value = Builtin.fptosi_FPIEEE64_Int64(source._value)
  }
  @_transparent public init?(exactly source: Double) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -9223372036854777856.0 && source < 9223372036854775808.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE64_Int64(source._value)
  }
  @_transparent public init(_ source: Float80) {
    _precondition(source.isFinite,
      "Float80 value cannot be converted to Int because it is either infinite or NaN")
    _precondition(source > -9223372036854775809.0,
      "Float80 value cannot be converted to Int because the result would be less than Int.min")
    _precondition(source < 9223372036854775808.0,
      "Float80 value cannot be converted to Int because the result would be greater than Int.max")
    self._value = Builtin.fptosi_FPIEEE80_Int64(source._value)
  }
  @_transparent public init?(exactly source: Float80) {
    // The value passed as `source` must not be infinite, NaN, or exceed the
    // bounds of the integer type; the result of `fptosi` or `fptoui` is
    // undefined if it overflows.
    guard source > -9223372036854775809.0 && source < 9223372036854775808.0 else {
      return nil
    }
    guard source == source.rounded(.towardZero) else {
      return nil
    }
    self._value = Builtin.fptosi_FPIEEE80_Int64(source._value)
  }
  @_transparent public static func == (lhs: Int, rhs: Int) -> Bool {
    return Bool(Builtin.cmp_eq_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func < (lhs: Int, rhs: Int) -> Bool {
    return Bool(Builtin.cmp_slt_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func += (lhs: inout Int, rhs: Int) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.sadd_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int(result)
  }
  @_transparent public static func -= (lhs: inout Int, rhs: Int) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.ssub_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int(result)
  }
  @_transparent public static func *= (lhs: inout Int, rhs: Int) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1233)
    let (result, overflow) =
      Builtin.smul_with_overflow_Int64(
        lhs._value, rhs._value, true._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int(result)
  }
  @_transparent public static func /= (lhs: inout Int, rhs: Int) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1215)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int)) {
      _preconditionFailure(
        "Division by zero")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1222)
    if _slowPath(
      lhs == Int.min && rhs == (-1 as Int)
    ) {
      _preconditionFailure(
        "Division results in an overflow")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1229)
    let (result, overflow) =
      (Builtin.sdiv_Int64(lhs._value, rhs._value),
      false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1237)
    Builtin.condfail(overflow)
    lhs = Int(result)
  }
  @_transparent public func dividedReportingOverflow(by other: Int) -> (partialValue: Int, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1256)
    if _slowPath(self == Int.min && other == (-1 as Int)) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1258)
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.sdiv_Int64(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func remainderReportingOverflow(dividingBy other: Int) -> (partialValue: Int, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1250)
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(other == (0 as Int)) {
      return (partialValue: self, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1256)
    if _slowPath(self == Int.min && other == (-1 as Int)) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1258)
      return (partialValue: 0, overflow: true)
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1261)

    let (newStorage, overflow) = (
      Builtin.srem_Int64(self._value, other._value),
      false._value)

// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func addingReportingOverflow(_ other: Int) -> (partialValue: Int, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.sadd_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func subtractingReportingOverflow(_ other: Int) -> (partialValue: Int, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.ssub_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public func multipliedReportingOverflow(by other: Int) -> (partialValue: Int, overflow: Bool) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1267)

    let (newStorage, overflow) =
      Builtin.smul_with_overflow_Int64(
        self._value, other._value, false._value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1272)

    return (
      partialValue: Int(newStorage),
      overflow: Bool(overflow))
  }
  @_transparent public static func %= (lhs: inout Int, rhs: Int) {
    // No LLVM primitives for checking overflow of division operations, so we
    // check manually.
    if _slowPath(rhs == (0 as Int)) {
      _preconditionFailure(
        "Division by zero in remainder operation")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1289)
    if _slowPath(lhs == Int.min && rhs == (-1 as Int)) {
      _preconditionFailure(
        "Division results in an overflow in remainder operation")
    }
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1294)

    let (newStorage, _) = (
      Builtin.srem_Int64(lhs._value, rhs._value),
      false._value)
    lhs = Int(newStorage)
  }
  @_transparent public init(_ _value: Builtin.Int64) {
    self._value = _value
  }
  @_transparent public static func &= (lhs: inout Int, rhs: Int) {
    lhs = Int(Builtin.and_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func |= (lhs: inout Int, rhs: Int) {
    lhs = Int(Builtin.or_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func ^= (lhs: inout Int, rhs: Int) {
    lhs = Int(Builtin.xor_Int64(lhs._value, rhs._value))
  }
  @_transparent public static func &>>= (lhs: inout Int, rhs: Int) {
    let rhs_ = rhs & 63
    lhs = Int(
      Builtin.ashr_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static func &<<= (lhs: inout Int, rhs: Int) {
    let rhs_ = rhs & 63
    lhs = Int(
      Builtin.shl_Int64(lhs._value, rhs_._value))
  }
  @_transparent public static var bitWidth: Int {
    get { return 64 }
  }
  @_transparent public var leadingZeroBitCount: Int {
    get {
    return Int(
      Int(
        Builtin.int_ctlz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var trailingZeroBitCount: Int {
    get {
    return Int(
      Int(
        Builtin.int_cttz_Int64(self._value, false._value)
      )._lowWord._value)
  }
  }
  @_transparent public var nonzeroBitCount: Int {
    get {
    return Int(
      Int(
        Builtin.int_ctpop_Int64(self._value)
      )._lowWord._value)
  }
  }
  @_fixed_layout public struct Words : RandomAccessCollection {
    public typealias Indices = Range<Int>
    public typealias SubSequence = Slice<Int.Words>
    @usableFromInline
    internal var _value: Int
    @inlinable public init(_ value: Int) {
      self._value = value
    }
    @inlinable public var count: Int {
      get {
      return (64 + 64 - 1) / 64
    }
    }
    @inlinable public var startIndex: Int {
      get { return 0 }
    }
    @inlinable public var endIndex: Int {
      get { return count }
    }
    @inlinable public var indices: Indices {
      get { return startIndex ..< endIndex }
    }
    @_transparent public func index(after i: Int) -> Int { return i + 1 }
    @_transparent public func index(before i: Int) -> Int { return i - 1 }
    @inlinable public subscript(position: Int) -> UInt {
      get {
        _precondition(position >= 0, "Negative word index")
        _precondition(position < endIndex, "Word index out of range")
        let shift = UInt(position._value) &* 64
        _internalInvariant(shift < UInt(_value.bitWidth._value))
        return (_value &>> Int(_truncatingBits: shift))._lowWord
      }
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<Swift.Int.Words>
  }
  @_transparent public var words: Words {
    get {
    return Words(self)
  }
  }
  @_transparent public var _lowWord: UInt {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1447)
    return UInt(
      Builtin.sextOrBitCast_Int64_Int64(_value)
    )
  }
  }
  @_transparent public init(_truncatingBits bits: UInt) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1456)
    self.init(
      Builtin.truncOrBitCast_Int64_Int64(bits._value))
  }
  public typealias Magnitude = UInt
  @_transparent public var magnitude: UInt {
    get {
    let base = UInt(_value)
    return self < (0 as Int) ? ~base &+ 1 : base
  }
  }
  @inlinable public func multipliedFullWidth(by other: Int) -> (high: Int, low: Int.Magnitude) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1525)
    let lhs_ = Builtin.sext_Int64_Int128(self._value)
    let rhs_ = Builtin.sext_Int64_Int128(other._value)

    let res = Builtin.mul_Int128(lhs_, rhs_)
    let low = Int.Magnitude(Builtin.truncOrBitCast_Int128_Int64(res))
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let shifted = Builtin.ashr_Int128(res, shift)
    let high = Int(Builtin.truncOrBitCast_Int128_Int64(shifted))
    return (high: high, low: low)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1535)
  }
  @inlinable public func dividingFullWidth(_ dividend: (high: Int, low: Int.Magnitude)) -> (quotient: Int, remainder: Int) {
    // FIXME(integers): tests
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1561)
    // FIXME(integers): handle division by zero and overflows
    _precondition(self != 0, "Division by zero")
    let lhsHigh = Builtin.sext_Int64_Int128(dividend.high._value)
    let shift = Builtin.zextOrBitCast_Int8_Int128(UInt8(64)._value)
    let lhsHighShifted = Builtin.shl_Int128(lhsHigh, shift)
    let lhsLow = Builtin.zext_Int64_Int128(dividend.low._value)
    let lhs_ = Builtin.or_Int128(lhsHighShifted, lhsLow)
    let rhs_ = Builtin.sext_Int64_Int128(self._value)

    let quotient_ = Builtin.sdiv_Int128(lhs_, rhs_)
    let remainder_ = Builtin.srem_Int128(lhs_, rhs_)

    let quotient = Int(
      Builtin.truncOrBitCast_Int128_Int64(quotient_))
    let remainder = Int(
      Builtin.truncOrBitCast_Int128_Int64(remainder_))

    return (quotient: quotient, remainder: remainder)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1580)
  }
  @_transparent public var byteSwapped: Int {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1588)
    return Int(Builtin.int_bswap_Int64(_value))
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1590)
  }
  }
  public var _value: Builtin.Int64
  @_transparent public init(_ _v: Builtin.Word) {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1603)
    self._value = Builtin.sextOrBitCast_Word_Int64(_v)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1605)
  }
  @_transparent public var _builtinWordValue: Builtin.Word {
    get {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1613)
    return Builtin.truncOrBitCast_Int64_Word(_value)
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1615)
  }
  }
  @inlinable @inline(__always) public func signum() -> Int {
    let isPositive = Int(Builtin.zext_Int1_Int64(
      (self > (0 as Int))._value))
    return isPositive | (self &>> 63)
  }
  public typealias Stride = Swift.Int
}
extension Int : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher._combine(UInt(_value))
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1647)
    return Hasher._hash(seed: seed, UInt64(_value))
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/IntegerTypes.swift.gyb", line: 1656)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Int : _HasCustomAnyHashableRepresentation {
  public func _toCustomAnyHashable() -> AnyHashable?
}
extension Int {
  @_transparent public static func & (lhs: Int, rhs: Int) -> Int {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
  @_transparent public static func | (lhs: Int, rhs: Int) -> Int {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
  @_transparent public static func ^ (lhs: Int, rhs: Int) -> Int {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
  @_transparent public static func &>> (lhs: Int, rhs: Int) -> Int {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
  @_transparent public static func &<< (lhs: Int, rhs: Int) -> Int {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
  @_transparent public static func / (lhs: Int, rhs: Int) -> Int {
    var lhs = lhs
    lhs /= rhs
    return lhs
  }
  @_transparent public static func % (lhs: Int, rhs: Int) -> Int {
    var lhs = lhs
    lhs %= rhs
    return lhs
  }
  @_transparent public static func + (lhs: Int, rhs: Int) -> Int {
    var lhs = lhs
    lhs += rhs
    return lhs
  }
  @_transparent public static func - (lhs: Int, rhs: Int) -> Int {
    var lhs = lhs
    lhs -= rhs
    return lhs
  }
  @_transparent public static func * (lhs: Int, rhs: Int) -> Int {
    var lhs = lhs
    lhs *= rhs
    return lhs
  }
  @_transparent public static func <= (lhs: Int, rhs: Int) -> Bool {
    return !(rhs < lhs)
  }
  @_transparent public static func >= (lhs: Int, rhs: Int) -> Bool {
    return !(lhs < rhs)
  }
  @_transparent public static func > (lhs: Int, rhs: Int) -> Bool {
    return rhs < lhs
  }
}
@_transparent public func _assumeNonNegative(_ x: Int) -> Int {
  _internalInvariant(x >= (0 as Int))
  return Int(Builtin.assumeNonNegative_Int64(x._value))
}
extension Int {
  @_transparent public func distance(to other: Int) -> Int {
    return other - self
  }
  @_transparent public func advanced(by n: Int) -> Int {
    return self + n
  }
}
@_transparent @inlinable internal func _unsafePlus(_ lhs: Int, _ rhs: Int) -> Int {
  return lhs &+ rhs
}
@_transparent @inlinable internal func _unsafeMinus(_ lhs: Int, _ rhs: Int) -> Int {
  return lhs &- rhs
}
@_fixed_layout public struct JoinedSequence<Base> where Base : Swift.Sequence, Base.Element : Swift.Sequence {
  public typealias Element = Base.Element.Element
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal var _separator: ContiguousArray<Element>
  @inlinable public init<Separator>(base: Base, separator: Separator) where Separator : Swift.Sequence, Separator.Element == Base.Element.Element {
    self._base = base
    self._separator = ContiguousArray(separator)
  }
}
extension JoinedSequence {
  @_fixed_layout public struct Iterator {
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal var _inner: Base.Element.Iterator?
    @usableFromInline
    internal var _separatorData: ContiguousArray<Element>
    @usableFromInline
    internal var _separator: ContiguousArray<Element>.Iterator?
    @usableFromInline
    @_frozen internal enum _JoinIteratorState {
      case start
      case generatingElements
      case generatingSeparator
      case end
      @usableFromInline
      internal static func == (a: Swift.JoinedSequence<Base>.Iterator._JoinIteratorState, b: Swift.JoinedSequence<Base>.Iterator._JoinIteratorState) -> Swift.Bool
      @usableFromInline
      internal var hashValue: Swift.Int {
        @usableFromInline
        get
      }
      @usableFromInline
      internal func hash(into hasher: inout Swift.Hasher)
    }
    @usableFromInline
    internal var _state: _JoinIteratorState = .start
    @inlinable public init<Separator>(base: Base.Iterator, separator: Separator) where Separator : Swift.Sequence, Separator.Element == Base.Element.Element {
      self._base = base
      self._separatorData = ContiguousArray(separator)
    }
  }
}
extension JoinedSequence.Iterator : IteratorProtocol {
  public typealias Element = Base.Element.Element
  @inlinable mutating public func next() -> Element? {
    while true {
      switch _state {
      case .start:
        if let nextSubSequence = _base.next() {
          _inner = nextSubSequence.makeIterator()
          _state = .generatingElements
        } else {
          _state = .end
          return nil
        }

      case .generatingElements:
        let result = _inner!.next()
        if _fastPath(result != nil) {
          return result
        }
        _inner = _base.next()?.makeIterator()
        if _inner == nil {
          _state = .end
          return nil
        }
        if !_separatorData.isEmpty {
          _separator = _separatorData.makeIterator()
          _state = .generatingSeparator
        }

      case .generatingSeparator:
        let result = _separator!.next()
        if _fastPath(result != nil) {
          return result
        }
        _state = .generatingElements

      case .end:
        return nil
      }
    }
  }
}
extension JoinedSequence : Sequence {
  @inlinable __consuming public func makeIterator() -> Iterator {
    return Iterator(base: _base.makeIterator(), separator: _separator)
  }
  @inlinable __consuming public func _copyToContiguousArray() -> ContiguousArray<Element> {
    var result = ContiguousArray<Element>()
    let separatorSize = _separator.count

    if separatorSize == 0 {
      for x in _base {
        result.append(contentsOf: x)
      }
      return result
    }

    var iter = _base.makeIterator()
    if let first = iter.next() {
      result.append(contentsOf: first)
      while let next = iter.next() {
        result.append(contentsOf: _separator)
        result.append(contentsOf: next)
      }
    }

    return result
  }
}
extension Sequence where Self.Element : Swift.Sequence {
  @inlinable __consuming public func joined<Separator>(separator: Separator) -> JoinedSequence<Self> where Separator : Swift.Sequence, Separator.Element == Self.Element.Element {
    return JoinedSequence(base: self, separator: separator)
  }
}
@_objcRuntimeName(_TtCs11_AnyKeyPath) public class AnyKeyPath : Hashable, _AppendKeyPath {
  @inlinable public static var rootType: Any.Type {
    get {
    return _rootAndValueType.root
  }
  }
  @inlinable public static var valueType: Any.Type {
    get {
    return _rootAndValueType.value
  }
  }
  final public var hashValue: Int {
    get
  }
  @_effects(releasenone) final public func hash(into hasher: inout Hasher)
  public static func == (a: AnyKeyPath, b: AnyKeyPath) -> Bool
  public var _kvcKeyPathString: String? {
    get
  }
  @usableFromInline
  internal class var _rootAndValueType: (root: Any.Type, value: Any.Type) {
    get
  }
  @usableFromInline
  internal var _storedInlineOffset: Int? {
    get
  }
  @objc deinit
}
public class PartialKeyPath<Root> : AnyKeyPath {
  @objc deinit
}
public class KeyPath<Root, Value> : PartialKeyPath<Root> {
  @usableFromInline
  final override internal class var _rootAndValueType: (root: Any.Type, value: Any.Type) {
    get
  }
  @usableFromInline
  final internal func _projectReadOnly(from root: Root) -> Value
  @objc deinit
}
public class WritableKeyPath<Root, Value> : KeyPath<Root, Value> {
  @usableFromInline
  internal func _projectMutableAddress(from base: UnsafePointer<Root>) -> (pointer: UnsafeMutablePointer<Value>, owner: AnyObject?)
  @objc deinit
}
public class ReferenceWritableKeyPath<Root, Value> : WritableKeyPath<Root, Value> {
  @usableFromInline
  final internal func _projectMutableAddress(from origBase: Root) -> (pointer: UnsafeMutablePointer<Value>, owner: AnyObject?)
  @objc deinit
}
@_silgen_name("swift_getAtPartialKeyPath")
public func _getAtPartialKeyPath<Root>(root: Root, keyPath: PartialKeyPath<Root>) -> Any
@_silgen_name("swift_getAtAnyKeyPath")
public func _getAtAnyKeyPath<RootValue>(root: RootValue, keyPath: AnyKeyPath) -> Any?
@_silgen_name("swift_getAtKeyPath")
public func _getAtKeyPath<Root, Value>(root: Root, keyPath: KeyPath<Root, Value>) -> Value
@_silgen_name("_swift_modifyAtWritableKeyPath_impl")
public func _modifyAtWritableKeyPath_impl<Root, Value>(root: inout Root, keyPath: WritableKeyPath<Root, Value>) -> (UnsafeMutablePointer<Value>, AnyObject?)
@_silgen_name("_swift_modifyAtReferenceWritableKeyPath_impl")
public func _modifyAtReferenceWritableKeyPath_impl<Root, Value>(root: Root, keyPath: ReferenceWritableKeyPath<Root, Value>) -> (UnsafeMutablePointer<Value>, AnyObject?)
@_silgen_name("swift_setAtWritableKeyPath")
public func _setAtWritableKeyPath<Root, Value>(root: inout Root, keyPath: WritableKeyPath<Root, Value>, value: __owned Value)
@_silgen_name("swift_setAtReferenceWritableKeyPath")
public func _setAtReferenceWritableKeyPath<Root, Value>(root: Root, keyPath: ReferenceWritableKeyPath<Root, Value>, value: __owned Value)
@_show_in_interface public protocol _AppendKeyPath {
}
extension _AppendKeyPath where Self == Swift.AnyKeyPath {
  @inlinable public func appending(path: AnyKeyPath) -> AnyKeyPath? {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}
extension _AppendKeyPath {
  @inlinable public func appending<Root>(path: AnyKeyPath) -> PartialKeyPath<Root>? where Self == Swift.PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
  @inlinable public func appending<Root, AppendedRoot, AppendedValue>(path: KeyPath<AppendedRoot, AppendedValue>) -> KeyPath<Root, AppendedValue>? where Self == Swift.PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
  @inlinable public func appending<Root, AppendedRoot, AppendedValue>(path: ReferenceWritableKeyPath<AppendedRoot, AppendedValue>) -> ReferenceWritableKeyPath<Root, AppendedValue>? where Self == Swift.PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}
extension _AppendKeyPath {
  @inlinable public func appending<Root, Value, AppendedValue>(path: KeyPath<Value, AppendedValue>) -> KeyPath<Root, AppendedValue> where Self : Swift.KeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
  @inlinable public func appending<Root, Value, AppendedValue>(path: ReferenceWritableKeyPath<Value, AppendedValue>) -> ReferenceWritableKeyPath<Root, AppendedValue> where Self == Swift.KeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}
extension _AppendKeyPath {
  @inlinable public func appending<Root, Value, AppendedValue>(path: WritableKeyPath<Value, AppendedValue>) -> WritableKeyPath<Root, AppendedValue> where Self == Swift.WritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
  @inlinable public func appending<Root, Value, AppendedValue>(path: ReferenceWritableKeyPath<Value, AppendedValue>) -> ReferenceWritableKeyPath<Root, AppendedValue> where Self == Swift.WritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}
extension _AppendKeyPath {
  @inlinable public func appending<Root, Value, AppendedValue>(path: WritableKeyPath<Value, AppendedValue>) -> ReferenceWritableKeyPath<Root, AppendedValue> where Self == Swift.ReferenceWritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}
@usableFromInline
internal func _tryToAppendKeyPaths<Result>(root: AnyKeyPath, leaf: AnyKeyPath) -> Result? where Result : Swift.AnyKeyPath
@usableFromInline
internal func _appendingKeyPaths<Root, Value, AppendedValue, Result>(root: KeyPath<Root, Value>, leaf: KeyPath<Value, AppendedValue>) -> Result where Result : Swift.KeyPath<Root, AppendedValue>
@_cdecl("swift_getKeyPathImpl")
public func _swift_getKeyPath(pattern: UnsafeMutableRawPointer, arguments: UnsafeRawPointer) -> UnsafeRawPointer
@_fixed_layout public struct KeyValuePairs<Key, Value> : ExpressibleByDictionaryLiteral {
  @usableFromInline
  internal let _elements: [(Key, Value)]
  @inlinable public init(dictionaryLiteral elements: (Key, Value)...) {
    self._elements = elements
  }
}
extension KeyValuePairs : RandomAccessCollection {
  public typealias Element = (key: Key, value: Value)
  public typealias Index = Int
  public typealias Indices = Range<Int>
  public typealias SubSequence = Slice<KeyValuePairs>
  @inlinable public var startIndex: Index {
    get { return 0 }
  }
  @inlinable public var endIndex: Index {
    get { return _elements.endIndex }
  }
  @inlinable public subscript(position: Index) -> Element {
    get {
    return _elements[position]
  }
  }
  public typealias Iterator = Swift.IndexingIterator<Swift.KeyValuePairs<Key, Value>>
}
extension KeyValuePairs : CustomStringConvertible {
  public var description: String {
    get
  }
}
extension KeyValuePairs : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
public protocol LazyCollectionProtocol : Swift.Collection, Swift.LazySequenceProtocol where Self.Elements : Swift.Collection {
}
extension LazyCollectionProtocol {
  @inlinable public var lazy: LazyCollection<Elements> {
    get {		
     return elements.lazy		
   }
  }
}
extension LazyCollectionProtocol where Self.Elements : Swift.LazyCollectionProtocol {
  @inlinable public var lazy: Elements {
    get {		
     return elements		
   }
  }
}
public typealias LazyCollection<T> = LazySequence<T> where T : Swift.Collection
extension LazySequence : Collection where Base : Swift.Collection {
  public typealias Index = Base.Index
  public typealias Indices = Base.Indices
  public typealias SubSequence = Slice<LazySequence>
  @inlinable public var startIndex: Index {
    get { return _base.startIndex }
  }
  @inlinable public var endIndex: Index {
    get { return _base.endIndex }
  }
  @inlinable public var indices: Indices {
    get { return _base.indices }
  }
  @inlinable public func index(after i: Index) -> Index {
    return _base.index(after: i)
  }
  @inlinable public subscript(position: Index) -> Element {
    get {
    return _base[position]
  }
  }
  @inlinable public var isEmpty: Bool {
    get {
    return _base.isEmpty
  }
  }
  @inlinable public var count: Int {
    get {
    return _base.count
  }
  }
  @inlinable public func _customIndexOfEquatableElement(_ element: Element) -> Index?? {
    return _base._customIndexOfEquatableElement(element)
  }
  @inlinable public func _customLastIndexOfEquatableElement(_ element: Element) -> Index?? {
    return _base._customLastIndexOfEquatableElement(element)
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _base.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index? {
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    return _base.distance(from:start, to: end)
  }
}
extension LazySequence : LazyCollectionProtocol where Base : Swift.Collection {
}
extension LazySequence : BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Index) -> Index {
    return _base.index(before: i)
  }
}
extension LazySequence : RandomAccessCollection where Base : Swift.RandomAccessCollection {
}
extension Slice : LazySequenceProtocol where Base : Swift.LazySequenceProtocol {
  public typealias Elements = Swift.Slice<Base>
}
extension ReversedCollection : LazySequenceProtocol where Base : Swift.LazySequenceProtocol {
  public typealias Elements = Swift.ReversedCollection<Base>
}
public protocol LazySequenceProtocol : Swift.Sequence {
  associatedtype Elements : Swift.Sequence = Self where Self.Element == Self.Elements.Element
  var elements: Elements { get }
}
extension LazySequenceProtocol where Self == Self.Elements {
  @inlinable public var elements: Self {
    get { return self }
  }
}
extension LazySequenceProtocol {
  @inlinable public var lazy: LazySequence<Elements> {
    get {
    return elements.lazy
  }
  }
}
extension LazySequenceProtocol where Self.Elements : Swift.LazySequenceProtocol {
  @inlinable public var lazy: Elements {
    get {
    return elements
  }
  }
}
@_fixed_layout public struct LazySequence<Base> where Base : Swift.Sequence {
  @usableFromInline
  internal var _base: Base
  @inlinable internal init(_base: Base) {
    self._base = _base
  }
}
extension LazySequence : Sequence {
  public typealias Element = Base.Element
  public typealias Iterator = Base.Iterator
  @inlinable __consuming public func makeIterator() -> Iterator {
    return _base.makeIterator()
  }
  @inlinable public var underestimatedCount: Int {
    get {
    return _base.underestimatedCount
  }
  }
  @discardableResult
  @inlinable __consuming public func _copyContents(initializing buf: UnsafeMutableBufferPointer<Element>) -> (Iterator, UnsafeMutableBufferPointer<Element>.Index) {
    return _base._copyContents(initializing: buf)
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Bool? { 
    return _base._customContainsEquatableElement(element)
  }
  @inlinable __consuming public func _copyToContiguousArray() -> ContiguousArray<Element> {
    return _base._copyToContiguousArray()
  }
}
extension LazySequence : LazySequenceProtocol {
  public typealias Elements = Base
  @inlinable public var elements: Elements {
    get { return _base }
  }
}
extension Sequence {
  @inlinable public var lazy: LazySequence<Self> {
    get {
    return LazySequence(_base: self)
  }
  }
}
extension Unicode.UTF16 {
  @available(*, unavailable, renamed: "Unicode.UTF16.isASCII")
  @inlinable public static func _isASCII(_ x: CodeUnit) -> Bool {
    return Unicode.UTF16.isASCII(x)
  }
}
@available(*, unavailable, renamed: "Unicode.UTF8.isASCII")
@inlinable internal func _isASCII(_ x: UInt8) -> Bool {
  return Unicode.UTF8.isASCII(x)
}
@available(*, unavailable, renamed: "Unicode.UTF8.isContinuation")
@inlinable internal func _isContinuation(_ x: UInt8) -> Bool {
  return UTF8.isContinuation(x)
}
extension Substring {
  @available(*, unavailable, renamed: "Substring.base")
  @inlinable internal var _wholeString: String {
    get { return base }
  }
}
extension String {
  @available(*, unavailable, renamed: "String.withUTF8")
  @inlinable internal func _withUTF8<R>(_ body: (UnsafeBufferPointer<UInt8>) throws -> R) rethrows -> R {
    var copy = self
    return try copy.withUTF8(body)
  }
}
extension Substring {
  @available(*, unavailable, renamed: "Substring.withUTF8")
  @inlinable internal func _withUTF8<R>(_ body: (UnsafeBufferPointer<UInt8>) throws -> R) rethrows -> R {
    var copy = self
    return try copy.withUTF8(body)
  }
}
@inlinable public func withExtendedLifetime<T, Result>(_ x: T, _ body: () throws -> Result) rethrows -> Result {
  defer { _fixLifetime(x) }
  return try body()
}
@inlinable public func withExtendedLifetime<T, Result>(_ x: T, _ body: (T) throws -> Result) rethrows -> Result {
  defer { _fixLifetime(x) }
  return try body(x)
}
@_transparent public func _fixLifetime<T>(_ x: T) {
  Builtin.fixLifetime(x)
}
@inlinable public func withUnsafeMutablePointer<T, Result>(to value: inout T, _ body: (UnsafeMutablePointer<T>) throws -> Result) rethrows -> Result {
  return try body(UnsafeMutablePointer<T>(Builtin.addressof(&value)))
}
@inlinable public func withUnsafePointer<T, Result>(to value: T, _ body: (UnsafePointer<T>) throws -> Result) rethrows -> Result {
  return try body(UnsafePointer<T>(Builtin.addressOfBorrow(value)))
}
@inlinable public func withUnsafePointer<T, Result>(to value: inout T, _ body: (UnsafePointer<T>) throws -> Result) rethrows -> Result {
  return try body(UnsafePointer<T>(Builtin.addressof(&value)))
}
extension String {
  @inlinable public func withCString<Result>(_ body: (UnsafePointer<Int8>) throws -> Result) rethrows -> Result {
    return try _guts.withCString(body)
  }
}
@usableFromInline
internal typealias _HeapObject = SwiftShims.HeapObject
@usableFromInline
@_silgen_name("swift_bufferAllocate")
internal func _swift_bufferAllocate(bufferType type: AnyClass, size: Int, alignmentMask: Int) -> AnyObject
@_fixed_layout open class ManagedBuffer<Header, Element> {
  final public var header: Header
  @objc deinit
}
extension ManagedBuffer {
  @inlinable final public class func create(minimumCapacity: Int, makingHeaderWith factory: (ManagedBuffer<Header, Element>) throws -> Header) rethrows -> ManagedBuffer<Header, Element> {

    let p = Builtin.allocWithTailElems_1(
         self,
         minimumCapacity._builtinWordValue, Element.self)

    let initHeaderVal = try factory(p)
    p.headerAddress.initialize(to: initHeaderVal)
    // The _fixLifetime is not really needed, because p is used afterwards.
    // But let's be conservative and fix the lifetime after we use the
    // headerAddress.
    _fixLifetime(p)
    return p
  }
  @inlinable final public var capacity: Int {
    get {
    let storageAddr = UnsafeMutableRawPointer(Builtin.bridgeToRawPointer(self))
    let endAddr = storageAddr + _swift_stdlib_malloc_size(storageAddr)
    let realCapacity = endAddr.assumingMemoryBound(to: Element.self) -
      firstElementAddress
    return realCapacity
  }
  }
  @inlinable final internal var firstElementAddress: UnsafeMutablePointer<Element> {
    get {
    return UnsafeMutablePointer(
      Builtin.projectTailElems(self, Element.self))
  }
  }
  @inlinable final internal var headerAddress: UnsafeMutablePointer<Header> {
    get {
    return UnsafeMutablePointer<Header>(Builtin.addressof(&header))
  }
  }
  @inlinable final public func withUnsafeMutablePointerToHeader<R>(_ body: (UnsafeMutablePointer<Header>) throws -> R) rethrows -> R {
    return try withUnsafeMutablePointers { (v, _) in return try body(v) }
  }
  @inlinable final public func withUnsafeMutablePointerToElements<R>(_ body: (UnsafeMutablePointer<Element>) throws -> R) rethrows -> R {
    return try withUnsafeMutablePointers { return try body($1) }
  }
  @inlinable final public func withUnsafeMutablePointers<R>(_ body: (UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(headerAddress, firstElementAddress)
  }
}
@_fixed_layout public struct ManagedBufferPointer<Header, Element> {
  @usableFromInline
  internal var _nativeBuffer: Builtin.NativeObject
  @inlinable public init(bufferClass: AnyClass, minimumCapacity: Int, makingHeaderWith factory: (_ buffer: AnyObject, _ capacity: (AnyObject) -> Int) throws -> Header) rethrows {
    self = ManagedBufferPointer(
      bufferClass: bufferClass, minimumCapacity: minimumCapacity)

    // initialize the header field
    try withUnsafeMutablePointerToHeader {
      $0.initialize(to: 
        try factory(
          self.buffer,
          {
            ManagedBufferPointer(unsafeBufferObject: $0).capacity
          }))
    }
    // FIXME: workaround for <rdar://problem/18619176>.  If we don't
    // access header somewhere, its addressor gets linked away
    _ = header
  }
  @inlinable public init(unsafeBufferObject buffer: AnyObject) {
    ManagedBufferPointer._checkValidBufferClass(type(of: buffer))

    self._nativeBuffer = Builtin.unsafeCastToNativeObject(buffer)
  }
  @inlinable internal init(_uncheckedUnsafeBufferObject buffer: AnyObject) {
    ManagedBufferPointer._internalInvariantValidBufferClass(type(of: buffer))
    self._nativeBuffer = Builtin.unsafeCastToNativeObject(buffer)
  }
  @inlinable internal init(bufferClass: AnyClass, minimumCapacity: Int) {
    ManagedBufferPointer._checkValidBufferClass(bufferClass, creating: true)
    _precondition(
      minimumCapacity >= 0,
      "ManagedBufferPointer must have non-negative capacity")

    self.init(
      _uncheckedBufferClass: bufferClass, minimumCapacity: minimumCapacity)
  }
  @inlinable internal init(_uncheckedBufferClass: AnyClass, minimumCapacity: Int) {
    ManagedBufferPointer._internalInvariantValidBufferClass(_uncheckedBufferClass, creating: true)
    _internalInvariant(
      minimumCapacity >= 0,
      "ManagedBufferPointer must have non-negative capacity")

    let totalSize = ManagedBufferPointer._elementOffset
      +  minimumCapacity * MemoryLayout<Element>.stride

    let newBuffer: AnyObject = _swift_bufferAllocate(
      bufferType: _uncheckedBufferClass,
      size: totalSize,
      alignmentMask: ManagedBufferPointer._alignmentMask)

    self._nativeBuffer = Builtin.unsafeCastToNativeObject(newBuffer)
  }
  @inlinable internal init(_ buffer: ManagedBuffer<Header, Element>) {
    _nativeBuffer = Builtin.unsafeCastToNativeObject(buffer)
  }
}
extension ManagedBufferPointer {
  @inlinable public var header: Header {
    _read {
      yield _headerPointer.pointee
    }
    _modify {
      yield &_headerPointer.pointee
    }
  }
  @inlinable public var buffer: AnyObject {
    get {
    return Builtin.castFromNativeObject(_nativeBuffer)
  }
  }
  @inlinable public var capacity: Int {
    get {
    return (
      _capacityInBytes &- ManagedBufferPointer._elementOffset
    ) / MemoryLayout<Element>.stride
  }
  }
  @inlinable public func withUnsafeMutablePointerToHeader<R>(_ body: (UnsafeMutablePointer<Header>) throws -> R) rethrows -> R {
    return try withUnsafeMutablePointers { (v, _) in return try body(v) }
  }
  @inlinable public func withUnsafeMutablePointerToElements<R>(_ body: (UnsafeMutablePointer<Element>) throws -> R) rethrows -> R {
    return try withUnsafeMutablePointers { return try body($1) }
  }
  @inlinable public func withUnsafeMutablePointers<R>(_ body: (UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R) rethrows -> R {
    defer { _fixLifetime(_nativeBuffer) }
    return try body(_headerPointer, _elementPointer)
  }
  @inlinable mutating public func isUniqueReference() -> Bool {
    return _isUnique(&_nativeBuffer)
  }
}
extension ManagedBufferPointer {
  @inlinable internal static func _checkValidBufferClass(_ bufferClass: AnyClass, creating: Bool = false) {
    _debugPrecondition(
      _class_getInstancePositiveExtentSize(bufferClass) == MemoryLayout<_HeapObject>.size
      || (
        (!creating || bufferClass is ManagedBuffer<Header, Element>.Type)
        && _class_getInstancePositiveExtentSize(bufferClass)
          == _headerOffset + MemoryLayout<Header>.size),
      "ManagedBufferPointer buffer class has illegal stored properties"
    )
    _debugPrecondition(
      _usesNativeSwiftReferenceCounting(bufferClass),
      "ManagedBufferPointer buffer class must be non-@objc"
    )
  }
  @inlinable internal static func _internalInvariantValidBufferClass(_ bufferClass: AnyClass, creating: Bool = false) {
    _internalInvariant(
      _class_getInstancePositiveExtentSize(bufferClass) == MemoryLayout<_HeapObject>.size
      || (
        (!creating || bufferClass is ManagedBuffer<Header, Element>.Type)
        && _class_getInstancePositiveExtentSize(bufferClass)
          == _headerOffset + MemoryLayout<Header>.size),
      "ManagedBufferPointer buffer class has illegal stored properties"
    )
    _internalInvariant(
      _usesNativeSwiftReferenceCounting(bufferClass),
      "ManagedBufferPointer buffer class must be non-@objc"
    )
  }
}
extension ManagedBufferPointer {
  @inlinable internal static var _alignmentMask: Int {
    get {
    return max(
      MemoryLayout<_HeapObject>.alignment,
      max(MemoryLayout<Header>.alignment, MemoryLayout<Element>.alignment)) &- 1
  }
  }
  @inlinable internal var _capacityInBytes: Int {
    get {
    return _swift_stdlib_malloc_size(_address)
  }
  }
  @inlinable internal var _address: UnsafeMutableRawPointer {
    get {
    return UnsafeMutableRawPointer(Builtin.bridgeToRawPointer(_nativeBuffer))
  }
  }
  @inlinable internal static var _headerOffset: Int {
    get {
    _onFastPath()
    return _roundUp(
      MemoryLayout<_HeapObject>.size,
      toAlignment: MemoryLayout<Header>.alignment)
  }
  }
  @inlinable internal var _headerPointer: UnsafeMutablePointer<Header> {
    get {
    _onFastPath()
    return (_address + ManagedBufferPointer._headerOffset).assumingMemoryBound(
      to: Header.self)
  }
  }
  @inlinable internal var _elementPointer: UnsafeMutablePointer<Element> {
    get {
    _onFastPath()
    return (_address + ManagedBufferPointer._elementOffset).assumingMemoryBound(
      to: Element.self)
  }
  }
  @inlinable internal static var _elementOffset: Int {
    get {
    _onFastPath()
    return _roundUp(
      _headerOffset + MemoryLayout<Header>.size,
      toAlignment: MemoryLayout<Element>.alignment)
  }
  }
}
extension ManagedBufferPointer : Equatable {
  @inlinable public static func == (lhs: ManagedBufferPointer, rhs: ManagedBufferPointer) -> Bool {
    return lhs._address == rhs._address
  }
}
@inlinable public func isKnownUniquelyReferenced<T>(_ object: inout T) -> Bool where T : AnyObject {
  return _isUnique(&object)
}
@inlinable public func isKnownUniquelyReferenced<T>(_ object: inout T?) -> Bool where T : AnyObject {
  return _isUnique(&object)
}
@_fixed_layout public struct LazyMapSequence<Base, Element> where Base : Swift.Sequence {
  public typealias Elements = LazyMapSequence
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal let _transform: (Base.Element) -> Element
  @inlinable internal init(_base: Base, transform: @escaping (Base.Element) -> Element) {
    self._base = _base
    self._transform = transform
  }
}
extension LazyMapSequence {
  @_fixed_layout public struct Iterator {
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal let _transform: (Base.Element) -> Element
    @inlinable public var base: Base.Iterator {
      get { return _base }
    }
    @inlinable internal init(_base: Base.Iterator, _transform: @escaping (Base.Element) -> Element) {
      self._base = _base
      self._transform = _transform
    }
  }
}
extension LazyMapSequence.Iterator : IteratorProtocol, Sequence {
  @inlinable mutating public func next() -> Element? {
    return _base.next().map(_transform)
  }
  public typealias Iterator = Swift.LazyMapSequence<Base, Element>.Iterator
}
extension LazyMapSequence : LazySequenceProtocol {
  @inlinable __consuming public func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator(), _transform: _transform)
  }
  @inlinable public var underestimatedCount: Int {
    get {
    return _base.underestimatedCount
  }
  }
}
public typealias LazyMapCollection<T, U> = LazyMapSequence<T, U> where T : Swift.Collection
extension LazyMapSequence : Collection where Base : Swift.Collection {
  public typealias Index = Base.Index
  public typealias Indices = Base.Indices
  public typealias SubSequence = LazyMapCollection<Base.SubSequence, Element>
  @inlinable public var startIndex: Base.Index {
    get { return _base.startIndex }
  }
  @inlinable public var endIndex: Base.Index {
    get { return _base.endIndex }
  }
  @inlinable public func index(after i: Index) -> Index { return _base.index(after: i) }
  @inlinable public func formIndex(after i: inout Index) { _base.formIndex(after: &i) }
  @inlinable public subscript(position: Base.Index) -> Element {
    get {
    return _transform(_base[position])
  }
  }
  @inlinable public subscript(bounds: Range<Base.Index>) -> SubSequence {
    get {
    return SubSequence(_base: _base[bounds], transform: _transform)
  }
  }
  @inlinable public var indices: Indices {
    get {
    return _base.indices
  }
  }
  @inlinable public var isEmpty: Bool {
    get { return _base.isEmpty }
  }
  @inlinable public var count: Int {
    get {
    return _base.count
  }
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _base.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index? {
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    return _base.distance(from: start, to: end)
  }
}
extension LazyMapSequence : BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Index) -> Index { return _base.index(before: i) }
  @inlinable public func formIndex(before i: inout Index) {
    _base.formIndex(before: &i)
  }
}
extension LazyMapSequence : LazyCollectionProtocol where Base : Swift.Collection {
}
extension LazyMapSequence : RandomAccessCollection where Base : Swift.RandomAccessCollection {
}
extension LazySequenceProtocol {
  @inlinable public func map<U>(_ transform: @escaping (Element) -> U) -> LazyMapSequence<Elements, U> {
    return LazyMapSequence(_base: elements, transform: transform)
  }
}
extension LazyMapSequence {
  @available(swift 5)
  @inlinable public func map<ElementOfResult>(_ transform: @escaping (Element) -> ElementOfResult) -> LazyMapSequence<Base, ElementOfResult> {
    return LazyMapSequence<Base, ElementOfResult>(
      _base: _base,
      transform: { transform(self._transform($0)) })
  }
}
extension LazyMapSequence where Base : Swift.Collection {
  @available(swift 5)
  @inlinable public func map<ElementOfResult>(_ transform: @escaping (Element) -> ElementOfResult) -> LazyMapCollection<Base, ElementOfResult> {
    return LazyMapCollection<Base, ElementOfResult>(
      _base: _base,
      transform: {transform(self._transform($0))})
  }
}
@_frozen public enum MemoryLayout<T> {
  @_transparent public static var size: Int {
    get {
    return Int(Builtin.sizeof(T.self))
  }
  }
  @_transparent public static var stride: Int {
    get {
    return Int(Builtin.strideof(T.self))
  }
  }
  @_transparent public static var alignment: Int {
    get {
    return Int(Builtin.alignof(T.self))
  }
  }
}
extension MemoryLayout {
  @_transparent public static func size(ofValue value: T) -> Int {
    return MemoryLayout.size
  }
  @_transparent public static func stride(ofValue value: T) -> Int {
    return MemoryLayout.stride
  }
  @_transparent public static func alignment(ofValue value: T) -> Int {
    return MemoryLayout.alignment
  }
  @_transparent public static func offset(of key: PartialKeyPath<T>) -> Int? {
    return key._storedInlineOffset
  }
}
extension Unicode {
  @_fixed_layout public struct Scalar {
    @inlinable internal init(_value: UInt32) {
      self._value = _value
    }
    @usableFromInline
    internal var _value: UInt32
  }
}
extension Unicode.Scalar : _ExpressibleByBuiltinUnicodeScalarLiteral, ExpressibleByUnicodeScalarLiteral {
  @inlinable public var value: UInt32 {
    get { return _value }
  }
  @_transparent public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self._value = UInt32(value)
  }
  @_transparent public init(unicodeScalarLiteral value: Unicode.Scalar) {
    self = value
  }
  @inlinable public init?(_ v: UInt32) {
    // Unicode 6.3.0:
    //
    //     D9.  Unicode codespace: A range of integers from 0 to 10FFFF.
    //
    //     D76. Unicode scalar value: Any Unicode code point except
    //     high-surrogate and low-surrogate code points.
    //
    //     * As a result of this definition, the set of Unicode scalar values
    //     consists of the ranges 0 to D7FF and E000 to 10FFFF, inclusive.
    if (v < 0xD800 || v > 0xDFFF) && v <= 0x10FFFF {
      self._value = v
      return
    }
    // Return nil in case of an invalid unicode scalar value.
    return nil
  }
  @inlinable public init?(_ v: UInt16) {
    self.init(UInt32(v))
  }
  @inlinable public init(_ v: UInt8) {
    self._value = UInt32(v)
  }
  @inlinable public init(_ v: Unicode.Scalar) {
    // This constructor allows one to provide necessary type context to
    // disambiguate between function overloads on 'String' and 'Unicode.Scalar'.
    self = v
  }
  public func escaped(asASCII forceASCII: Bool) -> String
  @inlinable public var isASCII: Bool {
    get {
    return value <= 127
  }
  }
  public typealias UnicodeScalarLiteralType = Swift.Unicode.Scalar
}
extension Unicode.Scalar : CustomStringConvertible, CustomDebugStringConvertible {
  @inlinable public var description: String {
    get {
    return String(self)
  }
  }
  public var debugDescription: String {
    get
  }
}
extension Unicode.Scalar : LosslessStringConvertible {
  @inlinable public init?(_ description: String) {
    let scalars = description.unicodeScalars
    guard let v = scalars.first, scalars.count == 1 else {
      return nil
    }
    self = v
  }
}
extension Unicode.Scalar : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine(self.value)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Unicode.Scalar {
  @inlinable public init?(_ v: Int) {
    if let us = Unicode.Scalar(UInt32(v)) {
      self = us
    } else {
      return nil
    }
  }
}
extension UInt8 {
  @inlinable public init(ascii v: Unicode.Scalar) {
    _precondition(v.value < 128,
        "Code point value does not fit into ASCII")
    self = UInt8(v.value)
  }
}
extension UInt32 {
  @inlinable public init(_ v: Unicode.Scalar) {
    self = v.value
  }
}
extension UInt64 {
  @inlinable public init(_ v: Unicode.Scalar) {
    self = UInt64(v.value)
  }
}
extension Unicode.Scalar : Equatable {
  @inlinable public static func == (lhs: Unicode.Scalar, rhs: Unicode.Scalar) -> Bool {
    return lhs.value == rhs.value
  }
}
extension Unicode.Scalar : Comparable {
  @inlinable public static func < (lhs: Unicode.Scalar, rhs: Unicode.Scalar) -> Bool {
    return lhs.value < rhs.value
  }
}
extension Unicode.Scalar {
  @_fixed_layout public struct UTF16View {
    @inlinable internal init(value: Unicode.Scalar) {
      self.value = value
    }
    @usableFromInline
    internal var value: Unicode.Scalar
  }
  @inlinable public var utf16: UTF16View {
    get {
    return UTF16View(value: self)
  }
  }
}
extension Unicode.Scalar.UTF16View : RandomAccessCollection {
  public typealias Indices = Range<Int>
  @inlinable public var startIndex: Int {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Int {
    get {
    return 0 + UTF16.width(value)
  }
  }
  @inlinable public subscript(position: Int) -> UTF16.CodeUnit {
    get {
    return position == 0 ? (
      endIndex == 1 ? UTF16.CodeUnit(value.value) : UTF16.leadSurrogate(value)
    ) : UTF16.trailSurrogate(value)
  }
  }
  public typealias Element = Swift.UTF16.CodeUnit
  public typealias Index = Swift.Int
  public typealias SubSequence = Swift.Slice<Swift.Unicode.Scalar.UTF16View>
  public typealias Iterator = Swift.IndexingIterator<Swift.Unicode.Scalar.UTF16View>
}
extension Unicode.Scalar {
  @available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @_fixed_layout public struct UTF8View {
    @inlinable internal init(value: Unicode.Scalar) {
      self.value = value
    }
    @usableFromInline
    internal var value: Unicode.Scalar
  }
  @available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  @inlinable public var utf8: UTF8View {
    get { return UTF8View(value: self) }
  }
}
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Unicode.Scalar.UTF8View : RandomAccessCollection {
  public typealias Indices = Range<Int>
  @inlinable public var startIndex: Int {
    get { return 0 }
  }
  @inlinable public var endIndex: Int {
    get { return 0 + UTF8.width(value) }
  }
  @inlinable public subscript(position: Int) -> UTF8.CodeUnit {
    get {
    _precondition(position >= startIndex && position < endIndex,
      "Unicode.Scalar.UTF8View index is out of bounds")
    return value.withUTF8CodeUnits { $0[position] }
  }
  }
  public typealias Element = Swift.UTF8.CodeUnit
  public typealias Index = Swift.Int
  public typealias SubSequence = Swift.Slice<Swift.Unicode.Scalar.UTF8View>
  public typealias Iterator = Swift.IndexingIterator<Swift.Unicode.Scalar.UTF8View>
}
extension Unicode.Scalar {
  @available(*, unavailable, message: "use 'Unicode.Scalar(0)'")
  public init()
}
extension Unicode.Scalar {
  @inlinable internal func withUTF8CodeUnits<Result>(_ body: (UnsafeBufferPointer<UInt8>) throws -> Result) rethrows -> Result {
    let encodedScalar = UTF8.encode(self)!
    var (codeUnits, utf8Count) = encodedScalar._bytes

    // The first code unit is in the least significant byte of codeUnits.
    codeUnits = codeUnits.littleEndian
    return try Swift.withUnsafePointer(to: &codeUnits) {
      return try $0.withMemoryRebound(to: UInt8.self, capacity: 4) {
        return try body(UnsafeBufferPointer(start: $0, count: utf8Count))
      }
    }
  }
}
extension Float : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Float : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Float.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension Double : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Double : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Double.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension Bool : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Bool : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Bool.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension String : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension String : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "String.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension Character : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Character : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Character.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension Unicode.Scalar : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Unicode.Scalar : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Unicode.Scalar.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension UInt8 : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension UInt8 : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UInt8.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension Int8 : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Int8 : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Int8.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension UInt16 : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension UInt16 : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UInt16.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension Int16 : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Int16 : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Int16.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension UInt32 : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension UInt32 : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UInt32.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension Int32 : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Int32 : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Int32.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension UInt64 : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension UInt64 : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UInt64.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension Int64 : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Int64 : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Int64.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension UInt : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension UInt : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UInt.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension Int : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Int : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Int.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension Float80 : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
@_transparent public func _isPowerOf2(_ x: UInt) -> Bool {
  if x == 0 {
    return false
  }
  // Note: use unchecked subtraction because we have checked that `x` is not
  // zero.
  return x & (x &- 1) == 0
}
@_transparent public func _isPowerOf2(_ x: Int) -> Bool {
  if x <= 0 {
    return false
  }
  // Note: use unchecked subtraction because we have checked that `x` is not
  // `Int.min`.
  return x & (x &- 1) == 0
}
@_transparent public func _autorelease(_ x: AnyObject) {
  Builtin.retain(x)
  Builtin.autorelease(x)
}
@_silgen_name("swift_getTypeName")
public func _getTypeName(_ type: Any.Type, qualified: Bool) -> (UnsafePointer<UInt8>, Int)
public func _typeName(_ type: Any.Type, qualified: Bool = true) -> String
public func _typeByName(_ name: String) -> Any.Type?
@_silgen_name("swift_getTypeByMangledNameInEnvironment")
public func _getTypeByMangledNameInEnvironment(_ name: UnsafePointer<UInt8>, _ nameLength: UInt, genericEnvironment: UnsafeRawPointer?, genericArguments: UnsafeRawPointer?) -> Any.Type?
@_silgen_name("swift_getTypeByMangledNameInContext")
public func _getTypeByMangledNameInContext(_ name: UnsafePointer<UInt8>, _ nameLength: UInt, genericContext: UnsafeRawPointer?, genericArguments: UnsafeRawPointer?) -> Any.Type?
public protocol MutableCollection : Swift.Collection where Self.SubSequence : Swift.MutableCollection {
  override associatedtype Element
  override associatedtype Index
  override associatedtype SubSequence
  @_borrowed override subscript(position: Index) -> Element { get set }
  override subscript(bounds: Range<Index>) -> SubSequence { get set }
  mutating func partition(by belongsInSecondPartition: (Element) throws -> Bool) rethrows -> Index
  mutating func swapAt(_ i: Index, _ j: Index)
  mutating func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R?
  mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R?
}
extension MutableCollection {
  @inlinable mutating public func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return nil
  }
  @inlinable mutating public func withContiguousMutableStorageIfAvailable<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return nil
  }
  @inlinable public subscript(bounds: Range<Index>) -> Slice<Self> {
    get {
      _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
      return Slice(base: self, bounds: bounds)
    }
    set {
      _writeBackMutableSlice(&self, bounds: bounds, slice: newValue)
    }
  }
  @inlinable mutating public func swapAt(_ i: Index, _ j: Index) {
    guard i != j else { return }
    let tmp = self[i]
    self[i] = self[j]
    self[j] = tmp
  }
}
@inlinable public func swap<T>(_ a: inout T, _ b: inout T) {
  // Semantically equivalent to (a, b) = (b, a).
  // Microoptimized to avoid retain/release traffic.
  let p1 = Builtin.addressof(&a)
  let p2 = Builtin.addressof(&b)
  _debugPrecondition(
    p1 != p2,
    "swapping a location with itself is not supported")

  // Take from P1.
  let tmp: T = Builtin.take(p1)
  // Transfer P2 into P1.
  Builtin.initialize(Builtin.take(p2) as T, p1)
  // Initialize P2.
  Builtin.initialize(tmp, p2)
}
@usableFromInline
@_fixed_layout internal struct _NativeDictionary<Key, Value> where Key : Swift.Hashable {
  @usableFromInline
  internal typealias Element = (key: Key, value: Value)
  @usableFromInline
  internal var _storage: __RawDictionaryStorage
  @inlinable internal init() {
    self._storage = __RawDictionaryStorage.empty
  }
  @inlinable internal init(_ storage: __owned __RawDictionaryStorage) {
    self._storage = storage
  }
  @inlinable internal init(capacity: Int) {
    if capacity == 0 {
      self._storage = __RawDictionaryStorage.empty
    } else {
      self._storage = _DictionaryStorage<Key, Value>.allocate(capacity: capacity)
    }
  }
  @inlinable internal init(_ cocoa: __owned __CocoaDictionary) {
    self.init(cocoa, capacity: cocoa.count)
  }
  @inlinable internal init(_ cocoa: __owned __CocoaDictionary, capacity: Int) {
    if capacity == 0 {
      self._storage = __RawDictionaryStorage.empty
    } else {
      _internalInvariant(cocoa.count <= capacity)
      self._storage =
        _DictionaryStorage<Key, Value>.convert(cocoa, capacity: capacity)
      for (key, value) in cocoa {
        insertNew(
          key: _forceBridgeFromObjectiveC(key, Key.self),
          value: _forceBridgeFromObjectiveC(value, Value.self))
      }
    }
  }
}
extension _NativeDictionary {
  @usableFromInline
  internal typealias Bucket = _HashTable.Bucket
  @inlinable internal var capacity: Int {
    @inline(__always) get {
      return _assumeNonNegative(_storage._capacity)
    }
  }
  @inlinable internal var hashTable: _HashTable {
    @inline(__always) get {
      return _storage._hashTable
    }
  }
  @inlinable internal var age: Int32 {
    @inline(__always) get {
      return _storage._age
    }
  }
  @inlinable internal var _keys: UnsafeMutablePointer<Key> {
    get {
    return _storage._rawKeys.assumingMemoryBound(to: Key.self)
  }
  }
  @inlinable internal var _values: UnsafeMutablePointer<Value> {
    get {
    return _storage._rawValues.assumingMemoryBound(to: Value.self)
  }
  }
  @inlinable @inline(__always) internal func invalidateIndices() {
    _storage._age &+= 1
  }
}
extension _NativeDictionary {
  @inlinable @inline(__always) internal func uncheckedKey(at bucket: Bucket) -> Key {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isOccupied(bucket))
    return _keys[bucket.offset]
  }
  @inlinable @inline(__always) internal func uncheckedValue(at bucket: Bucket) -> Value {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isOccupied(bucket))
    return _values[bucket.offset]
  }
  @inlinable @inline(__always) internal func uncheckedInitialize(at bucket: Bucket, toKey key: __owned Key, value: __owned Value) {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isValid(bucket))
    (_keys + bucket.offset).initialize(to: key)
    (_values + bucket.offset).initialize(to: value)
  }
  @inlinable @inline(__always) internal func uncheckedDestroy(at bucket: Bucket) {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isValid(bucket))
    (_keys + bucket.offset).deinitialize(count: 1)
    (_values + bucket.offset).deinitialize(count: 1)
  }
}
extension _NativeDictionary {
  @inlinable @inline(__always) internal func hashValue(for key: Key) -> Int {
    return key._rawHashValue(seed: _storage._seed)
  }
  @inlinable @inline(__always) internal func find(_ key: Key) -> (bucket: Bucket, found: Bool) {
    return find(key, hashValue: self.hashValue(for: key))
  }
  @inlinable @inline(__always) internal func find(_ key: Key, hashValue: Int) -> (bucket: Bucket, found: Bool) {
    let hashTable = self.hashTable
    var bucket = hashTable.idealBucket(forHashValue: hashValue)
    while hashTable._isOccupied(bucket) {
      if uncheckedKey(at: bucket) == key {
        return (bucket, true)
      }
      bucket = hashTable.bucket(wrappedAfter: bucket)
    }
    return (bucket, false)
  }
}
extension _NativeDictionary {
  @inlinable mutating internal func resize(capacity: Int) {
    let capacity = Swift.max(capacity, self.capacity)
    let newStorage = _DictionaryStorage<Key, Value>.resize(
      original: _storage,
      capacity: capacity,
      move: true)
    let result = _NativeDictionary(newStorage)
    if count > 0 {
      for bucket in hashTable {
        let key = (_keys + bucket.offset).move()
        let value = (_values + bucket.offset).move()
        result._unsafeInsertNew(key: key, value: value)
      }
      // Clear out old storage, ensuring that its deinit won't overrelease the
      // elements we've just moved out.
      _storage._hashTable.clear()
      _storage._count = 0
    }
    _storage = result._storage
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") mutating internal func copyAndResize(capacity: Int) {
    let capacity = Swift.max(capacity, self.capacity)
    let newStorage = _DictionaryStorage<Key, Value>.resize(
      original: _storage,
      capacity: capacity,
      move: false)
    let result = _NativeDictionary(newStorage)
    if count > 0 {
      for bucket in hashTable {
        result._unsafeInsertNew(
          key: self.uncheckedKey(at: bucket),
          value: self.uncheckedValue(at: bucket))
      }
    }
    _storage = result._storage
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") mutating internal func copy() {
    let newStorage = _DictionaryStorage<Key, Value>.copy(original: _storage)
    _internalInvariant(newStorage._scale == _storage._scale)
    _internalInvariant(newStorage._age == _storage._age)
    _internalInvariant(newStorage._seed == _storage._seed)
    let result = _NativeDictionary(newStorage)
    if count > 0 {
      result.hashTable.copyContents(of: hashTable)
      result._storage._count = self.count
      for bucket in hashTable {
        let key = uncheckedKey(at: bucket)
        let value = uncheckedValue(at: bucket)
        result.uncheckedInitialize(at: bucket, toKey: key, value: value)
      }
    }
    _storage = result._storage
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") mutating internal func ensureUnique(isUnique: Bool, capacity: Int) -> Bool {
    if _fastPath(capacity <= self.capacity && isUnique) {
      return false
    }
    if isUnique {
      resize(capacity: capacity)
      return true
    }
    if capacity <= self.capacity {
      copy()
      return false
    }
    copyAndResize(capacity: capacity)
    return true
  }
}
extension _NativeDictionary {
  @inlinable @inline(__always) internal func validatedBucket(for index: _HashTable.Index) -> Bucket {
    _precondition(hashTable.isOccupied(index.bucket) && index.age == age,
      "Attempting to access Dictionary elements using an invalid index")
    return index.bucket
  }
  @inlinable @inline(__always) internal func validatedBucket(for index: Dictionary<Key, Value>.Index) -> Bucket {
    guard index._isNative else {
      index._cocoaPath()
      // Accept Cocoa indices as long as they contain a key that exists in this
      // dictionary, and the address of their Cocoa object generates the same
      // age.
      let cocoa = index._asCocoa
      if cocoa.age == self.age {
        let key = _forceBridgeFromObjectiveC(cocoa.key, Key.self)
        let (bucket, found) = find(key)
        if found {
          return bucket
        }
      }
      _preconditionFailure(
        "Attempting to access Dictionary elements using an invalid index")
    }
    return validatedBucket(for: index._asNative)
  }
}
extension _NativeDictionary {
  @usableFromInline
  internal typealias Index = Dictionary<Key, Value>.Index
  @inlinable internal var startIndex: Index {
    get {
    let bucket = hashTable.startBucket
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  }
  @inlinable internal var endIndex: Index {
    get {
    let bucket = hashTable.endBucket
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  }
  @inlinable internal func index(after index: Index) -> Index {
    guard _fastPath(index._isNative) else {
      let _ = validatedBucket(for: index)
      let i = index._asCocoa
      return Index(_cocoa: i.dictionary.index(after: i))
    }
    let bucket = validatedBucket(for: index._asNative)
    let next = hashTable.occupiedBucket(after: bucket)
    return Index(_native: _HashTable.Index(bucket: next, age: age))
  }
  @inlinable internal func index(forKey key: Key) -> Index? {
    if count == 0 {
      // Fast path that avoids computing the hash of the key.
      return nil
    }
    let (bucket, found) = find(key)
    guard found else { return nil }
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  @inlinable internal var count: Int {
    @inline(__always) get {
      return _assumeNonNegative(_storage._count)
    }
  }
  @inlinable @inline(__always) internal func contains(_ key: Key) -> Bool {
    return find(key).found
  }
  @inlinable @inline(__always) internal func lookup(_ key: Key) -> Value? {
    if count == 0 {
      // Fast path that avoids computing the hash of the key.
      return nil
    }
    let (bucket, found) = self.find(key)
    guard found else { return nil }
    return self.uncheckedValue(at: bucket)
  }
  @inlinable @inline(__always) internal func lookup(_ index: Index) -> (key: Key, value: Value) {
    let bucket = validatedBucket(for: index)
    let key = self.uncheckedKey(at: bucket)
    let value = self.uncheckedValue(at: bucket)
    return (key, value)
  }
  @inlinable @inline(__always) internal func key(at index: Index) -> Key {
    let bucket = validatedBucket(for: index)
    return self.uncheckedKey(at: bucket)
  }
  @inlinable @inline(__always) internal func value(at index: Index) -> Value {
    let bucket = validatedBucket(for: index)
    return self.uncheckedValue(at: bucket)
  }
}
extension _NativeDictionary {
  @inlinable internal subscript(key: Key, isUnique isUnique: Bool) -> Value? {
    @inline(__always) get {
      // Dummy definition; don't use.
      return lookup(key)
    }
    @inline(__always) _modify {
      let (bucket, found) = mutatingFind(key, isUnique: isUnique)
      if found {
        // Move the old value out of storage, wrapping it into an optional
        // before yielding it.
        var value: Value? = (_values + bucket.offset).move()
        defer {
          // This is in a defer block because yield might throw, and we need to
          // preserve Dictionary's storage invariants when that happens.
          if let value = value {
            // **Mutation.** Initialize storage to new value.
            (_values + bucket.offset).initialize(to: value)
          } else {
            // **Removal.** We've already deinitialized the value; deinitialize
            // the key too and register the removal.
            (_keys + bucket.offset).deinitialize(count: 1)
            _delete(at: bucket)
          }
        }
        yield &value
      } else {
        var value: Value? = nil
        defer {
          // This is in a defer block because yield might throw, and we need to
          // preserve Dictionary invariants when that happens.
          if let value = value {
            // **Insertion.** Insert the new entry at the correct place.  Note
            // that `mutatingFind` already ensured that we have enough capacity.
            _insert(at: bucket, key: key, value: value)
          }
        }
        yield &value
      }
    }
  }
}
@usableFromInline
@inline(never) internal func KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_ keyType: Any.Type) -> Never
extension _NativeDictionary {
  @inlinable internal func _unsafeInsertNew(key: __owned Key, value: __owned Value) {
    _internalInvariant(count + 1 <= capacity)
    let hashValue = self.hashValue(for: key)
    if _isDebugAssertConfiguration() {
      // In debug builds, perform a full lookup and trap if we detect duplicate
      // elements -- these imply that the Element type violates Hashable
      // requirements. This is generally more costly than a direct insertion,
      // because we'll need to compare elements in case of hash collisions.
      let (bucket, found) = find(key, hashValue: hashValue)
      guard !found else {
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(Key.self)
      }
      hashTable.insert(bucket)
      uncheckedInitialize(at: bucket, toKey: key, value: value)
    } else {
      let bucket = hashTable.insertNew(hashValue: hashValue)
      uncheckedInitialize(at: bucket, toKey: key, value: value)
    }
    _storage._count &+= 1
  }
  @_alwaysEmitIntoClient @inlinable mutating internal func _unsafeUpdate(key: __owned Key, value: __owned Value) {
    let (bucket, found) = find(key)
    if found {
      // Note that we also update the key here. This method is used to handle
      // collisions arising from equality transitions during bridging, and in
      // that case it is desirable to keep values paired with their original
      // keys. This is not how `updateValue(_:, forKey:)` works.
      (_keys + bucket.offset).pointee = key
      (_values + bucket.offset).pointee = value
    } else {
      _precondition(count < capacity)
      _insert(at: bucket, key: key, value: value)
    }
  }
  @inlinable mutating internal func insertNew(key: __owned Key, value: __owned Value) {
    _ = ensureUnique(isUnique: true, capacity: count + 1)
    _unsafeInsertNew(key: key, value: value)
  }
  @inlinable mutating internal func mutatingFind(_ key: Key, isUnique: Bool) -> (bucket: Bucket, found: Bool) {
    let (bucket, found) = find(key)

    // Prepare storage.
    // If `key` isn't in the dictionary yet, assume that this access will end
    // up inserting it. (If we guess wrong, we might needlessly expand
    // storage; that's fine.) Otherwise this can only be a removal or an
    // in-place mutation.
    let rehashed = ensureUnique(
      isUnique: isUnique,
      capacity: count + (found ? 0 : 1))
    guard rehashed else { return (bucket, found) }
    let (b, f) = find(key)
    if f != found {
      KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(Key.self)
    }
    return (b, found)
  }
  @inlinable internal func _insert(at bucket: Bucket, key: __owned Key, value: __owned Value) {
    _internalInvariant(count < capacity)
    hashTable.insert(bucket)
    uncheckedInitialize(at: bucket, toKey: key, value: value)
    _storage._count += 1
  }
  @inlinable mutating internal func updateValue(_ value: __owned Value, forKey key: Key, isUnique: Bool) -> Value? {
    let (bucket, found) = mutatingFind(key, isUnique: isUnique)
    if found {
      let oldValue = (_values + bucket.offset).move()
      (_values + bucket.offset).initialize(to: value)
      return oldValue
    }
    _insert(at: bucket, key: key, value: value)
    return nil
  }
  @inlinable mutating internal func setValue(_ value: __owned Value, forKey key: Key, isUnique: Bool) {
    let (bucket, found) = mutatingFind(key, isUnique: isUnique)
    if found {
      (_values + bucket.offset).pointee = value
    } else {
      _insert(at: bucket, key: key, value: value)
    }
  }
}
extension _NativeDictionary {
  @inlinable @inline(__always) mutating internal func swapValuesAt(_ a: Bucket, _ b: Bucket, isUnique: Bool) {
    let rehashed = ensureUnique(isUnique: isUnique, capacity: capacity)
    _internalInvariant(!rehashed)
    _internalInvariant(hashTable.isOccupied(a) && hashTable.isOccupied(b))
    let value = (_values + a.offset).move()
    (_values + a.offset).moveInitialize(from: _values + b.offset, count: 1)
    (_values + b.offset).initialize(to: value)
  }
}
extension _NativeDictionary where Value : Swift.Equatable {
  @inlinable @inline(__always) internal func isEqual(to other: _NativeDictionary) -> Bool {
    if self._storage === other._storage { return true }
    if self.count != other.count { return false }

    for (key, value) in self {
      let (bucket, found) = other.find(key)
      guard found, other.uncheckedValue(at: bucket) == value else {
        return false
      }
    }
    return true
  }
  @inlinable internal func isEqual(to other: __CocoaDictionary) -> Bool {
    if self.count != other.count { return false }

    defer { _fixLifetime(self) }
    for bucket in self.hashTable {
      let key = self.uncheckedKey(at: bucket)
      let value = self.uncheckedValue(at: bucket)
      guard
        let cocoaValue = other.lookup(_bridgeAnythingToObjectiveC(key)),
        value == _forceBridgeFromObjectiveC(cocoaValue, Value.self)
      else {
        return false
      }
    }
    return true
  }
}
extension _NativeDictionary : _HashTableDelegate {
  @inlinable @inline(__always) internal func hashValue(at bucket: Bucket) -> Int {
    return hashValue(for: uncheckedKey(at: bucket))
  }
  @inlinable @inline(__always) internal func moveEntry(from source: Bucket, to target: Bucket) {
    _internalInvariant(hashTable.isValid(source))
    _internalInvariant(hashTable.isValid(target))
    (_keys + target.offset)
      .moveInitialize(from: _keys + source.offset, count: 1)
    (_values + target.offset)
      .moveInitialize(from: _values + source.offset, count: 1)
  }
  @inlinable @inline(__always) internal func swapEntry(_ left: Bucket, with right: Bucket) {
    _internalInvariant(hashTable.isValid(left))
    _internalInvariant(hashTable.isValid(right))
    swap(&_keys[left.offset], &_keys[right.offset])
    swap(&_values[left.offset], &_values[right.offset])
  }
}
extension _NativeDictionary {
  @inlinable @_effects(releasenone) @_semantics("optimize.sil.specialize.generic.size.never") internal func _delete(at bucket: Bucket) {
    hashTable.delete(at: bucket, with: self)
    _storage._count -= 1
    _internalInvariant(_storage._count >= 0)
    invalidateIndices()
  }
  @inlinable @_semantics("optimize.sil.specialize.generic.size.never") mutating internal func uncheckedRemove(at bucket: Bucket, isUnique: Bool) -> Element {
    _internalInvariant(hashTable.isOccupied(bucket))
    let rehashed = ensureUnique(isUnique: isUnique, capacity: capacity)
    _internalInvariant(!rehashed)
    let oldKey = (_keys + bucket.offset).move()
    let oldValue = (_values + bucket.offset).move()
    _delete(at: bucket)
    return (oldKey, oldValue)
  }
  @usableFromInline
  mutating internal func removeAll(isUnique: Bool)
}
extension _NativeDictionary {
  @inlinable internal func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> _NativeDictionary<Key, T> {
    let resultStorage = _DictionaryStorage<Key, T>.copy(original: _storage)
    _internalInvariant(resultStorage._seed == _storage._seed)
    let result = _NativeDictionary<Key, T>(resultStorage)
    // Because the current and new buffer have the same scale and seed, we can
    // initialize to the same locations in the new buffer, skipping hash value
    // recalculations.
    for bucket in hashTable {
      let key = self.uncheckedKey(at: bucket)
      let value = self.uncheckedValue(at: bucket)
      try result._insert(at: bucket, key: key, value: transform(value))
    }
    return result
  }
  @inlinable mutating internal func merge<S>(_ keysAndValues: __owned S, isUnique: Bool, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
    var isUnique = isUnique
    for (key, value) in keysAndValues {
      let (bucket, found) = mutatingFind(key, isUnique: isUnique)
      isUnique = true
      if found {
        do {
          let newValue = try combine(uncheckedValue(at: bucket), value)
          _values[bucket.offset] = newValue
        } catch _MergeError.keyCollision {
          fatalError("Duplicate values for key: '\(key)'")
        }
      } else {
        _insert(at: bucket, key: key, value: value)
      }
    }
  }
  @inlinable @inline(__always) internal init<S>(grouping values: __owned S, by keyForValue: (S.Element) throws -> Key) rethrows where Value == [S.Element], S : Swift.Sequence {
    self.init()
    for value in values {
      let key = try keyForValue(value)
      let (bucket, found) = mutatingFind(key, isUnique: true)
      if found {
        _values[bucket.offset].append(value)
      } else {
        _insert(at: bucket, key: key, value: [value])
      }
    }
  }
}
extension _NativeDictionary : Sequence {
  @usableFromInline
  @_fixed_layout internal struct Iterator {
    @usableFromInline
    internal let base: _NativeDictionary
    @usableFromInline
    internal var iterator: _HashTable.Iterator
    @inlinable @inline(__always) internal init(_ base: __owned _NativeDictionary) {
      self.base = base
      self.iterator = base.hashTable.makeIterator()
    }
  }
  @inlinable __consuming internal func makeIterator() -> Iterator {
    return Iterator(self)
  }
}
extension _NativeDictionary.Iterator : IteratorProtocol {
  @usableFromInline
  internal typealias Element = (key: Key, value: Value)
  @inlinable @inline(__always) mutating internal func nextKey() -> Key? {
    guard let index = iterator.next() else { return nil }
    return base.uncheckedKey(at: index)
  }
  @inlinable @inline(__always) mutating internal func nextValue() -> Value? {
    guard let index = iterator.next() else { return nil }
    return base.uncheckedValue(at: index)
  }
  @inlinable @inline(__always) mutating internal func next() -> Element? {
    guard let index = iterator.next() else { return nil }
    let key = base.uncheckedKey(at: index)
    let value = base.uncheckedValue(at: index)
    return (key, value)
  }
}
@usableFromInline
@_fixed_layout internal struct _NativeSet<Element> where Element : Swift.Hashable {
  @usableFromInline
  internal var _storage: __RawSetStorage
  @inlinable @inline(__always) internal init() {
    self._storage = __RawSetStorage.empty
  }
  @inlinable @inline(__always) internal init(_ storage: __owned __RawSetStorage) {
    self._storage = storage
  }
  @inlinable internal init(capacity: Int) {
    if capacity == 0 {
      self._storage = __RawSetStorage.empty
    } else {
      self._storage = _SetStorage<Element>.allocate(capacity: capacity)
    }
  }
  @inlinable internal init(_ cocoa: __owned __CocoaSet) {
    self.init(cocoa, capacity: cocoa.count)
  }
  @inlinable internal init(_ cocoa: __owned __CocoaSet, capacity: Int) {
    if capacity == 0 {
      self._storage = __RawSetStorage.empty
    } else {
      _internalInvariant(cocoa.count <= capacity)
      self._storage = _SetStorage<Element>.convert(cocoa, capacity: capacity)
      for element in cocoa {
        let nativeElement = _forceBridgeFromObjectiveC(element, Element.self)
        insertNew(nativeElement, isUnique: true)
      }
    }
  }
}
extension _NativeSet {
  @usableFromInline
  internal typealias Bucket = _HashTable.Bucket
  @inlinable internal var capacity: Int {
    @inline(__always) get {
      return _assumeNonNegative(_storage._capacity)
    }
  }
  @inlinable internal var hashTable: _HashTable {
    @inline(__always) get {
      return _storage._hashTable
    }
  }
  @inlinable internal var age: Int32 {
    @inline(__always) get {
      return _storage._age
    }
  }
  @inlinable internal var _elements: UnsafeMutablePointer<Element> {
    get {
    return _storage._rawElements.assumingMemoryBound(to: Element.self)
  }
  }
  @inlinable @inline(__always) internal func invalidateIndices() {
    _storage._age &+= 1
  }
}
extension _NativeSet {
  @inlinable @inline(__always) internal func uncheckedElement(at bucket: Bucket) -> Element {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isOccupied(bucket))
    return _elements[bucket.offset]
  }
  @inlinable @inline(__always) internal func uncheckedInitialize(at bucket: Bucket, to element: __owned Element) {
    _internalInvariant(hashTable.isValid(bucket))
    (_elements + bucket.offset).initialize(to: element)
  }
  @_alwaysEmitIntoClient @inlinable @inline(__always) internal func uncheckedAssign(at bucket: Bucket, to element: __owned Element) {
    _internalInvariant(hashTable.isOccupied(bucket))
    (_elements + bucket.offset).pointee = element
  }
}
extension _NativeSet {
  @inlinable @inline(__always) internal func hashValue(for element: Element) -> Int {
    return element._rawHashValue(seed: _storage._seed)
  }
  @inlinable @inline(__always) internal func find(_ element: Element) -> (bucket: Bucket, found: Bool) {
    return find(element, hashValue: self.hashValue(for: element))
  }
  @inlinable @inline(__always) internal func find(_ element: Element, hashValue: Int) -> (bucket: Bucket, found: Bool) {
    let hashTable = self.hashTable
    var bucket = hashTable.idealBucket(forHashValue: hashValue)
    while hashTable._isOccupied(bucket) {
      if uncheckedElement(at: bucket) == element {
        return (bucket, true)
      }
      bucket = hashTable.bucket(wrappedAfter: bucket)
    }
    return (bucket, false)
  }
}
extension _NativeSet {
  @inlinable mutating internal func resize(capacity: Int) {
    let capacity = Swift.max(capacity, self.capacity)
    let result = _NativeSet(_SetStorage<Element>.resize(
        original: _storage,
        capacity: capacity,
        move: true))
    if count > 0 {
      for bucket in hashTable {
        let element = (self._elements + bucket.offset).move()
        result._unsafeInsertNew(element)
      }
      // Clear out old storage, ensuring that its deinit won't overrelease the
      // elements we've just moved out.
      _storage._hashTable.clear()
      _storage._count = 0
    }
    _storage = result._storage
  }
  @inlinable mutating internal func copyAndResize(capacity: Int) {
    let capacity = Swift.max(capacity, self.capacity)
    let result = _NativeSet(_SetStorage<Element>.resize(
        original: _storage,
        capacity: capacity,
        move: false))
    if count > 0 {
      for bucket in hashTable {
        result._unsafeInsertNew(self.uncheckedElement(at: bucket))
      }
    }
    _storage = result._storage
  }
  @inlinable mutating internal func copy() {
    let newStorage = _SetStorage<Element>.copy(original: _storage)
    _internalInvariant(newStorage._scale == _storage._scale)
    _internalInvariant(newStorage._age == _storage._age)
    _internalInvariant(newStorage._seed == _storage._seed)
    let result = _NativeSet(newStorage)
    if count > 0 {
      result.hashTable.copyContents(of: hashTable)
      result._storage._count = self.count
      for bucket in hashTable {
        let element = uncheckedElement(at: bucket)
        result.uncheckedInitialize(at: bucket, to: element)
      }
    }
    _storage = result._storage
  }
  @inlinable @inline(__always) mutating internal func ensureUnique(isUnique: Bool, capacity: Int) -> Bool {
    if _fastPath(capacity <= self.capacity && isUnique) {
      return false
    }
    if isUnique {
      resize(capacity: capacity)
      return true
    }
    if capacity <= self.capacity {
      copy()
      return false
    }
    copyAndResize(capacity: capacity)
    return true
  }
}
extension _NativeSet {
  @inlinable @inline(__always) internal func validatedBucket(for index: _HashTable.Index) -> Bucket {
    _precondition(hashTable.isOccupied(index.bucket) && index.age == age,
      "Attempting to access Set elements using an invalid index")
    return index.bucket
  }
  @inlinable @inline(__always) internal func validatedBucket(for index: Set<Element>.Index) -> Bucket {
    guard index._isNative else {
      index._cocoaPath()
      let cocoa = index._asCocoa
      // Accept Cocoa indices as long as they contain an element that exists in
      // this set, and the address of their Cocoa object generates the same age.
      if cocoa.age == self.age {
        let element = _forceBridgeFromObjectiveC(cocoa.element, Element.self)
        let (bucket, found) = find(element)
        if found {
          return bucket
        }
      }
      _preconditionFailure(
        "Attempting to access Set elements using an invalid index")
    }
    return validatedBucket(for: index._asNative)
  }
}
extension _NativeSet {
  @usableFromInline
  internal typealias Index = Set<Element>.Index
  @inlinable internal var startIndex: Index {
    get {
    let bucket = hashTable.startBucket
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  }
  @inlinable internal var endIndex: Index {
    get {
    let bucket = hashTable.endBucket
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  }
  @inlinable internal func index(after index: Index) -> Index {
    // Note that _asNative forces this not to work on Cocoa indices.
    let bucket = validatedBucket(for: index._asNative)
    let next = hashTable.occupiedBucket(after: bucket)
    return Index(_native: _HashTable.Index(bucket: next, age: age))
  }
  @inlinable @inline(__always) internal func index(for element: Element) -> Index? {
    if count == 0 {
      // Fast path that avoids computing the hash of the key.
      return nil
    }
    let (bucket, found) = find(element)
    guard found else { return nil }
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
  @inlinable internal var count: Int {
    @inline(__always) get {
      return _assumeNonNegative(_storage._count)
    }
  }
  @inlinable @inline(__always) internal func contains(_ member: Element) -> Bool {
    // Fast path: Don't calculate the hash if the set has no elements.
    if count == 0 { return false }
    return find(member).found
  }
  @inlinable @inline(__always) internal func element(at index: Index) -> Element {
    let bucket = validatedBucket(for: index)
    return uncheckedElement(at: bucket)
  }
}
@usableFromInline
@inline(never) internal func ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_ elementType: Any.Type) -> Never
extension _NativeSet {
  @inlinable internal func _unsafeInsertNew(_ element: __owned Element) {
    _internalInvariant(count + 1 <= capacity)
    let hashValue = self.hashValue(for: element)
    if _isDebugAssertConfiguration() {
      // In debug builds, perform a full lookup and trap if we detect duplicate
      // elements -- these imply that the Element type violates Hashable
      // requirements. This is generally more costly than a direct insertion,
      // because we'll need to compare elements in case of hash collisions.
      let (bucket, found) = find(element, hashValue: hashValue)
      guard !found else {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(Element.self)
      }
      hashTable.insert(bucket)
      uncheckedInitialize(at: bucket, to: element)
    } else {
      let bucket = hashTable.insertNew(hashValue: hashValue)
      uncheckedInitialize(at: bucket, to: element)
    }
    _storage._count &+= 1
  }
  @inlinable mutating internal func insertNew(_ element: __owned Element, isUnique: Bool) {
    _ = ensureUnique(isUnique: isUnique, capacity: count + 1)
    _unsafeInsertNew(element)
  }
  @inlinable internal func _unsafeInsertNew(_ element: __owned Element, at bucket: Bucket) {
    hashTable.insert(bucket)
    uncheckedInitialize(at: bucket, to: element)
    _storage._count += 1
  }
  @inlinable mutating internal func insertNew(_ element: __owned Element, at bucket: Bucket, isUnique: Bool) {
    _internalInvariant(!hashTable.isOccupied(bucket))
    var bucket = bucket
    let rehashed = ensureUnique(isUnique: isUnique, capacity: count + 1)
    if rehashed {
      let (b, f) = find(element)
      if f {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(Element.self)
      }
      bucket = b
    }
    _unsafeInsertNew(element, at: bucket)
  }
  @inlinable mutating internal func update(with element: __owned Element, isUnique: Bool) -> Element? {
    var (bucket, found) = find(element)
    let rehashed = ensureUnique(
      isUnique: isUnique,
      capacity: count + (found ? 0 : 1))
    if rehashed {
      let (b, f) = find(element)
      if f != found {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(Element.self)
      }
      bucket = b
    }
    if found {
      let old = (_elements + bucket.offset).move()
      uncheckedInitialize(at: bucket, to: element)
      return old
    }
    _unsafeInsertNew(element, at: bucket)
    return nil
  }
  @_alwaysEmitIntoClient @inlinable mutating internal func _unsafeUpdate(with element: __owned Element) {
    let (bucket, found) = find(element)
    if found {
      uncheckedAssign(at: bucket, to: element)
    } else {
      _precondition(count < capacity)
      _unsafeInsertNew(element, at: bucket)
    }
  }
}
extension _NativeSet {
  @inlinable @inline(__always) internal func isEqual(to other: _NativeSet) -> Bool {
    if self._storage === other._storage { return true }
    if self.count != other.count { return false }

    for member in self {
      guard other.find(member).found else { return false }
    }
    return true
  }
  @inlinable internal func isEqual(to other: __CocoaSet) -> Bool {
    if self.count != other.count { return false }

    defer { _fixLifetime(self) }
    for bucket in self.hashTable {
      let key = self.uncheckedElement(at: bucket)
      let bridgedKey = _bridgeAnythingToObjectiveC(key)
      guard other.contains(bridgedKey) else { return false }
    }
    return true
  }
}
extension _NativeSet : _HashTableDelegate {
  @inlinable @inline(__always) internal func hashValue(at bucket: Bucket) -> Int {
    return hashValue(for: uncheckedElement(at: bucket))
  }
  @inlinable @inline(__always) internal func moveEntry(from source: Bucket, to target: Bucket) {
    (_elements + target.offset)
      .moveInitialize(from: _elements + source.offset, count: 1)
  }
}
extension _NativeSet {
  @inlinable @_effects(releasenone) mutating internal func _delete(at bucket: Bucket) {
    hashTable.delete(at: bucket, with: self)
    _storage._count -= 1
    _internalInvariant(_storage._count >= 0)
    invalidateIndices()
  }
  @inlinable @inline(__always) mutating internal func uncheckedRemove(at bucket: Bucket, isUnique: Bool) -> Element {
    _internalInvariant(hashTable.isOccupied(bucket))
    let rehashed = ensureUnique(isUnique: isUnique, capacity: capacity)
    _internalInvariant(!rehashed)
    let old = (_elements + bucket.offset).move()
    _delete(at: bucket)
    return old
  }
  @usableFromInline
  mutating internal func removeAll(isUnique: Bool)
}
extension _NativeSet : Sequence {
  @usableFromInline
  @_fixed_layout internal struct Iterator {
    @usableFromInline
    internal let base: _NativeSet
    @usableFromInline
    internal var iterator: _HashTable.Iterator
    @inlinable @inline(__always) internal init(_ base: __owned _NativeSet) {
      self.base = base
      self.iterator = base.hashTable.makeIterator()
    }
  }
  @inlinable @inline(__always) __consuming internal func makeIterator() -> Iterator {
    return Iterator(self)
  }
}
extension _NativeSet.Iterator : IteratorProtocol {
  @inlinable @inline(__always) mutating internal func next() -> Element? {
    guard let index = iterator.next() else { return nil }
    return base.uncheckedElement(at: index)
  }
}
public protocol _SwiftNewtypeWrapper : Swift.RawRepresentable, Swift._HasCustomAnyHashableRepresentation {
}
extension _SwiftNewtypeWrapper where Self : Swift.Hashable, Self.RawValue : Swift.Hashable {
  @inlinable public var hashValue: Int {
    get {
    return rawValue.hashValue
  }
  }
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine(rawValue)
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
    return rawValue._rawHashValue(seed: seed)
  }
}
extension _SwiftNewtypeWrapper {
  __consuming public func _toCustomAnyHashable() -> AnyHashable?
}
extension _SwiftNewtypeWrapper where Self : Swift.Hashable, Self.RawValue : Swift.Hashable {
  __consuming public func _toCustomAnyHashable() -> AnyHashable?
}
extension _SwiftNewtypeWrapper where Self.RawValue : Swift._ObjectiveCBridgeable {
  public typealias _ObjectiveCType = Self.RawValue._ObjectiveCType
  @inlinable public func _bridgeToObjectiveC() -> Self.RawValue._ObjectiveCType {
    return rawValue._bridgeToObjectiveC()
  }
  @inlinable public static func _forceBridgeFromObjectiveC(_ source: Self.RawValue._ObjectiveCType, result: inout Self?) {
    var innerResult: Self.RawValue?
    Self.RawValue._forceBridgeFromObjectiveC(source, result: &innerResult)
    result = innerResult.flatMap { Self(rawValue: $0) }
  }
  @inlinable public static func _conditionallyBridgeFromObjectiveC(_ source: Self.RawValue._ObjectiveCType, result: inout Self?) -> Bool {
    var innerResult: Self.RawValue?
    let success = Self.RawValue._conditionallyBridgeFromObjectiveC(
      source,
      result: &innerResult)
    result = innerResult.flatMap { Self(rawValue: $0) }
    return success
  }
  @inlinable @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Self.RawValue._ObjectiveCType?) -> Self {
    return Self(
      rawValue: Self.RawValue._unconditionallyBridgeFromObjectiveC(source))!
  }
}
extension _SwiftNewtypeWrapper where Self.RawValue : AnyObject {
  @inlinable public func _bridgeToObjectiveC() -> Self.RawValue {
    return rawValue
  }
  @inlinable public static func _forceBridgeFromObjectiveC(_ source: Self.RawValue, result: inout Self?) {
    result = Self(rawValue: source)
  }
  @inlinable public static func _conditionallyBridgeFromObjectiveC(_ source: Self.RawValue, result: inout Self?) -> Bool {
    result = Self(rawValue: source)
    return result != nil
  }
  @inlinable @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Self.RawValue?) -> Self {
    return Self(rawValue: source!)!
  }
}
@_fixed_layout public struct ObjectIdentifier {
  @usableFromInline
  internal let _value: Builtin.RawPointer
  @inlinable public init(_ x: AnyObject) {
    self._value = Builtin.bridgeToRawPointer(x)
  }
  @inlinable public init(_ x: Any.Type) {
    self._value = unsafeBitCast(x, to: Builtin.RawPointer.self)
  }
}
extension ObjectIdentifier : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension ObjectIdentifier : Equatable {
  @inlinable public static func == (x: ObjectIdentifier, y: ObjectIdentifier) -> Bool {
    return Bool(Builtin.cmp_eq_RawPointer(x._value, y._value))
  }
}
extension ObjectIdentifier : Comparable {
  @inlinable public static func < (lhs: ObjectIdentifier, rhs: ObjectIdentifier) -> Bool {
    return UInt(bitPattern: lhs) < UInt(bitPattern: rhs)
  }
}
extension ObjectIdentifier : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine(Int(Builtin.ptrtoint_Word(_value)))
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension UInt {
  @inlinable public init(bitPattern objectID: ObjectIdentifier) {
    self.init(Builtin.ptrtoint_Word(objectID._value))
  }
}
extension Int {
  @inlinable public init(bitPattern objectID: ObjectIdentifier) {
    self.init(bitPattern: UInt(bitPattern: objectID))
  }
}
@_frozen public enum Optional<Wrapped> : ExpressibleByNilLiteral {
  case none
  case some(Wrapped)
  @_transparent public init(_ some: Wrapped) { self = .some(some) }
  @inlinable public func map<U>(_ transform: (Wrapped) throws -> U) rethrows -> U? {
    switch self {
    case .some(let y):
      return .some(try transform(y))
    case .none:
      return .none
    }
  }
  @inlinable public func flatMap<U>(_ transform: (Wrapped) throws -> U?) rethrows -> U? {
    switch self {
    case .some(let y):
      return try transform(y)
    case .none:
      return .none
    }
  }
  @_transparent public init(nilLiteral: ()) {
    self = .none
  }
  @inlinable public var unsafelyUnwrapped: Wrapped {
    @inline(__always) get {
      if let x = self {
        return x
      }
      _debugPreconditionFailure("unsafelyUnwrapped of nil optional")
    }
  }
  @inlinable internal var _unsafelyUnwrappedUnchecked: Wrapped {
    @inline(__always) get {
      if let x = self {
        return x
      }
      _internalInvariantFailure("_unsafelyUnwrappedUnchecked of nil optional")
    }
  }
}
extension Optional : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension Optional : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
@_transparent public func _diagnoseUnexpectedNilOptional(_filenameStart: Builtin.RawPointer, _filenameLength: Builtin.Word, _filenameIsASCII: Builtin.Int1, _line: Builtin.Word, _isImplicitUnwrap: Builtin.Int1) {
  // Cannot use _preconditionFailure as the file and line info would not be
  // printed.
  preconditionFailure(
    Bool(_isImplicitUnwrap)
      ? "Unexpectedly found nil while implicitly unwrapping an Optional value"
      : "Unexpectedly found nil while unwrapping an Optional value",
    file: StaticString(_start: _filenameStart,
                       utf8CodeUnitCount: _filenameLength,
                       isASCII: _filenameIsASCII),
    line: UInt(_line))
}
extension Optional : Equatable where Wrapped : Swift.Equatable {
  @inlinable public static func == (lhs: Wrapped?, rhs: Wrapped?) -> Bool {
    switch (lhs, rhs) {
    case let (l?, r?):
      return l == r
    case (nil, nil):
      return true
    default:
      return false
    }
  }
}
extension Optional : Hashable where Wrapped : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    switch self {
    case .none:
      hasher.combine(0 as UInt8)
    case .some(let wrapped):
      hasher.combine(1 as UInt8)
      hasher.combine(wrapped)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_fixed_layout public struct _OptionalNilComparisonType : ExpressibleByNilLiteral {
  @_transparent public init(nilLiteral: ()) {
  }
}
extension Optional {
  @_transparent public static func ~= (lhs: _OptionalNilComparisonType, rhs: Wrapped?) -> Bool {
    switch rhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
  @_transparent public static func == (lhs: Wrapped?, rhs: _OptionalNilComparisonType) -> Bool {
    switch lhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
  @_transparent public static func != (lhs: Wrapped?, rhs: _OptionalNilComparisonType) -> Bool {
    switch lhs {
    case .some:
      return true
    case .none:
      return false
    }
  }
  @_transparent public static func == (lhs: _OptionalNilComparisonType, rhs: Wrapped?) -> Bool {
    switch rhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
  @_transparent public static func != (lhs: _OptionalNilComparisonType, rhs: Wrapped?) -> Bool {
    switch rhs {
    case .some:
      return true
    case .none:
      return false
    }
  }
}
@_transparent public func ?? <T>(optional: T?, defaultValue: @autoclosure () throws -> T) rethrows -> T {
  switch optional {
  case .some(let value):
    return value
  case .none:
    return try defaultValue()
  }
}
@_transparent public func ?? <T>(optional: T?, defaultValue: @autoclosure () throws -> T?) rethrows -> T? {
  switch optional {
  case .some(let value):
    return value
  case .none:
    return try defaultValue()
  }
}
extension Optional : _ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> AnyObject
  public static func _forceBridgeFromObjectiveC(_ source: AnyObject, result: inout Optional<Wrapped>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: AnyObject, result: inout Optional<Wrapped>?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: AnyObject?) -> Optional<Wrapped>
  public typealias _ObjectiveCType = Swift.AnyObject
}
public protocol OptionSet : Swift.RawRepresentable, Swift.SetAlgebra {
  associatedtype Element = Self
  init(rawValue: RawValue)
}
extension OptionSet {
  @inlinable public func union(_ other: Self) -> Self {
    var r: Self = Self(rawValue: self.rawValue)
    r.formUnion(other)
    return r
  }
  @inlinable public func intersection(_ other: Self) -> Self {
    var r = Self(rawValue: self.rawValue)
    r.formIntersection(other)
    return r
  }
  @inlinable public func symmetricDifference(_ other: Self) -> Self {
    var r = Self(rawValue: self.rawValue)
    r.formSymmetricDifference(other)
    return r
  }
}
extension OptionSet where Self == Self.Element {
  @inlinable public func contains(_ member: Self) -> Bool {
    return self.isSuperset(of: member)
  }
  @discardableResult
  @inlinable mutating public func insert(_ newMember: Element) -> (inserted: Bool, memberAfterInsert: Element) {
    let oldMember = self.intersection(newMember)
    let shouldInsert = oldMember != newMember
    let result = (
      inserted: shouldInsert,
      memberAfterInsert: shouldInsert ? newMember : oldMember)
    if shouldInsert {
      self.formUnion(newMember)
    }
    return result
  }
  @discardableResult
  @inlinable mutating public func remove(_ member: Element) -> Element? {
    let r = isSuperset(of: member) ? Optional(member) : nil
    self.subtract(member)
    return r
  }
  @discardableResult
  @inlinable mutating public func update(with newMember: Element) -> Element? {
    let r = self.intersection(newMember)
    self.formUnion(newMember)
    return r.isEmpty ? nil : r
  }
}
extension OptionSet where Self.RawValue : Swift.FixedWidthInteger {
  @inlinable public init() {
    self.init(rawValue: 0)
  }
  @inlinable mutating public func formUnion(_ other: Self) {
    self = Self(rawValue: self.rawValue | other.rawValue)
  }
  @inlinable mutating public func formIntersection(_ other: Self) {
    self = Self(rawValue: self.rawValue & other.rawValue)
  }
  @inlinable mutating public func formSymmetricDifference(_ other: Self) {
    self = Self(rawValue: self.rawValue ^ other.rawValue)
  }
}
public protocol TextOutputStream {
  mutating func _lock()
  mutating func _unlock()
  mutating func write(_ string: String)
  mutating func _writeASCII(_ buffer: UnsafeBufferPointer<UInt8>)
}
extension TextOutputStream {
  mutating public func _lock()
  mutating public func _unlock()
  mutating public func _writeASCII(_ buffer: UnsafeBufferPointer<UInt8>)
}
public protocol TextOutputStreamable {
  func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
public protocol CustomStringConvertible {
  var description: String { get }
}
public protocol LosslessStringConvertible : Swift.CustomStringConvertible {
  init?(_ description: String)
}
public protocol CustomDebugStringConvertible {
  var debugDescription: String { get }
}
@usableFromInline
@_semantics("optimize.sil.specialize.generic.never") internal func _print_unlocked<T, TargetStream>(_ value: T, _ target: inout TargetStream) where TargetStream : Swift.TextOutputStream
@_semantics("optimize.sil.specialize.generic.never") @inline(never) public func _debugPrint_unlocked<T, TargetStream>(_ value: T, _ target: inout TargetStream) where TargetStream : Swift.TextOutputStream
extension String : TextOutputStream {
  mutating public func write(_ other: String)
  mutating public func _writeASCII(_ buffer: UnsafeBufferPointer<UInt8>)
}
extension String : TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
extension Character : TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
extension Unicode.Scalar : TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
public var _playgroundPrintHook: ((String) -> Void)?
public protocol _Pointer : Swift.CustomDebugStringConvertible, Swift.CustomReflectable, Swift.Hashable, Swift.Strideable {
  typealias Distance = Int
  associatedtype Pointee
  var _rawValue: Builtin.RawPointer { get }
  init(_ _rawValue: Builtin.RawPointer)
}
extension _Pointer {
  @_transparent public init(_ from: OpaquePointer) {
    self.init(from._rawValue)
  }
  @_transparent public init?(_ from: OpaquePointer?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
  @_transparent public init?(bitPattern: Int) {
    if bitPattern == 0 { return nil }
    self.init(Builtin.inttoptr_Word(bitPattern._builtinWordValue))
  }
  @_transparent public init?(bitPattern: UInt) {
    if bitPattern == 0 { return nil }
    self.init(Builtin.inttoptr_Word(bitPattern._builtinWordValue))
  }
  @_transparent public init(_ other: Self) {
    self.init(other._rawValue)
  }
  @_transparent public init?(_ other: Self?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped._rawValue)
  }
}
extension _Pointer {
  @_transparent public static func == (lhs: Self, rhs: Self) -> Bool {
    return Bool(Builtin.cmp_eq_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}
extension _Pointer {
  @_transparent public static func < (lhs: Self, rhs: Self) -> Bool {
    return Bool(Builtin.cmp_ult_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}
extension _Pointer {
  @_transparent public func successor() -> Self {
    return advanced(by: 1)
  }
  @_transparent public func predecessor() -> Self {
    return advanced(by: -1)
  }
  @_transparent public func distance(to end: Self) -> Int {
    return
      Int(Builtin.sub_Word(Builtin.ptrtoint_Word(end._rawValue),
                           Builtin.ptrtoint_Word(_rawValue)))
      / MemoryLayout<Pointee>.stride
  }
  @_transparent public func advanced(by n: Int) -> Self {
    return Self(Builtin.gep_Word(
      self._rawValue, n._builtinWordValue, Pointee.self))
  }
}
extension _Pointer {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine(UInt(bitPattern: self))
  }
  @inlinable public func _rawHashValue(seed: Int) -> Int {
    return Hasher._hash(seed: seed, UInt(bitPattern: self))
  }
}
extension _Pointer {
  public var debugDescription: String {
    get
  }
}
extension _Pointer {
  public var customMirror: Mirror {
    get
  }
}
extension Int {
  @_transparent public init<P>(bitPattern pointer: P?) where P : Swift._Pointer {
    if let pointer = pointer {
      self = Int(Builtin.ptrtoint_Word(pointer._rawValue))
    } else {
      self = 0
    }
  }
}
extension UInt {
  @_transparent public init<P>(bitPattern pointer: P?) where P : Swift._Pointer {
    if let pointer = pointer {
      self = UInt(Builtin.ptrtoint_Word(pointer._rawValue))
    } else {
      self = 0
    }
  }
}
extension Strideable where Self : Swift._Pointer {
  @_transparent public static func + (lhs: Self, rhs: Self.Stride) -> Self {
    return lhs.advanced(by: rhs)
  }
  @_transparent public static func + (lhs: Self.Stride, rhs: Self) -> Self {
    return rhs.advanced(by: lhs)
  }
  @_transparent public static func - (lhs: Self, rhs: Self.Stride) -> Self {
    return lhs.advanced(by: -rhs)
  }
  @_transparent public static func - (lhs: Self, rhs: Self) -> Self.Stride {
    return rhs.distance(to: lhs)
  }
  @_transparent public static func += (lhs: inout Self, rhs: Self.Stride) {
    lhs = lhs.advanced(by: rhs)
  }
  @_transparent public static func -= (lhs: inout Self, rhs: Self.Stride) {
    lhs = lhs.advanced(by: -rhs)
  }
}
@_transparent public func _convertPointerToPointerArgument<FromPointer, ToPointer>(_ from: FromPointer) -> ToPointer where FromPointer : Swift._Pointer, ToPointer : Swift._Pointer {
  return ToPointer(from._rawValue)
}
@_transparent public func _convertInOutToPointerArgument<ToPointer>(_ from: Builtin.RawPointer) -> ToPointer where ToPointer : Swift._Pointer {
  return ToPointer(from)
}
@_transparent public func _convertConstArrayToPointerArgument<FromElement, ToPointer>(_ arr: [FromElement]) -> (AnyObject?, ToPointer) where ToPointer : Swift._Pointer {
  let (owner, opaquePointer) = arr._cPointerArgs()

  let validPointer: ToPointer
  if let addr = opaquePointer {
    validPointer = ToPointer(addr._rawValue)
  } else {
    let lastAlignedValue = ~(MemoryLayout<FromElement>.alignment - 1)
    let lastAlignedPointer = UnsafeRawPointer(bitPattern: lastAlignedValue)!
    validPointer = ToPointer(lastAlignedPointer._rawValue)
  }
  return (owner, validPointer)
}
@_transparent public func _convertMutableArrayToPointerArgument<FromElement, ToPointer>(_ a: inout [FromElement]) -> (AnyObject?, ToPointer) where ToPointer : Swift._Pointer {
  // TODO: Putting a canary at the end of the array in checked builds might
  // be a good idea

  // Call reserve to force contiguous storage.
  a.reserveCapacity(0)
  _debugPrecondition(a._baseAddressIfContiguous != nil || a.isEmpty)

  return _convertConstArrayToPointerArgument(a)
}
public func _convertConstStringToUTF8PointerArgument<ToPointer>(_ str: String) -> (AnyObject?, ToPointer) where ToPointer : Swift._Pointer
@_frozen public enum Never {
}
extension Never : Error {
}
extension Never : Equatable {
  public static func == (a: Swift.Never, b: Swift.Never) -> Swift.Bool
}
extension Never : Comparable {
  public static func < (lhs: Never, rhs: Never) -> Bool
}
extension Never : Hashable {
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public typealias Void = ()
public typealias Float32 = Float
public typealias Float64 = Double
public typealias IntegerLiteralType = Int
public typealias FloatLiteralType = Double
public typealias BooleanLiteralType = Bool
public typealias UnicodeScalarType = String
public typealias ExtendedGraphemeClusterType = String
public typealias StringLiteralType = String
public typealias _MaxBuiltinFloatType = Builtin.FPIEEE80
public typealias AnyObject = Builtin.AnyObject
public typealias AnyClass = AnyObject.Type
@_transparent public func ~= <T>(a: T, b: T) -> Bool where T : Swift.Equatable {
  return a == b
}
precedencegroup AssignmentPrecedence {
  associativity: right
  assignment: true
}
precedencegroup FunctionArrowPrecedence {
  associativity: right
  higherThan: AssignmentPrecedence
}
precedencegroup TernaryPrecedence {
  associativity: right
  higherThan: FunctionArrowPrecedence
}
precedencegroup DefaultPrecedence {
  higherThan: TernaryPrecedence
}
precedencegroup LogicalDisjunctionPrecedence {
  associativity: left
  higherThan: TernaryPrecedence
}
precedencegroup LogicalConjunctionPrecedence {
  associativity: left
  higherThan: LogicalDisjunctionPrecedence
}
precedencegroup ComparisonPrecedence {
  higherThan: LogicalConjunctionPrecedence
}
precedencegroup NilCoalescingPrecedence {
  associativity: right
  higherThan: ComparisonPrecedence
}
precedencegroup CastingPrecedence {
  higherThan: NilCoalescingPrecedence
}
precedencegroup RangeFormationPrecedence {
  higherThan: CastingPrecedence
}
precedencegroup AdditionPrecedence {
  associativity: left
  higherThan: RangeFormationPrecedence
}
precedencegroup MultiplicationPrecedence {
  associativity: left
  higherThan: AdditionPrecedence
}
precedencegroup BitwiseShiftPrecedence {
  higherThan: MultiplicationPrecedence
}
postfix operator ++
postfix operator --
postfix operator ... : Comparable
prefix operator ++
prefix operator --
prefix operator ! : Bool
prefix operator ~ : BinaryInteger
prefix operator + : AdditiveArithmetic
prefix operator - : SignedNumeric
prefix operator ... : Comparable
prefix operator ..< : Comparable
infix operator << : BitwiseShiftPrecedence, BinaryInteger
infix operator &<< : BitwiseShiftPrecedence, FixedWidthInteger
infix operator >> : BitwiseShiftPrecedence, BinaryInteger
infix operator &>> : BitwiseShiftPrecedence, FixedWidthInteger
infix operator * : MultiplicationPrecedence, Numeric
infix operator &* : MultiplicationPrecedence, FixedWidthInteger
infix operator / : MultiplicationPrecedence, BinaryInteger, FloatingPoint
infix operator % : MultiplicationPrecedence, BinaryInteger
infix operator & : MultiplicationPrecedence, BinaryInteger
infix operator + : AdditionPrecedence, AdditiveArithmetic, String, Array, Strideable
infix operator &+ : AdditionPrecedence, FixedWidthInteger
infix operator - : AdditionPrecedence, AdditiveArithmetic, Strideable
infix operator &- : AdditionPrecedence, FixedWidthInteger
infix operator | : AdditionPrecedence, BinaryInteger
infix operator ^ : AdditionPrecedence, BinaryInteger
infix operator ... : RangeFormationPrecedence, Comparable
infix operator ..< : RangeFormationPrecedence, Comparable
infix operator ?? : NilCoalescingPrecedence
infix operator < : ComparisonPrecedence, Comparable
infix operator <= : ComparisonPrecedence, Comparable
infix operator > : ComparisonPrecedence, Comparable
infix operator >= : ComparisonPrecedence, Comparable
infix operator == : ComparisonPrecedence, Equatable
infix operator != : ComparisonPrecedence, Equatable
infix operator === : ComparisonPrecedence
infix operator !== : ComparisonPrecedence
infix operator ~= : ComparisonPrecedence
infix operator && : LogicalConjunctionPrecedence, Bool
infix operator || : LogicalDisjunctionPrecedence, Bool
infix operator *= : AssignmentPrecedence, Numeric
infix operator &*= : AssignmentPrecedence, FixedWidthInteger
infix operator /= : AssignmentPrecedence, BinaryInteger
infix operator %= : AssignmentPrecedence, BinaryInteger
infix operator += : AssignmentPrecedence, AdditiveArithmetic, String, Array, Strideable
infix operator &+= : AssignmentPrecedence, FixedWidthInteger
infix operator -= : AssignmentPrecedence, AdditiveArithmetic, Strideable
infix operator &-= : AssignmentPrecedence, FixedWidthInteger
infix operator <<= : AssignmentPrecedence, BinaryInteger
infix operator &<<= : AssignmentPrecedence, FixedWidthInteger
infix operator >>= : AssignmentPrecedence, BinaryInteger
infix operator &>>= : AssignmentPrecedence, FixedWidthInteger
infix operator &= : AssignmentPrecedence, BinaryInteger
infix operator ^= : AssignmentPrecedence, BinaryInteger
infix operator |= : AssignmentPrecedence, BinaryInteger
infix operator ~> : DefaultPrecedence
@_fixed_layout public struct LazyPrefixWhileSequence<Base> where Base : Swift.Sequence {
  public typealias Element = Base.Element
  @inlinable internal init(_base: Base, predicate: @escaping (Element) -> Bool) {
    self._base = _base
    self._predicate = predicate
  }
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal let _predicate: (Element) -> Bool
}
extension LazyPrefixWhileSequence {
  @_fixed_layout public struct Iterator {
    public typealias Element = Base.Element
    @usableFromInline
    internal var _predicateHasFailed: Swift.Bool = false
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal let _predicate: (Element) -> Bool
    @inlinable internal init(_base: Base.Iterator, predicate: @escaping (Element) -> Bool) {
      self._base = _base
      self._predicate = predicate
    }
  }
}
extension LazyPrefixWhileSequence.Iterator : IteratorProtocol, Sequence {
  @inlinable mutating public func next() -> Element? {
    // Return elements from the base iterator until one fails the predicate.
    if !_predicateHasFailed, let nextElement = _base.next() {
      if _predicate(nextElement) {
        return nextElement
      } else {
        _predicateHasFailed = true
      }
    }
    return nil
  }
  public typealias Iterator = Swift.LazyPrefixWhileSequence<Base>.Iterator
}
extension LazyPrefixWhileSequence : Sequence {
  @inlinable __consuming public func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator(), predicate: _predicate)
  }
}
extension LazyPrefixWhileSequence : LazySequenceProtocol {
  public typealias Elements = LazyPrefixWhileSequence
}
extension LazySequenceProtocol {
  @inlinable __consuming public func prefix(while predicate: @escaping (Elements.Element) -> Bool) -> LazyPrefixWhileSequence<Self.Elements> {
    return LazyPrefixWhileSequence(_base: self.elements, predicate: predicate)
  }
}
public typealias LazyPrefixWhileCollection<T> = LazyPrefixWhileSequence<T> where T : Swift.Collection
extension LazyPrefixWhileSequence where Base : Swift.Collection {
  @usableFromInline
  @_frozen internal enum _IndexRepresentation {
    case index(Base.Index)
    case pastEnd
  }
  @_fixed_layout public struct Index {
    @usableFromInline
    internal let _value: _IndexRepresentation
    @inlinable internal init(_ i: Base.Index) {
      self._value = .index(i)
    }
    @inlinable internal init(endOf: Base) {
      self._value = .pastEnd
    }
  }
}
extension LazyPrefixWhileSequence.Index : Comparable {
  @inlinable public static func == (lhs: LazyPrefixWhileCollection<Base>.Index, rhs: LazyPrefixWhileCollection<Base>.Index) -> Bool {
    switch (lhs._value, rhs._value) {
    case let (.index(l), .index(r)):
      return l == r
    case (.pastEnd, .pastEnd):
      return true
    case (.pastEnd, .index), (.index, .pastEnd):
      return false
    }
  }
  @inlinable public static func < (lhs: LazyPrefixWhileCollection<Base>.Index, rhs: LazyPrefixWhileCollection<Base>.Index) -> Bool {
    switch (lhs._value, rhs._value) {
    case let (.index(l), .index(r)):
      return l < r
    case (.index, .pastEnd):
      return true
    case (.pastEnd, _):
      return false
    }
  }
}
extension LazyPrefixWhileSequence.Index : Hashable where Base.Index : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    switch _value {
    case .index(let value):
      hasher.combine(value)
    case .pastEnd:
      hasher.combine(Int.max)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension LazyPrefixWhileSequence : Collection where Base : Swift.Collection {
  public typealias SubSequence = Slice<LazyPrefixWhileCollection<Base>>
  @inlinable public var startIndex: Index {
    get {
    return Index(_base.startIndex)
  }
  }
  @inlinable public var endIndex: Index {
    get {
    // If the first element of `_base` satisfies the predicate, there is at
    // least one element in the lazy collection: Use the explicit `.pastEnd` index.
    if let first = _base.first, _predicate(first) {
      return Index(endOf: _base)
    }

    // `_base` is either empty or `_predicate(_base.first!) == false`. In either
    // case, the lazy collection is empty, so `endIndex == startIndex`.
    return startIndex
  }
  }
  @inlinable public func index(after i: Index) -> Index {
    _precondition(i != endIndex, "Can't advance past endIndex")
    guard case .index(let i) = i._value else {
      _preconditionFailure("Invalid index passed to index(after:)")
    }
    let nextIndex = _base.index(after: i)
    guard nextIndex != _base.endIndex && _predicate(_base[nextIndex]) else {
      return Index(endOf: _base)
    }
    return Index(nextIndex)
  }
  @inlinable public subscript(position: Index) -> Element {
    get {
    switch position._value {
    case .index(let i):
      return _base[i]
    case .pastEnd:
      _preconditionFailure("Index out of range")
    }
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.LazyPrefixWhileSequence<Base>>
}
extension LazyPrefixWhileSequence : LazyCollectionProtocol where Base : Swift.Collection {
}
extension LazyPrefixWhileSequence : BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Index) -> Index {
    switch i._value {
    case .index(let i):
      _precondition(i != _base.startIndex, "Can't move before startIndex")
      return Index(_base.index(before: i))
    case .pastEnd:
      // Look for the position of the last element in a non-empty
      // prefix(while:) collection by searching forward for a predicate
      // failure.

      // Safe to assume that `_base.startIndex != _base.endIndex`; if they
      // were equal, `_base.startIndex` would be used as the `endIndex` of
      // this collection.
      _internalInvariant(!_base.isEmpty)
      var result = _base.startIndex
      while true {
        let next = _base.index(after: result)
        if next == _base.endIndex || !_predicate(_base[next]) {
          break
        }
        result = next
      }
      return Index(result)
    }
  }
}
public func print(_ items: Any..., separator: String = " ", terminator: String = "\n")
public func debugPrint(_ items: Any..., separator: String = " ", terminator: String = "\n")
public func print<Target>(_ items: Any..., separator: String = " ", terminator: String = "\n", to output: inout Target) where Target : Swift.TextOutputStream
public func debugPrint<Target>(_ items: Any..., separator: String = " ", terminator: String = "\n", to output: inout Target) where Target : Swift.TextOutputStream
public protocol RandomNumberGenerator {
  mutating func next() -> UInt64
}
extension RandomNumberGenerator {
  @inlinable mutating public func next<T>() -> T where T : Swift.FixedWidthInteger, T : Swift.UnsignedInteger {
    return T._random(using: &self)
  }
  @inlinable mutating public func next<T>(upperBound: T) -> T where T : Swift.FixedWidthInteger, T : Swift.UnsignedInteger {
    _precondition(upperBound != 0, "upperBound cannot be zero.")
    let tmp = (T.max % upperBound) + 1
    let range = tmp == upperBound ? 0 : tmp
    var random: T = 0

    repeat {
      random = next()
    } while random < range

    return random % upperBound
  }
}
@_fixed_layout public struct SystemRandomNumberGenerator : RandomNumberGenerator {
  @inlinable public init() { }
  @inlinable mutating public func next() -> UInt64 {
    var random: UInt64 = 0
    swift_stdlib_random(&random, MemoryLayout<UInt64>.size)
    return random
  }
}
public protocol RandomAccessCollection : Swift.BidirectionalCollection where Self.Indices : Swift.RandomAccessCollection, Self.SubSequence : Swift.RandomAccessCollection {
  override associatedtype Element
  override associatedtype Index
  override associatedtype SubSequence
  override associatedtype Indices
  override var indices: Indices { get }
  override subscript(bounds: Range<Index>) -> SubSequence { get }
  @_borrowed override subscript(position: Index) -> Element { get }
  override var startIndex: Index { get }
  override var endIndex: Index { get }
  override func index(before i: Index) -> Index
  override func formIndex(before i: inout Index)
  override func index(after i: Index) -> Index
  override func formIndex(after i: inout Index)
  @_nonoverride func index(_ i: Index, offsetBy distance: Int) -> Index
  @_nonoverride func index(_ i: Index, offsetBy distance: Int, limitedBy limit: Index) -> Index?
  @_nonoverride func distance(from start: Index, to end: Index) -> Int
}
extension RandomAccessCollection {
  @inlinable public func index(_ i: Index, offsetBy distance: Int, limitedBy limit: Index) -> Index? {
    // FIXME: swift-3-indexing-model: tests.
    let l = self.distance(from: i, to: limit)
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return index(i, offsetBy: distance)
  }
}
extension RandomAccessCollection where Self.Index : Swift.Strideable, Self.Index.Stride == Swift.Int {
  @_implements(Swift.Collection, Indices) public typealias _Default_Indices = Range<Index>
}
extension RandomAccessCollection where Self.Index : Swift.Strideable, Self.Indices == Swift.Range<Self.Index>, Self.Index.Stride == Swift.Int {
  @inlinable public var indices: Range<Index> {
    get {
    return startIndex..<endIndex
  }
  }
  @inlinable public func index(after i: Index) -> Index {
    // FIXME: swift-3-indexing-model: tests for the trap.
    _failEarlyRangeCheck(
      i, bounds: Range(uncheckedBounds: (startIndex, endIndex)))
    return i.advanced(by: 1)
  }
  @inlinable public func index(before i: Index) -> Index {
    let result = i.advanced(by: -1)
    // FIXME: swift-3-indexing-model: tests for the trap.
    _failEarlyRangeCheck(
      result, bounds: Range(uncheckedBounds: (startIndex, endIndex)))
    return result
  }
  @inlinable public func index(_ i: Index, offsetBy distance: Index.Stride) -> Index {
    let result = i.advanced(by: distance)
    // This range check is not precise, tighter bounds exist based on `n`.
    // Unfortunately, we would need to perform index manipulation to
    // compute those bounds, which is probably too slow in the general
    // case.
    // FIXME: swift-3-indexing-model: tests for the trap.
    _failEarlyRangeCheck(
      result, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    return result
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Index.Stride {
    // FIXME: swift-3-indexing-model: tests for traps.
    _failEarlyRangeCheck(
      start, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    _failEarlyRangeCheck(
      end, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    return start.distance(to: end)
  }
}
public protocol RangeExpression {
  associatedtype Bound : Swift.Comparable
  func relative<C>(to collection: C) -> Range<Bound> where C : Swift.Collection, Self.Bound == C.Index
  func contains(_ element: Bound) -> Bool
}
extension RangeExpression {
  @inlinable public static func ~= (pattern: Self, value: Bound) -> Bool {
    return pattern.contains(value)
  }
}
@_fixed_layout public struct Range<Bound> where Bound : Swift.Comparable {
  public let lowerBound: Bound
  public let upperBound: Bound
  @inlinable public init(uncheckedBounds bounds: (lower: Bound, upper: Bound)) {
    self.lowerBound = bounds.lower
    self.upperBound = bounds.upper
  }
  @inlinable public func contains(_ element: Bound) -> Bool {
    return lowerBound <= element && element < upperBound
  }
  @inlinable public var isEmpty: Bool {
    get {
    return lowerBound == upperBound
  }
  }
}
extension Range : Sequence where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public typealias Element = Bound
  public typealias Iterator = IndexingIterator<Range<Bound>>
}
extension Range : Collection, BidirectionalCollection, RandomAccessCollection where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public typealias Index = Bound
  public typealias Indices = Range<Bound>
  public typealias SubSequence = Range<Bound>
  @inlinable public var startIndex: Index {
    get { return lowerBound }
  }
  @inlinable public var endIndex: Index {
    get { return upperBound }
  }
  @inlinable public func index(after i: Index) -> Index {
    _failEarlyRangeCheck(i, bounds: startIndex..<endIndex)

    return i.advanced(by: 1)
  }
  @inlinable public func index(before i: Index) -> Index {
    _precondition(i > lowerBound)
    _precondition(i <= upperBound)

    return i.advanced(by: -1)
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int) -> Index {
    let r = i.advanced(by: numericCast(n))
    _precondition(r >= lowerBound)
    _precondition(r <= upperBound)
    return r
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    return numericCast(start.distance(to: end))
  }
  @inlinable public subscript(bounds: Range<Index>) -> Range<Bound> {
    get {
    return bounds
  }
  }
  @inlinable public var indices: Indices {
    get {
    return self
  }
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Bool? {
    return lowerBound <= element && element < upperBound
  }
  @inlinable public func _customIndexOfEquatableElement(_ element: Bound) -> Index?? {
    return lowerBound <= element && element < upperBound ? element : nil
  }
  @inlinable public func _customLastIndexOfEquatableElement(_ element: Bound) -> Index?? {
    // The first and last elements are the same because each element is unique.
    return _customIndexOfEquatableElement(element)
  }
  @inlinable public subscript(position: Index) -> Element {
    get {
    // FIXME: swift-3-indexing-model: tests for the range check.
    _debugPrecondition(self.contains(position), "Index out of range")
    return position
  }
  }
}
extension Range where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public init(_ other: ClosedRange<Bound>)
}
extension Range : RangeExpression {
  @inlinable public func relative<C>(to collection: C) -> Range<Bound> where Bound == C.Index, C : Swift.Collection {
    return Range(uncheckedBounds: (lower: lowerBound, upper: upperBound))
  }
}
extension Range {
  @inlinable @inline(__always) public func clamped(to limits: Range) -> Range {
    let lower =         
      limits.lowerBound > self.lowerBound ? limits.lowerBound
          : limits.upperBound < self.lowerBound ? limits.upperBound
          : self.lowerBound
    let upper =
      limits.upperBound < self.upperBound ? limits.upperBound
          : limits.lowerBound > self.upperBound ? limits.lowerBound
          : self.upperBound
    return Range(uncheckedBounds: (lower: lower, upper: upper))
  }
}
extension Range : CustomStringConvertible {
  @inlinable public var description: String {
    get {
    return "\(lowerBound)..<\(upperBound)"
  }
  }
}
extension Range : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension Range : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Range : Equatable {
  @inlinable public static func == (lhs: Range<Bound>, rhs: Range<Bound>) -> Bool {
    return
      lhs.lowerBound == rhs.lowerBound &&
      lhs.upperBound == rhs.upperBound
  }
}
extension Range : Hashable where Bound : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine(lowerBound)
    hasher.combine(upperBound)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Range : Decodable where Bound : Swift.Decodable {
  public init(from decoder: Decoder) throws
}
extension Range : Encodable where Bound : Swift.Encodable {
  public func encode(to encoder: Encoder) throws
}
@_fixed_layout public struct PartialRangeUpTo<Bound> where Bound : Swift.Comparable {
  public let upperBound: Bound
  @inlinable public init(_ upperBound: Bound) { self.upperBound = upperBound }
}
extension PartialRangeUpTo : RangeExpression {
  @_transparent public func relative<C>(to collection: C) -> Range<Bound> where Bound == C.Index, C : Swift.Collection {
    return collection.startIndex..<self.upperBound
  }
  @_transparent public func contains(_ element: Bound) -> Bool {
    return element < upperBound
  }
}
extension PartialRangeUpTo : Decodable where Bound : Swift.Decodable {
  public init(from decoder: Decoder) throws
}
extension PartialRangeUpTo : Encodable where Bound : Swift.Encodable {
  public func encode(to encoder: Encoder) throws
}
@_fixed_layout public struct PartialRangeThrough<Bound> where Bound : Swift.Comparable {
  public let upperBound: Bound
  @inlinable public init(_ upperBound: Bound) { self.upperBound = upperBound }
}
extension PartialRangeThrough : RangeExpression {
  @_transparent public func relative<C>(to collection: C) -> Range<Bound> where Bound == C.Index, C : Swift.Collection {
    return collection.startIndex..<collection.index(after: self.upperBound)
  }
  @_transparent public func contains(_ element: Bound) -> Bool {
    return element <= upperBound
  }
}
extension PartialRangeThrough : Decodable where Bound : Swift.Decodable {
  public init(from decoder: Decoder) throws
}
extension PartialRangeThrough : Encodable where Bound : Swift.Encodable {
  public func encode(to encoder: Encoder) throws
}
@_fixed_layout public struct PartialRangeFrom<Bound> where Bound : Swift.Comparable {
  public let lowerBound: Bound
  @inlinable public init(_ lowerBound: Bound) { self.lowerBound = lowerBound }
}
extension PartialRangeFrom : RangeExpression {
  @_transparent public func relative<C>(to collection: C) -> Range<Bound> where Bound == C.Index, C : Swift.Collection {
    return self.lowerBound..<collection.endIndex
  }
  @inlinable public func contains(_ element: Bound) -> Bool {
    return lowerBound <= element
  }
}
extension PartialRangeFrom : Sequence where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public typealias Element = Bound
  @_fixed_layout public struct Iterator : IteratorProtocol {
    @usableFromInline
    internal var _current: Bound
    @inlinable public init(_current: Bound) { self._current = _current }
    @inlinable mutating public func next() -> Bound? {
      defer { _current = _current.advanced(by: 1) }
      return _current
    }
    public typealias Element = Bound
  }
  @inlinable __consuming public func makeIterator() -> Iterator { 
    return Iterator(_current: lowerBound) 
  }
}
extension PartialRangeFrom : Decodable where Bound : Swift.Decodable {
  public init(from decoder: Decoder) throws
}
extension PartialRangeFrom : Encodable where Bound : Swift.Encodable {
  public func encode(to encoder: Encoder) throws
}
extension Comparable {
  @_transparent public static func ..< (minimum: Self, maximum: Self) -> Range<Self> {
    _precondition(minimum <= maximum,
      "Can't form Range with upperBound < lowerBound")
    return Range(uncheckedBounds: (lower: minimum, upper: maximum))
  }
  @_transparent prefix public static func ..< (maximum: Self) -> PartialRangeUpTo<Self> {
    return PartialRangeUpTo(maximum)
  }
  @_transparent prefix public static func ... (maximum: Self) -> PartialRangeThrough<Self> {
    return PartialRangeThrough(maximum)
  }
  @_transparent postfix public static func ... (minimum: Self) -> PartialRangeFrom<Self> {
    return PartialRangeFrom(minimum)
  }
}
@_frozen public enum UnboundedRange_ {
  postfix public static func ... (_: UnboundedRange_)
}
public typealias UnboundedRange = (UnboundedRange_) -> ()
extension Collection {
  @inlinable public subscript<R>(r: R) -> SubSequence where R : Swift.RangeExpression, Self.Index == R.Bound {
    get {
    return self[r.relative(to: self)]
  }
  }
  @inlinable public subscript(x: UnboundedRange) -> SubSequence {
    get {
    return self[startIndex...]
  }
  }
}
extension MutableCollection {
  @inlinable public subscript<R>(r: R) -> SubSequence where R : Swift.RangeExpression, Self.Index == R.Bound {
    get {
      return self[r.relative(to: self)]
    }
    set {
      self[r.relative(to: self)] = newValue
    }
  }
  @inlinable public subscript(x: UnboundedRange) -> SubSequence {
    get {
      return self[startIndex...]
    }
    set {
      self[startIndex...] = newValue
    }
  }
}
extension Range {
  @inlinable public func overlaps(_ other: Range<Bound>) -> Bool {
    return (!other.isEmpty && self.contains(other.lowerBound))
        || (!self.isEmpty && other.contains(self.lowerBound))
  }
  @inlinable public func overlaps(_ other: ClosedRange<Bound>) -> Bool {
    return self.contains(other.lowerBound)
        || (!self.isEmpty && other.contains(self.lowerBound))
  }
}
public typealias CountableRange<Bound> = Range<Bound> where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger
public typealias CountablePartialRangeFrom<Bound> = PartialRangeFrom<Bound> where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger
public protocol RangeReplaceableCollection : Swift.Collection where Self.SubSequence : Swift.RangeReplaceableCollection {
  override associatedtype SubSequence
  init()
  mutating func replaceSubrange<C>(_ subrange: Range<Index>, with newElements: __owned C) where C : Swift.Collection, Self.Element == C.Element
  mutating func reserveCapacity(_ n: Int)
  init(repeating repeatedValue: Element, count: Int)
  init<S>(_ elements: S) where S : Swift.Sequence, Self.Element == S.Element
  mutating func append(_ newElement: __owned Element)
  mutating func append<S>(contentsOf newElements: __owned S) where S : Swift.Sequence, Self.Element == S.Element
  mutating func insert(_ newElement: __owned Element, at i: Index)
  mutating func insert<S>(contentsOf newElements: __owned S, at i: Index) where S : Swift.Collection, Self.Element == S.Element
  @discardableResult
  mutating func remove(at i: Index) -> Element
  mutating func removeSubrange(_ bounds: Range<Index>)
  mutating func _customRemoveLast() -> Element?
  mutating func _customRemoveLast(_ n: Int) -> Bool
  @discardableResult
  mutating func removeFirst() -> Element
  mutating func removeFirst(_ k: Int)
  mutating func removeAll(keepingCapacity keepCapacity: Bool)
  mutating func removeAll(where shouldBeRemoved: (Element) throws -> Bool) rethrows
  @_borrowed override subscript(bounds: Index) -> Element { get }
  override subscript(bounds: Range<Index>) -> SubSequence { get }
}
extension RangeReplaceableCollection {
  @inlinable public init(repeating repeatedValue: Element, count: Int) {
    self.init()
    if count != 0 {
      let elements = Repeated(_repeating: repeatedValue, count: count)
      append(contentsOf: elements)
    }
  }
  @inlinable public init<S>(_ elements: S) where S : Swift.Sequence, Self.Element == S.Element {
    self.init()
    append(contentsOf: elements)
  }
  @inlinable mutating public func append(_ newElement: __owned Element) {
    insert(newElement, at: endIndex)
  }
  @inlinable mutating public func append<S>(contentsOf newElements: __owned S) where S : Swift.Sequence, Self.Element == S.Element {

    let approximateCapacity = self.count +
      numericCast(newElements.underestimatedCount)
    self.reserveCapacity(approximateCapacity)
    for element in newElements {
      append(element)
    }
  }
  @inlinable mutating public func insert(_ newElement: __owned Element, at i: Index) {
    replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
  @inlinable mutating public func insert<C>(contentsOf newElements: __owned C, at i: Index) where C : Swift.Collection, Self.Element == C.Element {
    replaceSubrange(i..<i, with: newElements)
  }
  @discardableResult
  @inlinable mutating public func remove(at position: Index) -> Element {
    _precondition(!isEmpty, "Can't remove from an empty collection")
    let result: Element = self[position]
    replaceSubrange(position..<index(after: position), with: EmptyCollection())
    return result
  }
  @inlinable mutating public func removeSubrange(_ bounds: Range<Index>) {
    replaceSubrange(bounds, with: EmptyCollection())
  }
  @inlinable mutating public func removeFirst(_ k: Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    _precondition(count >= k,
      "Can't remove more items from a collection than it has")
    let end = index(startIndex, offsetBy: k)
    removeSubrange(startIndex..<end)
  }
  @discardableResult
  @inlinable mutating public func removeFirst() -> Element {
    _precondition(!isEmpty,
      "Can't remove first element from an empty collection")
    let firstElement = first!
    removeFirst(1)
    return firstElement
  }
  @inlinable mutating public func removeAll(keepingCapacity keepCapacity: Bool = false) {
    if !keepCapacity {
      self = Self()
    }
    else {
      replaceSubrange(startIndex..<endIndex, with: EmptyCollection())
    }
  }
  @inlinable mutating public func reserveCapacity(_ n: Int) {}
}
extension RangeReplaceableCollection where Self == Self.SubSequence {
  @discardableResult
  @inlinable mutating public func removeFirst() -> Element {
    _precondition(!isEmpty, "Can't remove items from an empty collection")
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
  @inlinable mutating public func removeFirst(_ k: Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    _precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    self = self[index(startIndex, offsetBy: k)..<endIndex]
  }
}
extension RangeReplaceableCollection {
  @inlinable mutating public func replaceSubrange<C, R>(_ subrange: R, with newElements: __owned C) where C : Swift.Collection, R : Swift.RangeExpression, Self.Element == C.Element, Self.Index == R.Bound {
    self.replaceSubrange(subrange.relative(to: self), with: newElements)
  }
  @inlinable mutating public func removeSubrange<R>(_ bounds: R) where R : Swift.RangeExpression, Self.Index == R.Bound {
    removeSubrange(bounds.relative(to: self))
  }
}
extension RangeReplaceableCollection {
  @inlinable mutating public func _customRemoveLast() -> Element? {
    return nil
  }
  @inlinable mutating public func _customRemoveLast(_ n: Int) -> Bool {
    return false
  }
}
extension RangeReplaceableCollection where Self : Swift.BidirectionalCollection, Self == Self.SubSequence {
  @inlinable mutating public func _customRemoveLast() -> Element? {
    let element = last!
    self = self[startIndex..<index(before: endIndex)]
    return element
  }
  @inlinable mutating public func _customRemoveLast(_ n: Int) -> Bool {
    self = self[startIndex..<index(endIndex, offsetBy: numericCast(-n))]
    return true
  }
}
extension RangeReplaceableCollection where Self : Swift.BidirectionalCollection {
  @inlinable mutating public func popLast() -> Element? {
    if isEmpty { return nil }
    // duplicate of removeLast logic below, to avoid redundant precondition
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
  @discardableResult
  @inlinable mutating public func removeLast() -> Element {
    _precondition(!isEmpty, "Can't remove last element from an empty collection")
    // NOTE if you change this implementation, change popLast above as well
    // AND change the tie-breaker implementations in the next extension
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
  @inlinable mutating public func removeLast(_ k: Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    _precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    if _customRemoveLast(k) {
      return
    }
    let end = endIndex
    removeSubrange(index(end, offsetBy: -k)..<end)
  }
}
extension RangeReplaceableCollection where Self : Swift.BidirectionalCollection, Self == Self.SubSequence {
  @inlinable mutating public func popLast() -> Element? {
    if isEmpty { return nil }
    // duplicate of removeLast logic below, to avoid redundant precondition
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
  @discardableResult
  @inlinable mutating public func removeLast() -> Element {
    _precondition(!isEmpty, "Can't remove last element from an empty collection")
    // NOTE if you change this implementation, change popLast above as well
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
  @inlinable mutating public func removeLast(_ k: Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    _precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    if _customRemoveLast(k) {
      return
    }
    let end = endIndex
    removeSubrange(index(end, offsetBy: -k)..<end)
  }
}
extension RangeReplaceableCollection {
  @inlinable public static func + <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.Sequence, Self.Element == Other.Element {
    var lhs = lhs
    // FIXME: what if lhs is a reference type?  This will mutate it.
    lhs.append(contentsOf: rhs)
    return lhs
  }
  @inlinable public static func + <Other>(lhs: Other, rhs: Self) -> Self where Other : Swift.Sequence, Self.Element == Other.Element {
    var result = Self()
    result.reserveCapacity(rhs.count + numericCast(lhs.underestimatedCount))
    result.append(contentsOf: lhs)
    result.append(contentsOf: rhs)
    return result
  }
  @inlinable public static func += <Other>(lhs: inout Self, rhs: Other) where Other : Swift.Sequence, Self.Element == Other.Element {
    lhs.append(contentsOf: rhs)
  }
  @inlinable public static func + <Other>(lhs: Self, rhs: Other) -> Self where Other : Swift.RangeReplaceableCollection, Self.Element == Other.Element {
    var lhs = lhs
    // FIXME: what if lhs is a reference type?  This will mutate it.
    lhs.append(contentsOf: rhs)
    return lhs
  }
}
extension RangeReplaceableCollection {
  @available(swift 4.0)
  @inlinable __consuming public func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> Self {
    return try Self(self.lazy.filter(isIncluded))
  }
}
extension RangeReplaceableCollection where Self : Swift.MutableCollection {
  @inlinable mutating public func removeAll(where shouldBeRemoved: (Element) throws -> Bool) rethrows {
    let suffixStart = try _halfStablePartition(isSuffixElement: shouldBeRemoved)
    removeSubrange(suffixStart...)
  }
}
extension RangeReplaceableCollection {
  @inlinable mutating public func removeAll(where shouldBeRemoved: (Element) throws -> Bool) rethrows {
    // FIXME: Switch to using RRC.filter once stdlib is compiled for 4.0
    // self = try filter { try !predicate($0) }
    self = try Self(self.lazy.filter { try !shouldBeRemoved($0) })
  }
}
@_fixed_layout public struct Repeated<Element> {
  public let count: Int
  public let repeatedValue: Element
}
extension Repeated : RandomAccessCollection {
  public typealias Indices = Range<Int>
  public typealias Index = Int
  @inlinable internal init(_repeating repeatedValue: Element, count: Int) {
    _precondition(count >= 0, "Repetition count should be non-negative")
    self.count = count
    self.repeatedValue = repeatedValue
  }
  @inlinable public var startIndex: Index {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return count
  }
  }
  @inlinable public subscript(position: Int) -> Element {
    get {
    _precondition(position >= 0 && position < count, "Index out of range")
    return repeatedValue
  }
  }
  public typealias Iterator = Swift.IndexingIterator<Swift.Repeated<Element>>
  public typealias SubSequence = Swift.Slice<Swift.Repeated<Element>>
}
@inlinable public func repeatElement<T>(_ element: T, count n: Int) -> Repeated<T> {
  return Repeated(_repeating: element, count: n)
}
public func _replPrintLiteralString(_ text: String)
@inline(never) public func _replDebugPrintln<T>(_ value: T)
@_frozen public enum Result<Success, Failure> where Failure : Swift.Error {
  case success(Success)
  case failure(Failure)
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> Result<NewSuccess, Failure>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> Result<Success, NewFailure> where NewFailure : Swift.Error
  public func flatMap<NewSuccess>(_ transform: (Success) -> Result<NewSuccess, Failure>) -> Result<NewSuccess, Failure>
  public func flatMapError<NewFailure>(_ transform: (Failure) -> Result<Success, NewFailure>) -> Result<Success, NewFailure> where NewFailure : Swift.Error
  public func get() throws -> Success
}
extension Result where Failure == Swift.Error {
  @_transparent public init(catching body: () throws -> Success) {
    do {
      self = .success(try body())
    } catch {
      self = .failure(error)
    }
  }
}
extension Result : Equatable where Success : Swift.Equatable, Failure : Swift.Equatable {
  public static func == (a: Swift.Result<Success, Failure>, b: Swift.Result<Success, Failure>) -> Swift.Bool
}
extension Result : Hashable where Success : Swift.Hashable, Failure : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension MutableCollection where Self : Swift.BidirectionalCollection {
  @inlinable mutating public func reverse() {
    if isEmpty { return }
    var f = startIndex
    var l = index(before: endIndex)
    while f < l {
      swapAt(f, l)
      formIndex(after: &f)
      formIndex(before: &l)
    }
  }
}
@_fixed_layout public struct ReversedCollection<Base> where Base : Swift.BidirectionalCollection {
  public let _base: Base
  @inlinable internal init(_base: Base) {
    self._base = _base
  }
}
extension ReversedCollection {
  @_fixed_layout public struct Iterator {
    @usableFromInline
    internal let _base: Base
    @usableFromInline
    internal var _position: Base.Index
    @inlinable @inline(__always) public init(_base: Base) {
      self._base = _base
      self._position = _base.endIndex
    }
  }
}
extension ReversedCollection.Iterator : IteratorProtocol, Sequence {
  public typealias Element = Base.Element
  @inlinable @inline(__always) mutating public func next() -> Element? {
    guard _fastPath(_position != _base.startIndex) else { return nil }
    _base.formIndex(before: &_position)
    return _base[_position]
  }
  public typealias Iterator = Swift.ReversedCollection<Base>.Iterator
}
extension ReversedCollection : Sequence {
  public typealias Element = Base.Element
  @inlinable @inline(__always) __consuming public func makeIterator() -> Iterator {
    return Iterator(_base: _base)
  }
}
extension ReversedCollection {
  @_fixed_layout public struct Index {
    public let base: Base.Index
    @inlinable public init(_ base: Base.Index) {
      self.base = base
    }
  }
}
extension ReversedCollection.Index : Comparable {
  @inlinable public static func == (lhs: ReversedCollection<Base>.Index, rhs: ReversedCollection<Base>.Index) -> Bool {
    // Note ReversedIndex has inverted logic compared to base Base.Index
    return lhs.base == rhs.base
  }
  @inlinable public static func < (lhs: ReversedCollection<Base>.Index, rhs: ReversedCollection<Base>.Index) -> Bool {
    // Note ReversedIndex has inverted logic compared to base Base.Index
    return lhs.base > rhs.base
  }
}
extension ReversedCollection.Index : Hashable where Base.Index : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine(base)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension ReversedCollection : BidirectionalCollection {
  @inlinable public var startIndex: Index {
    get {
    return Index(_base.endIndex)
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return Index(_base.startIndex)
  }
  }
  @inlinable public func index(after i: Index) -> Index {
    return Index(_base.index(before: i.base))
  }
  @inlinable public func index(before i: Index) -> Index {
    return Index(_base.index(after: i.base))
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int) -> Index {
    // FIXME: swift-3-indexing-model: `-n` can trap on Int.min.
    return Index(_base.index(i.base, offsetBy: -n))
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index? {
    // FIXME: swift-3-indexing-model: `-n` can trap on Int.min.
    return _base.index(i.base, offsetBy: -n, limitedBy: limit.base)
                .map(Index.init)
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    return _base.distance(from: end.base, to: start.base)
  }
  @inlinable public subscript(position: Index) -> Element {
    get {
    return _base[_base.index(before: position.base)]
  }
  }
  public typealias SubSequence = Swift.Slice<Swift.ReversedCollection<Base>>
  public typealias Indices = Swift.DefaultIndices<Swift.ReversedCollection<Base>>
}
extension ReversedCollection : RandomAccessCollection where Base : Swift.RandomAccessCollection {
}
extension ReversedCollection {
  @available(swift 4.2)
  @inlinable __consuming public func reversed() -> Base {
    return _base
  }
}
extension BidirectionalCollection {
  @inlinable __consuming public func reversed() -> ReversedCollection<Self> {
    return ReversedCollection(_base: self)
  }
}
@_transparent public func _stdlib_atomicCompareExchangeStrongPtr(object target: UnsafeMutablePointer<UnsafeRawPointer?>, expected: UnsafeMutablePointer<UnsafeRawPointer?>, desired: UnsafeRawPointer?) -> Bool {

  // We use Builtin.Word here because Builtin.RawPointer can't be nil.
  let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Word(
    target._rawValue,
    UInt(bitPattern: expected.pointee)._builtinWordValue,
    UInt(bitPattern: desired)._builtinWordValue)
  expected.pointee = UnsafeRawPointer(bitPattern: Int(oldValue))
  return Bool(won)
}
@_transparent public func _stdlib_atomicCompareExchangeStrongPtr<T>(object target: UnsafeMutablePointer<UnsafeMutablePointer<T>>, expected: UnsafeMutablePointer<UnsafeMutablePointer<T>>, desired: UnsafeMutablePointer<T>) -> Bool {
  let rawTarget = UnsafeMutableRawPointer(target).assumingMemoryBound(
    to: Optional<UnsafeRawPointer>.self)
  let rawExpected = UnsafeMutableRawPointer(expected).assumingMemoryBound(
    to: Optional<UnsafeRawPointer>.self)
  return _stdlib_atomicCompareExchangeStrongPtr(
    object: rawTarget,
    expected: rawExpected,
    desired: UnsafeRawPointer(desired))
}
@_transparent public func _stdlib_atomicCompareExchangeStrongPtr<T>(object target: UnsafeMutablePointer<UnsafeMutablePointer<T>?>, expected: UnsafeMutablePointer<UnsafeMutablePointer<T>?>, desired: UnsafeMutablePointer<T>?) -> Bool {
  let rawTarget = UnsafeMutableRawPointer(target).assumingMemoryBound(
    to: Optional<UnsafeRawPointer>.self)
  let rawExpected = UnsafeMutableRawPointer(expected).assumingMemoryBound(
    to: Optional<UnsafeRawPointer>.self)
  return _stdlib_atomicCompareExchangeStrongPtr(
    object: rawTarget,
    expected: rawExpected,
    desired: UnsafeRawPointer(desired))
}
@discardableResult
@_transparent public func _stdlib_atomicInitializeARCRef(object target: UnsafeMutablePointer<AnyObject?>, desired: AnyObject) -> Bool {
  var expected: UnsafeRawPointer?
  let desiredPtr = Unmanaged.passRetained(desired).toOpaque()
  let rawTarget = UnsafeMutableRawPointer(target).assumingMemoryBound(
    to: Optional<UnsafeRawPointer>.self)
  let wonRace = _stdlib_atomicCompareExchangeStrongPtr(
    object: rawTarget, expected: &expected, desired: desiredPtr)
  if !wonRace {
    // Some other thread initialized the value.  Balance the retain that we
    // performed on 'desired'.
    Unmanaged.passUnretained(desired).release()
  }
  return wonRace
}
@_transparent public func _stdlib_atomicLoadARCRef(object target: UnsafeMutablePointer<AnyObject?>) -> AnyObject? {
  let value = Builtin.atomicload_seqcst_Word(target._rawValue)
  if let unwrapped = UnsafeRawPointer(bitPattern: Int(value)) {
    return Unmanaged<AnyObject>.fromOpaque(unwrapped).takeUnretainedValue()
  }
  return nil
}
public func _uint64ToString(_ value: UInt64, radix: Int64 = 10, uppercase: Bool = false) -> String
@inlinable internal func _rawPointerToString(_ value: Builtin.RawPointer) -> String {
  var result = _uint64ToString(
    UInt64(
      UInt(bitPattern: UnsafeRawPointer(value))),
      radix: 16,
      uppercase: false
    )
  for _ in 0..<(2 * MemoryLayout<UnsafeRawPointer>.size - result.utf16.count) {
    result = "0" + result
  }
  return "0x" + result
}
@usableFromInline
@_fixed_layout @objc @_swift_native_objc_runtime_base(__SwiftNativeNSArrayBase) internal class __SwiftNativeNSArray {
  @inlinable @nonobjc internal init() {}
  @objc @inlinable deinit {}
}
@usableFromInline
@_fixed_layout @objc @_swift_native_objc_runtime_base(__SwiftNativeNSDictionaryBase) internal class __SwiftNativeNSDictionary {
  @objc deinit
}
@usableFromInline
@_fixed_layout @objc @_swift_native_objc_runtime_base(__SwiftNativeNSSetBase) internal class __SwiftNativeNSSet {
  @objc deinit
}
@_fixed_layout @objc @_swift_native_objc_runtime_base(__SwiftNativeNSDataBase) open class __SwiftNativeNSData {
  @inlinable @objc public init() {}
  @objc @inlinable deinit {}
}
public func _stdlib_initializeReturnAutoreleased()
extension Hasher {
  @usableFromInline
  @_fixed_layout internal struct _State {
    private var v0: UInt64 = 0x736f6d6570736575
    private var v1: UInt64 = 0x646f72616e646f6d
    private var v2: UInt64 = 0x6c7967656e657261
    private var v3: UInt64 = 0x7465646279746573
    private var v4: UInt64 = 0
    private var v5: UInt64 = 0
    private var v6: UInt64 = 0
    private var v7: UInt64 = 0
  }
}
public protocol IteratorProtocol {
  associatedtype Element
  mutating func next() -> Element?
}
public protocol Sequence {
  associatedtype Element where Self.Element == Self.Iterator.Element
  associatedtype Iterator : Swift.IteratorProtocol
  __consuming func makeIterator() -> Iterator
  var underestimatedCount: Int { get }
  func _customContainsEquatableElement(_ element: Element) -> Bool?
  __consuming func _copyToContiguousArray() -> ContiguousArray<Element>
  __consuming func _copyContents(initializing ptr: UnsafeMutableBufferPointer<Element>) -> (Iterator, UnsafeMutableBufferPointer<Element>.Index)
  func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R?
}
extension Sequence where Self : Swift.IteratorProtocol {
  public typealias _Default_Iterator = Self
}
extension Sequence where Self == Self.Iterator {
  @inlinable __consuming public func makeIterator() -> Self {
    return self
  }
}
@_fixed_layout public struct DropFirstSequence<Base> where Base : Swift.Sequence {
  @usableFromInline
  internal let _base: Base
  @usableFromInline
  internal let _limit: Int
  @inlinable public init(_ base: Base, dropping limit: Int) {
    _precondition(limit >= 0, 
      "Can't drop a negative number of elements from a sequence")
    _base = base
    _limit = limit
  }
}
extension DropFirstSequence : Sequence {
  public typealias Element = Base.Element
  public typealias Iterator = Base.Iterator
  public typealias SubSequence = AnySequence<Element>
  @inlinable __consuming public func makeIterator() -> Iterator {
    var it = _base.makeIterator()
    var dropped = 0
    while dropped < _limit, it.next() != nil { dropped &+= 1 }
    return it
  }
  @inlinable __consuming public func dropFirst(_ k: Int) -> DropFirstSequence<Base> {
    // If this is already a _DropFirstSequence, we need to fold in
    // the current drop count and drop limit so no data is lost.
    //
    // i.e. [1,2,3,4].dropFirst(1).dropFirst(1) should be equivalent to
    // [1,2,3,4].dropFirst(2).
    return DropFirstSequence(_base, dropping: _limit + k)
  }
}
@_fixed_layout public struct PrefixSequence<Base> where Base : Swift.Sequence {
  @usableFromInline
  internal var _base: Base
  @usableFromInline
  internal let _maxLength: Int
  @inlinable public init(_ base: Base, maxLength: Int) {
    _precondition(maxLength >= 0, "Can't take a prefix of negative length")
    _base = base
    _maxLength = maxLength
  }
}
extension PrefixSequence {
  @_fixed_layout public struct Iterator {
    @usableFromInline
    internal var _base: Base.Iterator
    @usableFromInline
    internal var _remaining: Int
    @inlinable internal init(_ base: Base.Iterator, maxLength: Int) {
      _base = base
      _remaining = maxLength
    }
  }
}
extension PrefixSequence.Iterator : IteratorProtocol {
  public typealias Element = Base.Element
  @inlinable mutating public func next() -> Element? {
    if _remaining != 0 {
      _remaining &-= 1
      return _base.next()
    } else {
      return nil
    }
  }
}
extension PrefixSequence : Sequence {
  @inlinable __consuming public func makeIterator() -> Iterator {
    return Iterator(_base.makeIterator(), maxLength: _maxLength)
  }
  @inlinable __consuming public func prefix(_ maxLength: Int) -> PrefixSequence<Base> {
    let length = Swift.min(maxLength, self._maxLength)
    return PrefixSequence(_base, maxLength: length)
  }
  public typealias Element = Base.Element
}
@_fixed_layout public struct DropWhileSequence<Base> where Base : Swift.Sequence {
  public typealias Element = Base.Element
  @usableFromInline
  internal var _iterator: Base.Iterator
  @usableFromInline
  internal var _nextElement: Element?
  @inlinable internal init(iterator: Base.Iterator, predicate: (Element) throws -> Bool) rethrows {
    _iterator = iterator
    _nextElement = _iterator.next()
    
    while let x = _nextElement, try predicate(x) {
      _nextElement = _iterator.next()
    }
  }
  @inlinable internal init(_ base: Base, predicate: (Element) throws -> Bool) rethrows {
    self = try DropWhileSequence(iterator: base.makeIterator(), predicate: predicate)
  }
}
extension DropWhileSequence {
  @_fixed_layout public struct Iterator {
    @usableFromInline
    internal var _iterator: Base.Iterator
    @usableFromInline
    internal var _nextElement: Element?
    @inlinable internal init(_ iterator: Base.Iterator, nextElement: Element?) {
      _iterator = iterator
      _nextElement = nextElement
    }
  }
}
extension DropWhileSequence.Iterator : IteratorProtocol {
  public typealias Element = Base.Element
  @inlinable mutating public func next() -> Element? {
    guard let next = _nextElement else { return nil }
    _nextElement = _iterator.next()
    return next
  }
}
extension DropWhileSequence : Sequence {
  @inlinable public func makeIterator() -> Iterator {
    return Iterator(_iterator, nextElement: _nextElement)
  }
  @inlinable __consuming public func drop(while predicate: (Element) throws -> Bool) rethrows -> DropWhileSequence<Base> {
    guard let x = _nextElement, try predicate(x) else { return self }
    return try DropWhileSequence(iterator: _iterator, predicate: predicate)
  }
}
extension Sequence {
  @inlinable public func map<T>(_ transform: (Element) throws -> T) rethrows -> [T] {
    let initialCapacity = underestimatedCount
    var result = ContiguousArray<T>()
    result.reserveCapacity(initialCapacity)

    var iterator = self.makeIterator()

    // Add elements up to the initial capacity without checking for regrowth.
    for _ in 0..<initialCapacity {
      result.append(try transform(iterator.next()!))
    }
    // Add remaining elements, if any.
    while let element = iterator.next() {
      result.append(try transform(element))
    }
    return Array(result)
  }
  @inlinable __consuming public func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element] {
    return try _filter(isIncluded)
  }
  @_transparent public func _filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element] {

    var result = ContiguousArray<Element>()

    var iterator = self.makeIterator()

    while let element = iterator.next() {
      if try isIncluded(element) {
        result.append(element)
      }
    }

    return Array(result)
  }
  @inlinable public var underestimatedCount: Int {
    get {
    return 0
  }
  }
  @inlinable @inline(__always) public func _customContainsEquatableElement(_ element: Iterator.Element) -> Bool? {
    return nil
  }
  @inlinable public func forEach(_ body: (Element) throws -> Void) rethrows {
    for element in self {
      try body(element)
    }
  }
}
extension Sequence {
  @inlinable public func first(where predicate: (Element) throws -> Bool) rethrows -> Element? {
    for element in self  {
      if try predicate(element) {
        return element
      }
    }
    return nil
  }
}
extension Sequence where Self.Element : Swift.Equatable {
  @inlinable __consuming public func split(separator: Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Element>] {
    return split(
      maxSplits: maxSplits,
      omittingEmptySubsequences: omittingEmptySubsequences,
      whereSeparator: { $0 == separator })
  }
}
extension Sequence {
  @inlinable __consuming public func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (Element) throws -> Bool) rethrows -> [ArraySlice<Element>] {
    _precondition(maxSplits >= 0, "Must take zero or more splits")
    let whole = Array(self)
    return try whole.split(
                  maxSplits: maxSplits, 
                  omittingEmptySubsequences: omittingEmptySubsequences, 
                  whereSeparator: isSeparator)
  }
  @inlinable __consuming public func suffix(_ maxLength: Int) -> [Element] {
    _precondition(maxLength >= 0, "Can't take a suffix of negative length from a sequence")
    guard maxLength != 0 else { return [] }

    // FIXME: <rdar://problem/21885650> Create reusable RingBuffer<T>
    // Put incoming elements into a ring buffer to save space. Once all
    // elements are consumed, reorder the ring buffer into a copy and return it.
    // This saves memory for sequences particularly longer than `maxLength`.
    var ringBuffer = ContiguousArray<Element>()
    ringBuffer.reserveCapacity(Swift.min(maxLength, underestimatedCount))

    var i = 0

    for element in self {
      if ringBuffer.count < maxLength {
        ringBuffer.append(element)
      } else {
        ringBuffer[i] = element
        i = (i + 1) % maxLength
      }
    }

    if i != ringBuffer.startIndex {
      var rotated = ContiguousArray<Element>()
      rotated.reserveCapacity(ringBuffer.count)
      rotated += ringBuffer[i..<ringBuffer.endIndex]
      rotated += ringBuffer[0..<i]
      return Array(rotated)
    } else {
      return Array(ringBuffer)
    }
  }
  @inlinable __consuming public func dropFirst(_ k: Int = 1) -> DropFirstSequence<Self> {
    return DropFirstSequence(self, dropping: k)
  }
  @inlinable __consuming public func dropLast(_ k: Int = 1) -> [Element] {
    _precondition(k >= 0, "Can't drop a negative number of elements from a sequence")
    guard k != 0 else { return Array(self) }

    // FIXME: <rdar://problem/21885650> Create reusable RingBuffer<T>
    // Put incoming elements from this sequence in a holding tank, a ring buffer
    // of size <= k. If more elements keep coming in, pull them out of the
    // holding tank into the result, an `Array`. This saves
    // `k` * sizeof(Element) of memory, because slices keep the entire
    // memory of an `Array` alive.
    var result = ContiguousArray<Element>()
    var ringBuffer = ContiguousArray<Element>()
    var i = ringBuffer.startIndex

    for element in self {
      if ringBuffer.count < k {
        ringBuffer.append(element)
      } else {
        result.append(ringBuffer[i])
        ringBuffer[i] = element
        i = (i + 1) % k
      }
    }
    return Array(result)
  }
  @inlinable __consuming public func drop(while predicate: (Element) throws -> Bool) rethrows -> DropWhileSequence<Self> {
    return try DropWhileSequence(self, predicate: predicate)
  }
  @inlinable __consuming public func prefix(_ maxLength: Int) -> PrefixSequence<Self> {
    return PrefixSequence(self, maxLength: maxLength)
  }
  @inlinable __consuming public func prefix(while predicate: (Element) throws -> Bool) rethrows -> [Element] {
    var result = ContiguousArray<Element>()

    for element in self {
      guard try predicate(element) else {
        break
      }
      result.append(element)
    }
    return Array(result)
  }
}
extension Sequence {
  @inlinable __consuming public func _copyContents(initializing buffer: UnsafeMutableBufferPointer<Element>) -> (Iterator, UnsafeMutableBufferPointer<Element>.Index) {
    var it = self.makeIterator()
    guard var ptr = buffer.baseAddress else { return (it,buffer.startIndex) }
    for idx in buffer.startIndex..<buffer.count {
      guard let x = it.next() else {
        return (it, idx)
      }
      ptr.initialize(to: x)
      ptr += 1
    }
    return (it,buffer.endIndex)
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    return nil
  }
}
@_fixed_layout public struct IteratorSequence<Base> where Base : Swift.IteratorProtocol {
  @usableFromInline
  internal var _base: Base
  @inlinable public init(_ base: Base) {
    _base = base
  }
}
extension IteratorSequence : IteratorProtocol, Sequence {
  @inlinable mutating public func next() -> Base.Element? {
    return _base.next()
  }
  public typealias Element = Base.Element
  public typealias Iterator = Swift.IteratorSequence<Base>
}
extension Sequence {
  @inlinable public func enumerated() -> EnumeratedSequence<Self> {
    return EnumeratedSequence(_base: self)
  }
}
extension Sequence {
  @warn_unqualified_access
  @inlinable public func min(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Element? {
    var it = makeIterator()
    guard var result = it.next() else { return nil }
    while let e = it.next() {
      if try areInIncreasingOrder(e, result) { result = e }
    }
    return result
  }
  @warn_unqualified_access
  @inlinable public func max(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Element? {
    var it = makeIterator()
    guard var result = it.next() else { return nil }
    while let e = it.next() {
      if try areInIncreasingOrder(result, e) { result = e }
    }
    return result
  }
}
extension Sequence where Self.Element : Swift.Comparable {
  @warn_unqualified_access
  @inlinable public func min() -> Element? {
    return self.min(by: <)
  }
  @warn_unqualified_access
  @inlinable public func max() -> Element? {
    return self.max(by: <)
  }
}
extension Sequence {
  @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Swift.Sequence {
    var possiblePrefixIterator = possiblePrefix.makeIterator()
    for e0 in self {
      if let e1 = possiblePrefixIterator.next() {
        if try !areEquivalent(e0, e1) {
          return false
        }
      }
      else {
        return true
      }
    }
    return possiblePrefixIterator.next() == nil
  }
}
extension Sequence where Self.Element : Swift.Equatable {
  @inlinable public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Swift.Sequence, Self.Element == PossiblePrefix.Element {
    return self.starts(with: possiblePrefix, by: ==)
  }
}
extension Sequence {
  @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Swift.Sequence {
    var iter1 = self.makeIterator()
    var iter2 = other.makeIterator()
    while true {
      switch (iter1.next(), iter2.next()) {
      case let (e1?, e2?):
        if try !areEquivalent(e1, e2) {
          return false
        }
      case (_?, nil), (nil, _?): return false
      case (nil, nil):           return true
      }
    }
  }
}
extension Sequence where Self.Element : Swift.Equatable {
  @inlinable public func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Swift.Sequence, Self.Element == OtherSequence.Element {
    return self.elementsEqual(other, by: ==)
  }
}
extension Sequence {
  @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Bool where OtherSequence : Swift.Sequence, Self.Element == OtherSequence.Element {
    var iter1 = self.makeIterator()
    var iter2 = other.makeIterator()
    while true {
      if let e1 = iter1.next() {
        if let e2 = iter2.next() {
          if try areInIncreasingOrder(e1, e2) {
            return true
          }
          if try areInIncreasingOrder(e2, e1) {
            return false
          }
          continue // Equivalent
        }
        return false
      }

      return iter2.next() != nil
    }
  }
}
extension Sequence where Self.Element : Swift.Comparable {
  @inlinable public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Swift.Sequence, Self.Element == OtherSequence.Element {
    return self.lexicographicallyPrecedes(other, by: <)
  }
}
extension Sequence {
  @inlinable public func contains(where predicate: (Element) throws -> Bool) rethrows -> Bool {
    for e in self {
      if try predicate(e) {
        return true
      }
    }
    return false
  }
  @inlinable public func allSatisfy(_ predicate: (Element) throws -> Bool) rethrows -> Bool {
    return try !contains { try !predicate($0) }
  }
}
extension Sequence where Self.Element : Swift.Equatable {
  @inlinable public func contains(_ element: Element) -> Bool {
    if let result = _customContainsEquatableElement(element) {
      return result
    } else {
      return self.contains { $0 == element }
    }
  }
}
extension Sequence {
  @inlinable public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_ partialResult: Result, Element) throws -> Result) rethrows -> Result {
    var accumulator = initialResult
    for element in self {
      accumulator = try nextPartialResult(accumulator, element)
    }
    return accumulator
  }
  @inlinable public func reduce<Result>(into initialResult: __owned Result, _ updateAccumulatingResult: (_ partialResult: inout Result, Element) throws -> ()) rethrows -> Result {
    var accumulator = initialResult
    for element in self {
      try updateAccumulatingResult(&accumulator, element)
    }
    return accumulator
  }
}
extension Sequence {
  @inlinable __consuming public func reversed() -> [Element] {
    // FIXME(performance): optimize to 1 pass?  But Array(self) can be
    // optimized to a memcpy() sometimes.  Those cases are usually collections,
    // though.
    var result = Array(self)
    let count = result.count
    for i in 0..<count/2 {
      result.swapAt(i, count - ((i + 1) as Int))
    }
    return result
  }
}
extension Sequence {
  @inlinable public func flatMap<SegmentOfResult>(_ transform: (Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Swift.Sequence {
    var result: [SegmentOfResult.Element] = []
    for element in self {
      result.append(contentsOf: try transform(element))
    }
    return result
  }
}
extension Sequence {
  @inlinable public func compactMap<ElementOfResult>(_ transform: (Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult] {
    return try _compactMap(transform)
  }
  @inlinable @inline(__always) public func _compactMap<ElementOfResult>(_ transform: (Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult] {
    var result: [ElementOfResult] = []
    for element in self {
      if let newElement = try transform(element) {
        result.append(newElement)
      }
    }
    return result
  }
}
@_fixed_layout public struct Set<Element> where Element : Swift.Hashable {
  @usableFromInline
  internal var _variant: _Variant
  public init(minimumCapacity: Int)
  @inlinable internal init(_native: __owned _NativeSet<Element>) {
    _variant = _Variant(native: _native)
  }
  @inlinable internal init(_cocoa: __owned __CocoaSet) {
    _variant = _Variant(cocoa: _cocoa)
  }
  @inlinable public init(_immutableCocoaSet: __owned AnyObject) {
    _internalInvariant(_isBridgedVerbatimToObjectiveC(Element.self),
      "Set can be backed by NSSet _variant only when the member type can be bridged verbatim to Objective-C")
    self.init(_cocoa: __CocoaSet(_immutableCocoaSet))
  }
}
extension Set : ExpressibleByArrayLiteral {
  @inlinable public init(arrayLiteral elements: Element...) {
    if elements.isEmpty {
      self.init()
      return
    }
    let native = _NativeSet<Element>(capacity: elements.count)
    for element in elements {
      let (bucket, found) = native.find(element)
      if found {
        // FIXME: Shouldn't this trap?
        continue
      }
      native._unsafeInsertNew(element, at: bucket)
    }
    self.init(_native: native)
  }
  public typealias ArrayLiteralElement = Element
}
extension Set : Sequence {
  @inlinable @inline(__always) __consuming public func makeIterator() -> Iterator {
    return _variant.makeIterator()
  }
  @inlinable public func contains(_ member: Element) -> Bool {
    return _variant.contains(member)
  }
  @inlinable @inline(__always) public func _customContainsEquatableElement(_ member: Element) -> Bool? {
    return contains(member)
  }
}
extension Set {
  @available(swift 4.0)
  @inlinable __consuming public func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> Set {
    // FIXME(performance): Eliminate rehashes by using a bitmap.
    var result = Set()
    for element in self {
      if try isIncluded(element) {
        result.insert(element)
      }
    }
    return result
  }
}
extension Set : Collection {
  @inlinable public var startIndex: Index {
    get {
    return _variant.startIndex
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return _variant.endIndex
  }
  }
  @inlinable public subscript(position: Index) -> Element {
    get {
      return _variant.element(at: position)
    }
  }
  @inlinable public func index(after i: Index) -> Index {
    return _variant.index(after: i)
  }
  @inlinable public func formIndex(after i: inout Index) {
    _variant.formIndex(after: &i)
  }
  @inlinable public func firstIndex(of member: Element) -> Index? {
    return _variant.index(for: member)
  }
  @inlinable @inline(__always) public func _customIndexOfEquatableElement(_ member: Element) -> Index?? {
    return Optional(firstIndex(of: member))
  }
  @inlinable @inline(__always) public func _customLastIndexOfEquatableElement(_ member: Element) -> Index?? {
    // The first and last elements are the same because each element is unique.
    return _customIndexOfEquatableElement(member)
  }
  @inlinable public var count: Int {
    get {
    return _variant.count
  }
  }
  @inlinable public var isEmpty: Bool {
    get {
    return count == 0
  }
  }
  public typealias SubSequence = Swift.Slice<Swift.Set<Element>>
  public typealias Indices = Swift.DefaultIndices<Swift.Set<Element>>
}
extension Set : Equatable {
  @inlinable public static func == (lhs: Set<Element>, rhs: Set<Element>) -> Bool {
    switch (lhs._variant.isNative, rhs._variant.isNative) {
    case (true, true):
      return lhs._variant.asNative.isEqual(to: rhs._variant.asNative)
    case (false, false):
      return lhs._variant.asCocoa.isEqual(to: rhs._variant.asCocoa)
    case (true, false):
      return lhs._variant.asNative.isEqual(to: rhs._variant.asCocoa)
    case (false, true):
      return rhs._variant.asNative.isEqual(to: lhs._variant.asCocoa)
    }
  }
}
extension Set : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    // FIXME(ABI)#177: <rdar://problem/18915294> Cache Set<T> hashValue

    // Generate a seed from a snapshot of the hasher.  This makes members' hash
    // values depend on the state of the hasher, which improves hashing
    // quality. (E.g., it makes it possible to resolve collisions by passing in
    // a different hasher.)
    var copy = hasher
    let seed = copy._finalize()

    var hash = 0
    for member in self {
      hash ^= member._rawHashValue(seed: seed)
    }
    hasher.combine(hash)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Set : _HasCustomAnyHashableRepresentation {
  __consuming public func _toCustomAnyHashable() -> AnyHashable?
}
extension Set : SetAlgebra {
  @discardableResult
  @inlinable mutating public func insert(_ newMember: __owned Element) -> (inserted: Bool, memberAfterInsert: Element) {
    return _variant.insert(newMember)
  }
  @discardableResult
  @inlinable mutating public func update(with newMember: __owned Element) -> Element? {
    return _variant.update(with: newMember)
  }
  @discardableResult
  @inlinable mutating public func remove(_ member: Element) -> Element? {
    return _variant.remove(member)
  }
  @discardableResult
  @inlinable mutating public func remove(at position: Index) -> Element {
    return _variant.remove(at: position)
  }
  @inlinable mutating public func removeAll(keepingCapacity keepCapacity: Bool = false) {
    _variant.removeAll(keepingCapacity: keepCapacity)
  }
  @discardableResult
  @inlinable mutating public func removeFirst() -> Element {
    _precondition(!isEmpty, "Can't removeFirst from an empty Set")
    return remove(at: startIndex)
  }
  @inlinable public init() {
    self = Set<Element>(_native: _NativeSet())
  }
  @inlinable public init<Source>(_ sequence: __owned Source) where Element == Source.Element, Source : Swift.Sequence {
    self.init(minimumCapacity: sequence.underestimatedCount)
    if let s = sequence as? Set<Element> {
      // If this sequence is actually a native `Set`, then we can quickly
      // adopt its native buffer and let COW handle uniquing only
      // if necessary.
      self._variant = s._variant
    } else {
      for item in sequence {
        insert(item)
      }
    }
  }
  @inlinable public func isSubset<S>(of possibleSuperset: S) -> Bool where Element == S.Element, S : Swift.Sequence {
    guard !isEmpty else { return true }
    
    let other = Set(possibleSuperset)
    return isSubset(of: other)
  }
  @inlinable public func isStrictSubset<S>(of possibleStrictSuperset: S) -> Bool where Element == S.Element, S : Swift.Sequence {
    // FIXME: code duplication.
    let other = Set(possibleStrictSuperset)
    return isStrictSubset(of: other)
  }
  @inlinable public func isSuperset<S>(of possibleSubset: __owned S) -> Bool where Element == S.Element, S : Swift.Sequence {
    for member in possibleSubset {
      if !contains(member) {
        return false
      }
    }
    return true
  }
  @inlinable public func isStrictSuperset<S>(of possibleStrictSubset: S) -> Bool where Element == S.Element, S : Swift.Sequence {
    let other = Set(possibleStrictSubset)
    return other.isStrictSubset(of: self)
  }
  @inlinable public func isDisjoint<S>(with other: S) -> Bool where Element == S.Element, S : Swift.Sequence {
    return _isDisjoint(with: other)
  }
  @inlinable __consuming public func union<S>(_ other: __owned S) -> Set<Element> where Element == S.Element, S : Swift.Sequence {
    var newSet = self
    newSet.formUnion(other)
    return newSet
  }
  @inlinable mutating public func formUnion<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
    for item in other {
      insert(item)
    }
  }
  @inlinable __consuming public func subtracting<S>(_ other: S) -> Set<Element> where Element == S.Element, S : Swift.Sequence {
    return self._subtracting(other)
  }
  @inlinable __consuming internal func _subtracting<S>(_ other: S) -> Set<Element> where Element == S.Element, S : Swift.Sequence {
    var newSet = self
    newSet.subtract(other)
    return newSet
  }
  @inlinable mutating public func subtract<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
    _subtract(other)
  }
  @inlinable mutating internal func _subtract<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
    // If self is empty we don't need to iterate over `other` because there's
    // nothing to remove on self.
    guard !isEmpty else { return }

    for item in other {
      remove(item)
    }
  }
  @inlinable __consuming public func intersection<S>(_ other: S) -> Set<Element> where Element == S.Element, S : Swift.Sequence {
    let otherSet = Set(other)
    return intersection(otherSet)
  }
  @inlinable mutating public func formIntersection<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
    // Because `intersect` needs to both modify and iterate over
    // the left-hand side, the index may become invalidated during
    // traversal so an intermediate set must be created.
    //
    // FIXME(performance): perform this operation at a lower level
    // to avoid invalidating the index and avoiding a copy.
    let result = self.intersection(other)

    // The result can only have fewer or the same number of elements.
    // If no elements were removed, don't perform a reassignment
    // as this may cause an unnecessary uniquing COW.
    if result.count != count {
      self = result
    }
  }
  @inlinable __consuming public func symmetricDifference<S>(_ other: __owned S) -> Set<Element> where Element == S.Element, S : Swift.Sequence {
    var newSet = self
    newSet.formSymmetricDifference(other)
    return newSet
  }
  @inlinable mutating public func formSymmetricDifference<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
    let otherSet = Set(other)
    formSymmetricDifference(otherSet)
  }
}
extension Set : CustomStringConvertible, CustomDebugStringConvertible {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
}
extension Set {
  @inlinable mutating public func subtract(_ other: Set<Element>) {
    _subtract(other)
  }
  @inlinable public func isSubset(of other: Set<Element>) -> Bool {
    guard self.count <= other.count else { return false }
    for member in self {
      if !other.contains(member) {
        return false
      }
    }
    return true
  }
  @inlinable public func isSuperset(of other: Set<Element>) -> Bool {
    return other.isSubset(of: self)
  }
  @inlinable public func isDisjoint(with other: Set<Element>) -> Bool {
    return _isDisjoint(with: other)
  }
  @inlinable internal func _isDisjoint<S>(with other: S) -> Bool where Element == S.Element, S : Swift.Sequence {
    guard !isEmpty else { return true }

    for member in other {
      if contains(member) {
        return false
      }
    }
    return true
  }
  @inlinable __consuming public func subtracting(_ other: Set<Element>) -> Set<Element> {
    return self._subtracting(other)
  }
  @inlinable public func isStrictSuperset(of other: Set<Element>) -> Bool {
    return self.isSuperset(of: other) && self != other
  }
  @inlinable public func isStrictSubset(of other: Set<Element>) -> Bool {
    return other.isStrictSuperset(of: self)
  }
  @inlinable __consuming public func intersection(_ other: Set<Element>) -> Set<Element> {
    var newSet = Set<Element>()
    for member in self {
      if other.contains(member) {
        newSet.insert(member)
      }
    }
    return newSet
  }
  @inlinable mutating public func formSymmetricDifference(_ other: __owned Set<Element>) {
    for member in other {
      if contains(member) {
        remove(member)
      } else {
        insert(member)
      }
    }
  }
}
extension Set {
  @_fixed_layout public struct Index {
    @usableFromInline
    @_frozen internal enum _Variant {
      case native(_HashTable.Index)
      case cocoa(__CocoaSet.Index)
    }
    @usableFromInline
    internal var _variant: _Variant
    @inlinable @inline(__always) internal init(_variant: __owned _Variant) {
      self._variant = _variant
    }
    @inlinable @inline(__always) internal init(_native index: _HashTable.Index) {
      self.init(_variant: .native(index))
    }
    @inlinable @inline(__always) internal init(_cocoa index: __owned __CocoaSet.Index) {
      self.init(_variant: .cocoa(index))
    }
  }
}
extension Set.Index {
  @usableFromInline
  @_transparent internal var _guaranteedNative: Bool {
    get {
    return _canBeClass(Element.self) == 0
  }
  }
  @usableFromInline
  @_transparent internal func _cocoaPath() {
    if _guaranteedNative {
      _conditionallyUnreachable()
    }
  }
  @inlinable @inline(__always) mutating internal func _isUniquelyReferenced() -> Bool {
    defer { _fixLifetime(self) }
    var handle = _asCocoa.handleBitPattern
    return handle == 0 || _isUnique_native(&handle)
  }
  @usableFromInline
  @_transparent internal var _isNative: Bool {
    get {
    switch _variant {
    case .native:
      return true
    case .cocoa:
      _cocoaPath()
      return false
    }
  }
  }
  @usableFromInline
  @_transparent internal var _asNative: _HashTable.Index {
    get {
    switch _variant {
    case .native(let nativeIndex):
      return nativeIndex
    case .cocoa:
      _preconditionFailure(
        "Attempting to access Set elements using an invalid index")
    }
  }
  }
  @usableFromInline
  internal var _asCocoa: __CocoaSet.Index {
    @_transparent get {
      switch _variant {
      case .native:
        _preconditionFailure(
          "Attempting to access Set elements using an invalid index")
      case .cocoa(let cocoaIndex):
        return cocoaIndex
      }
    }
    _modify
  }
}
extension Set.Index : Equatable {
  @inlinable public static func == (lhs: Set<Element>.Index, rhs: Set<Element>.Index) -> Bool {
    switch (lhs._variant, rhs._variant) {
    case (.native(let lhsNative), .native(let rhsNative)):
      return lhsNative == rhsNative
    case (.cocoa(let lhsCocoa), .cocoa(let rhsCocoa)):
      lhs._cocoaPath()
      return lhsCocoa == rhsCocoa
    default:
      _preconditionFailure("Comparing indexes from different sets")
    }
  }
}
extension Set.Index : Comparable {
  @inlinable public static func < (lhs: Set<Element>.Index, rhs: Set<Element>.Index) -> Bool {
    switch (lhs._variant, rhs._variant) {
    case (.native(let lhsNative), .native(let rhsNative)):
      return lhsNative < rhsNative
    case (.cocoa(let lhsCocoa), .cocoa(let rhsCocoa)):
      lhs._cocoaPath()
      return lhsCocoa < rhsCocoa
    default:
      _preconditionFailure("Comparing indexes from different sets")
    }
  }
}
extension Set.Index : Hashable {
  public func hash(into hasher: inout Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Set {
  @_fixed_layout public struct Iterator {
    @usableFromInline
    @_frozen internal enum _Variant {
      case native(_NativeSet<Element>.Iterator)
      case cocoa(__CocoaSet.Iterator)
    }
    @usableFromInline
    internal var _variant: _Variant
    @inlinable internal init(_variant: __owned _Variant) {
      self._variant = _variant
    }
    @inlinable internal init(_native: __owned _NativeSet<Element>.Iterator) {
      self.init(_variant: .native(_native))
    }
    @usableFromInline
    internal init(_cocoa: __owned __CocoaSet.Iterator)
  }
}
extension Set.Iterator {
  @usableFromInline
  @_transparent internal var _guaranteedNative: Bool {
    get {
    return _canBeClass(Element.self) == 0
  }
  }
  @usableFromInline
  @_transparent internal func _cocoaPath() {
    if _guaranteedNative {
      _conditionallyUnreachable()
    }
  }
  @usableFromInline
  @_transparent internal var _isNative: Bool {
    get {
    switch _variant {
    case .native:
      return true
    case .cocoa:
      _cocoaPath()
      return false
    }
  }
  }
  @usableFromInline
  @_transparent internal var _asNative: _NativeSet<Element>.Iterator {
    get {
      switch _variant {
      case .native(let nativeIterator):
        return nativeIterator
      case .cocoa:
        _internalInvariantFailure("internal error: does not contain a native index")
      }
    }
    set {
      self._variant = .native(newValue)
    }
  }
  @usableFromInline
  @_transparent internal var _asCocoa: __CocoaSet.Iterator {
    get {
      switch _variant {
      case .native:
        _internalInvariantFailure("internal error: does not contain a Cocoa index")
      case .cocoa(let cocoa):
        return cocoa
      }
    }
  }
}
extension Set.Iterator : IteratorProtocol {
  @inlinable @inline(__always) mutating public func next() -> Element? {
    guard _isNative else {
      guard let cocoaElement = _asCocoa.next() else { return nil }
      return _forceBridgeFromObjectiveC(cocoaElement, Element.self)
    }
    return _asNative.next()
  }
}
extension Set.Iterator : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Set : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Set {
  @inlinable mutating public func popFirst() -> Element? {
    guard !isEmpty else { return nil }
    return remove(at: startIndex)
  }
  @inlinable public var capacity: Int {
    get {
    return _variant.capacity
  }
  }
  mutating public func reserveCapacity(_ minimumCapacity: Int)
}
public typealias SetIndex<Element> = Set<Element>.Index where Element : Swift.Hashable
public typealias SetIterator<Element> = Set<Element>.Iterator where Element : Swift.Hashable
public protocol SetAlgebra : Swift.Equatable, Swift.ExpressibleByArrayLiteral {
  associatedtype Element
  init()
  func contains(_ member: Element) -> Bool
  __consuming func union(_ other: __owned Self) -> Self
  __consuming func intersection(_ other: Self) -> Self
  __consuming func symmetricDifference(_ other: __owned Self) -> Self
  @discardableResult
  mutating func insert(_ newMember: __owned Element) -> (inserted: Bool, memberAfterInsert: Element)
  @discardableResult
  mutating func remove(_ member: Element) -> Element?
  @discardableResult
  mutating func update(with newMember: __owned Element) -> Element?
  mutating func formUnion(_ other: __owned Self)
  mutating func formIntersection(_ other: Self)
  mutating func formSymmetricDifference(_ other: __owned Self)
  __consuming func subtracting(_ other: Self) -> Self
  func isSubset(of other: Self) -> Bool
  func isDisjoint(with other: Self) -> Bool
  func isSuperset(of other: Self) -> Bool
  var isEmpty: Bool { get }
  init<S>(_ sequence: __owned S) where S : Swift.Sequence, Self.Element == S.Element
  mutating func subtract(_ other: Self)
}
extension SetAlgebra {
  @inlinable public init<S>(_ sequence: __owned S) where S : Swift.Sequence, Self.Element == S.Element {
    self.init()
    for e in sequence { insert(e) }
  }
  @inlinable mutating public func subtract(_ other: Self) {
    self.formIntersection(self.symmetricDifference(other))
  }
  @inlinable public func isSubset(of other: Self) -> Bool {
    return self.intersection(other) == self
  }
  @inlinable public func isSuperset(of other: Self) -> Bool {
    return other.isSubset(of: self)
  }
  @inlinable public func isDisjoint(with other: Self) -> Bool {
    return self.intersection(other).isEmpty
  }
  @inlinable public func subtracting(_ other: Self) -> Self {
    return self.intersection(self.symmetricDifference(other))
  }
  @inlinable public var isEmpty: Bool {
    get {
    return self == Self()
  }
  }
  @inlinable public func isStrictSuperset(of other: Self) -> Bool {
    return self.isSuperset(of: other) && self != other
  }
  @inlinable public func isStrictSubset(of other: Self) -> Bool {
    return other.isStrictSuperset(of: self)
  }
}
extension SetAlgebra where Self.ArrayLiteralElement == Self.Element {
  @inlinable public init(arrayLiteral: Element...) {
    self.init(arrayLiteral)
  }
}
extension Set where Element == Swift.AnyHashable {
  @inlinable mutating public func insert<ConcreteElement>(_ newMember: __owned ConcreteElement) -> (inserted: Bool, memberAfterInsert: ConcreteElement) where ConcreteElement : Swift.Hashable {
    let (inserted, memberAfterInsert) =
      insert(AnyHashable(newMember))
    return (
      inserted: inserted,
      memberAfterInsert: memberAfterInsert.base as! ConcreteElement)
  }
  @discardableResult
  @inlinable mutating public func update<ConcreteElement>(with newMember: __owned ConcreteElement) -> ConcreteElement? where ConcreteElement : Swift.Hashable {
    return update(with: AnyHashable(newMember))
      .map { $0.base as! ConcreteElement }
  }
  @discardableResult
  @inlinable mutating public func remove<ConcreteElement>(_ member: ConcreteElement) -> ConcreteElement? where ConcreteElement : Swift.Hashable {
    return remove(AnyHashable(member))
      .map { $0.base as! ConcreteElement }
  }
}
extension _NativeSet {
  @usableFromInline
  __consuming internal func bridged() -> AnyObject
}
@usableFromInline
@_fixed_layout internal struct __CocoaSet {
  @usableFromInline
  internal let object: AnyObject
  @inlinable internal init(_ object: __owned AnyObject) {
    self.object = object
  }
}
extension __CocoaSet {
  @usableFromInline
  @_effects(releasenone) internal func member(for index: Index) -> AnyObject
  @usableFromInline
  internal func member(for element: AnyObject) -> AnyObject?
}
extension __CocoaSet {
  @usableFromInline
  internal func isEqual(to other: __CocoaSet) -> Bool
}
extension __CocoaSet {
  @usableFromInline
  internal typealias Element = AnyObject
  @usableFromInline
  internal var startIndex: Index {
    @_effects(releasenone) get
  }
  @usableFromInline
  internal var endIndex: Index {
    @_effects(releasenone) get
  }
  @usableFromInline
  @_effects(releasenone) internal func index(after index: Index) -> Index
  @usableFromInline
  internal func formIndex(after index: inout Index, isUnique: Bool)
  @usableFromInline
  @_effects(releasenone) internal func index(for element: AnyObject) -> Index?
  @usableFromInline
  internal var count: Int {
    get
  }
  @usableFromInline
  internal func contains(_ element: AnyObject) -> Bool
  @usableFromInline
  @_effects(releasenone) internal func element(at i: Index) -> AnyObject
}
extension __CocoaSet {
  @usableFromInline
  @_fixed_layout internal struct Index {
    internal var _storage: Builtin.BridgeObject
    internal var _offset: Int
  }
}
extension __CocoaSet.Index {
  @usableFromInline
  internal var handleBitPattern: UInt {
    @_effects(readonly) get
  }
}
extension __CocoaSet.Index {
  @usableFromInline
  @nonobjc internal var element: AnyObject {
    @_effects(readonly) get
  }
  @usableFromInline
  @nonobjc internal var age: Int32 {
    @_effects(releasenone) get
  }
}
extension __CocoaSet.Index : Equatable {
  @usableFromInline
  @_effects(readonly) internal static func == (lhs: __CocoaSet.Index, rhs: __CocoaSet.Index) -> Bool
}
extension __CocoaSet.Index : Comparable {
  @usableFromInline
  @_effects(readonly) internal static func < (lhs: __CocoaSet.Index, rhs: __CocoaSet.Index) -> Bool
}
extension __CocoaSet : Sequence {
  @usableFromInline
  final internal class Iterator {
    @objc @usableFromInline
    deinit
  }
  @usableFromInline
  __consuming internal func makeIterator() -> Iterator
}
extension __CocoaSet.Iterator : IteratorProtocol {
  @usableFromInline
  internal typealias Element = AnyObject
  @usableFromInline
  final internal func next() -> Element?
}
extension Set {
  @inlinable __consuming public func _bridgeToObjectiveCImpl() -> AnyObject {
    guard _variant.isNative else {
      return _variant.asCocoa.object
    }
    return _variant.asNative.bridged()
  }
  public static func _bridgeFromObjectiveCAdoptingNativeStorageOf(_ s: __owned AnyObject) -> Set<Element>?
}
@_fixed_layout public struct _SetBuilder<Element> where Element : Swift.Hashable {
  @usableFromInline
  internal var _target: _NativeSet<Element>
  @usableFromInline
  internal let _requestedCount: Int
  @inlinable public init(count: Int) {
    _target = _NativeSet(capacity: count)
    _requestedCount = count
  }
  @inlinable @inline(__always) mutating public func add(member: Element) {
    _precondition(_target.count < _requestedCount,
      "Can't add more members than promised")
    _target._unsafeInsertNew(member)
  }
  @inlinable __consuming public func take() -> Set<Element> {
    _precondition(_target.count == _requestedCount,
      "The number of members added does not match the promised count")
    return Set(_native: _target)
  }
}
extension Set {
  @_alwaysEmitIntoClient @inlinable @inline(__always) internal init?<C>(_mapping source: C, allowingDuplicates: Bool, transform: (C.Element) -> Element?) where C : Swift.Collection {
    var target = _NativeSet<Element>(capacity: source.count)
    if allowingDuplicates {
      for m in source {
        guard let member = transform(m) else { return nil }
        target._unsafeUpdate(with: member)
      }
    } else {
      for m in source {
        guard let member = transform(m) else { return nil }
        target._unsafeInsertNew(member)
      }
    }
    self.init(_native: target)
  }
}
@inlinable public func _setUpCast<DerivedValue, BaseValue>(_ source: Set<DerivedValue>) -> Set<BaseValue> where DerivedValue : Swift.Hashable, BaseValue : Swift.Hashable {
  return Set(
    _mapping: source,
    // String and NSString have different concepts of equality, so Set<NSString>
    // may generate key collisions when "upcasted" to Set<String>.
    // See rdar://problem/35995647
    allowingDuplicates: (BaseValue.self == String.self)
  ) { member in
    (member as! BaseValue)
  }!
}
@inlinable public func _setDownCast<BaseValue, DerivedValue>(_ source: Set<BaseValue>) -> Set<DerivedValue> where BaseValue : Swift.Hashable, DerivedValue : Swift.Hashable {

  if _isClassOrObjCExistential(BaseValue.self)
  && _isClassOrObjCExistential(DerivedValue.self) {
    guard source._variant.isNative else {
      return Set(_immutableCocoaSet: source._variant.asCocoa.object)
    }
    return Set(_immutableCocoaSet: source._variant.asNative.bridged())
  }
  // We can't just delegate to _setDownCastConditional here because we rely on
  // `as!` to generate nice runtime errors when the downcast fails.

  return Set(
    _mapping: source,
    // String and NSString have different concepts of equality, so
    // NSString-keyed Sets may generate key collisions when downcasted
    // to String. See rdar://problem/35995647
    allowingDuplicates: (DerivedValue.self == String.self)
  ) { member in
    (member as! DerivedValue)
  }!
}
@inlinable public func _setDownCastConditional<BaseValue, DerivedValue>(_ source: Set<BaseValue>) -> Set<DerivedValue>? where BaseValue : Swift.Hashable, DerivedValue : Swift.Hashable {
  return Set(
    _mapping: source,
    // String and NSString have different concepts of equality, so
    // NSString-keyed Sets may generate key collisions when downcasted
    // to String. See rdar://problem/35995647
    allowingDuplicates: (DerivedValue.self == String.self)
  ) { member in
    member as? DerivedValue
  }
}
@objc @usableFromInline
@_fixed_layout @_objc_non_lazy_realization internal class __RawSetStorage : __SwiftNativeNSSet {
  @usableFromInline
  @nonobjc final internal var _count: Int
  @usableFromInline
  @nonobjc final internal var _capacity: Int
  @usableFromInline
  @nonobjc final internal var _scale: Int8
  @usableFromInline
  @nonobjc final internal var _reservedScale: Int8
  @nonobjc final internal var _extra: Int16
  @usableFromInline
  @nonobjc final internal var _age: Int32
  @usableFromInline
  final internal var _seed: Int
  @usableFromInline
  @nonobjc final internal var _rawElements: UnsafeMutableRawPointer
  @inlinable @nonobjc final internal var _bucketCount: Int {
    @inline(__always) get { return 1 &<< _scale }
  }
  @inlinable @nonobjc final internal var _metadata: UnsafeMutablePointer<_HashTable.Word> {
    @inline(__always) get {
      let address = Builtin.projectTailElems(self, _HashTable.Word.self)
      return UnsafeMutablePointer(address)
    }
  }
  @inlinable @nonobjc final internal var _hashTable: _HashTable {
    @inline(__always) get {
      return _HashTable(words: _metadata, bucketCount: _bucketCount)
    }
  }
  @objc @usableFromInline
  deinit
}
@objc @usableFromInline
@_fixed_layout internal class __EmptySetSingleton : __RawSetStorage {
  @objc @usableFromInline
  deinit
}
extension __RawSetStorage {
  @inlinable @nonobjc internal static var empty: __EmptySetSingleton {
    get {
    return Builtin.bridgeFromRawPointer(
      Builtin.addressof(&_swiftEmptySetSingleton))
  }
  }
}
extension __EmptySetSingleton {
}
@usableFromInline
final internal class _SetStorage<Element> : __RawSetStorage where Element : Swift.Hashable {
  @objc deinit
  @inlinable final internal var _elements: UnsafeMutablePointer<Element> {
    @inline(__always) get {
      return self._rawElements.assumingMemoryBound(to: Element.self)
    }
  }
}
extension _SetStorage {
  @usableFromInline
  @_effects(releasenone) internal static func copy(original: __RawSetStorage) -> _SetStorage
  @usableFromInline
  @_effects(releasenone) internal static func resize(original: __RawSetStorage, capacity: Int, move: Bool) -> _SetStorage
  @usableFromInline
  @_effects(releasenone) internal static func allocate(capacity: Int) -> _SetStorage
  @usableFromInline
  @_effects(releasenone) internal static func convert(_ cocoa: __CocoaSet, capacity: Int) -> _SetStorage
}
extension Set {
  @usableFromInline
  @_fixed_layout internal struct _Variant {
    @usableFromInline
    internal var object: _BridgeStorage<__RawSetStorage>
    @inlinable @inline(__always) internal init(dummy: ()) {
      self.object = _BridgeStorage(taggedPayload: 0)
    }
    @inlinable @inline(__always) internal init(native: __owned _NativeSet<Element>) {
      self.object = _BridgeStorage(native: native._storage)
    }
    @inlinable @inline(__always) internal init(cocoa: __owned __CocoaSet) {
      self.object = _BridgeStorage(objC: cocoa.object)
    }
  }
}
extension Set._Variant {
  @usableFromInline
  @_transparent internal var guaranteedNative: Bool {
    get {
    return _canBeClass(Element.self) == 0
  }
  }
  @inlinable mutating internal func isUniquelyReferenced() -> Bool {
    return object.isUniquelyReferencedUnflaggedNative()
  }
  @usableFromInline
  @_transparent internal var isNative: Bool {
    get {
    if guaranteedNative { return true }
    return object.isUnflaggedNative
  }
  }
  @usableFromInline
  @_transparent internal var asNative: _NativeSet<Element> {
    get {
      return _NativeSet(object.unflaggedNativeInstance)
    }
    set {
      self = .init(native: newValue)
    }
    _modify {
      var native = _NativeSet<Element>(object.unflaggedNativeInstance)
      self = .init(dummy: ())
      defer {
        // This is in a defer block because yield might throw, and we need to
        // preserve Set's storage invariants when that happens.
        object = .init(native: native._storage)
      }
      yield &native
    }
  }
  @inlinable internal var asCocoa: __CocoaSet {
    get {
    return __CocoaSet(object.objCInstance)
  }
  }
  @inlinable internal var capacity: Int {
    get {
    guard isNative else {
      return asCocoa.count
    }
    return asNative.capacity
  }
  }
}
extension Set._Variant {
  @usableFromInline
  internal typealias Index = Set<Element>.Index
  @inlinable internal var startIndex: Index {
    get {
    guard isNative else {
      return Index(_cocoa: asCocoa.startIndex)
    }
    return asNative.startIndex
  }
  }
  @inlinable internal var endIndex: Index {
    get {
    guard isNative else {
      return Index(_cocoa: asCocoa.endIndex)
    }
    return asNative.endIndex
  }
  }
  @inlinable internal func index(after index: Index) -> Index {
    guard isNative else {
      return Index(_cocoa: asCocoa.index(after: index._asCocoa))
    }
    return asNative.index(after: index)
  }
  @inlinable internal func formIndex(after index: inout Index) {
    guard isNative else {
      let isUnique = index._isUniquelyReferenced()
      asCocoa.formIndex(after: &index._asCocoa, isUnique: isUnique)
      return
    }
    index = asNative.index(after: index)
  }
  @inlinable @inline(__always) internal func index(for element: Element) -> Index? {
    guard isNative else {
      let cocoaElement = _bridgeAnythingToObjectiveC(element)
      guard let index = asCocoa.index(for: cocoaElement) else { return nil }
      return Index(_cocoa: index)
    }
    return asNative.index(for: element)
  }
  @inlinable internal var count: Int {
    @inline(__always) get {
      guard isNative else {
        return asCocoa.count
      }
      return asNative.count
    }
  }
  @inlinable @inline(__always) internal func contains(_ member: Element) -> Bool {
    guard isNative else {
      return asCocoa.contains(_bridgeAnythingToObjectiveC(member))
    }
    return asNative.contains(member)
  }
  @inlinable @inline(__always) internal func element(at index: Index) -> Element {
    guard isNative else {
      let cocoaMember = asCocoa.element(at: index._asCocoa)
      return _forceBridgeFromObjectiveC(cocoaMember, Element.self)
    }
    return asNative.element(at: index)
  }
}
extension Set._Variant {
  @inlinable mutating internal func update(with value: __owned Element) -> Element? {
    guard isNative else {
      // Make sure we have space for an extra element.
      var native = _NativeSet<Element>(asCocoa, capacity: asCocoa.count + 1)
      let old = native.update(with: value, isUnique: true)
      self = .init(native: native)
      return old
    }
    let isUnique = self.isUniquelyReferenced()
    return asNative.update(with: value, isUnique: isUnique)
  }
  @inlinable mutating internal func insert(_ element: __owned Element) -> (inserted: Bool, memberAfterInsert: Element) {
    guard isNative else {
      // Make sure we have space for an extra element.
      let cocoaMember = _bridgeAnythingToObjectiveC(element)
      let cocoa = asCocoa
      if let m = cocoa.member(for: cocoaMember) {
        return (false, _forceBridgeFromObjectiveC(m, Element.self))
      }
      var native = _NativeSet<Element>(cocoa, capacity: cocoa.count + 1)
      native.insertNew(element, isUnique: true)
      self = .init(native: native)
      return (true, element)
    }
    let (bucket, found) = asNative.find(element)
    if found {
      return (false, asNative.uncheckedElement(at: bucket))
    }
    let isUnique = self.isUniquelyReferenced()
    asNative.insertNew(element, at: bucket, isUnique: isUnique)
    return (true, element)
  }
  @discardableResult
  @inlinable mutating internal func remove(at index: Index) -> Element {
    guard isNative else {
      // We have to migrate the data first.  But after we do so, the Cocoa
      // index becomes useless, so get the element first.
      let cocoa = asCocoa
      let cocoaMember = cocoa.member(for: index._asCocoa)
      let nativeMember = _forceBridgeFromObjectiveC(cocoaMember, Element.self)
      return _migrateToNative(cocoa, removing: nativeMember)
    }
    let isUnique = isUniquelyReferenced()
    let bucket = asNative.validatedBucket(for: index)
    return asNative.uncheckedRemove(at: bucket, isUnique: isUnique)
  }
  @discardableResult
  @inlinable mutating internal func remove(_ member: Element) -> Element? {
    guard isNative else {
      let cocoa = asCocoa
      let cocoaMember = _bridgeAnythingToObjectiveC(member)
      guard cocoa.contains(cocoaMember) else { return nil }
      return _migrateToNative(cocoa, removing: member)
    }
    let (bucket, found) = asNative.find(member)
    guard found else { return nil }
    let isUnique = isUniquelyReferenced()
    return asNative.uncheckedRemove(at: bucket, isUnique: isUnique)
  }
  @inlinable mutating internal func _migrateToNative(_ cocoa: __CocoaSet, removing member: Element) -> Element {
    // FIXME(performance): fuse data migration and element deletion into one
    // operation.
    var native = _NativeSet<Element>(cocoa)
    let (bucket, found) = native.find(member)
    _precondition(found, "Bridging did not preserve equality")
    let old = native.uncheckedRemove(at: bucket, isUnique: true)
    _precondition(member == old, "Bridging did not preserve equality")
    self = .init(native: native)
    return old
  }
  @inlinable mutating internal func removeAll(keepingCapacity keepCapacity: Bool) {
    if !keepCapacity {
      self = .init(native: _NativeSet<Element>())
      return
    }
    guard count > 0 else { return }

    guard isNative else {
      self = .init(native: _NativeSet(capacity: asCocoa.count))
      return
    }
    let isUnique = isUniquelyReferenced()
    asNative.removeAll(isUnique: isUnique)
  }
}
extension Set._Variant {
  @inlinable @inline(__always) __consuming internal func makeIterator() -> Set<Element>.Iterator {
    guard isNative else {
      return Set.Iterator(_cocoa: asCocoa.makeIterator())
    }
    return Set.Iterator(_native: asNative.makeIterator())
  }
}
@inlinable internal func _makeSwiftNSFastEnumerationState() -> _SwiftNSFastEnumerationState {
  return _SwiftNSFastEnumerationState(
    state: 0, itemsPtr: nil, mutationsPtr: nil,
    extra: (0, 0, 0, 0, 0))
}
@usableFromInline
internal var _fastEnumerationStorageMutationsTarget: CUnsignedLong
@usableFromInline
internal let _fastEnumerationStorageMutationsPtr: Swift.UnsafeMutablePointer<Swift.CUnsignedLong>
@_fixed_layout public struct Slice<Base> where Base : Swift.Collection {
  public var _startIndex: Base.Index
  public var _endIndex: Base.Index
  @usableFromInline
  internal var _base: Base
  @inlinable public init(base: Base, bounds: Range<Base.Index>) {
    self._base = base
    self._startIndex = bounds.lowerBound
    self._endIndex = bounds.upperBound
  }
  @inlinable public var base: Base {
    get {
    return _base
  }
  }
}
extension Slice : Collection {
  public typealias Index = Base.Index
  public typealias Indices = Base.Indices
  public typealias Element = Base.Element
  public typealias SubSequence = Slice<Base>
  public typealias Iterator = IndexingIterator<Slice<Base>>
  @inlinable public var startIndex: Index {
    get {
    return _startIndex
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return _endIndex
  }
  }
  @inlinable public subscript(index: Index) -> Base.Element {
    get {
      _failEarlyRangeCheck(index, bounds: startIndex..<endIndex)
      return _base[index]
    }
  }
  @inlinable public subscript(bounds: Range<Index>) -> Slice<Base> {
    get {
      _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
      return Slice(base: _base, bounds: bounds)
    }
  }
  public var indices: Indices {
    get
  }
  @inlinable public func index(after i: Index) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(after: i)
  }
  @inlinable public func formIndex(after i: inout Index) {
    // FIXME: swift-3-indexing-model: range check.
    _base.formIndex(after: &i)
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index? {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    // FIXME: swift-3-indexing-model: range check.
    return _base.distance(from: start, to: end)
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Index, bounds: Range<Index>) {
    _base._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Range<Index>, bounds: Range<Index>) {
    _base._failEarlyRangeCheck(range, bounds: bounds)
  }
}
extension Slice : BidirectionalCollection where Base : Swift.BidirectionalCollection {
  @inlinable public func index(before i: Index) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(before: i)
  }
  @inlinable public func formIndex(before i: inout Index) {
    // FIXME: swift-3-indexing-model: range check.
    _base.formIndex(before: &i)
  }
}
extension Slice : MutableCollection where Base : Swift.MutableCollection {
  @inlinable public subscript(index: Index) -> Base.Element {
    get {
      _failEarlyRangeCheck(index, bounds: startIndex..<endIndex)
      return _base[index]
    }
    set {
      _failEarlyRangeCheck(index, bounds: startIndex..<endIndex)
      _base[index] = newValue
      // MutableSlice requires that the underlying collection's subscript
      // setter does not invalidate indices, so our `startIndex` and `endIndex`
      // continue to be valid.
    }
  }
  @inlinable public subscript(bounds: Range<Index>) -> Slice<Base> {
    get {
      _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
      return Slice(base: _base, bounds: bounds)
    }
    set {
      _writeBackMutableSlice(&self, bounds: bounds, slice: newValue)
    }
  }
}
extension Slice : RandomAccessCollection where Base : Swift.RandomAccessCollection {
}
extension Slice : RangeReplaceableCollection where Base : Swift.RangeReplaceableCollection {
  @inlinable public init() {
    self._base = Base()
    self._startIndex = _base.startIndex
    self._endIndex = _base.endIndex
  }
  @inlinable public init(repeating repeatedValue: Base.Element, count: Int) {
    self._base = Base(repeating: repeatedValue, count: count)
    self._startIndex = _base.startIndex
    self._endIndex = _base.endIndex
  }
  @inlinable public init<S>(_ elements: S) where S : Swift.Sequence, Base.Element == S.Element {
    self._base = Base(elements)
    self._startIndex = _base.startIndex
    self._endIndex = _base.endIndex
  }
  @inlinable mutating public func replaceSubrange<C>(_ subRange: Range<Index>, with newElements: C) where C : Swift.Collection, Base.Element == C.Element {

    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset =
      _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount =
      _base.distance(from: _startIndex, to: subRange.lowerBound)
      + _base.distance(from: subRange.upperBound, to: _endIndex)
      + (numericCast(newElements.count) as Int)
    _base.replaceSubrange(subRange, with: newElements)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
  @inlinable mutating public func insert(_ newElement: Base.Element, at i: Index) {
    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count + 1
    _base.insert(newElement, at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
  @inlinable mutating public func insert<S>(contentsOf newElements: S, at i: Index) where S : Swift.Collection, Base.Element == S.Element {

    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count + newElements.count
    _base.insert(contentsOf: newElements, at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
  @inlinable mutating public func remove(at i: Index) -> Base.Element {
    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count - 1
    let result = _base.remove(at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    return result
  }
  @inlinable mutating public func removeSubrange(_ bounds: Range<Index>) {
    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount =
      count - distance(from: bounds.lowerBound, to: bounds.upperBound)
    _base.removeSubrange(bounds)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
}
extension Slice where Base : Swift.BidirectionalCollection, Base : Swift.RangeReplaceableCollection {
  @inlinable mutating public func replaceSubrange<C>(_ subRange: Range<Index>, with newElements: C) where C : Swift.Collection, Base.Element == C.Element {
    // FIXME: swift-3-indexing-model: range check.
    if subRange.lowerBound == _base.startIndex {
      let newSliceCount =
        _base.distance(from: _startIndex, to: subRange.lowerBound)
        + _base.distance(from: subRange.upperBound, to: _endIndex)
        + (numericCast(newElements.count) as Int)
      _base.replaceSubrange(subRange, with: newElements)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = subRange.lowerBound == _startIndex
      let lastValidIndex = _base.index(before: subRange.lowerBound)
      let newEndIndexOffset =
        _base.distance(from: subRange.upperBound, to: _endIndex)
        + (numericCast(newElements.count) as Int) + 1
      _base.replaceSubrange(subRange, with: newElements)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
  @inlinable mutating public func insert(_ newElement: Base.Element, at i: Index) {
    // FIXME: swift-3-indexing-model: range check.
    if i == _base.startIndex {
      let newSliceCount = count + 1
      _base.insert(newElement, at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset = _base.distance(from: i, to: _endIndex) + 2
      _base.insert(newElement, at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
  @inlinable mutating public func insert<S>(contentsOf newElements: S, at i: Index) where S : Swift.Collection, Base.Element == S.Element {
    // FIXME: swift-3-indexing-model: range check.
    if i == _base.startIndex {
      let newSliceCount = count + numericCast(newElements.count)
      _base.insert(contentsOf: newElements, at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset =
        _base.distance(from: i, to: _endIndex)
        + numericCast(newElements.count) + 1
      _base.insert(contentsOf: newElements, at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
  @inlinable mutating public func remove(at i: Index) -> Base.Element {
    // FIXME: swift-3-indexing-model: range check.
    if i == _base.startIndex {
      let newSliceCount = count - 1
      let result = _base.remove(at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
      return result
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset = _base.distance(from: i, to: _endIndex)
      let result = _base.remove(at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
      return result
    }
  }
  @inlinable mutating public func removeSubrange(_ bounds: Range<Index>) {
    // FIXME: swift-3-indexing-model: range check.
    if bounds.lowerBound == _base.startIndex {
      let newSliceCount =
        count - _base.distance(from: bounds.lowerBound, to: bounds.upperBound)
      _base.removeSubrange(bounds)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = bounds.lowerBound == _startIndex
      let lastValidIndex = _base.index(before: bounds.lowerBound)
      let newEndIndexOffset =
          _base.distance(from: bounds.lowerBound, to: _endIndex)
        - _base.distance(from: bounds.lowerBound, to: bounds.upperBound)
        + 1
      _base.removeSubrange(bounds)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
}
@usableFromInline
@_fixed_layout internal struct _SmallString {
  @usableFromInline
  internal typealias RawBitPattern = (UInt64, UInt64)
  @usableFromInline
  internal var _storage: RawBitPattern
  @inlinable @inline(__always) internal var rawBits: RawBitPattern {
    get { return _storage }
  }
  @inlinable internal var leadingRawBits: UInt64 {
    @inline(__always) get { return _storage.0 }
    @inline(__always) set { _storage.0 = newValue }
  }
  @inlinable internal var trailingRawBits: UInt64 {
    @inline(__always) get { return _storage.1 }
    @inline(__always) set { _storage.1 = newValue }
  }
  @inlinable @inline(__always) internal init(rawUnchecked bits: RawBitPattern) {
    self._storage = bits
  }
  @inlinable @inline(__always) internal init(raw bits: RawBitPattern) {
    self.init(rawUnchecked: bits)
    _invariantCheck()
  }
  @inlinable @inline(__always) internal init(_ object: _StringObject) {
    _internalInvariant(object.isSmall)
    // On big-endian platforms the byte order is the reverse of _StringObject.
    let leading = object.rawBits.0.littleEndian
    let trailing = object.rawBits.1.littleEndian
    self.init(raw: (leading, trailing))
  }
  @inlinable @inline(__always) internal init() {
    self.init(_StringObject(empty:()))
  }
}
extension _SmallString {
  @inlinable @inline(__always) internal static var capacity: Int {
    get {
    return 15
  }
  }
  @inlinable @inline(__always) internal var rawDiscriminatedObject: UInt64 {
    get {
    // Reverse the bytes on big-endian systems.
    return _storage.1.littleEndian
  }
  }
  @inlinable @inline(__always) internal var capacity: Int {
    get { return _SmallString.capacity }
  }
  @inlinable @inline(__always) internal var count: Int {
    get {
    return _StringObject.getSmallCount(fromRaw: rawDiscriminatedObject)
  }
  }
  @inlinable @inline(__always) internal var unusedCapacity: Int {
    get { return capacity &- count }
  }
  @inlinable @inline(__always) internal var isASCII: Bool {
    get {
    return _StringObject.getSmallIsASCII(fromRaw: rawDiscriminatedObject)
  }
  }
  @inlinable @inline(__always) internal var zeroTerminatedRawCodeUnits: RawBitPattern {
    get {
    let smallStringCodeUnitMask = ~UInt64(0xFF).bigEndian // zero last byte
    return (self._storage.0, self._storage.1 & smallStringCodeUnitMask)
  }
  }
}
extension _SmallString {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension _SmallString : RandomAccessCollection, MutableCollection {
  @usableFromInline
  internal typealias Index = Int
  @usableFromInline
  internal typealias Element = UInt8
  @usableFromInline
  internal typealias SubSequence = _SmallString
  @inlinable @inline(__always) internal var startIndex: Int {
    get { return 0 }
  }
  @inlinable @inline(__always) internal var endIndex: Int {
    get { return count }
  }
  @inlinable internal subscript(idx: Int) -> UInt8 {
    @inline(__always) get {
      _internalInvariant(idx >= 0 && idx <= 15)
      if idx < 8 {
        return leadingRawBits._uncheckedGetByte(at: idx)
      } else {
        return trailingRawBits._uncheckedGetByte(at: idx &- 8)
      }
    }
    @inline(__always) set {
      _internalInvariant(idx >= 0 && idx <= 15)
      if idx < 8 {
        leadingRawBits._uncheckedSetByte(at: idx, to: newValue)
      } else {
        trailingRawBits._uncheckedSetByte(at: idx &- 8, to: newValue)
      }
    }
  }
  @inlinable @inline(__always) internal subscript(bounds: Range<Index>) -> SubSequence {
    get {
    // TODO(String performance): In-vector-register operation
    return self.withUTF8 { utf8 in
      let rebased = UnsafeBufferPointer(rebasing: utf8[bounds])
      return _SmallString(rebased)._unsafelyUnwrappedUnchecked
    }
  }
  }
  @usableFromInline
  internal typealias Indices = Swift.Range<Swift._SmallString.Index>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Swift._SmallString>
}
extension _SmallString {
  @inlinable @inline(__always) internal func withUTF8<Result>(_ f: (UnsafeBufferPointer<UInt8>) throws -> Result) rethrows -> Result {
    var raw = self.zeroTerminatedRawCodeUnits
    return try Swift.withUnsafeBytes(of: &raw) { rawBufPtr in
      let ptr = rawBufPtr.baseAddress._unsafelyUnwrappedUnchecked
        .assumingMemoryBound(to: UInt8.self)
      return try f(UnsafeBufferPointer(start: ptr, count: self.count))
    }
  }
}
extension _SmallString {
  @inlinable @inline(__always) internal init(leading: UInt64, trailing: UInt64, count: Int) {
    _internalInvariant(count <= _SmallString.capacity)

    let isASCII = (leading | trailing) & 0x8080_8080_8080_8080 == 0
    let discriminator = _StringObject.Nibbles
      .small(withCount: count, isASCII: isASCII)
      .littleEndian // reversed byte order on big-endian platforms
    _internalInvariant(trailing & discriminator == 0)

    self.init(raw: (leading, trailing | discriminator))
    _internalInvariant(self.count == count)
  }
  @inlinable @inline(__always) internal init?(_ input: UnsafeBufferPointer<UInt8>) {
    if input.isEmpty {
      self.init()
      return
    }

    let count = input.count
    guard count <= _SmallString.capacity else { return nil }

    // TODO(SIMD): The below can be replaced with just be a masked unaligned
    // vector load
    let ptr = input.baseAddress._unsafelyUnwrappedUnchecked
    let leading = _bytesToUInt64(ptr, Swift.min(input.count, 8))
    let trailing = count > 8 ? _bytesToUInt64(ptr + 8, count &- 8) : 0

    self.init(leading: leading, trailing: trailing, count: count)
  }
  @usableFromInline
  internal init?(_ base: _SmallString, appending other: _SmallString)
}
extension _SmallString {
  @usableFromInline
  @_effects(readonly) internal init(taggedCocoa cocoa: AnyObject)
}
extension UInt64 {
  @inlinable @inline(__always) internal func _uncheckedGetByte(at i: Int) -> UInt8 {
    _internalInvariant(i >= 0 && i < MemoryLayout<UInt64>.stride)
    let shift = UInt64(truncatingIfNeeded: i) &* 8
    return UInt8(truncatingIfNeeded: (self &>> shift))
  }
  @inlinable @inline(__always) mutating internal func _uncheckedSetByte(at i: Int, to value: UInt8) {
    _internalInvariant(i >= 0 && i < MemoryLayout<UInt64>.stride)
    let shift = UInt64(truncatingIfNeeded: i) &* 8
    let valueMask: UInt64 = 0xFF &<< shift
    self = (self & ~valueMask) | (UInt64(truncatingIfNeeded: value) &<< shift)
  }
}
@inlinable @inline(__always) internal func _bytesToUInt64(_ input: UnsafePointer<UInt8>, _ c: Int) -> UInt64 {
  // FIXME: This should be unified with _loadPartialUnalignedUInt64LE.
  // Unfortunately that causes regressions in literal concatenation tests. (Some
  // owned to guaranteed specializations don't get inlined.)
  var r: UInt64 = 0
  var shift: Int = 0
  for idx in 0..<c {
    r = r | (UInt64(input[idx]) &<< shift)
    shift = shift &+ 8
  }
  // Convert from little-endian to host byte order.
  return r.littleEndian
}
extension Sequence where Self.Element : Swift.Comparable {
  @inlinable public func sorted() -> [Element] {
    return sorted(by: <)
  }
}
extension Sequence {
  @inlinable public func sorted(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> [Element] {
    var result = ContiguousArray(self)
    try result.sort(by: areInIncreasingOrder)
    return Array(result)
  }
}
extension MutableCollection where Self : Swift.RandomAccessCollection, Self.Element : Swift.Comparable {
  @inlinable mutating public func sort() {
    sort(by: <)
  }
}
extension MutableCollection where Self : Swift.RandomAccessCollection {
  @inlinable mutating public func sort(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows {
    let didSortUnsafeBuffer = try _withUnsafeMutableBufferPointerIfSupported {
      buffer -> Void? in
        try buffer._stableSortImpl(by: areInIncreasingOrder)
    }
    if didSortUnsafeBuffer == nil {
      // Fallback since we can't use an unsafe buffer: sort into an outside
      // array, then copy elements back in.
      let sortedElements = try sorted(by: areInIncreasingOrder)
      for (i, j) in zip(indices, sortedElements.indices) {
        self[i] = sortedElements[j]
      }
    }
  }
}
extension MutableCollection where Self : Swift.BidirectionalCollection {
  @inlinable mutating internal func _insertionSort(within range: Range<Index>, sortedEnd: Index, by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows {
    var sortedEnd = sortedEnd
    
    // Continue sorting until the sorted elements cover the whole sequence.
    while sortedEnd != range.upperBound {
      var i = sortedEnd
      // Look backwards for `self[i]`'s position in the sorted sequence,
      // moving each element forward to make room.
      repeat {
        let j = index(before: i)
        
        // If `self[i]` doesn't belong before `self[j]`, we've found
        // its position.
        if try !areInIncreasingOrder(self[i], self[j]) {
          break
        }
        
        swapAt(i, j)
        i = j
      } while i != range.lowerBound
      
      formIndex(after: &sortedEnd)
    }
  }
  @inlinable mutating public func _insertionSort(within range: Range<Index>, by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows {
    if range.isEmpty {
      return
    }
    
    // One element is trivially already-sorted, so the actual sort can
    // start on the second element.
    let sortedEnd = index(after: range.lowerBound)
    try _insertionSort(
      within: range, sortedEnd: sortedEnd, by: areInIncreasingOrder)
  }
  @inlinable mutating internal func _reverse(within range: Range<Index>) {
    var f = range.lowerBound
    var l = range.upperBound
    while f < l {
      formIndex(before: &l)
      swapAt(f, l)
      formIndex(after: &f)
    }
  }
}
@inlinable internal func _merge<Element>(low: UnsafeMutablePointer<Element>, mid: UnsafeMutablePointer<Element>, high: UnsafeMutablePointer<Element>, buffer: UnsafeMutablePointer<Element>, by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Bool {
  let lowCount = mid - low
  let highCount = high - mid
  
  var destLow = low         // Lower bound of uninitialized storage
  var bufferLow = buffer    // Lower bound of the initialized buffer
  var bufferHigh = buffer   // Upper bound of the initialized buffer

  // When we exit the merge, move any remaining elements from the buffer back
  // into `destLow` (aka the collection we're sorting). The buffer can have
  // remaining elements if `areIncreasingOrder` throws, or more likely if the
  // merge runs out of elements from the array before exhausting the buffer.
  defer {
    destLow.moveInitialize(from: bufferLow, count: bufferHigh - bufferLow)
  }
  
  if lowCount < highCount {
    // Move the lower group of elements into the buffer, then traverse from
    // low to high in both the buffer and the higher group of elements.
    //
    // After moving elements, the storage and buffer look like this, where
    // `x` is uninitialized memory:
    //
    // Storage: [x, x, x, x, x, 6, 8, 8, 10, 12, 15]
    //           ^              ^
    //        destLow        srcLow
    //
    // Buffer:  [4, 4, 7, 8, 9, x, ...]
    //           ^              ^
    //        bufferLow     bufferHigh
    buffer.moveInitialize(from: low, count: lowCount)
    bufferHigh = bufferLow + lowCount
    
    var srcLow = mid

    // Each iteration moves the element that compares lower into `destLow`,
    // preferring the buffer when equal to maintain stability. Elements are
    // moved from either `bufferLow` or `srcLow`, with those pointers
    // incrementing as elements are moved.
    while bufferLow < bufferHigh && srcLow < high {
      if try areInIncreasingOrder(srcLow.pointee, bufferLow.pointee) {
        destLow.moveInitialize(from: srcLow, count: 1)
        srcLow += 1
      } else {
        destLow.moveInitialize(from: bufferLow, count: 1)
        bufferLow += 1
      }
      destLow += 1
    }
  } else {
    // Move the higher group of elements into the buffer, then traverse from
    // high to low in both the buffer and the lower group of elements.
    //
    // After moving elements, the storage and buffer look like this, where
    // `x` is uninitialized memory:
    //
    // Storage: [4, 4, 7, 8, 9, 6, x, x,  x,  x,  x]
    //                          ^  ^                 ^
    //                    srcHigh  destLow        destHigh (past the end)
    //
    // Buffer:                    [8, 8, 10, 12, 15, x, ...]
    //                             ^                 ^
    //                          bufferLow        bufferHigh
    buffer.moveInitialize(from: mid, count: highCount)
    bufferHigh = bufferLow + highCount
    
    var destHigh = high
    var srcHigh = mid
    destLow = mid

    // Each iteration moves the element that compares higher into `destHigh`,
    // preferring the buffer when equal to maintain stability. Elements are
    // moved from either `bufferHigh - 1` or `srcHigh - 1`, with those
    // pointers decrementing as elements are moved.
    //
    // Note: At the start of each iteration, each `...High` pointer points one
    // past the element they're referring to.
    while bufferHigh > bufferLow && srcHigh > low {
      destHigh -= 1
      if try areInIncreasingOrder(
        (bufferHigh - 1).pointee, (srcHigh - 1).pointee
      ) {
        srcHigh -= 1
        destHigh.moveInitialize(from: srcHigh, count: 1)
        
        // Moved an element from the lower initialized portion to the upper,
        // sorted, initialized portion, so `destLow` moves down one.
        destLow -= 1
      } else {
        bufferHigh -= 1
        destHigh.moveInitialize(from: bufferHigh, count: 1)
      }
    }
  }

  // FIXME: Remove this, it works around rdar://problem/45044610
  return true
}
@inlinable internal func _minimumMergeRunLength(_ c: Int) -> Int {
  // Max out at `2^6 == 64` elements
  let bitsToUse = 6
  
  if c < 1 << bitsToUse {
    return c
  }
  let offset = (Int.bitWidth - bitsToUse) - c.leadingZeroBitCount
  let mask = (1 << offset) - 1
  return c >> offset + (c & mask == 0 ? 0 : 1)
}
@inlinable internal func _findNextRun<C>(in elements: C, from start: C.Index, by areInIncreasingOrder: (C.Element, C.Element) throws -> Bool) rethrows -> (end: C.Index, descending: Bool) where C : Swift.RandomAccessCollection {
  _internalInvariant(start < elements.endIndex)

  var previous = start
  var current = elements.index(after: start)
  guard current < elements.endIndex else {
    // This is a one-element run, so treating it as ascending saves a
    // meaningless call to `reverse()`.
    return (current, false)
  }

  // Check whether the run beginning at `start` is ascending or descending.
  // An ascending run can include consecutive equal elements, but because a
  // descending run will be reversed, it must be strictly descending.
  let isDescending =
    try areInIncreasingOrder(elements[current], elements[previous])
  
  // Advance `current` until there's a break in the ascending / descending
  // pattern.
  repeat {
    previous = current
    elements.formIndex(after: &current)
  } while try current < elements.endIndex &&
    isDescending == areInIncreasingOrder(elements[current], elements[previous])
    
  return(current, isDescending)
}
extension UnsafeMutableBufferPointer {
  @inlinable mutating public func _mergeRuns(_ runs: inout [Range<Index>], at i: Int, buffer: UnsafeMutablePointer<Element>, by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Bool {
    _internalInvariant(runs[i - 1].upperBound == runs[i].lowerBound)
    let low = runs[i - 1].lowerBound
    let middle = runs[i].lowerBound
    let high = runs[i].upperBound
    
    let result = try _merge(
      low: baseAddress! + low,
      mid: baseAddress! + middle,
      high: baseAddress! + high,
      buffer: buffer,
      by: areInIncreasingOrder)
    
    runs[i - 1] = low..<high
    runs.remove(at: i)

    // FIXME: Remove this, it works around rdar://problem/45044610
    return result
  }
  @inlinable mutating public func _mergeTopRuns(_ runs: inout [Range<Index>], buffer: UnsafeMutablePointer<Element>, by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Bool {
    // The invariants for the `runs` array are:
    // (a) - for all i in 2..<runs.count:
    //         - runs[i - 2].count > runs[i - 1].count + runs[i].count
    // (b) - for c = runs.count - 1:
    //         - runs[i - 1].count > runs[i].count
    //
    // Loop until the invariant is satisified for the top four elements of
    // `runs`. Because this method is called for every added run, and only
    // the top three runs are ever merged, this guarantees the invariant holds
    // for the whole array.
    //
    // At all times, `runs` is one of the following, where W, X, Y, and Z are
    // the counts of their respective ranges:
    // - [ ...?, W, X, Y, Z ]
    // - [ X, Y, Z ]
    // - [ Y, Z ]
    //
    // If W > X + Y, X > Y + Z, and Y > Z, then the invariants are satisfied
    // for the entirety of `runs`.
    
    // FIXME: Remove this, it works around rdar://problem/45044610
    var result = true

    // The invariant is always in place for a single element.
    while runs.count > 1 {
      var lastIndex = runs.count - 1
      
      // Check for the three invariant-breaking conditions, and break out of
      // the while loop if none are met.
      if lastIndex >= 3 &&
        (runs[lastIndex - 3].count <=
          runs[lastIndex - 2].count + runs[lastIndex - 1].count)
      {
        // Second-to-last three runs do not follow W > X + Y.
        // Always merge Y with the smaller of X or Z.
        if runs[lastIndex - 2].count < runs[lastIndex].count {
          lastIndex -= 1
        }
      } else if lastIndex >= 2 &&
        (runs[lastIndex - 2].count <=
          runs[lastIndex - 1].count + runs[lastIndex].count)
      {
        // Last three runs do not follow X > Y + Z.
        // Always merge Y with the smaller of X or Z.
        if runs[lastIndex - 2].count < runs[lastIndex].count {
          lastIndex -= 1
        }
      } else if runs[lastIndex - 1].count <= runs[lastIndex].count {
        // Last two runs do not follow Y > Z, so merge Y and Z.
        // This block is intentionally blank--the merge happens below.
      } else {
        // All invariants satisfied!
        break
      }
      
      // Merge the runs at `i` and `i - 1`.
      result = try result && _mergeRuns(
        &runs, at: lastIndex, buffer: buffer, by: areInIncreasingOrder)
    }

    return result
  }
  @inlinable mutating public func _finalizeRuns(_ runs: inout [Range<Index>], buffer: UnsafeMutablePointer<Element>, by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows -> Bool {
    // FIXME: Remove this, it works around rdar://problem/45044610
    var result = true
    while runs.count > 1 {
      result = try result && _mergeRuns(
        &runs, at: runs.count - 1, buffer: buffer, by: areInIncreasingOrder)
    }
    return result
  }
  @inlinable mutating public func _stableSortImpl(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows {
    let minimumRunLength = _minimumMergeRunLength(count)
    if count <= minimumRunLength {
      try _insertionSort(
        within: startIndex..<endIndex, by: areInIncreasingOrder)
      return
    }

    // FIXME: Remove this, it works around rdar://problem/45044610
    var result = true

    // Use array's allocating initializer to create a temporary buffer---this
    // keeps the buffer allocation going through the same tail-allocated path
    // as other allocating methods.
    //
    // There's no need to set the initialized count within the initializing
    // closure, since the buffer is guaranteed to be uninitialized at exit.
    _ = try Array<Element>(_unsafeUninitializedCapacity: count / 2) {
      buffer, _ in
      var runs: [Range<Index>] = []
      
      var start = startIndex
      while start < endIndex {
        // Find the next consecutive run, reversing it if necessary.
        var (end, descending) =
          try _findNextRun(in: self, from: start, by: areInIncreasingOrder)
        if descending {
          _reverse(within: start..<end)
        }
        
        // If the current run is shorter than the minimum length, use the
        // insertion sort to extend it.
        if end < endIndex && end - start < minimumRunLength {
          let newEnd = Swift.min(endIndex, start + minimumRunLength)
          try _insertionSort(
            within: start..<newEnd, sortedEnd: end, by: areInIncreasingOrder)
          end = newEnd
        }
        
        // Append this run and merge down as needed to maintain the `runs`
        // invariants.
        runs.append(start..<end)
        result = try result && _mergeTopRuns(
          &runs, buffer: buffer.baseAddress!, by: areInIncreasingOrder)
        start = end
      }
      
      result = try result && _finalizeRuns(
        &runs, buffer: buffer.baseAddress!, by: areInIncreasingOrder)
      assert(runs.count == 1, "Didn't complete final merge")
    }

    // FIXME: Remove this, it works around rdar://problem/45044610
    precondition(result)
  }
}
@_fixed_layout public struct StaticString : _ExpressibleByBuiltinUnicodeScalarLiteral, _ExpressibleByBuiltinExtendedGraphemeClusterLiteral, _ExpressibleByBuiltinStringLiteral, ExpressibleByUnicodeScalarLiteral, ExpressibleByExtendedGraphemeClusterLiteral, ExpressibleByStringLiteral, CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  @usableFromInline
  internal var _startPtrOrData: Builtin.Word
  @usableFromInline
  internal var _utf8CodeUnitCount: Builtin.Word
  @usableFromInline
  internal var _flags: Builtin.Int8
  @_transparent public var utf8Start: UnsafePointer<UInt8> {
    get {
    _precondition(
      hasPointerRepresentation,
      "StaticString should have pointer representation")
    return UnsafePointer(bitPattern: UInt(_startPtrOrData))!
  }
  }
  @_transparent public var unicodeScalar: Unicode.Scalar {
    get {
    _precondition(
      !hasPointerRepresentation,
      "StaticString should have Unicode scalar representation")
    return Unicode.Scalar(UInt32(UInt(_startPtrOrData)))!
  }
  }
  @_transparent public var utf8CodeUnitCount: Int {
    get {
    _precondition(
      hasPointerRepresentation,
      "StaticString should have pointer representation")
    return Int(_utf8CodeUnitCount)
  }
  }
  @_transparent public var hasPointerRepresentation: Bool {
    get {
    return (UInt8(_flags) & 0x1) == 0
  }
  }
  @_transparent public var isASCII: Bool {
    get {
    return (UInt8(_flags) & 0x2) != 0
  }
  }
  @_transparent public func withUTF8Buffer<R>(_ body: (UnsafeBufferPointer<UInt8>) -> R) -> R {
    if hasPointerRepresentation {
      return body(UnsafeBufferPointer(
        start: utf8Start, count: utf8CodeUnitCount))
    } else {
      var buffer: UInt64 = 0
      var i = 0
      let sink: (UInt8) -> Void = {
        buffer = buffer | (UInt64($0) << (UInt64(i) * 8))
        i += 1
      }
      UTF8.encode(unicodeScalar, into: sink)
      return body(UnsafeBufferPointer(
        start: UnsafePointer(Builtin.addressof(&buffer)),
        count: i))
    }
  }
  @_transparent public init() {
    self = ""
  }
  @usableFromInline
  @_transparent internal init(_start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    // We don't go through UnsafePointer here to make things simpler for alias
    // analysis. A higher-level algorithm may be trying to make sure an
    // unrelated buffer is not accessed or freed.
    self._startPtrOrData = Builtin.ptrtoint_Word(_start)
    self._utf8CodeUnitCount = utf8CodeUnitCount
    self._flags = Bool(isASCII)
      ? (0x2 as UInt8)._value
      : (0x0 as UInt8)._value
  }
  @usableFromInline
  @_transparent internal init(unicodeScalar: Builtin.Int32) {
    self._startPtrOrData = UInt(UInt32(unicodeScalar))._builtinWordValue
    self._utf8CodeUnitCount = 0._builtinWordValue
    self._flags = Unicode.Scalar(_builtinUnicodeScalarLiteral: unicodeScalar).isASCII
      ? (0x3 as UInt8)._value
      : (0x1 as UInt8)._value
  }
  @_effects(readonly) @_transparent public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self = StaticString(unicodeScalar: value)
  }
  @_effects(readonly) @_transparent public init(unicodeScalarLiteral value: StaticString) {
    self = value
  }
  @_effects(readonly) @_transparent public init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    self = StaticString(
      _builtinStringLiteral: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII
    )
  }
  @_effects(readonly) @_transparent public init(extendedGraphemeClusterLiteral value: StaticString) {
    self = value
  }
  @_effects(readonly) @_transparent public init(_builtinStringLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    self = StaticString(
      _start: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII)
  }
  @_effects(readonly) @_transparent public init(stringLiteral value: StaticString) {
    self = value
  }
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
  public typealias StringLiteralType = Swift.StaticString
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StaticString
  public typealias UnicodeScalarLiteralType = Swift.StaticString
}
extension StaticString {
  public var customMirror: Mirror {
    get
  }
}
public protocol Strideable : Swift.Comparable {
  associatedtype Stride : Swift.Comparable, Swift.SignedNumeric
  func distance(to other: Self) -> Stride
  func advanced(by n: Stride) -> Self
  static func _step(after current: (index: Int?, value: Self), from start: Self, by distance: Self.Stride) -> (index: Int?, value: Self)
}
extension Strideable {
  @inlinable public static func < (x: Self, y: Self) -> Bool {
    return x.distance(to: y) > 0
  }
  @inlinable public static func == (x: Self, y: Self) -> Bool {
    return x.distance(to: y) == 0
  }
}
extension Strideable {
  @inlinable public static func _step(after current: (index: Int?, value: Self), from start: Self, by distance: Self.Stride) -> (index: Int?, value: Self) {
    return (nil, current.value.advanced(by: distance))
  }
}
extension Strideable where Self.Stride : Swift.FloatingPoint {
  @inlinable public static func _step(after current: (index: Int?, value: Self), from start: Self, by distance: Self.Stride) -> (index: Int?, value: Self) {
    if let i = current.index {
      // When Stride is a floating-point type, we should avoid accumulating
      // rounding error from repeated addition.
      return (i + 1, start.advanced(by: Stride(i + 1) * distance))
    }
    return (nil, current.value.advanced(by: distance))
  }
}
extension Strideable where Self : Swift.FloatingPoint, Self == Self.Stride {
  @inlinable public static func _step(after current: (index: Int?, value: Self), from start: Self, by distance: Self.Stride) -> (index: Int?, value: Self) {
    if let i = current.index {
      // When both Self and Stride are the same floating-point type, we should
      // take advantage of fused multiply-add (where supported) to eliminate
      // intermediate rounding error.
      return (i + 1, start.addingProduct(Stride(i + 1), distance))
    }
    return (nil, current.value.advanced(by: distance))
  }
}
@_fixed_layout public struct StrideToIterator<Element> where Element : Swift.Strideable {
  @usableFromInline
  internal let _start: Element
  @usableFromInline
  internal let _end: Element
  @usableFromInline
  internal let _stride: Element.Stride
  @usableFromInline
  internal var _current: (index: Int?, value: Element)
  @inlinable internal init(_start: Element, end: Element, stride: Element.Stride) {
    self._start = _start
    _end = end
    _stride = stride
    _current = (0, _start)
  }
}
extension StrideToIterator : IteratorProtocol {
  @inlinable mutating public func next() -> Element? {
    let result = _current.value
    if _stride > 0 ? result >= _end : result <= _end {
      return nil
    }
    _current = Element._step(after: _current, from: _start, by: _stride)
    return result
  }
}
@_fixed_layout public struct StrideTo<Element> where Element : Swift.Strideable {
  @usableFromInline
  internal let _start: Element
  @usableFromInline
  internal let _end: Element
  @usableFromInline
  internal let _stride: Element.Stride
  @inlinable internal init(_start: Element, end: Element, stride: Element.Stride) {
    _precondition(stride != 0, "Stride size must not be zero")
    // At start, striding away from end is allowed; it just makes for an
    // already-empty Sequence.
    self._start = _start
    self._end = end
    self._stride = stride
  }
}
extension StrideTo : Sequence {
  @inlinable __consuming public func makeIterator() -> StrideToIterator<Element> {
    return StrideToIterator(_start: _start, end: _end, stride: _stride)
  }
  @inlinable public var underestimatedCount: Int {
    get {
    var it = self.makeIterator()
    var count = 0
    while it.next() != nil {
      count += 1
    }
    return count
  }
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Bool? {
    if element < _start || _end <= element {
      return false
    }
    return nil
  }
  public typealias Iterator = Swift.StrideToIterator<Element>
}
extension StrideTo : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
@inlinable public func stride<T>(from start: T, to end: T, by stride: T.Stride) -> StrideTo<T> where T : Swift.Strideable {
  return StrideTo(_start: start, end: end, stride: stride)
}
@_fixed_layout public struct StrideThroughIterator<Element> where Element : Swift.Strideable {
  @usableFromInline
  internal let _start: Element
  @usableFromInline
  internal let _end: Element
  @usableFromInline
  internal let _stride: Element.Stride
  @usableFromInline
  internal var _current: (index: Int?, value: Element)
  @usableFromInline
  internal var _didReturnEnd: Bool = false
  @inlinable internal init(_start: Element, end: Element, stride: Element.Stride) {
    self._start = _start
    _end = end
    _stride = stride
    _current = (0, _start)
  }
}
extension StrideThroughIterator : IteratorProtocol {
  @inlinable mutating public func next() -> Element? {
    let result = _current.value
    if _stride > 0 ? result >= _end : result <= _end {
      // This check is needed because if we just changed the above operators
      // to > and <, respectively, we might advance current past the end
      // and throw it out of bounds (e.g. above Int.max) unnecessarily.
      if result == _end && !_didReturnEnd {
        _didReturnEnd = true
        return result
      }
      return nil
    }
    _current = Element._step(after: _current, from: _start, by: _stride)
    return result
  }
}
@_fixed_layout public struct StrideThrough<Element> where Element : Swift.Strideable {
  @usableFromInline
  internal let _start: Element
  @usableFromInline
  internal let _end: Element
  @usableFromInline
  internal let _stride: Element.Stride
  @inlinable internal init(_start: Element, end: Element, stride: Element.Stride) {
    _precondition(stride != 0, "Stride size must not be zero")
    self._start = _start
    self._end = end
    self._stride = stride
  }
}
extension StrideThrough : Sequence {
  @inlinable __consuming public func makeIterator() -> StrideThroughIterator<Element> {
    return StrideThroughIterator(_start: _start, end: _end, stride: _stride)
  }
  @inlinable public var underestimatedCount: Int {
    get {
    var it = self.makeIterator()
    var count = 0
    while it.next() != nil {
      count += 1
    }
    return count
  }
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Bool? {
    if element < _start || _end < element {
      return false
    }
    return nil
  }
  public typealias Iterator = Swift.StrideThroughIterator<Element>
}
extension StrideThrough : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
@inlinable public func stride<T>(from start: T, through end: T, by stride: T.Stride) -> StrideThrough<T> where T : Swift.Strideable {
  return StrideThrough(_start: start, end: end, stride: stride)
}
extension String : Hashable {
  public func hash(into hasher: inout Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension StringProtocol {
  @_specialize(exported: false, kind: full, where Self == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring)
  public func hash(into hasher: inout Hasher)
}
@inlinable @_transparent internal func unimplemented_utf8_32bit(_ message: String = "", file: StaticString = #file, line: UInt = #line) -> Never {
  fatalError("32-bit: Unimplemented for UTF-8 support", file: file, line: line)
}
@_fixed_layout public struct String {
  public var _guts: _StringGuts
  @inlinable @inline(__always) internal init(_ _guts: _StringGuts) {
    self._guts = _guts
    _invariantCheck()
  }
  @inlinable @inline(__always) @_semantics("string.init_empty") public init() { self.init(_StringGuts()) }
}
extension String {
  @inlinable @inline(__always) internal func _invariantCheck() {}
  public func _dump()
}
extension String {
  @inlinable @inline(__always) public init<C, Encoding>(decoding codeUnits: C, as sourceEncoding: Encoding.Type) where C : Swift.Collection, Encoding : Swift._UnicodeEncoding, C.Element == Encoding.CodeUnit {
    guard _fastPath(sourceEncoding == UTF8.self) else {
      self = String._fromCodeUnits(
        codeUnits, encoding: sourceEncoding, repair: true)!.0
      return
    }

    if let contigBytes = codeUnits as? _HasContiguousBytes,
       contigBytes._providesContiguousBytesNoCopy
    {
      self = contigBytes.withUnsafeBytes { rawBufPtr in
        return String._fromUTF8Repairing(
          UnsafeBufferPointer(
            start: rawBufPtr.baseAddress?.assumingMemoryBound(to: UInt8.self),
            count: rawBufPtr.count)).0
      }
      return
    }

    // Just copying to an Array is significantly faster than performing
    // generic operations
    self = Array(codeUnits).withUnsafeBufferPointer {
      let raw = UnsafeRawBufferPointer($0)
      return String._fromUTF8Repairing(raw.bindMemory(to: UInt8.self)).0
    }
    return
  }
  @inlinable @inline(__always) public func withCString<Result, TargetEncoding>(encodedAs targetEncoding: TargetEncoding.Type, _ body: (UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result where TargetEncoding : Swift._UnicodeEncoding {
    if targetEncoding == UTF8.self {
      return try self.withCString {
        (cPtr: UnsafePointer<CChar>) -> Result  in
        _internalInvariant(UInt8.self == TargetEncoding.CodeUnit.self)
        let ptr = UnsafeRawPointer(cPtr).assumingMemoryBound(
          to: TargetEncoding.CodeUnit.self)
        return try body(ptr)
      }
    }
    return try _slowWithCString(encodedAs: targetEncoding, body)
  }
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _slowWithCString<Result, TargetEncoding>(encodedAs targetEncoding: TargetEncoding.Type, _ body: (UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result where TargetEncoding : Swift._UnicodeEncoding
}
extension String : _ExpressibleByBuiltinUnicodeScalarLiteral {
  @_effects(readonly) @inlinable @inline(__always) public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self.init(Unicode.Scalar(_unchecked: UInt32(value)))
  }
  @inlinable @inline(__always) public init(_ scalar: Unicode.Scalar) {
    self = scalar.withUTF8CodeUnits { String._uncheckedFromUTF8($0) }
  }
}
extension String : _ExpressibleByBuiltinExtendedGraphemeClusterLiteral {
  @inlinable @inline(__always) @_effects(readonly) @_semantics("string.makeUTF8") public init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    self.init(
      _builtinStringLiteral: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII)
  }
}
extension String : _ExpressibleByBuiltinStringLiteral {
  @inlinable @inline(__always) @_effects(readonly) @_semantics("string.makeUTF8") public init(_builtinStringLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1) {
    let bufPtr = UnsafeBufferPointer(
      start: UnsafeRawPointer(start).assumingMemoryBound(to: UInt8.self),
      count: Int(utf8CodeUnitCount))
    if let smol = _SmallString(bufPtr) {
      self = String(_StringGuts(smol))
      return
    }
    self.init(_StringGuts(bufPtr, isASCII: Bool(isASCII)))
  }
}
extension String : ExpressibleByStringLiteral {
  @inlinable @inline(__always) public init(stringLiteral value: String) {
    self = value
  }
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension String : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension String {
  @inlinable @_effects(readonly) @_semantics("string.concat") public static func + (lhs: String, rhs: String) -> String {
    var result = lhs
    result.append(rhs)
    return result
  }
  @inlinable @_semantics("string.append") public static func += (lhs: inout String, rhs: String) {
    lhs.append(rhs)
  }
}
extension Sequence where Self.Element : Swift.StringProtocol {
  @_specialize(exported: false, kind: full, where Self == Swift.Array<Swift.Substring>)
  @_specialize(exported: false, kind: full, where Self == Swift.Array<Swift.String>)
  public func joined(separator: String = "") -> String
}
extension BidirectionalCollection where Self.Element == Swift.String {
  @_specialize(exported: false, kind: full, where Self == Swift.Array<Swift.String>)
  public func joined(separator: String = "") -> String
}
extension String {
  @_effects(releasenone) public func lowercased() -> String
  @_effects(releasenone) public func uppercased() -> String
  @inlinable @inline(__always) public init<T>(_ value: T) where T : Swift.LosslessStringConvertible {
    self = value.description
  }
}
extension String : CustomStringConvertible {
  @inlinable public var description: String {
    get { return self }
  }
}
extension String {
  public var _nfcCodeUnits: [UInt8] {
    get
  }
  public func _withNFCCodeUnits(_ f: (UInt8) throws -> Void) rethrows
}
@usableFromInline
internal typealias _CocoaString = AnyObject
@usableFromInline
@_effects(releasenone) internal func _stdlib_binary_CFStringCreateCopy(_ source: _CocoaString) -> _CocoaString
@usableFromInline
@_effects(readonly) internal func _stdlib_binary_CFStringGetLength(_ source: _CocoaString) -> Int
@usableFromInline
@_effects(readonly) internal func _stdlib_binary_CFStringGetCharactersPtr(_ source: _CocoaString) -> UnsafeMutablePointer<UTF16.CodeUnit>?
@usableFromInline
@_effects(releasenone) internal func _bridgeCocoaString(_ cocoaString: _CocoaString) -> _StringGuts
extension String {
  public init(_cocoaString: AnyObject)
}
extension String {
  @_effects(releasenone) public func _bridgeToObjectiveCImpl() -> AnyObject
}
@_silgen_name("swift_stdlib_getDescription")
public func _getDescription<T>(_ x: T) -> AnyObject
extension StringProtocol {
  @_specialize(exported: false, kind: full, where Self == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring)
  public func _toUTF16Offset(_ idx: Index) -> Int
  @_specialize(exported: false, kind: full, where Self == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring)
  public func _toUTF16Index(_ offset: Int) -> Index
  @_specialize(exported: false, kind: full, where Self == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring)
  public func _toUTF16Offsets(_ indices: Range<Index>) -> Range<Int>
  @_specialize(exported: false, kind: full, where Self == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring)
  public func _toUTF16Indices(_ range: Range<Int>) -> Range<Index>
}
extension String {
  public func _copyUTF16CodeUnits(into buffer: UnsafeMutableBufferPointer<UInt16>, range: Range<Int>)
}
extension String : BidirectionalCollection {
  public typealias IndexDistance = Int
  public typealias SubSequence = Substring
  public typealias Element = Character
  @inlinable @inline(__always) public var startIndex: Index {
    get { return _guts.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Index {
    get { return _guts.endIndex }
  }
  @inline(__always) public var count: Int {
    get
  }
  public func index(after i: Index) -> Index
  public func index(before i: Index) -> Index
  @inlinable @inline(__always) public func index(_ i: Index, offsetBy n: IndexDistance) -> Index {
    // TODO: known-ASCII and single-scalar-grapheme fast path, etc.
    return _index(i, offsetBy: n)
  }
  @inlinable @inline(__always) public func index(_ i: Index, offsetBy n: IndexDistance, limitedBy limit: Index) -> Index? {
    // TODO: known-ASCII and single-scalar-grapheme fast path, etc.
    return _index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable @inline(__always) public func distance(from start: Index, to end: Index) -> IndexDistance {
    // TODO: known-ASCII and single-scalar-grapheme fast path, etc.
    return _distance(from: start, to: end)
  }
  @inlinable @inline(__always) public subscript(i: Index) -> Character {
    get {
    _boundsCheck(i)

    let i = _guts.scalarAlign(i)
    let distance = _characterStride(startingAt: i)
    return _guts.errorCorrectedCharacter(
      startingAt: i._encodedOffset, endingAt: i._encodedOffset &+ distance)
  }
  }
  @inlinable @inline(__always) internal func _characterStride(startingAt i: Index) -> Int {
    // Fast check if it's already been measured, otherwise check resiliently
    if let d = i.characterStride { return d }

    if i == endIndex { return 0 }

    return _guts._opaqueCharacterStride(startingAt: i._encodedOffset)
  }
  @inlinable @inline(__always) internal func _characterStride(endingAt i: Index) -> Int {
    if i == startIndex { return 0 }

    return _guts._opaqueCharacterStride(endingAt: i._encodedOffset)
  }
  public typealias Indices = Swift.DefaultIndices<Swift.String>
}
extension String {
  @_fixed_layout public struct Iterator : IteratorProtocol {
    @usableFromInline
    internal var _guts: _StringGuts
    @usableFromInline
    internal var _position: Int = 0
    @usableFromInline
    internal var _end: Int
    @inlinable internal init(_ guts: _StringGuts) {
      self._end = guts.count
      self._guts = guts
    }
    @inlinable mutating public func next() -> Character? {
      guard _fastPath(_position < _end) else { return nil }

      let len = _guts._opaqueCharacterStride(startingAt: _position)
      let nextPosition = _position &+ len
      let result = _guts.errorCorrectedCharacter(
        startingAt: _position, endingAt: nextPosition)
      _position = nextPosition
      return result
    }
    public typealias Element = Swift.Character
  }
  @inlinable __consuming public func makeIterator() -> Iterator {
    return Iterator(_guts)
  }
}
extension StringProtocol {
  @_specialize(exported: false, kind: full, where Self == Swift.String, RHS == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.String, RHS == Swift.Substring)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring, RHS == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring, RHS == Swift.Substring)
  @inlinable @_effects(readonly) public static func == <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : Swift.StringProtocol {
    return _stringCompare(
      lhs._wholeGuts, lhs._offsetRange,
      rhs._wholeGuts, rhs._offsetRange,
      expecting: .equal)
  }
  @inlinable @inline(__always) @_effects(readonly) public static func != <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : Swift.StringProtocol {
    return !(lhs == rhs)
  }
  @_specialize(exported: false, kind: full, where Self == Swift.String, RHS == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.String, RHS == Swift.Substring)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring, RHS == Swift.String)
  @_specialize(exported: false, kind: full, where Self == Swift.Substring, RHS == Swift.Substring)
  @inlinable @_effects(readonly) public static func < <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : Swift.StringProtocol {
    return _stringCompare(
      lhs._wholeGuts, lhs._offsetRange,
      rhs._wholeGuts, rhs._offsetRange,
      expecting: .less)
  }
  @inlinable @inline(__always) @_effects(readonly) public static func > <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : Swift.StringProtocol {
    return rhs < lhs
  }
  @inlinable @inline(__always) @_effects(readonly) public static func <= <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : Swift.StringProtocol {
    return !(rhs < lhs)
  }
  @inlinable @inline(__always) @_effects(readonly) public static func >= <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : Swift.StringProtocol {
    return !(lhs < rhs)
  }
}
extension String : Equatable {
  @inlinable @inline(__always) @_effects(readonly) @_semantics("string.equals") public static func == (lhs: String, rhs: String) -> Bool {
    return _stringCompare(lhs._guts, rhs._guts, expecting: .equal)
  }
}
extension String : Comparable {
  @inlinable @inline(__always) @_effects(readonly) public static func < (lhs: String, rhs: String) -> Bool {
    return _stringCompare(lhs._guts, rhs._guts, expecting: .less)
  }
}
extension Substring : Equatable {
}
@inlinable @inline(__always) @_effects(readonly) internal func _stringCompare(_ lhs: _StringGuts, _ rhs: _StringGuts, expecting: _StringComparisonResult) -> Bool {
  if lhs.rawBits == rhs.rawBits { return expecting == .equal }
  return _stringCompareWithSmolCheck(lhs, rhs, expecting: expecting)
}
@usableFromInline
@_effects(readonly) internal func _stringCompareWithSmolCheck(_ lhs: _StringGuts, _ rhs: _StringGuts, expecting: _StringComparisonResult) -> Bool
@usableFromInline
@inline(never) @_effects(readonly) internal func _stringCompareInternal(_ lhs: _StringGuts, _ rhs: _StringGuts, expecting: _StringComparisonResult) -> Bool
@inlinable @inline(__always) @_effects(readonly) internal func _stringCompare(_ lhs: _StringGuts, _ lhsRange: Range<Int>, _ rhs: _StringGuts, _ rhsRange: Range<Int>, expecting: _StringComparisonResult) -> Bool {
  if lhs.rawBits == rhs.rawBits && lhsRange == rhsRange {
    return expecting == .equal
  }
  return _stringCompareInternal(
    lhs, lhsRange, rhs, rhsRange, expecting: expecting)
}
@usableFromInline
@_effects(readonly) internal func _stringCompareInternal(_ lhs: _StringGuts, _ lhsRange: Range<Int>, _ rhs: _StringGuts, _ rhsRange: Range<Int>, expecting: _StringComparisonResult) -> Bool
@usableFromInline
@_frozen internal enum _StringComparisonResult {
  case equal
  case less
  @inlinable @inline(__always) internal init(signedNotation int: Int) {
    _internalInvariant(int <= 0)
    self = int == 0 ? .equal : .less
  }
  @inlinable @inline(__always) internal static func == (lhs: _StringComparisonResult, rhs: _StringComparisonResult) -> Bool {
    switch (lhs, rhs) {
      case (.equal, .equal): return true
      case (.less, .less): return true
      default: return false
    }
  }
  @usableFromInline
  internal var hashValue: Swift.Int {
    @usableFromInline
    get
  }
  @usableFromInline
  internal func hash(into hasher: inout Swift.Hasher)
}
extension String {
  @usableFromInline
  internal static func _fromASCII(_ input: UnsafeBufferPointer<UInt8>) -> String
  public static func _tryFromUTF8(_ input: UnsafeBufferPointer<UInt8>) -> String?
  @usableFromInline
  internal static func _fromUTF8Repairing(_ input: UnsafeBufferPointer<UInt8>) -> (result: String, repairsMade: Bool)
  @usableFromInline
  internal static func _uncheckedFromUTF8(_ input: UnsafeBufferPointer<UInt8>) -> String
  @usableFromInline
  internal static func _uncheckedFromUTF8(_ input: UnsafeBufferPointer<UInt8>, isASCII: Bool) -> String
  @usableFromInline
  internal static func _uncheckedFromUTF8(_ input: UnsafeBufferPointer<UInt8>, asciiPreScanResult: Bool) -> String
  @usableFromInline
  internal static func _uncheckedFromUTF16(_ input: UnsafeBufferPointer<UInt16>) -> String
  @usableFromInline
  @inline(never) internal static func _fromCodeUnits<Input, Encoding>(_ input: Input, encoding: Encoding.Type, repair: Bool) -> (String, repairsMade: Bool)? where Input : Swift.Collection, Encoding : Swift._UnicodeEncoding, Input.Element == Encoding.CodeUnit
  public static func _fromInvalidUTF16(_ utf16: UnsafeBufferPointer<UInt16>) -> String
  @usableFromInline
  internal static func _fromSubstring(_ substring: __shared Substring) -> String
  @_alwaysEmitIntoClient @inline(never) internal static func _copying(_ str: String) -> String {
    return String._copying(str[...])
  }
  @_alwaysEmitIntoClient @inline(never) internal static func _copying(_ str: Substring) -> String {
    if _fastPath(str._wholeGuts.isFastUTF8) {
      return str._wholeGuts.withFastUTF8(range: str._offsetRange) {
        String._uncheckedFromUTF8($0)
      }
    }
    return Array(str.utf8).withUnsafeBufferPointer {
      String._uncheckedFromUTF8($0)
    }
  }
}
@_fixed_layout public struct _StringGuts {
  @usableFromInline
  internal var _object: _StringObject
  @inlinable @inline(__always) internal init(_ object: _StringObject) {
    self._object = object
    _invariantCheck()
  }
  @inlinable @inline(__always) internal init() {
    self.init(_StringObject(empty: ()))
  }
}
extension _StringGuts {
  @inlinable @inline(__always) internal var rawBits: _StringObject.RawBitPattern {
    get {
    return _object.rawBits
  }
  }
}
extension _StringGuts {
  @inlinable @inline(__always) internal init(_ smol: _SmallString) {
    self.init(_StringObject(smol))
  }
  @inlinable @inline(__always) internal init(_ bufPtr: UnsafeBufferPointer<UInt8>, isASCII: Bool) {
    self.init(_StringObject(immortal: bufPtr, isASCII: isASCII))
  }
}
extension _StringGuts {
  @inlinable @inline(__always) internal var count: Int {
    get { return _object.count }
  }
  @inlinable @inline(__always) internal var isEmpty: Bool {
    get { return count == 0 }
  }
  @inlinable @inline(__always) internal var isSmall: Bool {
    get { return _object.isSmall }
  }
  @inlinable @inline(__always) internal var asSmall: _SmallString {
    get {
    return _SmallString(_object)
  }
  }
  @inlinable @inline(__always) internal var isASCII: Bool {
    get {
    return _object.isASCII
  }
  }
  @inlinable @inline(__always) internal var isFastASCII: Bool {
    get {
    return isFastUTF8 && _object.isASCII
  }
  }
}
extension _StringGuts {
  @_transparent @inlinable internal var isFastUTF8: Bool {
    get { return _fastPath(_object.providesFastUTF8) }
  }
  @inlinable @inline(__always) internal var isForeign: Bool {
    get {
     return _slowPath(_object.isForeign)
  }
  }
  @inlinable @inline(__always) internal func withFastUTF8<R>(_ f: (UnsafeBufferPointer<UInt8>) throws -> R) rethrows -> R {
    _internalInvariant(isFastUTF8)

    if self.isSmall { return try _SmallString(_object).withUTF8(f) }

    defer { _fixLifetime(self) }
    return try f(_object.fastUTF8)
  }
  @inlinable @inline(__always) internal func withFastUTF8<R>(range: Range<Int>, _ f: (UnsafeBufferPointer<UInt8>) throws -> R) rethrows -> R {
    return try self.withFastUTF8 { wholeUTF8 in
      return try f(UnsafeBufferPointer(rebasing: wholeUTF8[range]))
    }
  }
  @inlinable @inline(__always) internal func withFastCChar<R>(_ f: (UnsafeBufferPointer<CChar>) throws -> R) rethrows -> R {
    return try self.withFastUTF8 { utf8 in
      let ptr = utf8.baseAddress._unsafelyUnwrappedUnchecked._asCChar
      return try f(UnsafeBufferPointer(start: ptr, count: utf8.count))
    }
  }
}
extension _StringGuts {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension _StringGuts {
  @inlinable @inline(__always) internal func withCString<Result>(_ body: (UnsafePointer<Int8>) throws -> Result) rethrows -> Result {
    if _slowPath(!_object.isFastZeroTerminated) {
      return try _slowWithCString(body)
    }

    return try self.withFastCChar {
      return try body($0.baseAddress._unsafelyUnwrappedUnchecked)
    }
  }
  @usableFromInline
  @inline(never) internal func _slowWithCString<Result>(_ body: (UnsafePointer<Int8>) throws -> Result) rethrows -> Result
}
extension _StringGuts {
  @inlinable internal func copyUTF8(into mbp: UnsafeMutableBufferPointer<UInt8>) -> Int? {
    let ptr = mbp.baseAddress._unsafelyUnwrappedUnchecked
    if _fastPath(self.isFastUTF8) {
      return self.withFastUTF8 { utf8 in
        guard utf8.count <= mbp.count else { return nil }

        let utf8Start = utf8.baseAddress._unsafelyUnwrappedUnchecked
        ptr.initialize(from: utf8Start, count: utf8.count)
        return utf8.count
      }
    }

    return _foreignCopyUTF8(into: mbp)
  }
  @usableFromInline
  @_effects(releasenone) @inline(never) internal func _foreignCopyUTF8(into mbp: UnsafeMutableBufferPointer<UInt8>) -> Int?
}
extension _StringGuts {
  @usableFromInline
  internal typealias Index = String.Index
  @inlinable @inline(__always) internal var startIndex: String.Index {
    get {
   return Index(_encodedOffset: 0)
  }
  }
  @inlinable @inline(__always) internal var endIndex: String.Index {
    get {
    return Index(_encodedOffset: self.count)
  }
  }
}
extension _StringGuts {
  @available(*, deprecated)
  public var _isContiguousASCII: Bool {
    get
  }
  @available(*, deprecated)
  public var _isContiguousUTF16: Bool {
    get
  }
  @available(*, deprecated)
  public var startASCII: UnsafeMutablePointer<UInt8> {
    get
  }
  @available(*, deprecated)
  public var startUTF16: UnsafeMutablePointer<UTF16.CodeUnit> {
    get
  }
}
extension _StringGuts {
  @inlinable public var _isSmall: Bool {
    get { return isSmall }
  }
  @inlinable public var _smallCodeUnits: (UInt64, UInt64) {
    get {
    return asSmall.zeroTerminatedRawCodeUnits
  }
  }
  @inlinable public var _isLargeZeroTerminatedContiguousUTF8: Bool {
    get {
    return !isSmall && _object.isFastZeroTerminated
  }
  }
  @inlinable public var _largeContiguousUTF8CodeUnits: UnsafeBufferPointer<UInt8> {
    get {
    return _object.fastUTF8
  }
  }
}
@available(*, deprecated)
public func _persistCString(_ p: UnsafePointer<CChar>?) -> [CChar]?
extension _StringGuts {
  @usableFromInline
  internal var isUniqueNative: Bool {
    @inline(__always) mutating get
  }
}
extension _StringGuts {
  @inlinable internal init(_initialCapacity capacity: Int) {
    self.init()
    if _slowPath(capacity > _SmallString.capacity) {
      self.grow(capacity)
    }
  }
  @usableFromInline
  mutating internal func grow(_ n: Int)
}
@usableFromInline
@_fixed_layout internal struct _StringObject {
  @usableFromInline
  @_frozen internal enum Nibbles {
  }
  @usableFromInline
  @_fixed_layout internal struct CountAndFlags {
    @usableFromInline
    internal var _storage: UInt64
    @inlinable @inline(__always) internal init(zero: ()) { self._storage = 0 }
  }
  @usableFromInline
  internal var _countAndFlagsBits: UInt64
  @usableFromInline
  internal var _object: Builtin.BridgeObject
  @inlinable @inline(__always) internal init(zero: ()) {
    self._countAndFlagsBits = 0
    self._object = Builtin.valueToBridgeObject(UInt64(0)._value)
  }
  @inlinable @inline(__always) internal var _countAndFlags: CountAndFlags {
    get {
    _internalInvariant(!isSmall)
    return CountAndFlags(rawUnchecked: _countAndFlagsBits)
  }
  }
}
extension _StringObject {
  @usableFromInline
  internal typealias RawBitPattern = (UInt64, UInt64)
  @inlinable @inline(__always) internal var rawBits: RawBitPattern {
    get {
    return (_countAndFlagsBits, discriminatedObjectRawBits)
  }
  }
  @inlinable @inline(__always) internal init(bridgeObject: Builtin.BridgeObject, countAndFlags: CountAndFlags) {
    self._object = bridgeObject
    self._countAndFlagsBits = countAndFlags._storage
    _invariantCheck()
  }
  @inlinable @inline(__always) internal init(object: AnyObject, discriminator: UInt64, countAndFlags: CountAndFlags) {
    let builtinRawObject: Builtin.Int64 = Builtin.reinterpretCast(object)
    let builtinDiscrim: Builtin.Int64 = discriminator._value
    self.init(
      bridgeObject: Builtin.reinterpretCast(
        Builtin.stringObjectOr_Int64(builtinRawObject, builtinDiscrim)),
      countAndFlags: countAndFlags)
  }
  @inlinable @inline(__always) internal init(pointerBits: UInt64, discriminator: UInt64, countAndFlags: CountAndFlags) {
    let builtinValueBits: Builtin.Int64 = pointerBits._value
    let builtinDiscrim: Builtin.Int64 = discriminator._value
    self.init(
      bridgeObject: Builtin.valueToBridgeObject(Builtin.stringObjectOr_Int64(
        builtinValueBits, builtinDiscrim)),
      countAndFlags: countAndFlags)
  }
  @inlinable @inline(__always) internal init(rawUncheckedValue bits: RawBitPattern) {
    self.init(zero:())
    self._countAndFlagsBits = bits.0
    self._object = Builtin.valueToBridgeObject(bits.1._value)
    _internalInvariant(self.rawBits == bits)
  }
  @inlinable @inline(__always) internal init(rawValue bits: RawBitPattern) {
    self.init(rawUncheckedValue: bits)
    _invariantCheck()
  }
  @inlinable @_transparent internal var discriminatedObjectRawBits: UInt64 {
    get {
    return Builtin.reinterpretCast(_object)
  }
  }
}
extension _StringObject.CountAndFlags {
  @usableFromInline
  internal typealias RawBitPattern = UInt64
  @inlinable @inline(__always) internal var rawBits: RawBitPattern {
    get {
   return _storage
  }
  }
  @inlinable @inline(__always) internal init(rawUnchecked bits: RawBitPattern) {
    self._storage = bits
  }
  @inlinable @inline(__always) internal init(raw bits: RawBitPattern) {
    self.init(rawUnchecked: bits)
    _invariantCheck()
  }
}
extension _StringObject.Nibbles {
  @inlinable @inline(__always) internal static var emptyString: UInt64 {
    get {
    return _StringObject.Nibbles.small(isASCII: true)
  }
  }
}
extension _StringObject.Nibbles {
  @inlinable @inline(__always) internal static var largeAddressMask: UInt64 {
    get { return 0x0FFF_FFFF_FFFF_FFFF }
  }
  @inlinable @inline(__always) internal static var discriminatorMask: UInt64 {
    get { return ~largeAddressMask }
  }
}
extension _StringObject.Nibbles {
  @inlinable @inline(__always) internal static func small(isASCII: Bool) -> UInt64 {
    return isASCII ? 0xE000_0000_0000_0000 : 0xA000_0000_0000_0000
  }
  @inlinable @inline(__always) internal static func small(withCount count: Int, isASCII: Bool) -> UInt64 {
    _internalInvariant(count <= _SmallString.capacity)
    return small(isASCII: isASCII) | UInt64(truncatingIfNeeded: count) &<< 56
  }
  @inlinable @inline(__always) internal static func largeImmortal() -> UInt64 {
    return 0x8000_0000_0000_0000
  }
  @inlinable @inline(__always) internal static func largeMortal() -> UInt64 { return 0x0000_0000_0000_0000 }
}
extension _StringObject {
  @inlinable @inline(__always) internal static var nativeBias: UInt {
    get {
    return 32
  }
  }
  @inlinable @inline(__always) internal var isImmortal: Bool {
    get {
    return (discriminatedObjectRawBits & 0x8000_0000_0000_0000) != 0
  }
  }
  @inlinable @inline(__always) internal var isMortal: Bool {
    get { return !isImmortal }
  }
  @inlinable @inline(__always) internal var isSmall: Bool {
    get {
    return (discriminatedObjectRawBits & 0x2000_0000_0000_0000) != 0
  }
  }
  @inlinable @inline(__always) internal var isLarge: Bool {
    get { return !isSmall }
  }
  @inlinable @inline(__always) internal var providesFastUTF8: Bool {
    get {
    return (discriminatedObjectRawBits & 0x1000_0000_0000_0000) == 0
  }
  }
  @inlinable @inline(__always) internal var isForeign: Bool {
    get { return !providesFastUTF8 }
  }
}
extension _StringObject {
  @inlinable @inline(__always) internal var largeFastIsTailAllocated: Bool {
    get {
    _internalInvariant(isLarge && providesFastUTF8)
    return _countAndFlags.isTailAllocated
  }
  }
  @_alwaysEmitIntoClient @inline(__always) internal var isPreferredRepresentation: Bool {
    get {
    return _fastPath(isSmall || _countAndFlags.isTailAllocated)
  }
  }
}
extension _StringObject {
  @inlinable @inline(__always) internal init(_ small: _SmallString) {
    // Small strings are encoded as _StringObjects in reverse byte order
    // on big-endian platforms. This is to match the discriminator to the
    // spare bits (the most significant nibble) in a pointer.
    let word1 = small.rawBits.0.littleEndian
    let word2 = small.rawBits.1.littleEndian
    // On 64-bit, we copy the raw bits (to host byte order).
    self.init(rawValue: (word1, word2))
    _internalInvariant(isSmall)
  }
  @inlinable internal static func getSmallCount(fromRaw x: UInt64) -> Int {
    return Int(truncatingIfNeeded: (x & 0x0F00_0000_0000_0000) &>> 56)
  }
  @inlinable @inline(__always) internal var smallCount: Int {
    get {
    _internalInvariant(isSmall)
    return _StringObject.getSmallCount(fromRaw: discriminatedObjectRawBits)
  }
  }
  @inlinable internal static func getSmallIsASCII(fromRaw x: UInt64) -> Bool {
    return x & 0x4000_0000_0000_0000 != 0
  }
  @inlinable @inline(__always) internal var smallIsASCII: Bool {
    get {
    _internalInvariant(isSmall)
    return _StringObject.getSmallIsASCII(fromRaw: discriminatedObjectRawBits)
  }
  }
  @inlinable @inline(__always) internal init(empty: ()) {
    // Canonical empty pattern: small zero-length string
    self._countAndFlagsBits = 0
    self._object = Builtin.valueToBridgeObject(Nibbles.emptyString._value)
    _internalInvariant(self.smallCount == 0)
    _invariantCheck()
  }
}
extension _StringObject.CountAndFlags {
  @inlinable @inline(__always) internal static var countMask: UInt64 {
    get { return 0x0000_FFFF_FFFF_FFFF }
  }
  @inlinable @inline(__always) internal static var flagsMask: UInt64 {
    get { return ~countMask }
  }
  @inlinable @inline(__always) internal static var isASCIIMask: UInt64 {
    get { return 0x8000_0000_0000_0000 }
  }
  @inlinable @inline(__always) internal static var isNFCMask: UInt64 {
    get { return 0x4000_0000_0000_0000 }
  }
  @inlinable @inline(__always) internal static var isNativelyStoredMask: UInt64 {
    get {
    return 0x2000_0000_0000_0000
  }
  }
  @inlinable @inline(__always) internal static var isTailAllocatedMask: UInt64 {
    get {
    return 0x1000_0000_0000_0000
  }
  }
  @inlinable @inline(__always) internal init(count: Int, isASCII: Bool, isNFC: Bool, isNativelyStored: Bool, isTailAllocated: Bool) {
    var rawBits = UInt64(truncatingIfNeeded: count)
    _internalInvariant(rawBits <= _StringObject.CountAndFlags.countMask)

    if isASCII {
      _internalInvariant(isNFC)
      rawBits |= _StringObject.CountAndFlags.isASCIIMask
    }

    if isNFC {
      rawBits |= _StringObject.CountAndFlags.isNFCMask
    }

    if isNativelyStored {
      _internalInvariant(isTailAllocated)
      rawBits |= _StringObject.CountAndFlags.isNativelyStoredMask
    }

    if isTailAllocated {
      rawBits |= _StringObject.CountAndFlags.isTailAllocatedMask
    }

    self.init(raw: rawBits)
    _internalInvariant(count == self.count)
    _internalInvariant(isASCII == self.isASCII)
    _internalInvariant(isNFC == self.isNFC)
    _internalInvariant(isNativelyStored == self.isNativelyStored)
    _internalInvariant(isTailAllocated == self.isTailAllocated)
  }
  @inlinable @inline(__always) internal init(count: Int, flags: UInt16) {
    // Currently, we only use top 4 flags
    _internalInvariant(flags & 0xF000 == flags)

    let rawBits = UInt64(truncatingIfNeeded: flags) &<< 48
                | UInt64(truncatingIfNeeded: count)
    self.init(raw: rawBits)
    _internalInvariant(self.count == count && self.flags == flags)
  }
  @inlinable @inline(__always) internal init(immortalCount: Int, isASCII: Bool) {
    self.init(
      count: immortalCount,
      isASCII: isASCII,
      isNFC: isASCII,
      isNativelyStored: false,
      isTailAllocated: true)
  }
  @inlinable @inline(__always) internal var count: Int {
    get {
    return Int(
      truncatingIfNeeded: _storage & _StringObject.CountAndFlags.countMask)
  }
  }
  @inlinable @inline(__always) internal var flags: UInt16 {
    get {
    return UInt16(truncatingIfNeeded: _storage &>> 48)
  }
  }
  @inlinable @inline(__always) internal var isASCII: Bool {
    get {
    return 0 != _storage & _StringObject.CountAndFlags.isASCIIMask
  }
  }
  @inlinable @inline(__always) internal var isNFC: Bool {
    get {
    return 0 != _storage & _StringObject.CountAndFlags.isNFCMask
  }
  }
  @inlinable @inline(__always) internal var isNativelyStored: Bool {
    get {
    return 0 != _storage & _StringObject.CountAndFlags.isNativelyStoredMask
  }
  }
  @inlinable @inline(__always) internal var isTailAllocated: Bool {
    get {
    return 0 != _storage & _StringObject.CountAndFlags.isTailAllocatedMask
  }
  }
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension _StringObject {
  @inlinable @inline(__always) internal var largeCount: Int {
    get {
    _internalInvariant(isLarge)
    return _countAndFlags.count
  }
  }
  @inlinable @inline(__always) internal var largeAddressBits: UInt {
    get {
    _internalInvariant(isLarge)
    return UInt(truncatingIfNeeded:
      discriminatedObjectRawBits & Nibbles.largeAddressMask)
  }
  }
  @inlinable @inline(__always) internal var nativeUTF8Start: UnsafePointer<UInt8> {
    get {
    _internalInvariant(largeFastIsTailAllocated)
    return UnsafePointer(
      bitPattern: largeAddressBits &+ _StringObject.nativeBias
    )._unsafelyUnwrappedUnchecked
  }
  }
  @inlinable @inline(__always) internal var nativeUTF8: UnsafeBufferPointer<UInt8> {
    get {
    _internalInvariant(largeFastIsTailAllocated)
    return UnsafeBufferPointer(start: nativeUTF8Start, count: largeCount)
  }
  }
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func getSharedUTF8Start() -> UnsafePointer<UInt8>
  @usableFromInline
  internal var sharedUTF8: UnsafeBufferPointer<UInt8> {
    @_effects(releasenone) @inline(never) get
  }
}
extension _StringObject {
  @inlinable @inline(__always) internal var count: Int {
    get { return isSmall ? smallCount : largeCount }
  }
  @inlinable @inline(__always) internal var isASCII: Bool {
    get {
    if isSmall { return smallIsASCII }
    return _countAndFlags.isASCII
  }
  }
  @inlinable @inline(__always) internal var fastUTF8: UnsafeBufferPointer<UInt8> {
    get {
    _internalInvariant(self.isLarge && self.providesFastUTF8)
    guard _fastPath(self.largeFastIsTailAllocated) else {
      return sharedUTF8
    }
    return UnsafeBufferPointer(
      start: self.nativeUTF8Start, count: self.largeCount)
  }
  }
  @usableFromInline
  internal var hasObjCBridgeableObject: Bool {
    @_effects(releasenone) get
  }
  @inlinable internal var isFastZeroTerminated: Bool {
    get {
    if _slowPath(!providesFastUTF8) { return false }

    // Small strings nul-terminate when spilling for contiguous access
    if isSmall { return true }

    // TODO(String performance): Use performance flag, which could be more
    // inclusive. For now, we only know native strings and small strings (when
    // accessed) are. We could also know about some shared strings.

    return largeFastIsTailAllocated
  }
  }
}
extension _StringObject {
  @inlinable @inline(__always) internal init(immortal bufPtr: UnsafeBufferPointer<UInt8>, isASCII: Bool) {
    let countAndFlags = CountAndFlags(
      immortalCount: bufPtr.count, isASCII: isASCII)
    // We bias to align code paths for mortal and immortal strings
    let biasedAddress = UInt(
      bitPattern: bufPtr.baseAddress._unsafelyUnwrappedUnchecked
    ) &- _StringObject.nativeBias

    self.init(
      pointerBits: UInt64(truncatingIfNeeded: biasedAddress),
      discriminator: Nibbles.largeImmortal(),
      countAndFlags: countAndFlags)
  }
}
extension _StringObject {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
public protocol StringProtocol : Swift.BidirectionalCollection, Swift.Comparable, Swift.ExpressibleByStringInterpolation, Swift.Hashable, Swift.LosslessStringConvertible, Swift.TextOutputStream, Swift.TextOutputStreamable where Self.Element == Swift.Character, Self.Index == Swift.String.Index, Self.StringInterpolation == Swift.DefaultStringInterpolation, Self.SubSequence : Swift.StringProtocol {
  associatedtype UTF8View : Swift.Collection where Self.UTF8View.Element == Swift.UInt8, Self.UTF8View.Index == Swift.String.Index, Self.SubSequence.UTF8View.Index == Swift.String.Index
  associatedtype UTF16View : Swift.BidirectionalCollection where Self.UTF16View.Element == Swift.UInt16, Self.UTF16View.Index == Swift.String.Index, Self.SubSequence.UTF16View.Index == Swift.String.Index
  associatedtype UnicodeScalarView : Swift.BidirectionalCollection where Self.UnicodeScalarView.Element == Swift.Unicode.Scalar, Self.UnicodeScalarView.Index == Swift.String.Index, Self.SubSequence.UnicodeScalarView.Index == Swift.String.Index
  associatedtype SubSequence = Swift.Substring
  var utf8: UTF8View { get }
  var utf16: UTF16View { get }
  var unicodeScalars: UnicodeScalarView { get }
  func hasPrefix(_ prefix: String) -> Bool
  func hasSuffix(_ prefix: String) -> Bool
  func lowercased() -> String
  func uppercased() -> String
  init<C, Encoding>(decoding codeUnits: C, as sourceEncoding: Encoding.Type) where C : Swift.Collection, Encoding : Swift._UnicodeEncoding, C.Element == Encoding.CodeUnit
  init(cString nullTerminatedUTF8: UnsafePointer<CChar>)
  init<Encoding>(decodingCString nullTerminatedCodeUnits: UnsafePointer<Encoding.CodeUnit>, as sourceEncoding: Encoding.Type) where Encoding : Swift._UnicodeEncoding
  func withCString<Result>(_ body: (UnsafePointer<CChar>) throws -> Result) rethrows -> Result
  func withCString<Result, Encoding>(encodedAs targetEncoding: Encoding.Type, _ body: (UnsafePointer<Encoding.CodeUnit>) throws -> Result) rethrows -> Result where Encoding : Swift._UnicodeEncoding
}
extension StringProtocol {
  public var _ephemeralString: String {
    @_specialize(exported: false, kind: full, where Self == Swift.String)
    @_specialize(exported: false, kind: full, where Self == Swift.Substring)
    get
  }
  @inlinable internal var _offsetRange: Range<Int> {
    @inline(__always) get {
      let start = startIndex
      let end = endIndex
      _internalInvariant(
        start.transcodedOffset == 0 && end.transcodedOffset == 0)
      return Range(uncheckedBounds: (start._encodedOffset, end._encodedOffset))
    }
  }
  @inlinable internal var _wholeGuts: _StringGuts {
    @_specialize(exported: false, kind: full, where Self == Swift.String)
    @_specialize(exported: false, kind: full, where Self == Swift.Substring)
    @inline(__always) get {
      if let str = self as? String {
        return str._guts
      }
      if let subStr = self as? Substring {
        return subStr._wholeGuts
      }
      return String(self)._guts
    }
  }
}
extension String {
  @_alwaysEmitIntoClient public var isContiguousUTF8: Bool {
    get { return _guts.isFastUTF8 }
  }
  @_alwaysEmitIntoClient mutating public func makeContiguousUTF8() {
    if _fastPath(isContiguousUTF8) { return }
    self = String._copying(self)
  }
  @_alwaysEmitIntoClient mutating public func withUTF8<R>(_ body: (UnsafeBufferPointer<UInt8>) throws -> R) rethrows -> R {
    makeContiguousUTF8()
    return try _guts.withFastUTF8(body)
  }
}
extension Substring {
  @_alwaysEmitIntoClient public var isContiguousUTF8: Bool {
    get { return self.base.isContiguousUTF8 }
  }
  @_alwaysEmitIntoClient mutating public func makeContiguousUTF8() {
    if _fastPath(isContiguousUTF8) { return }
    self = String._copying(self)[...]
  }
  @_alwaysEmitIntoClient mutating public func withUTF8<R>(_ body: (UnsafeBufferPointer<UInt8>) throws -> R) rethrows -> R {
    if _fastPath(isContiguousUTF8) {
      return try _wholeGuts.withFastUTF8(range: self._offsetRange) {
        return try body($0)
      }
    }

    makeContiguousUTF8()
    return try _wholeGuts.withFastUTF8(body)
  }
}
extension String {
  @_fixed_layout public struct Index {
    @usableFromInline
    internal var _rawBits: UInt64
    @inlinable @inline(__always) internal init(_ raw: UInt64) {
      self._rawBits = raw
      self._invariantCheck()
    }
  }
}
extension String.Index {
  @inlinable @inline(__always) internal var orderingValue: UInt64 {
    get { return _rawBits &>> 14 }
  }
  @inlinable @inline(__always) internal var isZeroPosition: Bool {
    get { return orderingValue == 0 }
  }
  public func utf16Offset<S>(in s: S) -> Int where S : Swift.StringProtocol
  @available(swift, deprecated: 4.2, message: "encodedOffset has been deprecated as most common usage is incorrect. Use utf16Offset(in:) to achieve the same behavior.")
  @inlinable public var encodedOffset: Int {
    get { return _encodedOffset }
  }
  @inlinable @inline(__always) internal var _encodedOffset: Int {
    get {
    return Int(truncatingIfNeeded: _rawBits &>> 16)
  }
  }
  @inlinable @inline(__always) internal var transcodedOffset: Int {
    get {
    return Int(truncatingIfNeeded: orderingValue & 0x3)
  }
  }
  @usableFromInline
  internal var characterStride: Int? {
    get
  }
  @inlinable @inline(__always) internal init(encodedOffset: Int, transcodedOffset: Int) {
    let pos = UInt64(truncatingIfNeeded: encodedOffset)
    let trans = UInt64(truncatingIfNeeded: transcodedOffset)
    _internalInvariant(pos == pos & 0x0000_FFFF_FFFF_FFFF)
    _internalInvariant(trans <= 3)

    self.init((pos &<< 16) | (trans &<< 14))
  }
  public init<S>(utf16Offset offset: Int, in s: S) where S : Swift.StringProtocol
  @available(swift, deprecated: 4.2, message: "encodedOffset has been deprecated as most common usage is incorrect. Use String.Index(utf16Offset:in:) to achieve the same behavior.")
  @inlinable public init(encodedOffset offset: Int) {
    self.init(_encodedOffset: offset)
  }
  @inlinable @inline(__always) internal init(_encodedOffset offset: Int) {
    self.init(encodedOffset: offset, transcodedOffset: 0)
  }
  @usableFromInline
  internal init(encodedOffset: Int, transcodedOffset: Int, characterStride: Int)
  @usableFromInline
  internal init(encodedOffset pos: Int, characterStride char: Int)
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension String.Index {
  @inlinable @inline(__always) internal var strippingTranscoding: String.Index {
    get {
    return String.Index(_encodedOffset: self._encodedOffset)
  }
  }
  @inlinable @inline(__always) internal var nextEncoded: String.Index {
    get {
    _internalInvariant(self.transcodedOffset == 0)
    return String.Index(_encodedOffset: self._encodedOffset &+ 1)
  }
  }
  @inlinable @inline(__always) internal var priorEncoded: String.Index {
    get {
    _internalInvariant(self.transcodedOffset == 0)
    return String.Index(_encodedOffset: self._encodedOffset &- 1)
  }
  }
  @inlinable @inline(__always) internal var nextTranscoded: String.Index {
    get {
    return String.Index(
      encodedOffset: self._encodedOffset,
      transcodedOffset: self.transcodedOffset &+ 1)
  }
  }
  @inlinable @inline(__always) internal var priorTranscoded: String.Index {
    get {
    return String.Index(
      encodedOffset: self._encodedOffset,
      transcodedOffset: self.transcodedOffset &- 1)
  }
  }
  @inlinable @inline(__always) internal func encoded(offsetBy n: Int) -> String.Index {
    return String.Index(_encodedOffset: self._encodedOffset &+ n)
  }
  @inlinable @inline(__always) internal func transcoded(withOffset n: Int) -> String.Index {
    _internalInvariant(self.transcodedOffset == 0)
    return String.Index(encodedOffset: self._encodedOffset, transcodedOffset: n)
  }
}
extension String.Index : Equatable {
  @inlinable @inline(__always) public static func == (lhs: String.Index, rhs: String.Index) -> Bool {
    return lhs.orderingValue == rhs.orderingValue
  }
}
extension String.Index : Comparable {
  @inlinable @inline(__always) public static func < (lhs: String.Index, rhs: String.Index) -> Bool {
    return lhs.orderingValue < rhs.orderingValue
  }
}
extension String.Index : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine(orderingValue)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension String.Index {
  public init?(_ sourcePosition: String.Index, within target: String)
  @available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public init?<S>(_ sourcePosition: String.Index, within target: S) where S : Swift.StringProtocol
  public func samePosition(in utf8: String.UTF8View) -> String.UTF8View.Index?
  public func samePosition(in utf16: String.UTF16View) -> String.UTF16View.Index?
}
@_fixed_layout public struct DefaultStringInterpolation : StringInterpolationProtocol {
  @usableFromInline
  internal var _storage: String
  @inlinable public init(literalCapacity: Int, interpolationCount: Int) {
    let capacityPerInterpolation = 2
    let initialCapacity = literalCapacity +
      interpolationCount * capacityPerInterpolation
    _storage = String(_StringGuts(_initialCapacity: initialCapacity))
  }
  @inlinable mutating public func appendLiteral(_ literal: String) {
    literal.write(to: &self)
  }
  @inlinable mutating public func appendInterpolation<T>(_ value: T) where T : Swift.CustomStringConvertible, T : Swift.TextOutputStreamable {
    value.write(to: &self)
  }
  @inlinable mutating public func appendInterpolation<T>(_ value: T) where T : Swift.TextOutputStreamable {
    value.write(to: &self)
  }
  @inlinable mutating public func appendInterpolation<T>(_ value: T) where T : Swift.CustomStringConvertible {
    value.description.write(to: &self)
  }
  @inlinable mutating public func appendInterpolation<T>(_ value: T) {
    _print_unlocked(value, &self)
  }
  @inlinable __consuming internal func make() -> String {
    return _storage
  }
  public typealias StringLiteralType = Swift.String
}
extension DefaultStringInterpolation : CustomStringConvertible {
  @inlinable public var description: String {
    get {
    return _storage
  }
  }
}
extension DefaultStringInterpolation : TextOutputStream {
  @inlinable mutating public func write(_ string: String) {
    _storage.append(string)
  }
  mutating public func _writeASCII(_ buffer: UnsafeBufferPointer<UInt8>)
}
extension String {
  @inlinable @_effects(readonly) public init(stringInterpolation: DefaultStringInterpolation) {
    self = stringInterpolation.make()
  }
}
extension Substring {
  @inlinable @_effects(readonly) public init(stringInterpolation: DefaultStringInterpolation) {
    self.init(stringInterpolation.make())
  }
}
extension String {
  public init(repeating repeatedValue: String, count: Int)
  @inlinable public var isEmpty: Bool {
    @inline(__always) get { return _guts.isEmpty }
  }
}
extension StringProtocol {
  @inlinable public func hasPrefix<Prefix>(_ prefix: Prefix) -> Bool where Prefix : Swift.StringProtocol {
    return self.starts(with: prefix)
  }
  @inlinable public func hasSuffix<Suffix>(_ suffix: Suffix) -> Bool where Suffix : Swift.StringProtocol {
    return self.reversed().starts(with: suffix.reversed())
  }
}
extension String {
  public func hasPrefix(_ prefix: String) -> Bool
  public func hasSuffix(_ suffix: String) -> Bool
}
extension String {
  public init<T>(_ value: T, radix: Int = 10, uppercase: Bool = false) where T : Swift.BinaryInteger
}
extension String : StringProtocol {
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
}
extension String : RangeReplaceableCollection {
  public init(repeating repeatedValue: Character, count: Int)
  @_specialize(exported: false, kind: full, where S == Swift.String)
  @_specialize(exported: false, kind: full, where S == Swift.Substring)
  public init<S>(_ other: S) where S : Swift.LosslessStringConvertible, S : Swift.Sequence, S.Element == Swift.Character
  @_specialize(exported: false, kind: full, where S == Swift.String)
  @_specialize(exported: false, kind: full, where S == Swift.Substring)
  @_specialize(exported: false, kind: full, where S == Swift.Array<Swift.Character>)
  public init<S>(_ characters: S) where S : Swift.Sequence, S.Element == Swift.Character
  mutating public func reserveCapacity(_ n: Int)
  mutating public func append(_ other: String)
  mutating public func append(_ c: Character)
  mutating public func append(contentsOf newElements: String)
  mutating public func append(contentsOf newElements: Substring)
  @_specialize(exported: false, kind: full, where S == Swift.String)
  @_specialize(exported: false, kind: full, where S == Swift.Substring)
  @_specialize(exported: false, kind: full, where S == Swift.Array<Swift.Character>)
  mutating public func append<S>(contentsOf newElements: S) where S : Swift.Sequence, S.Element == Swift.Character
  @_specialize(exported: false, kind: full, where C == Swift.String)
  @_specialize(exported: false, kind: full, where C == Swift.Substring)
  @_specialize(exported: false, kind: full, where C == Swift.Array<Swift.Character>)
  mutating public func replaceSubrange<C>(_ bounds: Range<Index>, with newElements: C) where C : Swift.Collection, C.Element == Swift.Character
  mutating public func insert(_ newElement: Character, at i: Index)
  @_specialize(exported: false, kind: full, where S == Swift.String)
  @_specialize(exported: false, kind: full, where S == Swift.Substring)
  @_specialize(exported: false, kind: full, where S == Swift.Array<Swift.Character>)
  mutating public func insert<S>(contentsOf newElements: S, at i: Index) where S : Swift.Collection, S.Element == Swift.Character
  @discardableResult
  mutating public func remove(at i: Index) -> Character
  mutating public func removeSubrange(_ bounds: Range<Index>)
  mutating public func removeAll(keepingCapacity keepCapacity: Bool = false)
}
extension String {
  @inlinable @inline(__always) internal func _boundsCheck(_ index: Index) {
    _precondition(index._encodedOffset >= 0 && index._encodedOffset < _guts.count,
      "String index is out of bounds")
  }
  @inlinable @inline(__always) internal func _boundsCheck(_ range: Range<Index>) {
    _precondition(
      range.lowerBound._encodedOffset >= 0 &&
      range.upperBound._encodedOffset <= _guts.count,
      "String index range is out of bounds")
  }
  @inlinable @inline(__always) internal func _boundsCheck(_ range: ClosedRange<Index>) {
    _precondition(
      range.lowerBound._encodedOffset >= 0 &&
      range.upperBound._encodedOffset < _guts.count,
      "String index range is out of bounds")
  }
}
extension String {
  @_transparent public func max<T>(_ x: T, _ y: T) -> T where T : Swift.Comparable {
    return Swift.max(x,y)
  }
  @_transparent public func min<T>(_ x: T, _ y: T) -> T where T : Swift.Comparable {
    return Swift.min(x,y)
  }
}
extension Sequence where Self.Element == Swift.String {
  @available(*, unavailable, message: "Operator '+' cannot be used to append a String to a sequence of strings")
  public static func + (lhs: Self, rhs: String) -> Never
  @available(*, unavailable, message: "Operator '+' cannot be used to append a String to a sequence of strings")
  public static func + (lhs: String, rhs: Self) -> Never
}
@_semantics("findStringSwitchCase") public func _findStringSwitchCase(cases: [StaticString], string: String) -> Int
@_fixed_layout public struct _OpaqueStringSwitchCache {
  internal var a: Builtin.Word
  internal var b: Builtin.Word
}
@_semantics("findStringSwitchCaseWithCache") public func _findStringSwitchCaseWithCache(cases: [StaticString], string: String, cache: inout _OpaqueStringSwitchCache) -> Int
public struct _StringRepresentation {
  public var _isASCII: Bool
  public var _count: Int
  public var _capacity: Int
  public enum _Form {
    case _small
    case _cocoa(object: AnyObject)
    case _native(object: AnyObject)
    case _immortal(address: UInt)
  }
  public var _form: _Form
  public var _objectIdentifier: ObjectIdentifier? {
    get
  }
}
extension String {
  public func _classify() -> _StringRepresentation
}
extension String {
  @_fixed_layout public struct UnicodeScalarView {
    @usableFromInline
    internal var _guts: _StringGuts
    @inlinable @inline(__always) internal init(_ _guts: _StringGuts) {
      self._guts = _guts
      _invariantCheck()
    }
  }
}
extension String.UnicodeScalarView {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension String.UnicodeScalarView : BidirectionalCollection {
  public typealias Index = String.Index
  @inlinable @inline(__always) public var startIndex: Index {
    get { return _guts.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Index {
    get { return _guts.endIndex }
  }
  @inlinable @inline(__always) public func index(after i: Index) -> Index {
    _internalInvariant(i < endIndex)
    // TODO(String performance): isASCII fast-path

    if _fastPath(_guts.isFastUTF8) {
      let len = _guts.fastUTF8ScalarLength(startingAt: i._encodedOffset)
      return i.encoded(offsetBy: len)
    }

    return _foreignIndex(after: i)
  }
  @inlinable @inline(__always) public func index(before i: Index) -> Index {
    precondition(i._encodedOffset > 0)
    // TODO(String performance): isASCII fast-path

    if _fastPath(_guts.isFastUTF8) {
      let len = _guts.withFastUTF8 { utf8 -> Int in
        return _utf8ScalarLength(utf8, endingAt: i._encodedOffset)
      }
      _internalInvariant(len <= 4, "invalid UTF8")
      return i.encoded(offsetBy: -len)
    }

    return _foreignIndex(before: i)
  }
  @inlinable @inline(__always) public subscript(position: Index) -> Unicode.Scalar {
    get {
    String(_guts)._boundsCheck(position)
    let i = _guts.scalarAlign(position)
    return _guts.errorCorrectedScalar(startingAt: i._encodedOffset).0
  }
  }
  public typealias Element = Swift.Unicode.Scalar
  public typealias Indices = Swift.DefaultIndices<Swift.String.UnicodeScalarView>
}
extension String.UnicodeScalarView {
  @_fixed_layout public struct Iterator : IteratorProtocol {
    @usableFromInline
    internal var _guts: _StringGuts
    @usableFromInline
    internal var _position: Int = 0
    @usableFromInline
    internal var _end: Int
    @inlinable internal init(_ guts: _StringGuts) {
      self._end = guts.count
      self._guts = guts
    }
    @inlinable @inline(__always) mutating public func next() -> Unicode.Scalar? {
      guard _fastPath(_position < _end) else { return nil }

      let (result, len) = _guts.errorCorrectedScalar(startingAt: _position)
      _position &+= len
      return result
    }
    public typealias Element = Swift.Unicode.Scalar
  }
  @inlinable __consuming public func makeIterator() -> Iterator {
    return Iterator(_guts)
  }
}
extension String.UnicodeScalarView : CustomStringConvertible {
  @inlinable @inline(__always) public var description: String {
    get { return String(_guts) }
  }
}
extension String.UnicodeScalarView : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension String {
  @inlinable @inline(__always) public init(_ unicodeScalars: UnicodeScalarView) {
    self.init(unicodeScalars._guts)
  }
  public typealias UnicodeScalarIndex = UnicodeScalarView.Index
  @inlinable public var unicodeScalars: UnicodeScalarView {
    @inline(__always) get { return UnicodeScalarView(_guts) }
    @inline(__always) set { _guts = newValue._guts }
  }
}
extension String.UnicodeScalarView : RangeReplaceableCollection {
  @inlinable @inline(__always) public init() {
    self.init(_StringGuts())
  }
  mutating public func reserveCapacity(_ n: Int)
  mutating public func append(_ c: Unicode.Scalar)
  mutating public func append<S>(contentsOf newElements: S) where S : Swift.Sequence, S.Element == Swift.Unicode.Scalar
  mutating public func replaceSubrange<C>(_ bounds: Range<Index>, with newElements: C) where C : Swift.Collection, C.Element == Swift.Unicode.Scalar
}
extension String.Index {
  public init?(_ sourcePosition: String.Index, within unicodeScalars: String.UnicodeScalarView)
  public func samePosition(in characters: String) -> String.Index?
}
extension String.UnicodeScalarView : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension String.UnicodeScalarView {
  public typealias SubSequence = Substring.UnicodeScalarView
  @available(swift 4)
  public subscript(r: Range<Index>) -> String.UnicodeScalarView.SubSequence {
    get
  }
}
extension String.UnicodeScalarView {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(after i: Index) -> Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(before i: Index) -> Index
}
extension String {
  @_fixed_layout public struct UTF16View {
    @usableFromInline
    internal var _guts: _StringGuts
    @inlinable internal init(_ guts: _StringGuts) {
      self._guts = guts
      _invariantCheck()
    }
  }
}
extension String.UTF16View {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension String.UTF16View : BidirectionalCollection {
  public typealias Index = String.Index
  @inlinable @inline(__always) public var startIndex: Index {
    get { return _guts.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Index {
    get { return _guts.endIndex }
  }
  @inlinable @inline(__always) public func index(after i: Index) -> Index {
    if _slowPath(_guts.isForeign) { return _foreignIndex(after: i) }
    if _guts.isASCII { return i.nextEncoded }

    // For a BMP scalar (1-3 UTF-8 code units), advance past it. For a non-BMP
    // scalar, use a transcoded offset first.
    let len = _guts.fastUTF8ScalarLength(startingAt: i._encodedOffset)
    if len == 4 && i.transcodedOffset == 0 {
      return i.nextTranscoded
    }
    return i.strippingTranscoding.encoded(offsetBy: len)
  }
  @inlinable @inline(__always) public func index(before i: Index) -> Index {
    precondition(!i.isZeroPosition)
    if _slowPath(_guts.isForeign) { return _foreignIndex(before: i) }
    if _guts.isASCII { return i.priorEncoded }

    if i.transcodedOffset != 0 {
      _internalInvariant(i.transcodedOffset == 1)
      return i.strippingTranscoding
    }

    let len = _guts.fastUTF8ScalarLength(endingAt: i._encodedOffset)
    if len == 4 {
      // 2 UTF-16 code units comprise this scalar; advance to the beginning and
      // start mid-scalar transcoding
      return i.encoded(offsetBy: -len).nextTranscoded
    }

    // Single UTF-16 code unit
    _internalInvariant((1...3) ~= len)
    return i.encoded(offsetBy: -len)
  }
  public func index(_ i: Index, offsetBy n: Int) -> Index
  public func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index?
  public func distance(from start: Index, to end: Index) -> Int
  @inlinable public var count: Int {
    get {
    if _slowPath(_guts.isForeign) {
      return _foreignCount()
    }
    return _nativeGetOffset(for: endIndex)
  }
  }
  @inlinable @inline(__always) public subscript(i: Index) -> UTF16.CodeUnit {
    get {
    String(_guts)._boundsCheck(i)

    if _fastPath(_guts.isFastUTF8) {
      let scalar = _guts.fastUTF8Scalar(
        startingAt: _guts.scalarAlign(i)._encodedOffset)
      if scalar.value <= 0xFFFF {
        return UInt16(truncatingIfNeeded: scalar.value)
      }
      return scalar.utf16[i.transcodedOffset]
    }

    return _foreignSubscript(position: i)
  }
  }
  public typealias Element = Swift.UTF16.CodeUnit
  public typealias Indices = Swift.DefaultIndices<Swift.String.UTF16View>
}
extension String.UTF16View {
  @_fixed_layout public struct Iterator : IteratorProtocol {
    @usableFromInline
    internal var _guts: _StringGuts
    @usableFromInline
    internal var _position: Int = 0
    @usableFromInline
    internal var _end: Int
    @usableFromInline
    internal var _nextIsTrailingSurrogate: UInt16? = nil
    @inlinable internal init(_ guts: _StringGuts) {
      self._end = guts.count
      self._guts = guts
    }
    @inlinable mutating public func next() -> UInt16? {
      if _slowPath(_nextIsTrailingSurrogate != nil) {
        let trailing = self._nextIsTrailingSurrogate._unsafelyUnwrappedUnchecked
        self._nextIsTrailingSurrogate = nil
        return trailing
      }
      guard _fastPath(_position < _end) else { return nil }

      let (scalar, len) = _guts.errorCorrectedScalar(startingAt: _position)
      _position &+= len

      if _slowPath(scalar.value > UInt16.max) {
        self._nextIsTrailingSurrogate = scalar.utf16[1]
        return scalar.utf16[0]
      }
      return UInt16(truncatingIfNeeded: scalar.value)
    }
    public typealias Element = Swift.UInt16
  }
  @inlinable __consuming public func makeIterator() -> Iterator {
    return Iterator(_guts)
  }
}
extension String.UTF16View : CustomStringConvertible {
  @inlinable @inline(__always) public var description: String {
    get { return String(_guts) }
  }
}
extension String.UTF16View : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension String {
  @inlinable public var utf16: UTF16View {
    @inline(__always) get { return UTF16View(_guts) }
    @inline(__always) set { self = String(newValue._guts) }
  }
  @available(swift 4.0)
  @inlinable @inline(__always) public init(_ utf16: UTF16View) {
    self.init(utf16._guts)
  }
}
extension String.Index {
  public init?(_ idx: String.Index, within target: String.UTF16View)
  public func samePosition(in unicodeScalars: String.UnicodeScalarView) -> String.UnicodeScalarIndex?
}
extension String.UTF16View : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension String.UTF16View {
  public typealias SubSequence = Substring.UTF16View
  public subscript(r: Range<Index>) -> Substring.UTF16View {
    get
  }
}
extension String.UTF16View {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(after i: Index) -> Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(before i: Index) -> Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignSubscript(position i: Index) -> UTF16.CodeUnit
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignDistance(from start: Index, to end: Index) -> Int
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index?
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(_ i: Index, offsetBy n: Int) -> Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignCount() -> Int
}
extension String.Index {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIsWithin(_ target: String.UTF16View) -> Bool
}
extension String.UTF16View {
  @inlinable @inline(__always) internal var _shortHeuristic: Int {
    get { return 32 }
  }
  @usableFromInline
  @_effects(releasenone) internal func _nativeGetOffset(for idx: Index) -> Int
  @usableFromInline
  @_effects(releasenone) internal func _nativeGetIndex(for offset: Int) -> Index
}
extension String {
  @usableFromInline
  internal func _nativeCopyUTF16CodeUnits(into buffer: UnsafeMutableBufferPointer<UInt16>, range: Range<String.Index>)
}
extension String {
  @_fixed_layout public struct UTF8View {
    @usableFromInline
    internal var _guts: _StringGuts
    @inlinable @inline(__always) internal init(_ guts: _StringGuts) {
      self._guts = guts
      _invariantCheck()
    }
  }
}
extension String.UTF8View {
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension String.UTF8View : BidirectionalCollection {
  public typealias Index = String.Index
  public typealias Element = UTF8.CodeUnit
  @inlinable @inline(__always) public var startIndex: Index {
    get { return _guts.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Index {
    get { return _guts.endIndex }
  }
  @inlinable @inline(__always) public func index(after i: Index) -> Index {
    if _fastPath(_guts.isFastUTF8) {
      return i.nextEncoded
    }

    return _foreignIndex(after: i)
  }
  @inlinable @inline(__always) public func index(before i: Index) -> Index {
    precondition(!i.isZeroPosition)
    if _fastPath(_guts.isFastUTF8) {
      return i.priorEncoded
    }

    return _foreignIndex(before: i)
  }
  @inlinable @inline(__always) public func index(_ i: Index, offsetBy n: Int) -> Index {
    if _fastPath(_guts.isFastUTF8) {
      _precondition(n + i._encodedOffset <= _guts.count)
      return i.encoded(offsetBy: n)
    }

    return _foreignIndex(i, offsetBy: n)
  }
  @inlinable @inline(__always) public func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index? {
    if _fastPath(_guts.isFastUTF8) {
      // Check the limit: ignore limit if it precedes `i` (in the correct
      // direction), otherwise must not be beyond limit (in the correct
      // direction).
      let iOffset = i._encodedOffset
      let result = iOffset + n
      let limitOffset = limit._encodedOffset
      if n >= 0 {
        guard limitOffset < iOffset || result <= limitOffset else { return nil }
      } else {
        guard limitOffset > iOffset || result >= limitOffset else { return nil }
      }
      return Index(_encodedOffset: result)
    }

    return _foreignIndex(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable @inline(__always) public func distance(from i: Index, to j: Index) -> Int {
    if _fastPath(_guts.isFastUTF8) {
      return j._encodedOffset &- i._encodedOffset
    }
    return _foreignDistance(from: i, to: j)
  }
  @inlinable @inline(__always) public subscript(i: Index) -> UTF8.CodeUnit {
    get {
    String(_guts)._boundsCheck(i)
    if _fastPath(_guts.isFastUTF8) {
      return _guts.withFastUTF8 { utf8 in utf8[_unchecked: i._encodedOffset] }
    }

    return _foreignSubscript(position: i)
  }
  }
  public typealias Indices = Swift.DefaultIndices<Swift.String.UTF8View>
  public typealias Iterator = Swift.IndexingIterator<Swift.String.UTF8View>
}
extension String.UTF8View : CustomStringConvertible {
  @inlinable @inline(__always) public var description: String {
    get { return String(_guts) }
  }
}
extension String.UTF8View : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension String {
  @inlinable public var utf8: UTF8View {
    @inline(__always) get { return UTF8View(self._guts) }
    set { self = String(newValue._guts) }
  }
  public var utf8CString: ContiguousArray<CChar> {
    get
  }
  @usableFromInline
  @inline(never) internal func _slowUTF8CString() -> ContiguousArray<CChar>
  @available(swift, introduced: 4.0, message: "Please use failable String.init?(_:UTF8View) when in Swift 3.2 mode")
  @inlinable @inline(__always) public init(_ utf8: UTF8View) {
    self = String(utf8._guts)
  }
}
extension String.UTF8View {
  @inlinable @inline(__always) public var count: Int {
    get {
    if _fastPath(_guts.isFastUTF8) {
      return _guts.count
    }
    return _foreignCount()
  }
  }
}
extension String.Index {
  @inlinable public init?(_ idx: String.Index, within target: String.UTF8View) {
    if _slowPath(target._guts.isForeign) {
      guard idx._foreignIsWithin(target) else { return nil }
    } else {
      // All indices, except sub-scalar UTF-16 indices pointing at trailing
      // surrogates, are valid.
      guard idx.transcodedOffset == 0 else { return nil }
    }

    self = idx
  }
}
extension String.UTF8View : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension String.UTF8View {
  public typealias SubSequence = Substring.UTF8View
  @available(swift 4)
  @inlinable public subscript(r: Range<Index>) -> String.UTF8View.SubSequence {
    get {
    return Substring.UTF8View(self, _bounds: r)
  }
  }
}
extension String.UTF8View {
  @inlinable @inline(__always) public func _copyContents(initializing buffer: UnsafeMutableBufferPointer<Iterator.Element>) -> (Iterator, UnsafeMutableBufferPointer<Iterator.Element>.Index) {
    guard buffer.baseAddress != nil else {
        _preconditionFailure(
          "Attempt to copy string contents into nil buffer pointer")
    }
    guard let written = _guts.copyUTF8(into: buffer) else {
      _preconditionFailure(
        "Insufficient space allocated to copy string contents")
    }

    let it = String().utf8.makeIterator()
    return (it, buffer.index(buffer.startIndex, offsetBy: written))
  }
}
extension String.UTF8View {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(after i: Index) -> Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(before i: Index) -> Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignSubscript(position i: Index) -> UTF8.CodeUnit
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(_ i: Index, offsetBy n: Int) -> Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIndex(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index?
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignDistance(from i: Index, to j: Index) -> Int
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignCount() -> Int
}
extension String.Index {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _foreignIsWithin(_ target: String.UTF8View) -> Bool
}
extension String.UTF8View {
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    guard _guts.isFastUTF8 else { return nil }
    return try _guts.withFastUTF8(body)
  }
}
extension String {
  @inlinable public init(_ substring: __shared Substring) {
    self = String._fromSubstring(substring)
  }
}
@_fixed_layout public struct Substring {
  @usableFromInline
  internal var _slice: Slice<String>
  @inlinable @inline(__always) internal init(_ slice: Slice<String>) {
    self._slice = slice
    _invariantCheck()
  }
  @inlinable @inline(__always) public init() {
    self.init(Slice())
  }
}
extension Substring {
  @_alwaysEmitIntoClient public var base: String {
    get { return _slice.base }
  }
  @inlinable @inline(__always) internal var _wholeGuts: _StringGuts {
    get { return base._guts }
  }
  @inlinable internal var _offsetRange: Range<Int> {
    @inline(__always) get {
      let start = _slice.startIndex
      let end = _slice.endIndex
      _internalInvariant(start.transcodedOffset == 0 && end.transcodedOffset == 0)

      return Range(uncheckedBounds: (start._encodedOffset, end._encodedOffset))
    }
  }
  @inlinable @inline(__always) internal func _invariantCheck() {}
}
extension Substring : StringProtocol {
  public typealias Index = String.Index
  public typealias SubSequence = Substring
  @inlinable @inline(__always) public var startIndex: Index {
    get { return _slice.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Index {
    get { return _slice.endIndex }
  }
  @inlinable @inline(__always) public func index(after i: Index) -> Index {
    _precondition(i < endIndex, "Cannot increment beyond endIndex")
    _precondition(i >= startIndex, "Cannot increment an invalid index")
    return _slice.index(after: i)
  }
  @inlinable @inline(__always) public func index(before i: Index) -> Index {
    _precondition(i <= endIndex, "Cannot decrement an invalid index")
    _precondition(i > startIndex, "Cannot decrement beyond startIndex")
    return _slice.index(before: i)
  }
  @inlinable @inline(__always) public func index(_ i: Index, offsetBy n: Int) -> Index {
    let result = _slice.index(i, offsetBy: n)
    _precondition(
      (_slice._startIndex ... _slice.endIndex).contains(result),
      "Operation results in an invalid index")
    return result
  }
  @inlinable @inline(__always) public func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index? {
    let result = _slice.index(i, offsetBy: n, limitedBy: limit)
    _precondition(result.map {
        (_slice._startIndex ... _slice.endIndex).contains($0)
      } ?? true,
      "Operation results in an invalid index")
    return result
  }
  @inlinable @inline(__always) public func distance(from start: Index, to end: Index) -> Int {
    return _slice.distance(from: start, to: end)
  }
  public subscript(i: Index) -> Character {
    get
  }
  mutating public func replaceSubrange<C>(_ bounds: Range<Index>, with newElements: C) where C : Swift.Collection, C.Element == Swift.Substring.Iterator.Element
  mutating public func replaceSubrange(_ bounds: Range<Index>, with newElements: Substring)
  @inlinable public init<C, Encoding>(decoding codeUnits: C, as sourceEncoding: Encoding.Type) where C : Swift.Collection, Encoding : Swift._UnicodeEncoding, C.Element == Encoding.CodeUnit {
    self.init(String(decoding: codeUnits, as: sourceEncoding))
  }
  public init(cString nullTerminatedUTF8: UnsafePointer<CChar>)
  @inlinable public init<Encoding>(decodingCString nullTerminatedCodeUnits: UnsafePointer<Encoding.CodeUnit>, as sourceEncoding: Encoding.Type) where Encoding : Swift._UnicodeEncoding {
    self.init(
      String(decodingCString: nullTerminatedCodeUnits, as: sourceEncoding))
  }
  @inlinable public func withCString<Result>(_ body: (UnsafePointer<CChar>) throws -> Result) rethrows -> Result {
    // TODO(String performance): Detect when we cover the rest of a nul-
    // terminated String, and thus can avoid a copy.
    return try String(self).withCString(body)
  }
  @inlinable public func withCString<Result, TargetEncoding>(encodedAs targetEncoding: TargetEncoding.Type, _ body: (UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result where TargetEncoding : Swift._UnicodeEncoding {
    // TODO(String performance): Detect when we cover the rest of a nul-
    // terminated String, and thus can avoid a copy.
    return try String(self).withCString(encodedAs: targetEncoding, body)
  }
  public typealias Element = Swift.Character
  public typealias Iterator = Swift.IndexingIterator<Swift.Substring>
  public typealias Indices = Swift.DefaultIndices<Swift.Substring>
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
  public var hashValue: Swift.Int {
    get
  }
}
extension Substring : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Substring : CustomStringConvertible {
  @inlinable @inline(__always) public var description: String {
    get { return String(self) }
  }
}
extension Substring : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension Substring : LosslessStringConvertible {
  @inlinable public init(_ content: String) {
    self = content[...]
  }
}
extension Substring {
  @_fixed_layout public struct UTF8View {
    @usableFromInline
    internal var _slice: Slice<String.UTF8View>
  }
}
extension Substring.UTF8View : BidirectionalCollection {
  public typealias Index = String.UTF8View.Index
  public typealias Indices = String.UTF8View.Indices
  public typealias Element = String.UTF8View.Element
  public typealias SubSequence = Substring.UTF8View
  @inlinable internal init(_ base: String.UTF8View, _bounds: Range<Index>) {
    _slice = Slice(
      base: String(base._guts).utf8,
      bounds: _bounds)
  }
  @inlinable public var startIndex: Index {
    get { return _slice.startIndex }
  }
  @inlinable public var endIndex: Index {
    get { return _slice.endIndex }
  }
  @inlinable public subscript(index: Index) -> Element {
    get { return _slice[index] }
  }
  @inlinable public var indices: Indices {
    get { return _slice.indices }
  }
  @inlinable public func index(after i: Index) -> Index { return _slice.index(after: i) }
  @inlinable public func formIndex(after i: inout Index) {
    _slice.formIndex(after: &i)
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _slice.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index? {
    return _slice.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    return _slice.distance(from: start, to: end)
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Index, bounds: Range<Index>) {
    _slice._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Range<Index>, bounds: Range<Index>) {
    _slice._failEarlyRangeCheck(range, bounds: bounds)
  }
  public func index(before i: Index) -> Index
  public func formIndex(before i: inout Index)
  public subscript(r: Range<Index>) -> Substring.UTF8View {
    get
  }
  public typealias Iterator = Swift.IndexingIterator<Swift.Substring.UTF8View>
}
extension Substring {
  @inlinable public var utf8: UTF8View {
    get {
      return base.utf8[startIndex..<endIndex]
    }
    set {
      self = Substring(newValue)
    }
  }
  public init(_ content: UTF8View)
}
extension String {
  public init?(_ codeUnits: Substring.UTF8View)
}
extension Substring {
  @_fixed_layout public struct UTF16View {
    @usableFromInline
    internal var _slice: Slice<String.UTF16View>
  }
}
extension Substring.UTF16View : BidirectionalCollection {
  public typealias Index = String.UTF16View.Index
  public typealias Indices = String.UTF16View.Indices
  public typealias Element = String.UTF16View.Element
  public typealias SubSequence = Substring.UTF16View
  @inlinable internal init(_ base: String.UTF16View, _bounds: Range<Index>) {
    _slice = Slice(
      base: String(base._guts).utf16,
      bounds: _bounds)
  }
  @inlinable public var startIndex: Index {
    get { return _slice.startIndex }
  }
  @inlinable public var endIndex: Index {
    get { return _slice.endIndex }
  }
  @inlinable public subscript(index: Index) -> Element {
    get { return _slice[index] }
  }
  @inlinable public var indices: Indices {
    get { return _slice.indices }
  }
  @inlinable public func index(after i: Index) -> Index { return _slice.index(after: i) }
  @inlinable public func formIndex(after i: inout Index) {
    _slice.formIndex(after: &i)
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _slice.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index? {
    return _slice.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    return _slice.distance(from: start, to: end)
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Index, bounds: Range<Index>) {
    _slice._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Range<Index>, bounds: Range<Index>) {
    _slice._failEarlyRangeCheck(range, bounds: bounds)
  }
  @inlinable public func index(before i: Index) -> Index { return _slice.index(before: i) }
  @inlinable public func formIndex(before i: inout Index) {
    _slice.formIndex(before: &i)
  }
  @inlinable public subscript(r: Range<Index>) -> Substring.UTF16View {
    get {
    return Substring.UTF16View(_slice.base, _bounds: r)
  }
  }
  public typealias Iterator = Swift.IndexingIterator<Swift.Substring.UTF16View>
}
extension Substring {
  @inlinable public var utf16: UTF16View {
    get {
      return base.utf16[startIndex..<endIndex]
    }
    set {
      self = Substring(newValue)
    }
  }
  public init(_ content: UTF16View)
}
extension String {
  public init?(_ codeUnits: Substring.UTF16View)
}
extension Substring {
  @_fixed_layout public struct UnicodeScalarView {
    @usableFromInline
    internal var _slice: Slice<String.UnicodeScalarView>
  }
}
extension Substring.UnicodeScalarView : BidirectionalCollection {
  public typealias Index = String.UnicodeScalarView.Index
  public typealias Indices = String.UnicodeScalarView.Indices
  public typealias Element = String.UnicodeScalarView.Element
  public typealias SubSequence = Substring.UnicodeScalarView
  @inlinable internal init(_ base: String.UnicodeScalarView, _bounds: Range<Index>) {
    _slice = Slice(
      base: String(base._guts).unicodeScalars,
      bounds: _bounds)
  }
  @inlinable public var startIndex: Index {
    get { return _slice.startIndex }
  }
  @inlinable public var endIndex: Index {
    get { return _slice.endIndex }
  }
  @inlinable public subscript(index: Index) -> Element {
    get { return _slice[index] }
  }
  @inlinable public var indices: Indices {
    get { return _slice.indices }
  }
  @inlinable public func index(after i: Index) -> Index { return _slice.index(after: i) }
  @inlinable public func formIndex(after i: inout Index) {
    _slice.formIndex(after: &i)
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _slice.index(i, offsetBy: n)
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index? {
    return _slice.index(i, offsetBy: n, limitedBy: limit)
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    return _slice.distance(from: start, to: end)
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Index, bounds: Range<Index>) {
    _slice._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Range<Index>, bounds: Range<Index>) {
    _slice._failEarlyRangeCheck(range, bounds: bounds)
  }
  @inlinable public func index(before i: Index) -> Index { return _slice.index(before: i) }
  @inlinable public func formIndex(before i: inout Index) {
    _slice.formIndex(before: &i)
  }
  @inlinable public subscript(r: Range<Index>) -> Substring.UnicodeScalarView {
    get {
    return Substring.UnicodeScalarView(_slice.base, _bounds: r)
  }
  }
  public typealias Iterator = Swift.IndexingIterator<Swift.Substring.UnicodeScalarView>
}
extension Substring {
  @inlinable public var unicodeScalars: UnicodeScalarView {
    get {
      return base.unicodeScalars[startIndex..<endIndex]
    }
    set {
      self = Substring(newValue)
    }
  }
  public init(_ content: UnicodeScalarView)
}
extension String {
  public init(_ content: Substring.UnicodeScalarView)
}
extension Substring.UnicodeScalarView : RangeReplaceableCollection {
  @inlinable public init() { _slice = Slice.init() }
  mutating public func replaceSubrange<C>(_ target: Range<Index>, with replacement: C) where C : Swift.Collection, C.Element == Swift.Substring.UnicodeScalarView.Element
}
extension Substring : RangeReplaceableCollection {
  @_specialize(exported: false, kind: full, where S == Swift.String)
  @_specialize(exported: false, kind: full, where S == Swift.Substring)
  @_specialize(exported: false, kind: full, where S == Swift.Array<Swift.Character>)
  public init<S>(_ elements: S) where S : Swift.Sequence, S.Element == Swift.Character
  @inlinable mutating public func append<S>(contentsOf elements: S) where S : Swift.Sequence, S.Element == Swift.Character {
    var string = String(self)
    self = Substring() // Keep unique storage if possible
    string.append(contentsOf: elements)
    self = Substring(string)
  }
}
extension Substring {
  public func lowercased() -> String
  public func uppercased() -> String
  public func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> String
}
extension Substring : TextOutputStream {
  mutating public func write(_ other: String)
}
extension Substring : TextOutputStreamable {
  @inlinable public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream {
    target.write(String(self))
  }
}
extension Substring : ExpressibleByUnicodeScalarLiteral {
  @inlinable public init(unicodeScalarLiteral value: String) {
     self.init(value)
  }
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Substring : ExpressibleByExtendedGraphemeClusterLiteral {
  @inlinable public init(extendedGraphemeClusterLiteral value: String) {
     self.init(value)
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
}
extension Substring : ExpressibleByStringLiteral {
  @inlinable public init(stringLiteral value: String) {
     self.init(value)
  }
  public typealias StringLiteralType = Swift.String
}
extension String {
  @available(swift 4)
  @inlinable public subscript(r: Range<Index>) -> Substring {
    get {
    _boundsCheck(r)
    return Substring(Slice(base: self, bounds: r))
  }
  }
}
extension Substring {
  @available(swift 4)
  @inlinable public subscript(r: Range<Index>) -> Substring {
    get {
    return Substring(_slice[r])
  }
  }
}
@usableFromInline
@_transparent internal func _isValidArrayIndex(_ index: Int, count: Int) -> Bool {
  return (index >= 0) && (index <= count)
}
@usableFromInline
@_transparent internal func _isValidArraySubscript(_ index: Int, count: Int) -> Bool {
  return (index >= 0) && (index < count)
}
@objc @usableFromInline
@_fixed_layout internal class __SwiftNativeNSArrayWithContiguousStorage : __SwiftNativeNSArray {
  @inlinable @nonobjc override internal init() {}
  @objc @inlinable deinit {}
}
extension __SwiftNativeNSArrayWithContiguousStorage {
}
@usableFromInline
@_fixed_layout @objc final internal class __SwiftDeferredNSArray : __SwiftNativeNSArrayWithContiguousStorage {
  @nonobjc final internal var _heapBufferBridged_DoNotUse: AnyObject?
  @usableFromInline
  @nonobjc final internal let _nativeStorage: __ContiguousArrayStorageBase
  @inlinable @nonobjc internal init(_nativeStorage: __ContiguousArrayStorageBase) {
    self._nativeStorage = _nativeStorage
  }
  @objc deinit
  @inlinable override internal init()
}
@objc @usableFromInline
@_fixed_layout internal class __ContiguousArrayStorageBase : __SwiftNativeNSArrayWithContiguousStorage {
  @usableFromInline
  final internal var countAndCapacity: _ArrayBody
  @inlinable @nonobjc internal init(_doNotCallMeBase: ()) {
    _internalInvariantFailure("creating instance of __ContiguousArrayStorageBase")
  }
  @inlinable internal func canStoreElements(ofDynamicType _: Any.Type) -> Bool {
    _internalInvariantFailure(
      "Concrete subclasses must implement canStoreElements(ofDynamicType:)")
  }
  @inlinable internal var staticElementType: Any.Type {
    get {
    _internalInvariantFailure(
      "Concrete subclasses must implement staticElementType")
  }
  }
  @objc @inlinable deinit {
    _internalInvariant(
      self !== _emptyArrayStorage, "Deallocating empty array storage?!")
  }
  @inlinable override internal init()
}
@_fixed_layout public struct _UIntBuffer<Element> where Element : Swift.FixedWidthInteger, Element : Swift.UnsignedInteger {
  public typealias Storage = UInt32
  public var _storage: Storage
  public var _bitCount: UInt8
  @inlinable @inline(__always) public init(_storage: Storage, _bitCount: UInt8) {
    self._storage = _storage
    self._bitCount = _bitCount
  }
  @inlinable @inline(__always) public init(containing e: Element) {
    _storage = Storage(truncatingIfNeeded: e)
    _bitCount = UInt8(truncatingIfNeeded: Element.bitWidth)
  }
}
extension _UIntBuffer : Sequence {
  public typealias SubSequence = Slice<_UIntBuffer>
  @_fixed_layout public struct Iterator : IteratorProtocol, Sequence {
    @inlinable @inline(__always) public init(_ x: _UIntBuffer) { _impl = x }
    @inlinable @inline(__always) mutating public func next() -> Element? {
      if _impl._bitCount == 0 { return nil }
      defer {
        _impl._storage = _impl._storage &>> Element.bitWidth
        _impl._bitCount = _impl._bitCount &- _impl._elementWidth
      }
      return Element(truncatingIfNeeded: _impl._storage)
    }
    public var _impl: _UIntBuffer
    public typealias Iterator = Swift._UIntBuffer<Element>.Iterator
  }
  @inlinable @inline(__always) public func makeIterator() -> Iterator {
    return Iterator(self)
  }
}
extension _UIntBuffer : Collection {
  @_fixed_layout public struct Index : Comparable {
    @usableFromInline
    internal var bitOffset: UInt8
    @inlinable internal init(bitOffset: UInt8) { self.bitOffset = bitOffset }
    @inlinable public static func == (lhs: Index, rhs: Index) -> Bool {
      return lhs.bitOffset == rhs.bitOffset
    }
    @inlinable public static func < (lhs: Index, rhs: Index) -> Bool {
      return lhs.bitOffset < rhs.bitOffset
    }
  }
  @inlinable public var startIndex: Index {
    @inline(__always) get { return Index(bitOffset: 0) }
  }
  @inlinable public var endIndex: Index {
    @inline(__always) get { return Index(bitOffset: _bitCount) }
  }
  @inlinable @inline(__always) public func index(after i: Index) -> Index {
    return Index(bitOffset: i.bitOffset &+ _elementWidth)
  }
  @inlinable internal var _elementWidth: UInt8 {
    get {
    return UInt8(truncatingIfNeeded: Element.bitWidth)
  }
  }
  @inlinable public subscript(i: Index) -> Element {
    @inline(__always) get {
      return Element(truncatingIfNeeded: _storage &>> i.bitOffset)
    }
  }
}
extension _UIntBuffer : BidirectionalCollection {
  @inlinable @inline(__always) public func index(before i: Index) -> Index {
    return Index(bitOffset: i.bitOffset &- _elementWidth)
  }
}
extension _UIntBuffer : RandomAccessCollection {
  public typealias Indices = DefaultIndices<_UIntBuffer>
  @inlinable @inline(__always) public func index(_ i: Index, offsetBy n: Int) -> Index {
    let x = Int(i.bitOffset) &+ n &* Element.bitWidth
    return Index(bitOffset: UInt8(truncatingIfNeeded: x))
  }
  @inlinable @inline(__always) public func distance(from i: Index, to j: Index) -> Int {
    return (Int(j.bitOffset) &- Int(i.bitOffset)) / Element.bitWidth
  }
}
extension FixedWidthInteger {
  @inline(__always) @inlinable internal func _fullShiftLeft<N>(_ n: N) -> Self where N : Swift.FixedWidthInteger {
    return (self &<< ((n &+ 1) &>> 1)) &<< (n &>> 1)
  }
  @inline(__always) @inlinable internal func _fullShiftRight<N>(_ n: N) -> Self where N : Swift.FixedWidthInteger {
    return (self &>> ((n &+ 1) &>> 1)) &>> (n &>> 1)
  }
  @inline(__always) @inlinable internal static func _lowBits<N>(_ n: N) -> Self where N : Swift.FixedWidthInteger {
    return ~((~0 as Self)._fullShiftLeft(n))
  }
}
extension Range {
  @inline(__always) @inlinable internal func _contains_(_ other: Range) -> Bool {
    return other.clamped(to: self) == other
  }
}
extension _UIntBuffer : RangeReplaceableCollection {
  @inlinable @inline(__always) public init() {
    _storage = 0
    _bitCount = 0
  }
  @inlinable public var capacity: Int {
    get {
    return Storage.bitWidth / Element.bitWidth
  }
  }
  @inlinable @inline(__always) mutating public func append(_ newElement: Element) {
    _debugPrecondition(count + 1 <= capacity)
    _storage &= ~(Storage(Element.max) &<< _bitCount)
    _storage |= Storage(newElement) &<< _bitCount
    _bitCount = _bitCount &+ _elementWidth
  }
  @discardableResult
  @inlinable @inline(__always) mutating public func removeFirst() -> Element {
    _debugPrecondition(!isEmpty)
    let result = Element(truncatingIfNeeded: _storage)
    _bitCount = _bitCount &- _elementWidth
    _storage = _storage._fullShiftRight(_elementWidth)
    return result
  }
  @inlinable @inline(__always) mutating public func replaceSubrange<C>(_ target: Range<Index>, with replacement: C) where Element == C.Element, C : Swift.Collection {
    _debugPrecondition(
      (0..<_bitCount)._contains_(
        target.lowerBound.bitOffset..<target.upperBound.bitOffset))
    
    let replacement1 = _UIntBuffer(replacement)

    let targetCount = distance(
      from: target.lowerBound, to: target.upperBound)
    let growth = replacement1.count &- targetCount
    _debugPrecondition(count + growth <= capacity)

    let headCount = distance(from: startIndex, to: target.lowerBound)
    let tailOffset = distance(from: startIndex, to: target.upperBound)

    let w = Element.bitWidth
    let headBits = _storage & ._lowBits(headCount &* w)
    let tailBits = _storage._fullShiftRight(tailOffset &* w)

    _storage = headBits
    _storage |= replacement1._storage &<< (headCount &* w)
    _storage |= tailBits &<< ((tailOffset &+ growth) &* w)
    _bitCount = UInt8(
      truncatingIfNeeded: Int(_bitCount) &+ growth &* w)
  }
}
extension String {
  @available(*, unavailable, message: "cannot subscript String with an Int, see the documentation comment for discussion")
  public subscript(i: Int) -> Character {
    get
  }
  @available(*, unavailable, message: "cannot subscript String with an integer range, see the documentation comment for discussion")
  public subscript<R>(bounds: R) -> String where R : Swift.RangeExpression, R.Bound == Swift.Int {
    get
  }
}
public protocol _UnicodeEncoding {
  associatedtype CodeUnit : Swift.FixedWidthInteger, Swift.UnsignedInteger where Self.CodeUnit == Self.EncodedScalar.Element
  associatedtype EncodedScalar : Swift.BidirectionalCollection
  static var encodedReplacementCharacter: EncodedScalar { get }
  static func decode(_ content: EncodedScalar) -> Unicode.Scalar
  static func encode(_ content: Unicode.Scalar) -> EncodedScalar?
  static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> EncodedScalar? where FromEncoding : Swift._UnicodeEncoding
  associatedtype ForwardParser : Swift._UnicodeParser where Self == Self.ForwardParser.Encoding, Self.ForwardParser.Encoding == Self.ReverseParser.Encoding
  associatedtype ReverseParser : Swift._UnicodeParser
  static func _isScalar(_ x: CodeUnit) -> Bool
}
extension _UnicodeEncoding {
  @inlinable public static func _isScalar(_ x: CodeUnit) -> Bool { return false }
  @inlinable public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> EncodedScalar? where FromEncoding : Swift._UnicodeEncoding {
    return encode(FromEncoding.decode(content))
  }
  @inlinable internal static func _encode(_ content: Unicode.Scalar) -> EncodedScalar {
    return encode(content) ?? encodedReplacementCharacter
  }
  @inlinable internal static func _transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> EncodedScalar where FromEncoding : Swift._UnicodeEncoding {
    return transcode(content, from: FromEncoding.self)
      ?? encodedReplacementCharacter
  }
  @inlinable internal static func _transcode<Source, SourceEncoding>(_ source: Source, from sourceEncoding: SourceEncoding.Type, into processScalar: (EncodedScalar) -> Void) where Source : Swift.Sequence, SourceEncoding : Swift._UnicodeEncoding, Source.Element == SourceEncoding.CodeUnit {
    var p = SourceEncoding.ForwardParser()
    var i = source.makeIterator()
    while true {
      switch p.parseScalar(from: &i) {
      case .valid(let e): processScalar(_transcode(e, from: sourceEncoding))
      case .error(_): processScalar(encodedReplacementCharacter)
      case .emptyInput: return
      }
    }
  }
}
extension Unicode {
  public typealias Encoding = _UnicodeEncoding
}
@inlinable @inline(__always) internal func _decodeUTF8(_ x: UInt8) -> Unicode.Scalar {
  _internalInvariant(UTF8.isASCII(x))
  return Unicode.Scalar(_unchecked: UInt32(x))
}
@inlinable @inline(__always) internal func _decodeUTF8(_ x: UInt8, _ y: UInt8) -> Unicode.Scalar {
  _internalInvariant(_utf8ScalarLength(x) == 2)
  _internalInvariant(UTF8.isContinuation(y))
  let x = UInt32(x)
  let value = ((x & 0b0001_1111) &<< 6) | _continuationPayload(y)
  return Unicode.Scalar(_unchecked: value)
}
@inlinable @inline(__always) internal func _decodeUTF8(_ x: UInt8, _ y: UInt8, _ z: UInt8) -> Unicode.Scalar {
  _internalInvariant(_utf8ScalarLength(x) == 3)
  _internalInvariant(UTF8.isContinuation(y) && UTF8.isContinuation(z))
  let x = UInt32(x)
  let value = ((x & 0b0000_1111) &<< 12)
            | (_continuationPayload(y) &<< 6)
            | _continuationPayload(z)
  return Unicode.Scalar(_unchecked: value)
}
@inlinable @inline(__always) internal func _decodeUTF8(_ x: UInt8, _ y: UInt8, _ z: UInt8, _ w: UInt8) -> Unicode.Scalar {
  _internalInvariant(_utf8ScalarLength(x) == 4)
  _internalInvariant(
    UTF8.isContinuation(y) && UTF8.isContinuation(z)
    && UTF8.isContinuation(w))
  let x = UInt32(x)
  let value = ((x & 0b0000_1111) &<< 18)
            | (_continuationPayload(y) &<< 12)
            | (_continuationPayload(z) &<< 6)
            | _continuationPayload(w)
  return Unicode.Scalar(_unchecked: value)
}
@inlinable internal func _decodeScalar(_ utf8: UnsafeBufferPointer<UInt8>, startingAt i: Int) -> (Unicode.Scalar, scalarLength: Int) {
  let cu0 = utf8[_unchecked: i]
  let len = _utf8ScalarLength(cu0)
  switch  len {
  case 1: return (_decodeUTF8(cu0), len)
  case 2: return (_decodeUTF8(cu0, utf8[_unchecked: i &+ 1]), len)
  case 3: return (_decodeUTF8(
    cu0, utf8[_unchecked: i &+ 1], utf8[_unchecked: i &+ 2]), len)
  case 4:
    return (_decodeUTF8(
      cu0,
      utf8[_unchecked: i &+ 1],
      utf8[_unchecked: i &+ 2],
      utf8[_unchecked: i &+ 3]),
    len)
  default: Builtin.unreachable()
  }
}
@inlinable internal func _decodeScalar(_ utf8: UnsafeBufferPointer<UInt8>, endingAt i: Int) -> (Unicode.Scalar, scalarLength: Int) {
  let len = _utf8ScalarLength(utf8, endingAt: i)
  let (scalar, scalarLen) = _decodeScalar(utf8, startingAt: i &- len)
  _internalInvariant(len == scalarLen)
  return (scalar, len)
}
@inlinable @inline(__always) internal func _utf8ScalarLength(_ x: UInt8) -> Int {
  _internalInvariant(!UTF8.isContinuation(x))
  if UTF8.isASCII(x) { return 1 }
  // TODO(String micro-performance): check codegen
  return (~x).leadingZeroBitCount
}
@inlinable @inline(__always) internal func _utf8ScalarLength(_ utf8: UnsafeBufferPointer<UInt8>, endingAt i: Int) -> Int {
  var len = 1
  while UTF8.isContinuation(utf8[_unchecked: i &- len]) {
    len &+= 1
  }
  _internalInvariant(len == _utf8ScalarLength(utf8[i &- len]))
  return len
}
@inlinable @inline(__always) internal func _continuationPayload(_ x: UInt8) -> UInt32 {
  return UInt32(x & 0x3F)
}
@inlinable @inline(__always) internal func _scalarAlign(_ utf8: UnsafeBufferPointer<UInt8>, _ idx: Int) -> Int {
  var i = idx
  while _slowPath(UTF8.isContinuation(utf8[_unchecked: i])) {
    i &-= 1
    _internalInvariant(i >= 0,
      "Malformed contents: starts with continuation byte")
  }
  return i
}
extension _StringGuts {
  @inlinable @inline(__always) internal func scalarAlign(_ idx: Index) -> Index {
    // TODO(String performance): isASCII check

    if _slowPath(idx.transcodedOffset != 0 || idx._encodedOffset == 0) {
      // Transcoded indices are already scalar aligned
      return String.Index(_encodedOffset: idx._encodedOffset)
    }
    if _slowPath(self.isForeign) {
      return foreignScalarAlign(idx)
    }

    return self.withFastUTF8 { utf8 in
      let i = _scalarAlign(utf8, idx._encodedOffset)

      // If no alignment is performed, keep grapheme cache
      if i == idx._encodedOffset {
        return idx
      }

      return Index(_encodedOffset: i)
    }
  }
  @inlinable internal func fastUTF8ScalarLength(startingAt i: Int) -> Int {
    _internalInvariant(isFastUTF8)
    let len = _utf8ScalarLength(self.withFastUTF8 { $0[i] })
    _internalInvariant((1...4) ~= len)
    return len
  }
  @inlinable internal func fastUTF8ScalarLength(endingAt i: Int) -> Int {
    _internalInvariant(isFastUTF8)

    return self.withFastUTF8 { utf8 in
      _internalInvariant(i == utf8.count || !UTF8.isContinuation(utf8[i]))
      var len = 1
      while UTF8.isContinuation(utf8[i &- len]) {
        _internalInvariant(i &- len > 0)
        len += 1
      }
      _internalInvariant(len <= 4)
      return len
    }
  }
  @inlinable internal func fastUTF8Scalar(startingAt i: Int) -> Unicode.Scalar {
    _internalInvariant(isFastUTF8)
    return self.withFastUTF8 { _decodeScalar($0, startingAt: i).0 }
  }
  @usableFromInline
  @_effects(releasenone) internal func isOnUnicodeScalarBoundary(_ i: String.Index) -> Bool
}
extension _StringGuts {
  @usableFromInline
  @_effects(releasenone) internal func foreignErrorCorrectedScalar(startingAt idx: String.Index) -> (Unicode.Scalar, scalarLength: Int)
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func foreignScalarAlign(_ idx: Index) -> Index
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func foreignErrorCorrectedGrapheme(startingAt start: Int, endingAt end: Int) -> Character
}
extension _StringGuts {
  @inlinable @inline(__always) internal func errorCorrectedScalar(startingAt i: Int) -> (Unicode.Scalar, scalarLength: Int) {
    if _fastPath(isFastUTF8) {
      return withFastUTF8 { _decodeScalar($0, startingAt: i) }
    }
    return foreignErrorCorrectedScalar(
      startingAt: String.Index(_encodedOffset: i))
  }
  @inlinable @inline(__always) internal func errorCorrectedCharacter(startingAt start: Int, endingAt end: Int) -> Character {
    if _fastPath(isFastUTF8) {
      return withFastUTF8(range: start..<end) { utf8 in
        return Character(unchecked: String._uncheckedFromUTF8(utf8))
      }
    }

    return foreignErrorCorrectedGrapheme(startingAt: start, endingAt: end)
  }
}
extension Unicode {
  @_frozen public enum ParseResult<T> {
    case valid(T)
    case emptyInput
    case error(length: Int)
    @inlinable internal var _valid: T? {
      get {
      if case .valid(let result) = self { return result }
      return nil
    }
    }
    @inlinable internal var _error: Int? {
      get {
      if case .error(let result) = self { return result }
      return nil
    }
    }
  }
}
public protocol _UnicodeParser {
  associatedtype Encoding : Swift._UnicodeEncoding
  init()
  mutating func parseScalar<I>(from input: inout I) -> Unicode.ParseResult<Encoding.EncodedScalar> where I : Swift.IteratorProtocol, I.Element == Self.Encoding.CodeUnit
}
extension Unicode {
  public typealias Parser = _UnicodeParser
}
extension Unicode.Scalar {
  public struct Properties {
    @usableFromInline
    internal var _scalar: Unicode.Scalar
  }
  public var properties: Properties {
    get
  }
}
extension Unicode.Scalar.Properties {
  public var isAlphabetic: Bool {
    get
  }
  public var isASCIIHexDigit: Bool {
    get
  }
  public var isBidiControl: Bool {
    get
  }
  public var isBidiMirrored: Bool {
    get
  }
  public var isDash: Bool {
    get
  }
  public var isDefaultIgnorableCodePoint: Bool {
    get
  }
  public var isDeprecated: Bool {
    get
  }
  public var isDiacritic: Bool {
    get
  }
  public var isExtender: Bool {
    get
  }
  public var isFullCompositionExclusion: Bool {
    get
  }
  public var isGraphemeBase: Bool {
    get
  }
  public var isGraphemeExtend: Bool {
    get
  }
  public var isHexDigit: Bool {
    get
  }
  public var isIDContinue: Bool {
    get
  }
  public var isIDStart: Bool {
    get
  }
  public var isIdeographic: Bool {
    get
  }
  public var isIDSBinaryOperator: Bool {
    get
  }
  public var isIDSTrinaryOperator: Bool {
    get
  }
  public var isJoinControl: Bool {
    get
  }
  public var isLogicalOrderException: Bool {
    get
  }
  public var isLowercase: Bool {
    get
  }
  public var isMath: Bool {
    get
  }
  public var isNoncharacterCodePoint: Bool {
    get
  }
  public var isQuotationMark: Bool {
    get
  }
  public var isRadical: Bool {
    get
  }
  public var isSoftDotted: Bool {
    get
  }
  public var isTerminalPunctuation: Bool {
    get
  }
  public var isUnifiedIdeograph: Bool {
    get
  }
  public var isUppercase: Bool {
    get
  }
  public var isWhitespace: Bool {
    get
  }
  public var isXIDContinue: Bool {
    get
  }
  public var isXIDStart: Bool {
    get
  }
  public var isSentenceTerminal: Bool {
    get
  }
  public var isVariationSelector: Bool {
    get
  }
  public var isPatternSyntax: Bool {
    get
  }
  public var isPatternWhitespace: Bool {
    get
  }
  public var isCased: Bool {
    get
  }
  public var isCaseIgnorable: Bool {
    get
  }
  public var changesWhenLowercased: Bool {
    get
  }
  public var changesWhenUppercased: Bool {
    get
  }
  public var changesWhenTitlecased: Bool {
    get
  }
  public var changesWhenCaseFolded: Bool {
    get
  }
  public var changesWhenCaseMapped: Bool {
    get
  }
  public var changesWhenNFKCCaseFolded: Bool {
    get
  }
  @available(OSX 10.12.2, iOS 10.2, tvOS 10.1, watchOS 3.1.1, *)
  public var isEmoji: Bool {
    get
  }
  @available(OSX 10.12.2, iOS 10.2, tvOS 10.1, watchOS 3.1.1, *)
  public var isEmojiPresentation: Bool {
    get
  }
  @available(OSX 10.12.2, iOS 10.2, tvOS 10.1, watchOS 3.1.1, *)
  public var isEmojiModifier: Bool {
    get
  }
  @available(OSX 10.12.2, iOS 10.2, tvOS 10.1, watchOS 3.1.1, *)
  public var isEmojiModifierBase: Bool {
    get
  }
}
extension Unicode.Scalar.Properties {
  public var lowercaseMapping: String {
    get
  }
  public var titlecaseMapping: String {
    get
  }
  public var uppercaseMapping: String {
    get
  }
}
extension Unicode {
  public typealias Version = (major: Int, minor: Int)
}
extension Unicode.Scalar.Properties {
  public var age: Unicode.Version? {
    get
  }
}
extension Unicode {
  public enum GeneralCategory {
    case uppercaseLetter
    case lowercaseLetter
    case titlecaseLetter
    case modifierLetter
    case otherLetter
    case nonspacingMark
    case spacingMark
    case enclosingMark
    case decimalNumber
    case letterNumber
    case otherNumber
    case connectorPunctuation
    case dashPunctuation
    case openPunctuation
    case closePunctuation
    case initialPunctuation
    case finalPunctuation
    case otherPunctuation
    case mathSymbol
    case currencySymbol
    case modifierSymbol
    case otherSymbol
    case spaceSeparator
    case lineSeparator
    case paragraphSeparator
    case control
    case format
    case surrogate
    case privateUse
    case unassigned
    public static func == (a: Swift.Unicode.GeneralCategory, b: Swift.Unicode.GeneralCategory) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
extension Unicode.Scalar.Properties {
  public var generalCategory: Unicode.GeneralCategory {
    get
  }
}
extension Unicode.Scalar.Properties {
  public var name: String? {
    get
  }
  public var nameAlias: String? {
    get
  }
}
extension Unicode {
  public struct CanonicalCombiningClass : Comparable, Hashable, RawRepresentable {
    public static let notReordered: Swift.Unicode.CanonicalCombiningClass
    public static let overlay: Swift.Unicode.CanonicalCombiningClass
    public static let nukta: Swift.Unicode.CanonicalCombiningClass
    public static let kanaVoicing: Swift.Unicode.CanonicalCombiningClass
    public static let virama: Swift.Unicode.CanonicalCombiningClass
    public static let attachedBelowLeft: Swift.Unicode.CanonicalCombiningClass
    public static let attachedBelow: Swift.Unicode.CanonicalCombiningClass
    public static let attachedAbove: Swift.Unicode.CanonicalCombiningClass
    public static let attachedAboveRight: Swift.Unicode.CanonicalCombiningClass
    public static let belowLeft: Swift.Unicode.CanonicalCombiningClass
    public static let below: Swift.Unicode.CanonicalCombiningClass
    public static let belowRight: Swift.Unicode.CanonicalCombiningClass
    public static let left: Swift.Unicode.CanonicalCombiningClass
    public static let right: Swift.Unicode.CanonicalCombiningClass
    public static let aboveLeft: Swift.Unicode.CanonicalCombiningClass
    public static let above: Swift.Unicode.CanonicalCombiningClass
    public static let aboveRight: Swift.Unicode.CanonicalCombiningClass
    public static let doubleBelow: Swift.Unicode.CanonicalCombiningClass
    public static let doubleAbove: Swift.Unicode.CanonicalCombiningClass
    public static let iotaSubscript: Swift.Unicode.CanonicalCombiningClass
    public let rawValue: UInt8
    public init(rawValue: UInt8)
    public static func == (lhs: CanonicalCombiningClass, rhs: CanonicalCombiningClass) -> Bool
    public static func < (lhs: CanonicalCombiningClass, rhs: CanonicalCombiningClass) -> Bool
    public var hashValue: Int {
      get
    }
    public func hash(into hasher: inout Hasher)
    public typealias RawValue = Swift.UInt8
  }
}
extension Unicode.Scalar.Properties {
  public var canonicalCombiningClass: Unicode.CanonicalCombiningClass {
    get
  }
}
extension Unicode {
  public enum NumericType {
    case decimal
    case digit
    case numeric
    public static func == (a: Swift.Unicode.NumericType, b: Swift.Unicode.NumericType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
extension Unicode.Scalar.Properties {
  public var numericType: Unicode.NumericType? {
    get
  }
  public var numericValue: Double? {
    get
  }
}
extension Character {
  @inlinable internal var _firstScalar: Unicode.Scalar {
    get {
    return self.unicodeScalars.first!
  }
  }
  @inlinable internal var _isSingleScalar: Bool {
    get {
    return self.unicodeScalars.index(
      after: self.unicodeScalars.startIndex
    ) == self.unicodeScalars.endIndex
  }
  }
  @inlinable public var isASCII: Bool {
    get {
    return asciiValue != nil
  }
  }
  @inlinable public var asciiValue: UInt8? {
    get {
    if _slowPath(self == "\r\n") { return 0x000A /* LINE FEED (LF) */ }
    if _slowPath(!_isSingleScalar || _firstScalar.value >= 0x80) { return nil }
    return UInt8(_firstScalar.value)
  }
  }
  public var isWhitespace: Bool {
    get
  }
  @inlinable public var isNewline: Bool {
    get {
    switch _firstScalar.value {
      case 0x000A...0x000D /* LF ... CR */: return true
      case 0x0085 /* NEXT LINE (NEL) */: return true
      case 0x2028 /* LINE SEPARATOR */: return true
      case 0x2029 /* PARAGRAPH SEPARATOR */: return true
      default: return false
    }
  }
  }
  public var isNumber: Bool {
    get
  }
  @inlinable public var isWholeNumber: Bool {
    get {
    return wholeNumberValue != nil
  }
  }
  public var wholeNumberValue: Int? {
    get
  }
  @inlinable public var isHexDigit: Bool {
    get {
    return hexDigitValue != nil
  }
  }
  public var hexDigitValue: Int? {
    get
  }
  public var isLetter: Bool {
    get
  }
  public func uppercased() -> String
  public func lowercased() -> String
  @usableFromInline
  internal var _isUppercased: Bool {
    get
  }
  @usableFromInline
  internal var _isLowercased: Bool {
    get
  }
  @inlinable public var isUppercase: Bool {
    get {
    if _fastPath(_isSingleScalar && _firstScalar.properties.isUppercase) {
      return true
    }
    return _isUppercased && isCased
  }
  }
  @inlinable public var isLowercase: Bool {
    get {
    if _fastPath(_isSingleScalar && _firstScalar.properties.isLowercase) {
      return true
    }
    return _isLowercased && isCased
  }
  }
  @inlinable public var isCased: Bool {
    get {
    if _fastPath(_isSingleScalar && _firstScalar.properties.isCased) {
      return true
    }
    return !_isUppercased || !_isLowercased
  }
  }
  public var isSymbol: Bool {
    get
  }
  public var isMathSymbol: Bool {
    get
  }
  public var isCurrencySymbol: Bool {
    get
  }
  public var isPunctuation: Bool {
    get
  }
}
@_fixed_layout public struct Unmanaged<Instance> where Instance : AnyObject {
  @usableFromInline
  unowned(unsafe) internal var _value: Instance
  @usableFromInline
  @_transparent internal init(_private: Instance) { _value = _private }
  @_transparent public static func fromOpaque(_ value: UnsafeRawPointer) -> Unmanaged {
    return Unmanaged(_private: unsafeBitCast(value, to: Instance.self))
  }
  @_transparent public func toOpaque() -> UnsafeMutableRawPointer {
    return unsafeBitCast(_value, to: UnsafeMutableRawPointer.self)
  }
  @_transparent public static func passRetained(_ value: Instance) -> Unmanaged {
    return Unmanaged(_private: value).retain()
  }
  @_transparent public static func passUnretained(_ value: Instance) -> Unmanaged {
    return Unmanaged(_private: value)
  }
  @inlinable public func takeUnretainedValue() -> Instance {
    return _value
  }
  @inlinable public func takeRetainedValue() -> Instance {
    let result = _value
    release()
    return result
  }
  @inlinable public func _withUnsafeGuaranteedRef<Result>(_ body: (Instance) throws -> Result) rethrows -> Result {
    let (guaranteedInstance, token) = Builtin.unsafeGuaranteed(_value)
    let result = try body(guaranteedInstance)
    Builtin.unsafeGuaranteedEnd(token)
    return result
  }
  @_transparent public func retain() -> Unmanaged {
    Builtin.retain(_value)
    return self
  }
  @_transparent public func release() {
    Builtin.release(_value)
  }
  @_transparent public func autorelease() -> Unmanaged {
    Builtin.autorelease(_value)
    return self
  }
}
@_fixed_layout public struct UnsafeMutableBufferPointer<Element> {
  @usableFromInline
  internal let _position: UnsafeMutablePointer<Element>?
  public let count: Int
}
extension UnsafeMutableBufferPointer {
  public typealias Iterator = UnsafeBufferPointer<Element>.Iterator
}
extension UnsafeMutableBufferPointer : Sequence {
  @inlinable public func makeIterator() -> Iterator {
    guard let start = _position else {
      return Iterator(_position: nil, _end: nil)
    }
    return Iterator(_position: start, _end: start + count)
  }
  @inlinable public func _copyContents(initializing destination: UnsafeMutableBufferPointer<Element>) -> (Iterator, UnsafeMutableBufferPointer<Element>.Index) {
    guard !isEmpty && !destination.isEmpty else { return (makeIterator(), 0) }
    let s = self.baseAddress._unsafelyUnwrappedUnchecked
    let d = destination.baseAddress._unsafelyUnwrappedUnchecked
    let n = Swift.min(destination.count, self.count)
    d.initialize(from: s, count: n)
    return (Iterator(_position: s + n, _end: s + count), n)
  }
}
extension UnsafeMutableBufferPointer : MutableCollection, RandomAccessCollection {
  public typealias Index = Int
  public typealias Indices = Range<Int>
  @inlinable public var startIndex: Int {
    get { return 0 }
  }
  @inlinable public var endIndex: Int {
    get { return count }
  }
  @inlinable public func index(after i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + 1
  }
  @inlinable public func formIndex(after i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i += 1
  }
  @inlinable public func index(before i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i - 1
  }
  @inlinable public func formIndex(before i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i -= 1
  }
  @inlinable public func index(_ i: Int, offsetBy n: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + n
  }
  @inlinable public func index(_ i: Int, offsetBy n: Int, limitedBy limit: Int) -> Int? {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    let l = limit - i
    if n > 0 ? l >= 0 && l < n : l <= 0 && n < l {
      return nil
    }
    return i + n
  }
  @inlinable public func distance(from start: Int, to end: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return end - start
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Int, bounds: Range<Int>) {
    // NOTE: In release mode, this method is a no-op for performance reasons.
    _debugPrecondition(index >= bounds.lowerBound)
    _debugPrecondition(index < bounds.upperBound)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Range<Int>, bounds: Range<Int>) {
    // NOTE: In release mode, this method is a no-op for performance reasons.
    _debugPrecondition(range.lowerBound >= bounds.lowerBound)
    _debugPrecondition(range.upperBound <= bounds.upperBound)
  }
  @inlinable public var indices: Indices {
    get {
    return startIndex..<endIndex
  }
  }
  @inlinable public subscript(i: Int) -> Element {
    get {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked[i]
    }
    nonmutating _modify {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      yield &_position._unsafelyUnwrappedUnchecked[i]
    }
  }
  @inlinable internal subscript(_unchecked i: Int) -> Element {
    get {
      _internalInvariant(i >= 0)
      _internalInvariant(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked[i]
    }
    nonmutating _modify {
      _internalInvariant(i >= 0)
      _internalInvariant(i < endIndex)
      yield &_position._unsafelyUnwrappedUnchecked[i]
    }
  }
  @inlinable public subscript(bounds: Range<Int>) -> Slice<UnsafeMutableBufferPointer<Element>> {
    get {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      return Slice(
        base: self, bounds: bounds)
    }
    nonmutating set {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      _debugPrecondition(bounds.count == newValue.count)

      // FIXME: swift-3-indexing-model: tests.
      if !newValue.isEmpty {
        (_position! + bounds.lowerBound).assign(
          from: newValue.base._position! + newValue.startIndex,
          count: newValue.count)
      }
    }
  }
  @inlinable public func swapAt(_ i: Int, _ j: Int) {
    guard i != j else { return }
    _debugPrecondition(i >= 0 && j >= 0)
    _debugPrecondition(i < endIndex && j < endIndex)
    let pi = (_position! + i)
    let pj = (_position! + j)
    let tmp = pi.move()
    pi.moveInitialize(from: pj, count: 1)
    pj.initialize(to: tmp)
  }
  public typealias SubSequence = Swift.Slice<Swift.UnsafeMutableBufferPointer<Element>>
}
extension UnsafeMutableBufferPointer {
  @inlinable public init(start: UnsafeMutablePointer<Element>?, count: Int) {
    _precondition(
      count >= 0, "UnsafeMutableBufferPointer with negative count")
    _precondition(
      count == 0 || start != nil,
      "UnsafeMutableBufferPointer has a nil start and nonzero count")
    _position = start
    self.count = count
  }
  @inlinable public init(_empty: ()) {
    _position = nil
    count = 0
  }
  @inlinable public init(mutating other: UnsafeBufferPointer<Element>) {
    _position = UnsafeMutablePointer<Element>(mutating: other._position)
    count = other.count
  }
  @inlinable mutating public func _withUnsafeMutableBufferPointerIfSupported<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try body(&self)
  }
  @inlinable mutating public func withContiguousMutableStorageIfAvailable<R>(_ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R? {
    let (oldBase, oldCount) = (self.baseAddress, self.count)
    defer { 
      _debugPrecondition((oldBase, oldCount) == (self.baseAddress, self.count),
      "UnsafeMutableBufferPointer.withUnsafeMutableBufferPointer: replacing the buffer is not allowed")
    } 
    return try body(&self)
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try body(UnsafeBufferPointer(self))
  }
  @inlinable public init(rebasing slice: Slice<UnsafeMutableBufferPointer<Element>>) {
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    self.init(start: base, count: slice.count)
  }
  @inlinable public func deallocate() {
    _position?.deallocate()
  }
  @inlinable public static func allocate(capacity count: Int) -> UnsafeMutableBufferPointer<Element> {
    let size = MemoryLayout<Element>.stride * count
    // For any alignment <= _minAllocationAlignment, force alignment = 0.
    // This forces the runtime's "aligned" allocation path so that
    // deallocation does not require the original alignment.
    //
    // The runtime guarantees:
    //
    // align == 0 || align > _minAllocationAlignment:
    //   Runtime uses "aligned allocation".
    //
    // 0 < align <= _minAllocationAlignment:
    //   Runtime may use either malloc or "aligned allocation".
    var align = Builtin.alignof(Element.self)
    if Int(align) <= _minAllocationAlignment() {
      align = (0)._builtinWordValue
    }
    let raw  = Builtin.allocRaw(size._builtinWordValue, align)
    Builtin.bindMemory(raw, count._builtinWordValue, Element.self)
    return UnsafeMutableBufferPointer(
      start: UnsafeMutablePointer(raw), count: count)
  }
  @inlinable public func initialize(repeating repeatedValue: Element) {
    guard let dstBase = _position else {
      return
    }

    dstBase.initialize(repeating: repeatedValue, count: count)
  }
  @inlinable public func assign(repeating repeatedValue: Element) {
    guard let dstBase = _position else {
      return
    }

    dstBase.assign(repeating: repeatedValue, count: count)
  }
  @inlinable public func withMemoryRebound<T, Result>(to type: T.Type, _ body: (UnsafeMutableBufferPointer<T>) throws -> Result) rethrows -> Result {
    if let base = _position {
      _debugPrecondition(MemoryLayout<Element>.stride == MemoryLayout<T>.stride)
      Builtin.bindMemory(base._rawValue, count._builtinWordValue, T.self)
      defer {
        Builtin.bindMemory(base._rawValue, count._builtinWordValue, Element.self)
      }

      return try body(UnsafeMutableBufferPointer<T>(
        start: UnsafeMutablePointer<T>(base._rawValue), count: count))
    }
    else {
      return try body(UnsafeMutableBufferPointer<T>(start: nil, count: 0))
    }
  }
  @inlinable public var baseAddress: UnsafeMutablePointer<Element>? {
    get {
    return _position
  }
  }
}
extension UnsafeMutableBufferPointer : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
@_fixed_layout public struct UnsafeBufferPointer<Element> {
  @usableFromInline
  internal let _position: UnsafePointer<Element>?
  public let count: Int
}
extension UnsafeBufferPointer {
  @_fixed_layout public struct Iterator {
    @usableFromInline
    internal var _position: UnsafePointer<Element>?, _end: UnsafePointer<Element>?
    @inlinable public init(_position: UnsafePointer<Element>?, _end: UnsafePointer<Element>?) {
        self._position = _position
        self._end = _end
    }
  }
}
extension UnsafeBufferPointer.Iterator : IteratorProtocol {
  @inlinable mutating public func next() -> Element? {
    guard let start = _position else {
      return nil
    }
    _internalInvariant(_end != nil, "inconsistent _position, _end pointers")

    if start == _end._unsafelyUnwrappedUnchecked { return nil }

    let result = start.pointee
    _position  = start + 1
    return result
  }
}
extension UnsafeBufferPointer : Sequence {
  @inlinable public func makeIterator() -> Iterator {
    guard let start = _position else {
      return Iterator(_position: nil, _end: nil)
    }
    return Iterator(_position: start, _end: start + count)
  }
  @inlinable public func _copyContents(initializing destination: UnsafeMutableBufferPointer<Element>) -> (Iterator, UnsafeMutableBufferPointer<Element>.Index) {
    guard !isEmpty && !destination.isEmpty else { return (makeIterator(), 0) }
    let s = self.baseAddress._unsafelyUnwrappedUnchecked
    let d = destination.baseAddress._unsafelyUnwrappedUnchecked
    let n = Swift.min(destination.count, self.count)
    d.initialize(from: s, count: n)
    return (Iterator(_position: s + n, _end: s + count), n)
  }
}
extension UnsafeBufferPointer : Collection, RandomAccessCollection {
  public typealias Index = Int
  public typealias Indices = Range<Int>
  @inlinable public var startIndex: Int {
    get { return 0 }
  }
  @inlinable public var endIndex: Int {
    get { return count }
  }
  @inlinable public func index(after i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + 1
  }
  @inlinable public func formIndex(after i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i += 1
  }
  @inlinable public func index(before i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i - 1
  }
  @inlinable public func formIndex(before i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i -= 1
  }
  @inlinable public func index(_ i: Int, offsetBy n: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + n
  }
  @inlinable public func index(_ i: Int, offsetBy n: Int, limitedBy limit: Int) -> Int? {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    let l = limit - i
    if n > 0 ? l >= 0 && l < n : l <= 0 && n < l {
      return nil
    }
    return i + n
  }
  @inlinable public func distance(from start: Int, to end: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for UnsafeBufferPointer performance. The
    // optimizer is not capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return end - start
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Int, bounds: Range<Int>) {
    // NOTE: In release mode, this method is a no-op for performance reasons.
    _debugPrecondition(index >= bounds.lowerBound)
    _debugPrecondition(index < bounds.upperBound)
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Range<Int>, bounds: Range<Int>) {
    // NOTE: In release mode, this method is a no-op for performance reasons.
    _debugPrecondition(range.lowerBound >= bounds.lowerBound)
    _debugPrecondition(range.upperBound <= bounds.upperBound)
  }
  @inlinable public var indices: Indices {
    get {
    return startIndex..<endIndex
  }
  }
  @inlinable public subscript(i: Int) -> Element {
    get {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked[i]
    }
  }
  @inlinable internal subscript(_unchecked i: Int) -> Element {
    get {
      _internalInvariant(i >= 0)
      _internalInvariant(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked[i]
    }
  }
  @inlinable public subscript(bounds: Range<Int>) -> Slice<UnsafeBufferPointer<Element>> {
    get {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      return Slice(
        base: self, bounds: bounds)
    }
  }
  public typealias SubSequence = Swift.Slice<Swift.UnsafeBufferPointer<Element>>
}
extension UnsafeBufferPointer {
  @inlinable public init(start: UnsafePointer<Element>?, count: Int) {
    _precondition(
      count >= 0, "UnsafeBufferPointer with negative count")
    _precondition(
      count == 0 || start != nil,
      "UnsafeBufferPointer has a nil start and nonzero count")
    _position = start
    self.count = count
  }
  @inlinable public init(_empty: ()) {
    _position = nil
    count = 0
  }
  @inlinable public init(_ other: UnsafeMutableBufferPointer<Element>) {
    _position = UnsafePointer<Element>(other._position)
    count = other.count
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    return try body(self)
  }
  @inlinable public init(rebasing slice: Slice<UnsafeBufferPointer<Element>>) {
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    self.init(start: base, count: slice.count)
  }
  @inlinable public init(rebasing slice: Slice<UnsafeMutableBufferPointer<Element>>) {
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    self.init(start: base, count: slice.count)
  }
  @inlinable public func deallocate() {
    _position?.deallocate()
  }
  @inlinable public func withMemoryRebound<T, Result>(to type: T.Type, _ body: (UnsafeBufferPointer<T>) throws -> Result) rethrows -> Result {
    if let base = _position {
      _debugPrecondition(MemoryLayout<Element>.stride == MemoryLayout<T>.stride)
      Builtin.bindMemory(base._rawValue, count._builtinWordValue, T.self)
      defer {
        Builtin.bindMemory(base._rawValue, count._builtinWordValue, Element.self)
      }

      return try body(UnsafeBufferPointer<T>(
        start: UnsafePointer<T>(base._rawValue), count: count))
    }
    else {
      return try body(UnsafeBufferPointer<T>(start: nil, count: 0))
    }
  }
  @inlinable public var baseAddress: UnsafePointer<Element>? {
    get {
    return _position
  }
  }
}
extension UnsafeBufferPointer : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension UnsafeMutableBufferPointer {
  @inlinable public func initialize<S>(from source: S) -> (S.Iterator, Index) where Element == S.Element, S : Swift.Sequence {
    return source._copyContents(initializing: self)
  }
}
@_fixed_layout public struct UnsafeMutableRawBufferPointer {
  @usableFromInline
  internal let _position: UnsafeMutableRawPointer?, _end: UnsafeMutableRawPointer?
}
extension UnsafeMutableRawBufferPointer {
  public typealias Iterator = UnsafeRawBufferPointer.Iterator
}
extension UnsafeMutableRawBufferPointer : Sequence {
  public typealias SubSequence = Slice<UnsafeMutableRawBufferPointer>
  @inlinable public func makeIterator() -> Iterator {
    return Iterator(_position: _position, _end: _end)
  }
}
extension UnsafeMutableRawBufferPointer : MutableCollection {
  public typealias Element = UInt8
  public typealias Index = Int
  public typealias Indices = Range<Int>
  @inlinable public var startIndex: Index {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return count
  }
  }
  @inlinable public var indices: Indices {
    get {
    return startIndex..<endIndex
  }
  }
  @inlinable public subscript(i: Int) -> Element {
    get {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked.load(fromByteOffset: i, as: UInt8.self)
    }
    nonmutating set {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      _position._unsafelyUnwrappedUnchecked.storeBytes(of: newValue, toByteOffset: i, as: UInt8.self)
    }
  }
  @inlinable public subscript(bounds: Range<Int>) -> SubSequence {
    get {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      return Slice(base: self, bounds: bounds)
    }
    nonmutating set {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      _debugPrecondition(bounds.count == newValue.count)

      if !newValue.isEmpty {
        (baseAddress! + bounds.lowerBound).copyMemory(
          from: newValue.base.baseAddress! + newValue.startIndex,
          byteCount: newValue.count)
      }
    }
  }
  @inlinable public func swapAt(_ i: Int, _ j: Int) {
    guard i != j else { return }
    _debugPrecondition(i >= 0 && j >= 0)
    _debugPrecondition(i < endIndex && j < endIndex)
    let pi = (_position! + i)
    let pj = (_position! + j)
    let tmp = pi.load(fromByteOffset: 0, as: UInt8.self)
    pi.copyMemory(from: pj, byteCount: MemoryLayout<UInt8>.size)
    pj.storeBytes(of: tmp, toByteOffset: 0, as: UInt8.self)
  }
  @inlinable public var count: Int {
    get {
    if let pos = _position {
      return _end! - pos
    }
    return 0
  }
  }
}
extension UnsafeMutableRawBufferPointer : RandomAccessCollection {
}
extension UnsafeMutableRawBufferPointer {
  @inlinable public static func allocate(byteCount: Int, alignment: Int) -> UnsafeMutableRawBufferPointer {
    let base = UnsafeMutableRawPointer.allocate(
      byteCount: byteCount, alignment: alignment)
    return UnsafeMutableRawBufferPointer(start: base, count: byteCount)
  }
  @inlinable public func deallocate() {
    _position?.deallocate()
  }
  @inlinable public func load<T>(fromByteOffset offset: Int = 0, as type: T.Type) -> T {
    _debugPrecondition(offset >= 0, "UnsafeMutableRawBufferPointer.load with negative offset")
    _debugPrecondition(offset + MemoryLayout<T>.size <= self.count,
      "UnsafeMutableRawBufferPointer.load out of bounds")
    return baseAddress!.load(fromByteOffset: offset, as: T.self)
  }
  @inlinable public func storeBytes<T>(of value: T, toByteOffset offset: Int = 0, as: T.Type) {
    _debugPrecondition(offset >= 0, "UnsafeMutableRawBufferPointer.storeBytes with negative offset")
    _debugPrecondition(offset + MemoryLayout<T>.size <= self.count,
      "UnsafeMutableRawBufferPointer.storeBytes out of bounds")

    baseAddress!.storeBytes(of: value, toByteOffset: offset, as: T.self)
  }
  @inlinable public func copyMemory(from source: UnsafeRawBufferPointer) {
    _debugPrecondition(source.count <= self.count,
      "UnsafeMutableRawBufferPointer.copyMemory source has too many elements")
    baseAddress?.copyMemory(from: source.baseAddress!, byteCount: source.count)
  }
  @inlinable public func copyBytes<C>(from source: C) where C : Swift.Collection, C.Element == Swift.UInt8 {
    _debugPrecondition(source.count <= self.count,
      "UnsafeMutableRawBufferPointer.copyBytes source has too many elements")
    guard let position = _position else {
      return
    }
    for (index, byteValue) in source.enumerated() {
      position.storeBytes(
        of: byteValue, toByteOffset: index, as: UInt8.self)
    }
  }
  @inlinable public init(start: UnsafeMutableRawPointer?, count: Int) {
    _precondition(count >= 0, "UnsafeMutableRawBufferPointer with negative count")
    _precondition(count == 0 || start != nil,
      "UnsafeMutableRawBufferPointer has a nil start and nonzero count")
    _position = start
    _end = start.map { $0 + count }
  }
  @inlinable public init(_ bytes: UnsafeMutableRawBufferPointer) {
    self.init(start: bytes.baseAddress, count: bytes.count)
  }
  @inlinable public init(mutating bytes: UnsafeRawBufferPointer) {
    self.init(start: UnsafeMutableRawPointer(mutating: bytes.baseAddress),
      count: bytes.count)
  }
  @inlinable public init<T>(_ buffer: UnsafeMutableBufferPointer<T>) {
    self.init(start: buffer.baseAddress,
      count: buffer.count * MemoryLayout<T>.stride)
  }
  @inlinable public init(rebasing slice: Slice<UnsafeMutableRawBufferPointer>) {
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    self.init(start: base, count: slice.count)
  }
  @inlinable public var baseAddress: UnsafeMutableRawPointer? {
    get {
    return _position
  }
  }
  @discardableResult
  @inlinable public func initializeMemory<T>(as type: T.Type, repeating repeatedValue: T) -> UnsafeMutableBufferPointer<T> {
    guard let base = _position else {
      return UnsafeMutableBufferPointer<T>(start: nil, count: 0)
    }
    
    let count = (_end! - base) / MemoryLayout<T>.stride
    let typed = base.initializeMemory(
      as: type, repeating: repeatedValue, count: count)
    return UnsafeMutableBufferPointer<T>(start: typed, count: count)
  }
  @inlinable public func initializeMemory<S>(as type: S.Element.Type, from source: S) -> (unwritten: S.Iterator, initialized: UnsafeMutableBufferPointer<S.Element>) where S : Swift.Sequence {
    // TODO: Optimize where `C` is a `ContiguousArrayBuffer`.

    var it = source.makeIterator()
    var idx = startIndex
    let elementStride = MemoryLayout<S.Element>.stride
    
    // This has to be a debug precondition due to the cost of walking over some collections.
    _debugPrecondition(source.underestimatedCount <= (count / elementStride),
      "insufficient space to accommodate source.underestimatedCount elements")
    guard let base = baseAddress else {
      // this can be a precondition since only an invalid argument should be costly
      _precondition(source.underestimatedCount == 0, 
        "no memory available to initialize from source")
      return (it, UnsafeMutableBufferPointer(start: nil, count: 0))
    }  

    for p in stride(from: base, 
      // only advance to as far as the last element that will fit
      to: base + count - elementStride + 1, 
      by: elementStride
    ) {
      // underflow is permitted -- e.g. a sequence into
      // the spare capacity of an Array buffer
      guard let x = it.next() else { break }
      p.initializeMemory(as: S.Element.self, repeating: x, count: 1)
      formIndex(&idx, offsetBy: elementStride)
    }

    return (it, UnsafeMutableBufferPointer(
                  start: base.assumingMemoryBound(to: S.Element.self), 
                  count: idx / elementStride))
  }
  @discardableResult
  @_transparent public func bindMemory<T>(to type: T.Type) -> UnsafeMutableBufferPointer<T> {
    guard let base = _position else {
      return UnsafeMutableBufferPointer<T>(start: nil, count: 0)
    }

    let capacity = count / MemoryLayout<T>.stride
    Builtin.bindMemory(base._rawValue, capacity._builtinWordValue, type)
    return UnsafeMutableBufferPointer<T>(
      start: UnsafeMutablePointer<T>(base._rawValue), count: capacity)
  }
}
extension UnsafeMutableRawBufferPointer : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension UnsafeMutableRawBufferPointer {
  @available(*, unavailable, message: "use 'UnsafeMutableRawBufferPointer(rebasing:)' to convert a slice into a zero-based raw buffer.")
  public subscript(bounds: Range<Int>) -> UnsafeMutableRawBufferPointer {
    get
    nonmutating set
  }
  @available(*, unavailable, message: "use 'UnsafeRawBufferPointer(rebasing:)' to convert a slice into a zero-based raw buffer.")
  public subscript(bounds: Range<Int>) -> UnsafeRawBufferPointer {
    get
    nonmutating set
  }
}
@_fixed_layout public struct UnsafeRawBufferPointer {
  @usableFromInline
  internal let _position: UnsafeRawPointer?, _end: UnsafeRawPointer?
}
extension UnsafeRawBufferPointer {
  @_fixed_layout public struct Iterator {
    @usableFromInline
    internal var _position: UnsafeRawPointer?, _end: UnsafeRawPointer?
    @inlinable internal init(_position: UnsafeRawPointer?, _end: UnsafeRawPointer?) {
      self._position = _position
      self._end = _end
    }
  }
}
extension UnsafeRawBufferPointer.Iterator : IteratorProtocol, Sequence {
  @inlinable mutating public func next() -> UInt8? {
    if _position == _end { return nil }

    let result = _position!.load(as: UInt8.self)
    _position! += 1
    return result
  }
  public typealias Element = Swift.UInt8
  public typealias Iterator = Swift.UnsafeRawBufferPointer.Iterator
}
extension UnsafeRawBufferPointer : Sequence {
  public typealias SubSequence = Slice<UnsafeRawBufferPointer>
  @inlinable public func makeIterator() -> Iterator {
    return Iterator(_position: _position, _end: _end)
  }
}
extension UnsafeRawBufferPointer : Collection {
  public typealias Element = UInt8
  public typealias Index = Int
  public typealias Indices = Range<Int>
  @inlinable public var startIndex: Index {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return count
  }
  }
  @inlinable public var indices: Indices {
    get {
    return startIndex..<endIndex
  }
  }
  @inlinable public subscript(i: Int) -> Element {
    get {
      _debugPrecondition(i >= 0)
      _debugPrecondition(i < endIndex)
      return _position._unsafelyUnwrappedUnchecked.load(fromByteOffset: i, as: UInt8.self)
    }
  }
  @inlinable public subscript(bounds: Range<Int>) -> SubSequence {
    get {
      _debugPrecondition(bounds.lowerBound >= startIndex)
      _debugPrecondition(bounds.upperBound <= endIndex)
      return Slice(base: self, bounds: bounds)
    }
  }
  @inlinable public var count: Int {
    get {
    if let pos = _position {
      return _end! - pos
    }
    return 0
  }
  }
}
extension UnsafeRawBufferPointer : RandomAccessCollection {
}
extension UnsafeRawBufferPointer {
  @inlinable public func deallocate() {
    _position?.deallocate()
  }
  @inlinable public func load<T>(fromByteOffset offset: Int = 0, as type: T.Type) -> T {
    _debugPrecondition(offset >= 0, "UnsafeRawBufferPointer.load with negative offset")
    _debugPrecondition(offset + MemoryLayout<T>.size <= self.count,
      "UnsafeRawBufferPointer.load out of bounds")
    return baseAddress!.load(fromByteOffset: offset, as: T.self)
  }
  @inlinable public init(start: UnsafeRawPointer?, count: Int) {
    _precondition(count >= 0, "UnsafeRawBufferPointer with negative count")
    _precondition(count == 0 || start != nil,
      "UnsafeRawBufferPointer has a nil start and nonzero count")
    _position = start
    _end = start.map { $0 + count }
  }
  @inlinable public init(_ bytes: UnsafeMutableRawBufferPointer) {
    self.init(start: bytes.baseAddress, count: bytes.count)
  }
  @inlinable public init(_ bytes: UnsafeRawBufferPointer) {
    self.init(start: bytes.baseAddress, count: bytes.count)
  }
  @inlinable public init<T>(_ buffer: UnsafeMutableBufferPointer<T>) {
    self.init(start: buffer.baseAddress,
      count: buffer.count * MemoryLayout<T>.stride)
  }
  @inlinable public init<T>(_ buffer: UnsafeBufferPointer<T>) {
    self.init(start: buffer.baseAddress,
      count: buffer.count * MemoryLayout<T>.stride)
  }
  @inlinable public init(rebasing slice: Slice<UnsafeRawBufferPointer>) {
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    self.init(start: base, count: slice.count)
  }
  @inlinable public init(rebasing slice: Slice<UnsafeMutableRawBufferPointer>) {
    let base = slice.base.baseAddress?.advanced(by: slice.startIndex)
    self.init(start: base, count: slice.count)
  }
  @inlinable public var baseAddress: UnsafeRawPointer? {
    get {
    return _position
  }
  }
  @discardableResult
  @_transparent public func bindMemory<T>(to type: T.Type) -> UnsafeBufferPointer<T> {
    guard let base = _position else {
      return UnsafeBufferPointer<T>(start: nil, count: 0)
    }

    let capacity = count / MemoryLayout<T>.stride
    Builtin.bindMemory(base._rawValue, capacity._builtinWordValue, type)
    return UnsafeBufferPointer<T>(
      start: UnsafePointer<T>(base._rawValue), count: capacity)
  }
}
extension UnsafeRawBufferPointer : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension UnsafeRawBufferPointer {
  @available(*, unavailable, message: "use 'UnsafeRawBufferPointer(rebasing:)' to convert a slice into a zero-based raw buffer.")
  public subscript(bounds: Range<Int>) -> UnsafeRawBufferPointer {
    get
  }
}
@inlinable public func withUnsafeMutableBytes<T, Result>(of value: inout T, _ body: (UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
  return try withUnsafeMutablePointer(to: &value) {
    return try body(UnsafeMutableRawBufferPointer(
        start: $0, count: MemoryLayout<T>.size))
  }
}
@inlinable public func withUnsafeBytes<T, Result>(of value: inout T, _ body: (UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
  return try withUnsafePointer(to: &value) {
    try body(UnsafeRawBufferPointer(start: $0, count: MemoryLayout<T>.size))
  }
}
@inlinable public func withUnsafeBytes<T, Result>(of value: T, _ body: (UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
  let addr = UnsafeRawPointer(Builtin.addressOfBorrow(value))
  let buffer = UnsafeRawBufferPointer(start: addr, count: MemoryLayout<T>.size)
  return try body(buffer)
}
@_fixed_layout public struct UnsafePointer<Pointee> : _Pointer {
  public typealias Distance = Int
  public let _rawValue: Builtin.RawPointer
  @_transparent public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
  @inlinable public func deallocate() {
    // Passing zero alignment to the runtime forces "aligned
    // deallocation". Since allocation via `UnsafeMutable[Raw][Buffer]Pointer`
    // always uses the "aligned allocation" path, this ensures that the
    // runtime's allocation and deallocation paths are compatible.
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (0)._builtinWordValue)
  }
  @inlinable public var pointee: Pointee {
    @_transparent unsafeAddress {
      return self
    }
  }
  @inlinable public func withMemoryRebound<T, Result>(to type: T.Type, capacity count: Int, _ body: (UnsafePointer<T>) throws -> Result) rethrows -> Result {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer {
      Builtin.bindMemory(_rawValue, count._builtinWordValue, Pointee.self)
    }
    return try body(UnsafePointer<T>(_rawValue))
  }
  @inlinable public subscript(i: Int) -> Pointee {
    @_transparent unsafeAddress {
      return self + i
    }
  }
  @inlinable internal static var _max: UnsafePointer {
    get {
    return UnsafePointer(
      bitPattern: 0 as Int &- MemoryLayout<Pointee>.stride
    )._unsafelyUnwrappedUnchecked
  }
  }
  public typealias Stride = Swift.Int
  public var hashValue: Swift.Int {
    get
  }
}
@_fixed_layout public struct UnsafeMutablePointer<Pointee> : _Pointer {
  public typealias Distance = Int
  public let _rawValue: Builtin.RawPointer
  @_transparent public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
  @_transparent public init(mutating other: UnsafePointer<Pointee>) {
    self._rawValue = other._rawValue
  }
  @_transparent public init?(mutating other: UnsafePointer<Pointee>?) {
    guard let unwrapped = other else { return nil }
    self.init(mutating: unwrapped)
  }
  @_transparent public init(_ other: UnsafeMutablePointer<Pointee>) {		
   self._rawValue = other._rawValue		
  }
  @_transparent public init?(_ other: UnsafeMutablePointer<Pointee>?) {		
   guard let unwrapped = other else { return nil }		
   self.init(unwrapped)		
  }
  @inlinable public static func allocate(capacity count: Int) -> UnsafeMutablePointer<Pointee> {
    let size = MemoryLayout<Pointee>.stride * count
    // For any alignment <= _minAllocationAlignment, force alignment = 0.
    // This forces the runtime's "aligned" allocation path so that
    // deallocation does not require the original alignment.
    //
    // The runtime guarantees:
    //
    // align == 0 || align > _minAllocationAlignment:
    //   Runtime uses "aligned allocation".
    //
    // 0 < align <= _minAllocationAlignment:
    //   Runtime may use either malloc or "aligned allocation".
    var align = Builtin.alignof(Pointee.self)
    if Int(align) <= _minAllocationAlignment() {
      align = (0)._builtinWordValue
    }
    let rawPtr = Builtin.allocRaw(size._builtinWordValue, align)
    Builtin.bindMemory(rawPtr, count._builtinWordValue, Pointee.self)
    return UnsafeMutablePointer(rawPtr)
  }
  @inlinable public func deallocate() {
    // Passing zero alignment to the runtime forces "aligned
    // deallocation". Since allocation via `UnsafeMutable[Raw][Buffer]Pointer`
    // always uses the "aligned allocation" path, this ensures that the
    // runtime's allocation and deallocation paths are compatible.
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (0)._builtinWordValue)
  }
  @inlinable public var pointee: Pointee {
    @_transparent unsafeAddress {
      return UnsafePointer(self)
    }
    @_transparent nonmutating unsafeMutableAddress {
      return self
    }
  }
  @inlinable public func initialize(repeating repeatedValue: Pointee, count: Int) {
    // FIXME: add tests (since the `count` has been added)
    _debugPrecondition(count >= 0,
      "UnsafeMutablePointer.initialize(repeating:count:): negative count")
    // Must not use `initializeFrom` with a `Collection` as that will introduce
    // a cycle.
    for offset in 0..<count {
      Builtin.initialize(repeatedValue, (self + offset)._rawValue)
    }
  }
  @inlinable public func initialize(to value: Pointee) {
    Builtin.initialize(value, self._rawValue)
  }
  @inlinable public func move() -> Pointee {
    return Builtin.take(_rawValue)
  }
  @inlinable public func assign(repeating repeatedValue: Pointee, count: Int) {
    _debugPrecondition(count >= 0, "UnsafeMutablePointer.assign(repeating:count:) with negative count")
    for i in 0..<count {
      self[i] = repeatedValue
    }
  }
  @inlinable public func assign(from source: UnsafePointer<Pointee>, count: Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.assign with negative count")
    if UnsafePointer(self) < source || UnsafePointer(self) >= source + count {
      // assign forward from a disjoint or following overlapping range.
      Builtin.assignCopyArrayFrontToBack(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // for i in 0..<count {
      //   self[i] = source[i]
      // }
    }
    else if UnsafePointer(self) != source {
      // assign backward from a non-following overlapping range.
      Builtin.assignCopyArrayBackToFront(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // var i = count-1
      // while i >= 0 {
      //   self[i] = source[i]
      //   i -= 1
      // }
    }
  }
  @inlinable public func moveInitialize(from source: UnsafeMutablePointer, count: Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.moveInitialize with negative count")
    if self < source || self >= source + count {
      // initialize forward from a disjoint or following overlapping range.
      Builtin.takeArrayFrontToBack(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // for i in 0..<count {
      //   (self + i).initialize(to: (source + i).move())
      // }
    }
    else {
      // initialize backward from a non-following overlapping range.
      Builtin.takeArrayBackToFront(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // var src = source + count
      // var dst = self + count
      // while dst != self {
      //   (--dst).initialize(to: (--src).move())
      // }
    }
  }
  @inlinable public func initialize(from source: UnsafePointer<Pointee>, count: Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.initialize with negative count")
    _debugPrecondition(
      UnsafePointer(self) + count <= source ||
      source + count <= UnsafePointer(self),
      "UnsafeMutablePointer.initialize overlapping range")
    Builtin.copyArray(
      Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // This builtin is equivalent to:
    // for i in 0..<count {
    //   (self + i).initialize(to: source[i])
    // }
  }
  @inlinable public func moveAssign(from source: UnsafeMutablePointer, count: Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.moveAssign(from:) with negative count")
    _debugPrecondition(
      self + count <= source || source + count <= self,
      "moveAssign overlapping range")
    Builtin.assignTakeArray(
      Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // These builtins are equivalent to:
    // for i in 0..<count {
    //   self[i] = (source + i).move()
    // }
  }
  @discardableResult
  @inlinable public func deinitialize(count: Int) -> UnsafeMutableRawPointer {
    _debugPrecondition(count >= 0, "UnsafeMutablePointer.deinitialize with negative count")
    // FIXME: optimization should be implemented, where if the `count` value
    // is 1, the `Builtin.destroy(Pointee.self, _rawValue)` gets called.
    Builtin.destroyArray(Pointee.self, _rawValue, count._builtinWordValue)
    return UnsafeMutableRawPointer(self)
  }
  @inlinable public func withMemoryRebound<T, Result>(to type: T.Type, capacity count: Int, _ body: (UnsafeMutablePointer<T>) throws -> Result) rethrows -> Result {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer {
      Builtin.bindMemory(_rawValue, count._builtinWordValue, Pointee.self)
    }
    return try body(UnsafeMutablePointer<T>(_rawValue))
  }
  @inlinable public subscript(i: Int) -> Pointee {
    @_transparent unsafeAddress {
      return UnsafePointer(self + i)
    }
    @_transparent nonmutating unsafeMutableAddress {
      return self + i
    }
  }
  @inlinable internal static var _max: UnsafeMutablePointer {
    get {
    return UnsafeMutablePointer(
      bitPattern: 0 as Int &- MemoryLayout<Pointee>.stride
    )._unsafelyUnwrappedUnchecked
  }
  }
  public typealias Stride = Swift.Int
  public var hashValue: Swift.Int {
    get
  }
}
@_fixed_layout public struct UnsafeRawPointer : _Pointer {
  public typealias Pointee = UInt8
  public let _rawValue: Builtin.RawPointer
  @_transparent public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
  @_transparent public init<T>(_ other: UnsafePointer<T>) {
    _rawValue = other._rawValue
  }
  @_transparent public init?<T>(_ other: UnsafePointer<T>?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
  @_transparent public init(_ other: UnsafeMutableRawPointer) {
    _rawValue = other._rawValue
  }
  @_transparent public init?(_ other: UnsafeMutableRawPointer?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
  @_transparent public init<T>(_ other: UnsafeMutablePointer<T>) {		
   _rawValue = other._rawValue		
  }
  @_transparent public init?<T>(_ other: UnsafeMutablePointer<T>?) {		
   guard let unwrapped = other else { return nil }		
   _rawValue = unwrapped._rawValue		
  }
  @inlinable public func deallocate() {
    // Passing zero alignment to the runtime forces "aligned
    // deallocation". Since allocation via `UnsafeMutable[Raw][Buffer]Pointer`
    // always uses the "aligned allocation" path, this ensures that the
    // runtime's allocation and deallocation paths are compatible.
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (0)._builtinWordValue)
  }
  @discardableResult
  @_transparent public func bindMemory<T>(to type: T.Type, capacity count: Int) -> UnsafePointer<T> {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    return UnsafePointer<T>(_rawValue)
  }
  @_transparent public func assumingMemoryBound<T>(to: T.Type) -> UnsafePointer<T> {
    return UnsafePointer<T>(_rawValue)
  }
  @inlinable public func load<T>(fromByteOffset offset: Int = 0, as type: T.Type) -> T {
    _debugPrecondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "load from misaligned raw pointer")

    return Builtin.loadRaw((self + offset)._rawValue)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension UnsafeRawPointer : Strideable {
  @_transparent public func advanced(by n: Int) -> UnsafeRawPointer {
    return UnsafeRawPointer(Builtin.gepRaw_Word(_rawValue, n._builtinWordValue))
  }
  public typealias Stride = Swift.Int
}
@_fixed_layout public struct UnsafeMutableRawPointer : _Pointer {
  public typealias Pointee = UInt8
  public let _rawValue: Builtin.RawPointer
  @_transparent public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
  @_transparent public init<T>(_ other: UnsafeMutablePointer<T>) {
    _rawValue = other._rawValue
  }
  @_transparent public init?<T>(_ other: UnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
  @_transparent public init(mutating other: UnsafeRawPointer) {
    _rawValue = other._rawValue
  }
  @_transparent public init?(mutating other: UnsafeRawPointer?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
  @inlinable public static func allocate(byteCount: Int, alignment: Int) -> UnsafeMutableRawPointer {
    // For any alignment <= _minAllocationAlignment, force alignment = 0.
    // This forces the runtime's "aligned" allocation path so that
    // deallocation does not require the original alignment.
    //
    // The runtime guarantees:
    //
    // align == 0 || align > _minAllocationAlignment:
    //   Runtime uses "aligned allocation".
    //
    // 0 < align <= _minAllocationAlignment:
    //   Runtime may use either malloc or "aligned allocation".
    var alignment = alignment
    if alignment <= _minAllocationAlignment() {
      alignment = 0
    }
    return UnsafeMutableRawPointer(Builtin.allocRaw(
        byteCount._builtinWordValue, alignment._builtinWordValue))
  }
  @inlinable public func deallocate() {
    // Passing zero alignment to the runtime forces "aligned
    // deallocation". Since allocation via `UnsafeMutable[Raw][Buffer]Pointer`
    // always uses the "aligned allocation" path, this ensures that the
    // runtime's allocation and deallocation paths are compatible.
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (0)._builtinWordValue)
  }
  @discardableResult
  @_transparent public func bindMemory<T>(to type: T.Type, capacity count: Int) -> UnsafeMutablePointer<T> {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    return UnsafeMutablePointer<T>(_rawValue)
  }
  @_transparent public func assumingMemoryBound<T>(to: T.Type) -> UnsafeMutablePointer<T> {
    return UnsafeMutablePointer<T>(_rawValue)
  }
  @discardableResult
  @inlinable public func initializeMemory<T>(as type: T.Type, repeating repeatedValue: T, count: Int) -> UnsafeMutablePointer<T> {
    _debugPrecondition(count >= 0,
      "UnsafeMutableRawPointer.initializeMemory: negative count")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    var nextPtr = self
    for _ in 0..<count {
      Builtin.initialize(repeatedValue, nextPtr._rawValue)
      nextPtr += MemoryLayout<T>.stride
    }
    return UnsafeMutablePointer(_rawValue)
  }
  @discardableResult
  @inlinable public func initializeMemory<T>(as type: T.Type, from source: UnsafePointer<T>, count: Int) -> UnsafeMutablePointer<T> {
    _debugPrecondition(
      count >= 0,
      "UnsafeMutableRawPointer.initializeMemory with negative count")
    _debugPrecondition(
      (UnsafeRawPointer(self + count * MemoryLayout<T>.stride)
        <= UnsafeRawPointer(source))
      || UnsafeRawPointer(source + count) <= UnsafeRawPointer(self),
      "UnsafeMutableRawPointer.initializeMemory overlapping range")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    Builtin.copyArray(
      T.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // This builtin is equivalent to:
    // for i in 0..<count {
    //   (self.assumingMemoryBound(to: T.self) + i).initialize(to: source[i])
    // }
    return UnsafeMutablePointer(_rawValue)
  }
  @discardableResult
  @inlinable public func moveInitializeMemory<T>(as type: T.Type, from source: UnsafeMutablePointer<T>, count: Int) -> UnsafeMutablePointer<T> {
    _debugPrecondition(
      count >= 0,
      "UnsafeMutableRawPointer.moveInitializeMemory with negative count")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    if self < UnsafeMutableRawPointer(source)
       || self >= UnsafeMutableRawPointer(source + count) {
      // initialize forward from a disjoint or following overlapping range.
      Builtin.takeArrayFrontToBack(
        T.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // for i in 0..<count {
      //   (self.assumingMemoryBound(to: T.self) + i)
      //   .initialize(to: (source + i).move())
      // }
    }
    else {
      // initialize backward from a non-following overlapping range.
      Builtin.takeArrayBackToFront(
        T.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // var src = source + count
      // var dst = self.assumingMemoryBound(to: T.self) + count
      // while dst != self {
      //   (--dst).initialize(to: (--src).move())
      // }
    }
    return UnsafeMutablePointer(_rawValue)
  }
  @inlinable public func load<T>(fromByteOffset offset: Int = 0, as type: T.Type) -> T {
    _debugPrecondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "load from misaligned raw pointer")

    return Builtin.loadRaw((self + offset)._rawValue)
  }
  @inlinable public func storeBytes<T>(of value: T, toByteOffset offset: Int = 0, as type: T.Type) {
    _debugPrecondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "storeBytes to misaligned raw pointer")

    var temp = value
    withUnsafeMutablePointer(to: &temp) { source in
      let rawSrc = UnsafeMutableRawPointer(source)._rawValue
      // FIXME: to be replaced by _memcpy when conversions are implemented.
      Builtin.int_memcpy_RawPointer_RawPointer_Int64(
        (self + offset)._rawValue, rawSrc, UInt64(MemoryLayout<T>.size)._value,
        /*volatile:*/ false._value)
    }
  }
  @inlinable public func copyMemory(from source: UnsafeRawPointer, byteCount: Int) {
    _debugPrecondition(
      byteCount >= 0, "UnsafeMutableRawPointer.copyMemory with negative count")

    _memmove(dest: self, src: source, size: UInt(byteCount))
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension UnsafeMutableRawPointer : Strideable {
  @_transparent public func advanced(by n: Int) -> UnsafeMutableRawPointer {
    return UnsafeMutableRawPointer(Builtin.gepRaw_Word(_rawValue, n._builtinWordValue))
  }
  public typealias Stride = Swift.Int
}
extension OpaquePointer {
  @_transparent public init(_ from: UnsafeMutableRawPointer) {
    self._rawValue = from._rawValue
  }
  @_transparent public init?(_ from: UnsafeMutableRawPointer?) {
    guard let unwrapped = from else { return nil }
    self._rawValue = unwrapped._rawValue
  }
  @_transparent public init(_ from: UnsafeRawPointer) {
    self._rawValue = from._rawValue
  }
  @_transparent public init?(_ from: UnsafeRawPointer?) {
    guard let unwrapped = from else { return nil }
    self._rawValue = unwrapped._rawValue
  }
}
public protocol _UTFParser {
  associatedtype Encoding : Swift._UnicodeEncoding
  func _parseMultipleCodeUnits() -> (isValid: Bool, bitCount: UInt8)
  func _bufferedScalar(bitCount: UInt8) -> Encoding.EncodedScalar
  var _buffer: _UIntBuffer<Encoding.CodeUnit> { get set }
}
extension _UTFParser where Self.Encoding.EncodedScalar : Swift.RangeReplaceableCollection {
  @inlinable @inline(__always) mutating public func parseScalar<I>(from input: inout I) -> Unicode.ParseResult<Encoding.EncodedScalar> where I : Swift.IteratorProtocol, I.Element == Self.Encoding.CodeUnit {

    // Bufferless single-scalar fastpath.
    if _fastPath(_buffer.isEmpty) {
      guard let codeUnit = input.next() else { return .emptyInput }
      // ASCII, return immediately.
      if Encoding._isScalar(codeUnit) {
        return .valid(Encoding.EncodedScalar(CollectionOfOne(codeUnit)))
      }
      // Non-ASCII, proceed to buffering mode.
      _buffer.append(codeUnit)
    } else if Encoding._isScalar(
      Encoding.CodeUnit(truncatingIfNeeded: _buffer._storage)
    ) {
      // ASCII in _buffer.  We don't refill the buffer so we can return
      // to bufferless mode once we've exhausted it.
      let codeUnit = Encoding.CodeUnit(truncatingIfNeeded: _buffer._storage)
      _buffer.remove(at: _buffer.startIndex)
      return .valid(Encoding.EncodedScalar(CollectionOfOne(codeUnit)))
    }
    // Buffering mode.
    // Fill buffer back to 4 bytes (or as many as are left in the iterator).
    repeat {
      if let codeUnit = input.next() {
        _buffer.append(codeUnit)
      } else {
        if _buffer.isEmpty { return .emptyInput }
        break // We still have some bytes left in our buffer.
      }
    } while _buffer.count < _buffer.capacity

    // Find one unicode scalar.
    let (isValid, scalarBitCount) = _parseMultipleCodeUnits()
    _internalInvariant(scalarBitCount % numericCast(Encoding.CodeUnit.bitWidth) == 0)
    _internalInvariant(1...4 ~= scalarBitCount / 8)
    _internalInvariant(scalarBitCount <= _buffer._bitCount)
    
    // Consume the decoded bytes (or maximal subpart of ill-formed sequence).
    let encodedScalar = _bufferedScalar(bitCount: scalarBitCount)
    
    _buffer._storage = UInt32(
      // widen to 64 bits so that we can empty the buffer in the 4-byte case
      truncatingIfNeeded: UInt64(_buffer._storage) &>> scalarBitCount)
      
    _buffer._bitCount = _buffer._bitCount &- scalarBitCount

    if _fastPath(isValid) {
      return .valid(encodedScalar)
    }
    return .error(
      length: Int(scalarBitCount / numericCast(Encoding.CodeUnit.bitWidth)))
  }
}
extension Unicode {
  @_frozen public enum UTF8 {
    case _swift3Buffer(Unicode.UTF8.ForwardParser)
  }
}
extension Unicode.UTF8 {
  @_alwaysEmitIntoClient public static func width(_ x: Unicode.Scalar) -> Int {
    switch x.value {
      case 0..<0x80: return 1
      case 0x80..<0x0800: return 2
      case 0x0800..<0x1_0000: return 3
      default: return 4
    }
  }
}
extension Unicode.UTF8 : _UnicodeEncoding {
  public typealias CodeUnit = UInt8
  public typealias EncodedScalar = _ValidUTF8Buffer
  @inlinable public static var encodedReplacementCharacter: EncodedScalar {
    get {
    return EncodedScalar.encodedReplacementCharacter
  }
  }
  @inline(__always) @inlinable public static func _isScalar(_ x: CodeUnit) -> Bool {
    return isASCII(x)
  }
  @_alwaysEmitIntoClient @inline(__always) public static func isASCII(_ x: CodeUnit) -> Bool {
    return x & 0b1000_0000 == 0
  }
  @inline(__always) @inlinable public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {
    switch source.count {
    case 1:
      return Unicode.Scalar(_unchecked: source._biasedBits &- 0x01)
    case 2:
      let bits = source._biasedBits &- 0x0101
      var value = (bits & 0b0_______________________11_1111__0000_0000) &>> 8
      value    |= (bits & 0b0________________________________0001_1111) &<< 6
      return Unicode.Scalar(_unchecked: value)
    case 3:
      let bits = source._biasedBits &- 0x010101
      var value = (bits & 0b0____________11_1111__0000_0000__0000_0000) &>> 16
      value    |= (bits & 0b0_______________________11_1111__0000_0000) &>> 2
      value    |= (bits & 0b0________________________________0000_1111) &<< 12
      return Unicode.Scalar(_unchecked: value)
    default:
      _internalInvariant(source.count == 4)
      let bits = source._biasedBits &- 0x01010101
      var value = (bits & 0b0_11_1111__0000_0000__0000_0000__0000_0000) &>> 24
      value    |= (bits & 0b0____________11_1111__0000_0000__0000_0000) &>> 10
      value    |= (bits & 0b0_______________________11_1111__0000_0000) &<< 4
      value    |= (bits & 0b0________________________________0000_0111) &<< 18
      return Unicode.Scalar(_unchecked: value)
    }
  }
  @inline(__always) @inlinable public static func encode(_ source: Unicode.Scalar) -> EncodedScalar? {
    var c = source.value
    if _fastPath(c < (1&<<7)) {
      return EncodedScalar(_containing: UInt8(c))
    }
    var o = c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    if _fastPath(c < (1&<<5)) {
      return EncodedScalar(_biasedBits: (o | c) &+ 0b0__1000_0001__1100_0001)
    }
    o |= c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    if _fastPath(c < (1&<<4)) {
      return EncodedScalar(
        _biasedBits: (o | c) &+ 0b0__1000_0001__1000_0001__1110_0001)
    }
    o |= c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    return EncodedScalar(
      _biasedBits: (o | c ) &+ 0b0__1000_0001__1000_0001__1000_0001__1111_0001)
  }
  @inlinable @inline(__always) public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> EncodedScalar? where FromEncoding : Swift._UnicodeEncoding {
    if _fastPath(FromEncoding.self == UTF16.self) {
      let c = _identityCast(content, to: UTF16.EncodedScalar.self)
      var u0 = UInt16(truncatingIfNeeded: c._storage) 
      if _fastPath(u0 < 0x80) {
        return EncodedScalar(_containing: UInt8(truncatingIfNeeded: u0))
      }
      var r = UInt32(u0 & 0b0__11_1111)
      r &<<= 8
      u0 &>>= 6
      if _fastPath(u0 < (1&<<5)) {
        return EncodedScalar(
          _biasedBits: (UInt32(u0) | r) &+ 0b0__1000_0001__1100_0001)
      }
      r |= UInt32(u0 & 0b0__11_1111)
      r &<<= 8
      if _fastPath(u0 & (0xF800 &>> 6) != (0xD800 &>> 6)) {
        u0 &>>= 6
        return EncodedScalar(
          _biasedBits: (UInt32(u0) | r) &+ 0b0__1000_0001__1000_0001__1110_0001)
      }
    }
    else if _fastPath(FromEncoding.self == UTF8.self) {
      return _identityCast(content, to: UTF8.EncodedScalar.self)
    }
    return encode(FromEncoding.decode(content))
  }
  @_fixed_layout public struct ForwardParser {
    public typealias _Buffer = _UIntBuffer<UInt8>
    @inline(__always) @inlinable public init() { _buffer = _Buffer() }
    public var _buffer: _Buffer
  }
  @_fixed_layout public struct ReverseParser {
    public typealias _Buffer = _UIntBuffer<UInt8>
    @inline(__always) @inlinable public init() { _buffer = _Buffer() }
    public var _buffer: _Buffer
  }
}
extension Unicode.UTF8.ReverseParser : Unicode.Parser, _UTFParser {
  public typealias Encoding = Unicode.UTF8
  @inline(__always) @inlinable public func _parseMultipleCodeUnits() -> (isValid: Bool, bitCount: UInt8) {
    _internalInvariant(_buffer._storage & 0x80 != 0) // this case handled elsewhere
    if _buffer._storage                & 0b0__1110_0000__1100_0000
                                      == 0b0__1100_0000__1000_0000 {
      // 2-byte sequence.  Top 4 bits of decoded result must be nonzero
      let top4Bits =  _buffer._storage & 0b0__0001_1110__0000_0000
      if _fastPath(top4Bits != 0) { return (true, 2*8) }
    }
    else if _buffer._storage     & 0b0__1111_0000__1100_0000__1100_0000
                                == 0b0__1110_0000__1000_0000__1000_0000 {
      // 3-byte sequence. The top 5 bits of the decoded result must be nonzero
      // and not a surrogate
      let top5Bits = _buffer._storage & 0b0__1111__0010_0000__0000_0000
      if _fastPath(
        top5Bits != 0 &&    top5Bits != 0b0__1101__0010_0000__0000_0000) {
        return (true, 3*8)
      }
    }
    else if _buffer._storage & 0b0__1111_1000__1100_0000__1100_0000__1100_0000
                            == 0b0__1111_0000__1000_0000__1000_0000__1000_0000 {
      // Make sure the top 5 bits of the decoded result would be in range
      let top5bits = _buffer._storage
                                  & 0b0__0111__0011_0000__0000_0000__0000_0000
      if _fastPath(
        top5bits != 0
        && top5bits <=              0b0__0100__0000_0000__0000_0000__0000_0000
      ) { return (true, 4*8) }
    }
    return (false, _invalidLength() &* 8)
  }
  @usableFromInline
  @inline(never) internal func _invalidLength() -> UInt8
  @inline(__always) @inlinable public func _bufferedScalar(bitCount: UInt8) -> Encoding.EncodedScalar {
    let x = UInt32(truncatingIfNeeded: _buffer._storage.byteSwapped)
    let shift = 32 &- bitCount
    return Encoding.EncodedScalar(_biasedBits: (x &+ 0x01010101) &>> shift)
  }
}
extension Unicode.UTF8.ForwardParser : Unicode.Parser, _UTFParser {
  public typealias Encoding = Unicode.UTF8
  @inline(__always) @inlinable public func _parseMultipleCodeUnits() -> (isValid: Bool, bitCount: UInt8) {
    _internalInvariant(_buffer._storage & 0x80 != 0) // this case handled elsewhere
    
    if _buffer._storage & 0b0__1100_0000__1110_0000
                       == 0b0__1000_0000__1100_0000 {
      // 2-byte sequence. At least one of the top 4 bits of the decoded result
      // must be nonzero.
      if _fastPath(_buffer._storage & 0b0_0001_1110 != 0) { return (true, 2*8) }
    }
    else if _buffer._storage         & 0b0__1100_0000__1100_0000__1111_0000
                                    == 0b0__1000_0000__1000_0000__1110_0000 {
      // 3-byte sequence. The top 5 bits of the decoded result must be nonzero
      // and not a surrogate
      let top5Bits =          _buffer._storage & 0b0___0010_0000__0000_1111
      if _fastPath(top5Bits != 0 && top5Bits != 0b0___0010_0000__0000_1101) {
        return (true, 3*8)
      }
    }
    else if _buffer._storage & 0b0__1100_0000__1100_0000__1100_0000__1111_1000
                            == 0b0__1000_0000__1000_0000__1000_0000__1111_0000 {
      // 4-byte sequence.  The top 5 bits of the decoded result must be nonzero
      // and no greater than 0b0__0100_0000
      let top5bits = UInt16(_buffer._storage       & 0b0__0011_0000__0000_0111)
      if _fastPath(
        top5bits != 0
        && top5bits.byteSwapped                   <= 0b0__0000_0100__0000_0000
      ) { return (true, 4*8) }
    }
    return (false, _invalidLength() &* 8)
  }
  @usableFromInline
  @inline(never) internal func _invalidLength() -> UInt8
  @inlinable public func _bufferedScalar(bitCount: UInt8) -> Encoding.EncodedScalar {
    let x = UInt32(_buffer._storage) &+ 0x01010101
    return _ValidUTF8Buffer(_biasedBits: x & ._lowBits(bitCount))
  }
}
extension Unicode {
  @_frozen public enum UTF16 {
    case _swift3Buffer(Unicode.UTF16.ForwardParser)
  }
}
extension Unicode.UTF16 {
  @inlinable public static func width(_ x: Unicode.Scalar) -> Int {
    return x.value <= UInt16.max ? 1 : 2
  }
  @inlinable public static func leadSurrogate(_ x: Unicode.Scalar) -> UTF16.CodeUnit {
    _precondition(width(x) == 2)
    return 0xD800 + UTF16.CodeUnit(truncatingIfNeeded:
      (x.value - 0x1_0000) &>> (10 as UInt32))
  }
  @inlinable public static func trailSurrogate(_ x: Unicode.Scalar) -> UTF16.CodeUnit {
    _precondition(width(x) == 2)
    return 0xDC00 + UTF16.CodeUnit(truncatingIfNeeded:
      (x.value - 0x1_0000) & (((1 as UInt32) &<< 10) - 1))
  }
  @inlinable public static func isLeadSurrogate(_ x: CodeUnit) -> Bool {
    return (x & 0xFC00) == 0xD800
  }
  @inlinable public static func isTrailSurrogate(_ x: CodeUnit) -> Bool {
    return (x & 0xFC00) == 0xDC00
  }
  @_alwaysEmitIntoClient public static func isSurrogate(_ x: CodeUnit) -> Bool {
    return isLeadSurrogate(x) || isTrailSurrogate(x)
  }
  @inlinable public static func _copy<T, U>(source: UnsafeMutablePointer<T>, destination: UnsafeMutablePointer<U>, count: Int) where T : Swift._StringElement, U : Swift._StringElement {
    if MemoryLayout<T>.stride == MemoryLayout<U>.stride {
      _memcpy(
        dest: UnsafeMutablePointer(destination),
        src: UnsafeMutablePointer(source),
        size: UInt(count) * UInt(MemoryLayout<U>.stride))
    }
    else {
      for i in 0..<count {
        let u16 = T._toUTF16CodeUnit((source + i).pointee)
        (destination + i).pointee = U._fromUTF16CodeUnit(u16)
      }
    }
  }
  @inlinable public static func transcodedLength<Input, Encoding>(of input: Input, decodedAs sourceEncoding: Encoding.Type, repairingIllFormedSequences: Bool) -> (count: Int, isASCII: Bool)? where Input : Swift.IteratorProtocol, Encoding : Swift._UnicodeEncoding, Input.Element == Encoding.CodeUnit {

    var utf16Count = 0
    var i = input
    var d = Encoding.ForwardParser()

    // Fast path for ASCII in a UTF8 buffer
    if sourceEncoding == Unicode.UTF8.self {
      var peek: Encoding.CodeUnit = 0
      while let u = i.next() {
        peek = u
        guard _fastPath(peek < 0x80) else { break }
        utf16Count = utf16Count + 1
      }
      if _fastPath(peek < 0x80) { return (utf16Count, true) }

      var d1 = UTF8.ForwardParser()
      d1._buffer.append(numericCast(peek))
      d = _identityCast(d1, to: Encoding.ForwardParser.self)
    }

    var utf16BitUnion: CodeUnit = 0
    while true {
      let s = d.parseScalar(from: &i)
      if _fastPath(s._valid != nil), let scalarContent = s._valid {
        let utf16 = transcode(scalarContent, from: sourceEncoding)
          ._unsafelyUnwrappedUnchecked
        utf16Count += utf16.count
        for x in utf16 { utf16BitUnion |= x }
      }
      else if let _ = s._error {
        guard _fastPath(repairingIllFormedSequences) else { return nil }
        utf16Count += 1
        utf16BitUnion |= UTF16._replacementCodeUnit
      }
      else {
        return (utf16Count, utf16BitUnion < 0x80)
      }
    }
  }
}
extension Unicode.UTF16 : Unicode.Encoding {
  public typealias CodeUnit = UInt16
  public typealias EncodedScalar = _UIntBuffer<UInt16>
  @inlinable internal static var _replacementCodeUnit: CodeUnit {
    @inline(__always) get { return 0xfffd }
  }
  @inlinable public static var encodedReplacementCharacter: EncodedScalar {
    get {
    return EncodedScalar(_storage: 0xFFFD, _bitCount: 16)
  }
  }
  @_alwaysEmitIntoClient public static func isASCII(_ x: CodeUnit) -> Bool {
    return x <= 0x7f
  }
  @inlinable public static func _isScalar(_ x: CodeUnit) -> Bool {
    return x & 0xf800 != 0xd800
  }
  @inlinable @inline(__always) internal static func _decodeSurrogates(_ lead: CodeUnit, _ trail: CodeUnit) -> Unicode.Scalar {
    _internalInvariant(isLeadSurrogate(lead))
    _internalInvariant(isTrailSurrogate(trail))
    return Unicode.Scalar(
      _unchecked: 0x10000 +
        (UInt32(lead & 0x03ff) &<< 10 | UInt32(trail & 0x03ff)))
  }
  @inlinable public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {
    let bits = source._storage
    if _fastPath(source._bitCount == 16) {
      return Unicode.Scalar(_unchecked: bits & 0xffff)
    }
    _internalInvariant(source._bitCount == 32)
    let lower: UInt32 = bits >> 16 & 0x03ff
    let upper: UInt32 = (bits & 0x03ff) << 10
    let value = 0x10000 + (lower | upper)
    return Unicode.Scalar(_unchecked: value)
  }
  @inlinable public static func encode(_ source: Unicode.Scalar) -> EncodedScalar? {
    let x = source.value
    if _fastPath(x < ((1 as UInt32) << 16)) {
      return EncodedScalar(_storage: x, _bitCount: 16)
    }
    let x1 = x - ((1 as UInt32) << 16)
    var r = (0xdc00 + (x1 & 0x3ff))
    r &<<= 16
    r |= (0xd800 + (x1 &>> 10 & 0x3ff))
    return EncodedScalar(_storage: r, _bitCount: 32)
  }
  @inlinable @inline(__always) public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> EncodedScalar? where FromEncoding : Swift._UnicodeEncoding {
    if _fastPath(FromEncoding.self == UTF8.self) {
      let c = _identityCast(content, to: UTF8.EncodedScalar.self)
      var b = c.count
      b = b &- 1
      if _fastPath(b == 0) {
        return EncodedScalar(
          _storage: (c._biasedBits &- 0x1) & 0b0__111_1111, _bitCount: 16)
      }
      var s = c._biasedBits &- 0x01010101
      var r = s
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      b = b &- 1
      
      if _fastPath(b == 0) {
        return EncodedScalar(_storage: r & 0b0__111_1111_1111, _bitCount: 16)
      }
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      b = b &- 1
      
      if _fastPath(b == 0) {
        return EncodedScalar(_storage: r & 0xFFFF, _bitCount: 16)
      }
      
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      r &= (1 &<< 21) - 1
      return encode(Unicode.Scalar(_unchecked: r))
    }
    else if _fastPath(FromEncoding.self == UTF16.self) {
      return unsafeBitCast(content, to: UTF16.EncodedScalar.self)
    }
    return encode(FromEncoding.decode(content))
  }
  @_fixed_layout public struct ForwardParser {
    public typealias _Buffer = _UIntBuffer<UInt16>
    @inlinable public init() { _buffer = _Buffer() }
    public var _buffer: _Buffer
  }
  @_fixed_layout public struct ReverseParser {
    public typealias _Buffer = _UIntBuffer<UInt16>
    @inlinable public init() { _buffer = _Buffer() }
    public var _buffer: _Buffer
  }
}
extension Unicode.UTF16.ReverseParser : Unicode.Parser, _UTFParser {
  public typealias Encoding = Unicode.UTF16
  @inlinable public func _parseMultipleCodeUnits() -> (isValid: Bool, bitCount: UInt8) {
    _internalInvariant(  // this case handled elsewhere
      !Encoding._isScalar(UInt16(truncatingIfNeeded: _buffer._storage)))
    if _fastPath(_buffer._storage & 0xFC00_FC00 == 0xD800_DC00) {
      return (true, 2*16)
    }
    return (false, 1*16)
  }
  @inlinable public func _bufferedScalar(bitCount: UInt8) -> Encoding.EncodedScalar {
    return Encoding.EncodedScalar(
      _storage:
        (_buffer._storage &<< 16 | _buffer._storage &>> 16) &>> (32 - bitCount),
      _bitCount: bitCount
    )
  }
}
extension Unicode.UTF16.ForwardParser : Unicode.Parser, _UTFParser {
  public typealias Encoding = Unicode.UTF16
  @inlinable public func _parseMultipleCodeUnits() -> (isValid: Bool, bitCount: UInt8) {
    _internalInvariant(  // this case handled elsewhere
      !Encoding._isScalar(UInt16(truncatingIfNeeded: _buffer._storage)))
    if _fastPath(_buffer._storage & 0xFC00_FC00 == 0xDC00_D800) {
      return (true, 2*16)
    }
    return (false, 1*16)
  }
  @inlinable public func _bufferedScalar(bitCount: UInt8) -> Encoding.EncodedScalar {
    var r = _buffer
    r._bitCount = bitCount
    return r
  }
}
extension Unicode {
  @_frozen public enum UTF32 {
    case _swift3Codec
    public static func == (a: Swift.Unicode.UTF32, b: Swift.Unicode.UTF32) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
extension Unicode.UTF32 : Unicode.Encoding {
  public typealias CodeUnit = UInt32
  public typealias EncodedScalar = CollectionOfOne<UInt32>
  @inlinable internal static var _replacementCodeUnit: CodeUnit {
    @inline(__always) get { return 0xFFFD }
  }
  @inlinable public static var encodedReplacementCharacter: EncodedScalar {
    get {
    return EncodedScalar(_replacementCodeUnit)
  }
  }
  @inlinable @inline(__always) public static func _isScalar(_ x: CodeUnit) -> Bool {
    return true
  }
  @_alwaysEmitIntoClient public static func isASCII(_ x: CodeUnit) -> Bool {
    return x <= 0x7F
  }
  @inlinable @inline(__always) public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {
    return Unicode.Scalar(_unchecked: source.first!)
  }
  @inlinable @inline(__always) public static func encode(_ source: Unicode.Scalar) -> EncodedScalar? {
    return EncodedScalar(source.value)
  }
  @_fixed_layout public struct Parser {
    @inlinable public init() { }
  }
  public typealias ForwardParser = Parser
  public typealias ReverseParser = Parser
}
extension Unicode.UTF32.Parser : Unicode.Parser {
  public typealias Encoding = Unicode.UTF32
  @inlinable mutating public func parseScalar<I>(from input: inout I) -> Unicode.ParseResult<Encoding.EncodedScalar> where I : Swift.IteratorProtocol, I.Element == Swift.Unicode.UTF32.Parser.Encoding.CodeUnit {
    let n = input.next()
    if _fastPath(n != nil), let x = n {
      // Check code unit is valid: not surrogate-reserved and within range.
      guard _fastPath((x &>> 11) != 0b1101_1 && x <= 0x10ffff)
      else { return .error(length: 1) }
      
      // x is a valid scalar.
      return .valid(UTF32.EncodedScalar(x))
    }
    return .emptyInput
  }
}
@_frozen public enum UnicodeDecodingResult : Equatable {
  case scalarValue(Unicode.Scalar)
  case emptyInput
  case error
  @inlinable public static func == (lhs: UnicodeDecodingResult, rhs: UnicodeDecodingResult) -> Bool {
    switch (lhs, rhs) {
    case (.scalarValue(let lhsScalar), .scalarValue(let rhsScalar)):
      return lhsScalar == rhsScalar
    case (.emptyInput, .emptyInput):
      return true
    case (.error, .error):
      return true
    default:
      return false
    }
  }
}
public protocol UnicodeCodec : Swift._UnicodeEncoding {
  init()
  mutating func decode<I>(_ input: inout I) -> UnicodeDecodingResult where I : Swift.IteratorProtocol, Self.CodeUnit == I.Element
  static func encode(_ input: Unicode.Scalar, into processCodeUnit: (CodeUnit) -> Void)
  static func _nullCodeUnitOffset(in input: UnsafePointer<CodeUnit>) -> Int
}
extension Unicode.UTF8 : UnicodeCodec {
  @inlinable public init() { self = ._swift3Buffer(ForwardParser()) }
  @inlinable @inline(__always) mutating public func decode<I>(_ input: inout I) -> UnicodeDecodingResult where I : Swift.IteratorProtocol, I.Element == Swift.Unicode.UTF8.CodeUnit {
    guard case ._swift3Buffer(var parser) = self else {
      Builtin.unreachable()
    }
    defer { self = ._swift3Buffer(parser) }

    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF8.decode(s))
    case .error: return .error
    case .emptyInput: return .emptyInput
    }
  }
  @inlinable public static func _decodeOne(_ buffer: UInt32) -> (result: UInt32?, length: UInt8) {
    // Note the buffer is read least significant byte first: [ #3 #2 #1 #0 ].

    if buffer & 0x80 == 0 { // 1-byte sequence (ASCII), buffer: [ ... ... ... CU0 ].
      let value = buffer & 0xff
      return (value, 1)
    }
    var p = ForwardParser()
    p._buffer._storage = buffer
    p._buffer._bitCount = 32
    var i = EmptyCollection<UInt8>().makeIterator()
    switch p.parseScalar(from: &i) {
    case .valid(let s):
      return (
        result: UTF8.decode(s).value,
        length: UInt8(truncatingIfNeeded: s.count))
    case .error(let l):
      return (result: nil, length: UInt8(truncatingIfNeeded: l))
    case .emptyInput: Builtin.unreachable()
    }
  }
  @inlinable @inline(__always) public static func encode(_ input: Unicode.Scalar, into processCodeUnit: (CodeUnit) -> Void) {
    var s = encode(input)!._biasedBits
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
  }
  @inlinable public static func isContinuation(_ byte: CodeUnit) -> Bool {
    return byte & 0b11_00__0000 == 0b10_00__0000
  }
  @inlinable public static func _nullCodeUnitOffset(in input: UnsafePointer<CodeUnit>) -> Int {
    return Int(_swift_stdlib_strlen_unsigned(input))
  }
  @inlinable public static func _nullCodeUnitOffset(in input: UnsafePointer<CChar>) -> Int {
    return Int(_swift_stdlib_strlen(input))
  }
}
extension Unicode.UTF16 : UnicodeCodec {
  @inlinable public init() { self = ._swift3Buffer(ForwardParser()) }
  @inlinable mutating public func decode<I>(_ input: inout I) -> UnicodeDecodingResult where I : Swift.IteratorProtocol, I.Element == Swift.Unicode.UTF16.CodeUnit {
    guard case ._swift3Buffer(var parser) = self else {
      Builtin.unreachable()
    }
    defer { self = ._swift3Buffer(parser) }
    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF16.decode(s))
    case .error: return .error
    case .emptyInput: return .emptyInput
    }
  }
  @inlinable mutating internal func _decodeOne<I>(_ input: inout I) -> (UnicodeDecodingResult, Int) where I : Swift.IteratorProtocol, I.Element == Swift.Unicode.UTF16.CodeUnit {
    let result = decode(&input)
    switch result {
    case .scalarValue(let us):
      return (result, UTF16.width(us))

    case .emptyInput:
      return (result, 0)

    case .error:
      return (result, 1)
    }
  }
  @inlinable public static func encode(_ input: Unicode.Scalar, into processCodeUnit: (CodeUnit) -> Void) {
    var s = encode(input)!._storage
    processCodeUnit(UInt16(truncatingIfNeeded: s))
    s &>>= 16
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt16(truncatingIfNeeded: s))
  }
}
extension Unicode.UTF32 : UnicodeCodec {
  @inlinable public init() { self = ._swift3Codec }
  @inlinable mutating public func decode<I>(_ input: inout I) -> UnicodeDecodingResult where I : Swift.IteratorProtocol, I.Element == Swift.Unicode.UTF32.CodeUnit {
    var parser = ForwardParser()
    
    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF32.decode(s))
    case .error:      return .error
    case .emptyInput:   return .emptyInput
    }
  }
  @inlinable public static func encode(_ input: Unicode.Scalar, into processCodeUnit: (CodeUnit) -> Void) {
    processCodeUnit(UInt32(input))
  }
}
@inlinable @inline(__always) public func transcode<Input, InputEncoding, OutputEncoding>(_ input: Input, from inputEncoding: InputEncoding.Type, to outputEncoding: OutputEncoding.Type, stoppingOnError stopOnError: Bool, into processCodeUnit: (OutputEncoding.CodeUnit) -> Void) -> Bool where Input : Swift.IteratorProtocol, InputEncoding : Swift._UnicodeEncoding, OutputEncoding : Swift._UnicodeEncoding, Input.Element == InputEncoding.CodeUnit {
  var input = input

  // NB.  It is not possible to optimize this routine to a memcpy if
  // InputEncoding == OutputEncoding.  The reason is that memcpy will not
  // substitute U+FFFD replacement characters for ill-formed sequences.

  var p = InputEncoding.ForwardParser()
  var hadError = false
  loop:
  while true {
    switch p.parseScalar(from: &input) {
    case .valid(let s):
      let t = OutputEncoding.transcode(s, from: inputEncoding)
      guard _fastPath(t != nil), let s = t else { break }
      s.forEach(processCodeUnit)
      continue loop
    case .emptyInput:
      return hadError
    case .error:
      if _slowPath(stopOnError) { return true }
      hadError = true
    }
    OutputEncoding.encodedReplacementCharacter.forEach(processCodeUnit)
  }
}
public protocol _StringElement {
  static func _toUTF16CodeUnit(_: Self) -> UTF16.CodeUnit
  static func _fromUTF16CodeUnit(_ utf16: UTF16.CodeUnit) -> Self
}
extension UInt16 : _StringElement {
  @inlinable public static func _toUTF16CodeUnit(_ x: UTF16.CodeUnit) -> UTF16.CodeUnit {
    return x
  }
  @inlinable public static func _fromUTF16CodeUnit(_ utf16: UTF16.CodeUnit) -> UTF16.CodeUnit {
    return utf16
  }
}
extension UInt8 : _StringElement {
  @inlinable public static func _toUTF16CodeUnit(_ x: UTF8.CodeUnit) -> UTF16.CodeUnit {
    _internalInvariant(x <= 0x7f, "should only be doing this with ASCII")
    return UTF16.CodeUnit(truncatingIfNeeded: x)
  }
  @inlinable public static func _fromUTF16CodeUnit(_ utf16: UTF16.CodeUnit) -> UTF8.CodeUnit {
    _internalInvariant(utf16 <= 0x7f, "should only be doing this with ASCII")
    return UTF8.CodeUnit(truncatingIfNeeded: utf16)
  }
}
extension Unicode.Scalar {
  @inlinable internal init(_unchecked value: UInt32) {
    _internalInvariant(value < 0xD800 || value > 0xDFFF,
      "high- and low-surrogate code points are not valid Unicode scalar values")
    _internalInvariant(value <= 0x10FFFF, "value is outside of Unicode codespace")

    self._value = value
  }
}
extension UnicodeCodec {
  @inlinable public static func _nullCodeUnitOffset(in input: UnsafePointer<CodeUnit>) -> Int {
    var length = 0
    while input[length] != 0 {
      length += 1
    }
    return length
  }
}
@available(*, unavailable, message: "use 'transcode(_:from:to:stoppingOnError:into:)'")
public func transcode<Input, InputEncoding, OutputEncoding>(_ inputEncoding: InputEncoding.Type, _ outputEncoding: OutputEncoding.Type, _ input: Input, _ output: (OutputEncoding.CodeUnit) -> Void, stopOnError: Bool) -> Bool where Input : Swift.IteratorProtocol, InputEncoding : Swift.UnicodeCodec, OutputEncoding : Swift.UnicodeCodec, Input.Element == InputEncoding.CodeUnit
@_frozen public enum Unicode {
}
extension _StringGuts {
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func isOnGraphemeClusterBoundary(_ i: String.Index) -> Bool
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _opaqueCharacterStride(startingAt i: Int) -> Int
  @usableFromInline
  @inline(never) @_effects(releasenone) internal func _opaqueCharacterStride(endingAt i: Int) -> Int
}
@_fixed_layout public struct _ValidUTF8Buffer {
  public typealias Element = Unicode.UTF8.CodeUnit
  @usableFromInline
  internal var _biasedBits: UInt32
  @inlinable internal init(_biasedBits: UInt32) {
    self._biasedBits = _biasedBits
  }
  @inlinable internal init(_containing e: Element) {
    _internalInvariant(
      e != 192 && e != 193 && !(245...255).contains(e), "invalid UTF8 byte")
    _biasedBits = UInt32(truncatingIfNeeded: e &+ 1)
  }
}
extension _ValidUTF8Buffer : Sequence {
  public typealias SubSequence = Slice<_ValidUTF8Buffer>
  @_fixed_layout public struct Iterator : IteratorProtocol, Sequence {
    @inlinable public init(_ x: _ValidUTF8Buffer) { _biasedBits = x._biasedBits }
    @inlinable mutating public func next() -> Element? {
      if _biasedBits == 0 { return nil }
      defer { _biasedBits >>= 8 }
      return Element(truncatingIfNeeded: _biasedBits) &- 1
    }
    @usableFromInline
    internal var _biasedBits: UInt32
    public typealias Element = Swift.UInt8
    public typealias Iterator = Swift._ValidUTF8Buffer.Iterator
  }
  @inlinable public func makeIterator() -> Iterator {
    return Iterator(self)
  }
}
extension _ValidUTF8Buffer : Collection {
  @_fixed_layout public struct Index : Comparable {
    @usableFromInline
    internal var _biasedBits: UInt32
    @inlinable internal init(_biasedBits: UInt32) { self._biasedBits = _biasedBits }
    @inlinable public static func == (lhs: Index, rhs: Index) -> Bool {
      return lhs._biasedBits == rhs._biasedBits
    }
    @inlinable public static func < (lhs: Index, rhs: Index) -> Bool {
      return lhs._biasedBits > rhs._biasedBits
    }
  }
  @inlinable public var startIndex: Index {
    get {
    return Index(_biasedBits: _biasedBits)
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return Index(_biasedBits: 0)
  }
  }
  @inlinable public var count: Int {
    get {
    return UInt32.bitWidth &>> 3 &- _biasedBits.leadingZeroBitCount &>> 3
  }
  }
  @inlinable public var isEmpty: Bool {
    get {
    return _biasedBits == 0
  }
  }
  @inlinable public func index(after i: Index) -> Index {
    _debugPrecondition(i._biasedBits != 0)
    return Index(_biasedBits: i._biasedBits >> 8)
  }
  @inlinable public subscript(i: Index) -> Element {
    get {
    return Element(truncatingIfNeeded: i._biasedBits) &- 1
  }
  }
}
extension _ValidUTF8Buffer : BidirectionalCollection {
  @inlinable public func index(before i: Index) -> Index {
    let offset = _ValidUTF8Buffer(_biasedBits: i._biasedBits).count
    _debugPrecondition(offset != 0)
    return Index(_biasedBits: _biasedBits &>> (offset &<< 3 - 8))
  }
}
extension _ValidUTF8Buffer : RandomAccessCollection {
  public typealias Indices = DefaultIndices<_ValidUTF8Buffer>
  @inlinable @inline(__always) public func distance(from i: Index, to j: Index) -> Int {
    _debugPrecondition(_isValid(i))
    _debugPrecondition(_isValid(j))
    return (
      i._biasedBits.leadingZeroBitCount - j._biasedBits.leadingZeroBitCount
    ) &>> 3
  }
  @inlinable @inline(__always) public func index(_ i: Index, offsetBy n: Int) -> Index {
    let startOffset = distance(from: startIndex, to: i)
    let newOffset = startOffset + n
    _debugPrecondition(newOffset >= 0)
    _debugPrecondition(newOffset <= count)
    return Index(_biasedBits: _biasedBits._fullShiftRight(newOffset &<< 3))
  }
}
extension _ValidUTF8Buffer : RangeReplaceableCollection {
  @inlinable public init() {
    _biasedBits = 0
  }
  @inlinable public var capacity: Int {
    get {
    return _ValidUTF8Buffer.capacity
  }
  }
  @inlinable public static var capacity: Int {
    get {
    return UInt32.bitWidth / Element.bitWidth
  }
  }
  @inlinable @inline(__always) mutating public func append(_ e: Element) {
    _debugPrecondition(count + 1 <= capacity)
    _internalInvariant(
      e != 192 && e != 193 && !(245...255).contains(e), "invalid UTF8 byte")
    _biasedBits |= UInt32(e &+ 1) &<< (count &<< 3)
  }
  @discardableResult
  @inlinable @inline(__always) mutating public func removeFirst() -> Element {
    _debugPrecondition(!isEmpty)
    let result = Element(truncatingIfNeeded: _biasedBits) &- 1
    _biasedBits = _biasedBits._fullShiftRight(8)
    return result
  }
  @inlinable internal func _isValid(_ i: Index) -> Bool {
    return i == endIndex || indices.contains(i)
  }
  @inlinable @inline(__always) mutating public func replaceSubrange<C>(_ target: Range<Index>, with replacement: C) where C : Swift.Collection, C.Element == Swift._ValidUTF8Buffer.Element {
    _debugPrecondition(_isValid(target.lowerBound))
    _debugPrecondition(_isValid(target.upperBound))
    var r = _ValidUTF8Buffer()
    for x in self[..<target.lowerBound] { r.append(x) }
    for x in replacement                { r.append(x) }
    for x in self[target.upperBound...] { r.append(x) }
    self = r
  }
}
extension _ValidUTF8Buffer {
  @inlinable @inline(__always) mutating public func append(contentsOf other: _ValidUTF8Buffer) {
    _debugPrecondition(count + other.count <= capacity)
    _biasedBits |= UInt32(
      truncatingIfNeeded: other._biasedBits) &<< (count &<< 3)
  }
}
extension _ValidUTF8Buffer {
  @inlinable public static var encodedReplacementCharacter: _ValidUTF8Buffer {
    get {
    return _ValidUTF8Buffer(_biasedBits: 0xBD_BF_EF &+ 0x01_01_01)
  }
  }
  @inlinable internal var _bytes: (bytes: UInt64, count: Int) {
    get {
    let count = self.count
    let mask: UInt64 = 1 &<< (UInt64(truncatingIfNeeded: count) &<< 3) &- 1
    let unbiased = UInt64(truncatingIfNeeded: _biasedBits) &- 0x0101010101010101
    return (unbiased & mask, count)
  }
  }
}
@inlinable internal func _writeBackMutableSlice<C, Slice_>(_ self_: inout C, bounds: Range<C.Index>, slice: Slice_) where C : Swift.MutableCollection, Slice_ : Swift.Collection, C.Element == Slice_.Element, C.Index == Slice_.Index {

  self_._failEarlyRangeCheck(bounds, bounds: self_.startIndex..<self_.endIndex)

  // FIXME(performance): can we use
  // _withUnsafeMutableBufferPointerIfSupported?  Would that create inout
  // aliasing violations if the newValue points to the same buffer?

  var selfElementIndex = bounds.lowerBound
  let selfElementsEndIndex = bounds.upperBound
  var newElementIndex = slice.startIndex
  let newElementsEndIndex = slice.endIndex

  while selfElementIndex != selfElementsEndIndex &&
    newElementIndex != newElementsEndIndex {

    self_[selfElementIndex] = slice[newElementIndex]
    self_.formIndex(after: &selfElementIndex)
    slice.formIndex(after: &newElementIndex)
  }

  _precondition(
    selfElementIndex == selfElementsEndIndex,
    "Cannot replace a slice of a MutableCollection with a slice of a smaller size")
  _precondition(
    newElementIndex == newElementsEndIndex,
    "Cannot replace a slice of a MutableCollection with a slice of a larger size")
}
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "BidirectionalCollection")
public typealias BidirectionalIndexable = BidirectionalCollection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "Collection")
public typealias IndexableBase = Collection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "Collection")
public typealias Indexable = Collection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "MutableCollection")
public typealias MutableIndexable = MutableCollection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "RandomAccessCollection")
public typealias RandomAccessIndexable = RandomAccessCollection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "RangeReplaceableIndexable")
public typealias RangeReplaceableIndexable = RangeReplaceableCollection
@available(swift, deprecated: 4.2, renamed: "EnumeratedSequence.Iterator")
public typealias EnumeratedIterator<T> = EnumeratedSequence<T>.Iterator where T : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "CollectionOfOne.Iterator")
public typealias IteratorOverOne<T> = CollectionOfOne<T>.Iterator
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "EmptyCollection.Iterator")
public typealias EmptyIterator<T> = EmptyCollection<T>.Iterator
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyFilterSequence.Iterator")
public typealias LazyFilterIterator<T> = LazyFilterSequence<T>.Iterator where T : Swift.Sequence
@available(swift, deprecated: 3.1, obsoleted: 5.0, message: "Use Base.Index")
public typealias LazyFilterIndex<Base> = Base.Index where Base : Swift.Collection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyDropWhileSequence.Iterator")
public typealias LazyDropWhileIterator<T> = LazyDropWhileSequence<T>.Iterator where T : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyDropWhileCollection.Index")
public typealias LazyDropWhileIndex<T> = LazyDropWhileCollection<T>.Index where T : Swift.Collection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyDropWhileCollection")
public typealias LazyDropWhileBidirectionalCollection<T> = LazyDropWhileCollection<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyFilterCollection")
public typealias LazyFilterBidirectionalCollection<T> = LazyFilterCollection<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyMapSequence.Iterator")
public typealias LazyMapIterator<T, E> = LazyMapSequence<T, E>.Iterator where T : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyMapCollection")
public typealias LazyMapBidirectionalCollection<T, E> = LazyMapCollection<T, E> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyMapCollection")
public typealias LazyMapRandomAccessCollection<T, E> = LazyMapCollection<T, E> where T : Swift.RandomAccessCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyCollection")
public typealias LazyBidirectionalCollection<T> = LazyCollection<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyCollection")
public typealias LazyRandomAccessCollection<T> = LazyCollection<T> where T : Swift.RandomAccessCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "FlattenCollection.Index")
public typealias FlattenCollectionIndex<T> = FlattenCollection<T>.Index where T : Swift.Collection, T.Element : Swift.Collection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "FlattenCollection.Index")
public typealias FlattenBidirectionalCollectionIndex<T> = FlattenCollection<T>.Index where T : Swift.BidirectionalCollection, T.Element : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "FlattenCollection")
public typealias FlattenBidirectionalCollection<T> = FlattenCollection<T> where T : Swift.BidirectionalCollection, T.Element : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "JoinedSequence.Iterator")
public typealias JoinedIterator<T> = JoinedSequence<T>.Iterator where T : Swift.Sequence, T.Element : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "Zip2Sequence.Iterator")
public typealias Zip2Iterator<T, U> = Zip2Sequence<T, U>.Iterator where T : Swift.Sequence, U : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyDropWhileSequence.Iterator")
public typealias LazyPrefixWhileIterator<T> = LazyPrefixWhileSequence<T>.Iterator where T : Swift.Sequence
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyDropWhileCollection.Index")
public typealias LazyPrefixWhileIndex<T> = LazyPrefixWhileCollection<T>.Index where T : Swift.Collection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "LazyPrefixWhileCollection")
public typealias LazyPrefixWhileBidirectionalCollection<T> = LazyPrefixWhileCollection<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "ReversedCollection")
public typealias ReversedRandomAccessCollection<T> = ReversedCollection<T> where T : Swift.RandomAccessCollection
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "ReversedCollection.Index")
public typealias ReversedIndex<T> = ReversedCollection<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias BidirectionalSlice<T> = Slice<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias RandomAccessSlice<T> = Slice<T> where T : Swift.RandomAccessCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias RangeReplaceableSlice<T> = Slice<T> where T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias RangeReplaceableBidirectionalSlice<T> = Slice<T> where T : Swift.BidirectionalCollection, T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias RangeReplaceableRandomAccessSlice<T> = Slice<T> where T : Swift.RandomAccessCollection, T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableSlice<T> = Slice<T> where T : Swift.MutableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableBidirectionalSlice<T> = Slice<T> where T : Swift.BidirectionalCollection, T : Swift.MutableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableRandomAccessSlice<T> = Slice<T> where T : Swift.MutableCollection, T : Swift.RandomAccessCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableRangeReplaceableSlice<T> = Slice<T> where T : Swift.MutableCollection, T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableRangeReplaceableBidirectionalSlice<T> = Slice<T> where T : Swift.BidirectionalCollection, T : Swift.MutableCollection, T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "Slice")
public typealias MutableRangeReplaceableRandomAccessSlice<T> = Slice<T> where T : Swift.MutableCollection, T : Swift.RandomAccessCollection, T : Swift.RangeReplaceableCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "DefaultIndices")
public typealias DefaultBidirectionalIndices<T> = DefaultIndices<T> where T : Swift.BidirectionalCollection
@available(swift, deprecated: 4.0, obsoleted: 5.0, renamed: "DefaultIndices")
public typealias DefaultRandomAccessIndices<T> = DefaultIndices<T> where T : Swift.RandomAccessCollection
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByNilLiteral")
public typealias NilLiteralConvertible = ExpressibleByNilLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinIntegerLiteral")
public typealias _BuiltinIntegerLiteralConvertible = _ExpressibleByBuiltinIntegerLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByIntegerLiteral")
public typealias IntegerLiteralConvertible = ExpressibleByIntegerLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinFloatLiteral")
public typealias _BuiltinFloatLiteralConvertible = _ExpressibleByBuiltinFloatLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByFloatLiteral")
public typealias FloatLiteralConvertible = ExpressibleByFloatLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinBooleanLiteral")
public typealias _BuiltinBooleanLiteralConvertible = _ExpressibleByBuiltinBooleanLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByBooleanLiteral")
public typealias BooleanLiteralConvertible = ExpressibleByBooleanLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinUnicodeScalarLiteral")
public typealias _BuiltinUnicodeScalarLiteralConvertible = _ExpressibleByBuiltinUnicodeScalarLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByUnicodeScalarLiteral")
public typealias UnicodeScalarLiteralConvertible = ExpressibleByUnicodeScalarLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinExtendedGraphemeClusterLiteral")
public typealias _BuiltinExtendedGraphemeClusterLiteralConvertible = _ExpressibleByBuiltinExtendedGraphemeClusterLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByExtendedGraphemeClusterLiteral")
public typealias ExtendedGraphemeClusterLiteralConvertible = ExpressibleByExtendedGraphemeClusterLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByBuiltinStringLiteral")
public typealias _BuiltinStringLiteralConvertible = _ExpressibleByBuiltinStringLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByStringLiteral")
public typealias StringLiteralConvertible = ExpressibleByStringLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByArrayLiteral")
public typealias ArrayLiteralConvertible = ExpressibleByArrayLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByDictionaryLiteral")
public typealias DictionaryLiteralConvertible = ExpressibleByDictionaryLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "ExpressibleByStringInterpolation")
public typealias StringInterpolationConvertible = ExpressibleByStringInterpolation
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByColorLiteral")
public typealias _ColorLiteralConvertible = _ExpressibleByColorLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByImageLiteral")
public typealias _ImageLiteralConvertible = _ExpressibleByImageLiteral
@available(swift, deprecated: 3.0, obsoleted: 5.0, renamed: "_ExpressibleByFileReferenceLiteral")
public typealias _FileReferenceLiteralConvertible = _ExpressibleByFileReferenceLiteral
@available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "ClosedRange.Index")
public typealias ClosedRangeIndex<T> = ClosedRange<T>.Index where T : Swift.Strideable, T.Stride : Swift.SignedInteger
@available(*, unavailable, renamed: "Optional")
public typealias ImplicitlyUnwrappedOptional<Wrapped> = Optional<Wrapped>
extension Range where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  @available(swift, deprecated: 4.2, obsoleted: 5.0, message: "CountableRange is now a Range. No need to convert any more.")
  public init(_ other: Range<Bound>)
}
extension ClosedRange where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  @available(swift, deprecated: 4.2, obsoleted: 5.0, message: "CountableClosedRange is now a ClosedRange. No need to convert any more.")
  public init(_ other: ClosedRange<Bound>)
}
@available(swift, deprecated: 5.0, renamed: "KeyValuePairs")
public typealias DictionaryLiteral<Key, Value> = KeyValuePairs<Key, Value>
extension LazySequenceProtocol {
  @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
  public func flatMap<ElementOfResult>(_ transform: @escaping (Elements.Element) -> ElementOfResult?) -> LazyMapSequence<LazyFilterSequence<LazyMapSequence<Elements, ElementOfResult?>>, ElementOfResult>
}
extension String {
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please use String directly")
  public typealias CharacterView = String
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please use String directly")
  public var characters: String {
    get
    set
  }
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please mutate the String directly")
  mutating public func withMutableCharacters<R>(_ body: (inout String) -> R) -> R
}
extension String.UnicodeScalarView : _CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnicodeScalarView.customPlaygroundQuickLook will be removed in Swift 5.0")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
public typealias UTF8 = Unicode.UTF8
public typealias UTF16 = Unicode.UTF16
public typealias UTF32 = Unicode.UTF32
public typealias UnicodeScalar = Unicode.Scalar
extension String.UTF16View : _CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UTF16View.customPlaygroundQuickLook will be removed in Swift 5.0")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension String.UTF8View : _CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UTF8View.customPlaygroundQuickLook will be removed in Swift 5.0")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension Substring {
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please use Substring directly")
  public typealias CharacterView = Substring
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please use Substring directly")
  public var characters: Substring {
    get
    set
  }
  @available(swift, deprecated: 3.2, obsoleted: 5.0, message: "Please mutate the Substring directly")
  mutating public func withMutableCharacters<R>(_ body: (inout Substring) -> R) -> R
}
extension Substring : _CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "Substring.customPlaygroundQuickLook will be removed in Swift 5.0")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension Collection {
  @available(*, unavailable, renamed: "Iterator")
  public typealias Generator = Iterator
  @available(swift, deprecated: 3.2, obsoleted: 5.0, renamed: "Element")
  public typealias _Element = Element
  @available(swift, deprecated: 4.0, obsoleted: 5.0, message: "all index distances are now of type Int")
  public func index<T>(_ i: Index, offsetBy n: T) -> Index where T : Swift.BinaryInteger
  @available(swift, deprecated: 4.0, obsoleted: 5.0, message: "all index distances are now of type Int")
  public func formIndex<T>(_ i: inout Index, offsetBy n: T) where T : Swift.BinaryInteger
  @available(swift, deprecated: 4.0, obsoleted: 5.0, message: "all index distances are now of type Int")
  public func index<T>(_ i: Index, offsetBy n: T, limitedBy limit: Index) -> Index? where T : Swift.BinaryInteger
  @available(swift, deprecated: 4.0, obsoleted: 5.0, message: "all index distances are now of type Int")
  public func formIndex<T>(_ i: inout Index, offsetBy n: T, limitedBy limit: Index) -> Bool where T : Swift.BinaryInteger
  @available(swift, deprecated: 4.0, obsoleted: 5.0, message: "all index distances are now of type Int")
  public func distance<T>(from start: Index, to end: Index) -> T where T : Swift.BinaryInteger
}
extension UnsafeMutablePointer {
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "initialize(repeating:count:)")
  public func initialize(to newValue: Pointee, count: Int = 1)
  @available(swift, deprecated: 4.1, obsoleted: 5.0, message: "the default argument to deinitialize(count:) has been removed, please specify the count explicitly")
  @discardableResult
  public func deinitialize() -> UnsafeMutableRawPointer
  @available(swift, deprecated: 4.1, obsoleted: 5.0, message: "Swift currently only supports freeing entire heap blocks, use deallocate() instead")
  public func deallocate(capacity _: Int)
  @available(swift, deprecated: 4.2, obsoleted: 5.0, message: "it will be removed in Swift 5.0.  Please use 'UnsafeMutableBufferPointer.initialize(from:)' instead")
  public func initialize<C>(from source: C) where Pointee == C.Element, C : Swift.Collection
}
extension UnsafeMutableRawPointer {
  @available(*, unavailable, renamed: "init(mutating:)")
  public init(_ from: UnsafeRawPointer)
  @available(*, unavailable, renamed: "init(mutating:)")
  public init?(_ from: UnsafeRawPointer?)
  @available(*, unavailable, renamed: "init(mutating:)")
  public init<T>(_ from: UnsafePointer<T>)
  @available(*, unavailable, renamed: "init(mutating:)")
  public init?<T>(_ from: UnsafePointer<T>?)
}
extension UnsafeRawPointer : _CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnsafeRawPointer.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension UnsafeMutableRawPointer : _CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnsafeMutableRawPointer.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    get
  }
}
extension UnsafePointer : _CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnsafePointer.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: PlaygroundQuickLook {
    get
  }
}
extension UnsafeMutablePointer : _CustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "UnsafeMutablePointer.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: PlaygroundQuickLook {
    get
  }
}
@available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "UnsafeBufferPointer.Iterator")
public typealias UnsafeBufferPointerIterator<T> = UnsafeBufferPointer<T>.Iterator
@available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "UnsafeRawBufferPointer.Iterator")
public typealias UnsafeRawBufferPointerIterator<T> = UnsafeBufferPointer<T>.Iterator
@available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "UnsafeRawBufferPointer.Iterator")
public typealias UnsafeMutableRawBufferPointerIterator<T> = UnsafeBufferPointer<T>.Iterator
extension UnsafeMutableRawPointer {
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "allocate(byteCount:alignment:)")
  public static func allocate(bytes size: Int, alignedTo alignment: Int) -> UnsafeMutableRawPointer
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "deallocate()", message: "Swift currently only supports freeing entire heap blocks, use deallocate() instead")
  public func deallocate(bytes _: Int, alignedTo _: Int)
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "copyMemory(from:byteCount:)")
  public func copyBytes(from source: UnsafeRawPointer, count: Int)
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "initializeMemory(as:repeating:count:)")
  @discardableResult
  public func initializeMemory<T>(as type: T.Type, at offset: Int = 0, count: Int = 1, to repeatedValue: T) -> UnsafeMutablePointer<T>
  @available(swift, deprecated: 4.1, obsoleted: 5.0, message: "it will be removed in Swift 5.0.  Please use 'UnsafeMutableRawBufferPointer.initialize(from:)' instead")
  @discardableResult
  public func initializeMemory<C>(as type: C.Element.Type, from source: C) -> UnsafeMutablePointer<C.Element> where C : Swift.Collection
}
extension UnsafeMutableRawBufferPointer {
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "allocate(byteCount:alignment:)")
  public static func allocate(count: Int) -> UnsafeMutableRawBufferPointer
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "copyMemory(from:)")
  public func copyBytes(from source: UnsafeRawBufferPointer)
}
extension Sequence {
  @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
  public func flatMap<ElementOfResult>(_ transform: (Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]
}
extension Collection {
  @available(swift, deprecated: 4.1, obsoleted: 5.0, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
  public func flatMap(_ transform: (Element) throws -> String?) rethrows -> [String]
}
extension Collection {
  @available(swift, deprecated: 5.0, renamed: "firstIndex(where:)")
  @inlinable public func index(where _predicate: (Element) throws -> Bool) rethrows -> Index? {
    return try firstIndex(where: _predicate)
  }
}
extension Collection where Self.Element : Swift.Equatable {
  @available(swift, deprecated: 5.0, renamed: "firstIndex(of:)")
  @inlinable public func index(of element: Element) -> Index? {
    return firstIndex(of: element)
  }
}
extension Zip2Sequence {
  @available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "Sequence1.Iterator")
  public typealias Stream1 = Sequence1.Iterator
  @available(swift, deprecated: 4.2, obsoleted: 5.0, renamed: "Sequence2.Iterator")
  public typealias Stream2 = Sequence2.Iterator
}
@available(swift, deprecated: 4.2, message: "PlaygroundQuickLook will be removed in a future Swift version. For customizing how types are presented in playgrounds, use CustomPlaygroundDisplayConvertible instead.")
public typealias PlaygroundQuickLook = _PlaygroundQuickLook
@_frozen public enum _PlaygroundQuickLook {
  case text(String)
  case int(Int64)
  case uInt(UInt64)
  case float(Float32)
  case double(Float64)
  case image(Any)
  case sound(Any)
  case color(Any)
  case bezierPath(Any)
  case attributedString(Any)
  case rectangle(Float64, Float64, Float64, Float64)
  case point(Float64, Float64)
  case size(Float64, Float64)
  case bool(Bool)
  case range(Int64, Int64)
  case view(Any)
  case sprite(Any)
  case url(String)
  case _raw([UInt8], String)
}
extension _PlaygroundQuickLook {
  @available(swift, deprecated: 4.2, obsoleted: 5.0, message: "PlaygroundQuickLook will be removed in a future Swift version.")
  public init(reflecting subject: Any)
}
@available(swift, deprecated: 4.2, obsoleted: 5.0, message: "CustomPlaygroundQuickLookable will be removed in a future Swift version. For customizing how types are presented in playgrounds, use CustomPlaygroundDisplayConvertible instead.")
public typealias CustomPlaygroundQuickLookable = _CustomPlaygroundQuickLookable
public protocol _CustomPlaygroundQuickLookable {
  var customPlaygroundQuickLook: _PlaygroundQuickLook { get }
}
@available(swift, deprecated: 4.2, obsoleted: 5.0, message: "_DefaultCustomPlaygroundQuickLookable will be removed in a future Swift version. For customizing how types are presented in playgrounds, use CustomPlaygroundDisplayConvertible instead.")
public typealias _DefaultCustomPlaygroundQuickLookable = __DefaultCustomPlaygroundQuickLookable
public protocol __DefaultCustomPlaygroundQuickLookable {
  var _defaultCustomPlaygroundQuickLook: _PlaygroundQuickLook { get }
}
@usableFromInline
internal let _availabilityNextMajorVersion: (Swift.Int, Swift.Int, Swift.Int)
@_semantics("availability.osversion") @inlinable public func _stdlib_isOSVersionAtLeast(_ major: Builtin.Word, _ minor: Builtin.Word, _ patch: Builtin.Word) -> Builtin.Int1 {
  // The call to _swift_stdlib_operatingSystemVersion is used as an indicator
  // that this function was called by a compiler optimization pass. If it is
  // replaced that pass needs to be updated.
  let runningVersion = _swift_stdlib_operatingSystemVersion()
  
  let queryVersion = (Int(major) == 9999
    ? _availabilityNextMajorVersion
    : (Int(major), Int(minor), Int(patch)))

  let result =
    (runningVersion.majorVersion,runningVersion.minorVersion,runningVersion.patchVersion)
    >= queryVersion

  return result._value
}
@available(OSX 10.15, iOS 13.0, *)
@_semantics("availability.osversion") @_effects(readnone) public func _stdlib_isVariantOSVersionAtLeast(_ major: Builtin.Word, _ minor: Builtin.Word, _ patch: Builtin.Word) -> Builtin.Int1
@_semantics("availability.osversion") @_effects(readnone) public func _stdlib_isOSVersionAtLeastOrVariantVersionAtLeast(_ major: Builtin.Word, _ minor: Builtin.Word, _ patch: Builtin.Word, _ variantMajor: Builtin.Word, _ variantMinor: Builtin.Word, _ variantPatch: Builtin.Word) -> Builtin.Int1
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public struct CollectionDifference<ChangeElement> {
  @_frozen public enum Change {
    case insert(offset: Int, element: ChangeElement, associatedWith: Int?)
    case remove(offset: Int, element: ChangeElement, associatedWith: Int?)
  }
  public let insertions: [Change]
  public let removals: [Change]
  public init?<Changes>(_ changes: Changes) where Changes : Swift.Collection, Changes.Element == Swift.CollectionDifference<ChangeElement>.Change
}
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension CollectionDifference : Collection {
  public typealias Element = Change
  @_fixed_layout public struct Index {
    @usableFromInline
    internal let _offset: Int
  }
  public var startIndex: Index {
    get
  }
  public var endIndex: Index {
    get
  }
  public func index(after index: Index) -> Index
  public subscript(position: Index) -> Element {
    get
  }
  public func index(before index: Index) -> Index
  public func formIndex(_ index: inout Index, offsetBy distance: Int)
  public func distance(from start: Index, to end: Index) -> Int
  public typealias Iterator = Swift.IndexingIterator<Swift.CollectionDifference<ChangeElement>>
  public typealias SubSequence = Swift.Slice<Swift.CollectionDifference<ChangeElement>>
  public typealias Indices = Swift.DefaultIndices<Swift.CollectionDifference<ChangeElement>>
}
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension CollectionDifference.Index : Equatable {
  @inlinable public static func == (lhs: CollectionDifference.Index, rhs: CollectionDifference.Index) -> Bool {
    return lhs._offset == rhs._offset
  }
}
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension CollectionDifference.Index : Comparable {
  @inlinable public static func < (lhs: CollectionDifference.Index, rhs: CollectionDifference.Index) -> Bool {
    return lhs._offset < rhs._offset
  }
}
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension CollectionDifference.Index : Hashable {
  @inlinable public func hash(into hasher: inout Hasher) {
    hasher.combine(_offset)
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension CollectionDifference.Change : Equatable where ChangeElement : Swift.Equatable {
  public static func == (a: Swift.CollectionDifference<ChangeElement>.Change, b: Swift.CollectionDifference<ChangeElement>.Change) -> Swift.Bool
}
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension CollectionDifference : Equatable where ChangeElement : Swift.Equatable {
  public static func == (a: Swift.CollectionDifference<ChangeElement>, b: Swift.CollectionDifference<ChangeElement>) -> Swift.Bool
}
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension CollectionDifference.Change : Hashable where ChangeElement : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension CollectionDifference : Hashable where ChangeElement : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension CollectionDifference where ChangeElement : Swift.Hashable {
  public func inferringMoves() -> CollectionDifference<ChangeElement>
}
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension CollectionDifference.Change : Codable where ChangeElement : Swift.Decodable, ChangeElement : Swift.Encodable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension CollectionDifference : Codable where ChangeElement : Swift.Decodable, ChangeElement : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@_fixed_layout public struct CollectionOfOne<Element> {
  @usableFromInline
  internal var _element: Element
  @inlinable public init(_ element: Element) {
    self._element = element
  }
}
extension CollectionOfOne {
  @_fixed_layout public struct Iterator {
    @usableFromInline
    internal var _elements: Element?
    @inlinable public init(_elements: Element?) {
      self._elements = _elements
    }
  }
}
extension CollectionOfOne.Iterator : IteratorProtocol {
  @inlinable mutating public func next() -> Element? {
    let result = _elements
    _elements = nil
    return result
  }
}
extension CollectionOfOne : RandomAccessCollection, MutableCollection {
  public typealias Index = Int
  public typealias Indices = Range<Int>
  public typealias SubSequence = Slice<CollectionOfOne<Element>>
  @inlinable public var startIndex: Index {
    get {
    return 0
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return 1
  }
  }
  @inlinable public func index(after i: Index) -> Index {
    _precondition(i == startIndex)
    return 1
  }
  @inlinable public func index(before i: Index) -> Index {
    _precondition(i == endIndex)
    return 0
  }
  @inlinable __consuming public func makeIterator() -> Iterator {
    return Iterator(_elements: _element)
  }
  @inlinable public subscript(position: Int) -> Element {
    _read {
      _precondition(position == 0, "Index out of range")
      yield _element
    }
    _modify {
      _precondition(position == 0, "Index out of range")
      yield &_element
    }
  }
  @inlinable public subscript(bounds: Range<Int>) -> SubSequence {
    get {
      _failEarlyRangeCheck(bounds, bounds: 0..<1)
      return Slice(base: self, bounds: bounds)
    }
    set {
      _failEarlyRangeCheck(bounds, bounds: 0..<1)
      let n = newValue.count
      _precondition(bounds.count == n, "CollectionOfOne can't be resized")
      if n == 1 { self = newValue.base }
    }
  }
  @inlinable public var count: Int {
    get {
    return 1
  }
  }
}
extension CollectionOfOne : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension CollectionOfOne : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension RangeReplaceableCollection {
  @available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public func applying(_ difference: CollectionDifference<Element>) -> Self?
}
extension BidirectionalCollection {
  @available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public func difference<C>(from other: C, by areEquivalent: (Element, C.Element) -> Bool) -> CollectionDifference<Element> where C : Swift.BidirectionalCollection, Self.Element == C.Element
}
extension BidirectionalCollection where Self.Element : Swift.Equatable {
  @available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public func difference<C>(from other: C) -> CollectionDifference<Element> where C : Swift.BidirectionalCollection, Self.Element == C.Element
}
@usableFromInline
@inline(never) internal func _abstract(file: StaticString = #file, line: UInt = #line) -> Never
@_fixed_layout public struct AnyIterator<Element> {
  @usableFromInline
  internal let _box: _AnyIteratorBoxBase<Element>
  @inlinable public init<I>(_ base: I) where Element == I.Element, I : Swift.IteratorProtocol {
    self._box = _IteratorBox(base)
  }
  @inlinable public init(_ body: @escaping () -> Element?) {
    self._box = _IteratorBox(_ClosureBasedIterator(body))
  }
  @inlinable internal init(_box: _AnyIteratorBoxBase<Element>) {
    self._box = _box
  }
}
extension AnyIterator : IteratorProtocol {
  @inlinable public func next() -> Element? {
    return _box.next()
  }
}
extension AnyIterator : Sequence {
  public typealias Iterator = Swift.AnyIterator<Element>
}
@usableFromInline
@_fixed_layout internal struct _ClosureBasedIterator<Element> : IteratorProtocol {
  @inlinable internal init(_ body: @escaping () -> Element?) {
    self._body = body
  }
  @inlinable internal func next() -> Element? { return _body() }
  @usableFromInline
  internal let _body: () -> Element?
}
@usableFromInline
@_fixed_layout internal class _AnyIteratorBoxBase<Element> : IteratorProtocol {
  @inlinable internal init() {}
  @objc @inlinable deinit {}
  @inlinable internal func next() -> Element? { _abstract() }
}
@usableFromInline
@_fixed_layout final internal class _IteratorBox<Base> : _AnyIteratorBoxBase<Base.Element> where Base : Swift.IteratorProtocol {
  @inlinable internal init(_ base: Base) { self._base = base }
  @objc @inlinable deinit {}
  @inlinable override final internal func next() -> Base.Element? { return _base.next() }
  @usableFromInline
  final internal var _base: Base
  @inlinable override internal init()
}
@usableFromInline
@_fixed_layout internal class _AnySequenceBox<Element> {
  @inlinable internal init() { }
  @inlinable internal func _makeIterator() -> AnyIterator<Element> { _abstract() }
  @inlinable internal var _underestimatedCount: Int {
    get { _abstract() }
  }
  @inlinable internal func _map<T>(_ transform: (Element) throws -> T) rethrows -> [T] {
    _abstract()
  }
  @inlinable internal func _filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element] {
    _abstract()
  }
  @inlinable internal func _forEach(_ body: (Element) throws -> Void) rethrows {
    _abstract()
  }
  @inlinable internal func __customContainsEquatableElement(_ element: Element) -> Bool? {
    _abstract()
  }
  @inlinable internal func __copyToContiguousArray() -> ContiguousArray<Element> {
    _abstract()
  }
  @inlinable internal func __copyContents(initializing buf: UnsafeMutableBufferPointer<Element>) -> (AnyIterator<Element>, UnsafeMutableBufferPointer<Element>.Index) {
    _abstract()
  }
  @objc @inlinable deinit {}
  @inlinable internal func _drop(while predicate: (Element) throws -> Bool) rethrows -> _AnySequenceBox<Element> {
    _abstract()
  }
  @inlinable internal func _dropFirst(_ n: Int) -> _AnySequenceBox<Element> {
    _abstract()
  }
  @inlinable internal func _dropLast(_ n: Int) -> [Element] {
    _abstract()
  }
  @inlinable internal func _prefix(_ maxLength: Int) -> _AnySequenceBox<Element> {
    _abstract()
  }
  @inlinable internal func _prefix(while predicate: (Element) throws -> Bool) rethrows -> [Element] {
    _abstract()
  }
  @inlinable internal func _suffix(_ maxLength: Int) -> [Element] {
    _abstract()
  }
}
@usableFromInline
@_fixed_layout internal class _AnyCollectionBox<Element> : _AnySequenceBox<Element> {
  @objc @inlinable deinit {}
  @inlinable override internal func _drop(while predicate: (Element) throws -> Bool) rethrows -> _AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _dropFirst(_ n: Int) -> _AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable internal func _dropLast(_ n: Int) -> _AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _prefix(_ maxLength: Int) -> _AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable internal func _prefix(while predicate: (Element) throws -> Bool) rethrows -> _AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable internal func _suffix(_ maxLength: Int) -> _AnyCollectionBox<Element> {
    _abstract()
  }
  @inlinable internal subscript(i: _AnyIndexBox) -> Element {
    get { _abstract() }
  }
  @inlinable internal func _index(after i: _AnyIndexBox) -> _AnyIndexBox { _abstract() }
  @inlinable internal func _formIndex(after i: _AnyIndexBox) { _abstract() }
  @inlinable internal func _index(_ i: _AnyIndexBox, offsetBy n: Int) -> _AnyIndexBox {
    _abstract()
  }
  @inlinable internal func _index(_ i: _AnyIndexBox, offsetBy n: Int, limitedBy limit: _AnyIndexBox) -> _AnyIndexBox? {
    _abstract()
  }
  @inlinable internal func _formIndex(_ i: inout _AnyIndexBox, offsetBy n: Int) {
    _abstract()
  }
  @inlinable internal func _formIndex(_ i: inout _AnyIndexBox, offsetBy n: Int, limitedBy limit: _AnyIndexBox) -> Bool {
    _abstract()
  }
  @inlinable internal func _distance(from start: _AnyIndexBox, to end: _AnyIndexBox) -> Int {
    _abstract()
  }
  @inlinable internal var _count: Int {
    get { _abstract() }
  }
  @inlinable internal init(_startIndex: _AnyIndexBox, endIndex: _AnyIndexBox) {
    self._startIndex = _startIndex
    self._endIndex = endIndex
  }
  @usableFromInline
  final internal let _startIndex: _AnyIndexBox
  @usableFromInline
  final internal let _endIndex: _AnyIndexBox
  @inlinable internal subscript(start start: _AnyIndexBox, end end: _AnyIndexBox) -> _AnyCollectionBox<Element> {
    get { _abstract() }
  }
  @inlinable override internal init()
}
@usableFromInline
@_fixed_layout internal class _AnyBidirectionalCollectionBox<Element> : _AnyCollectionBox<Element> {
  @objc @inlinable deinit {}
  @inlinable override internal func _drop(while predicate: (Element) throws -> Bool) rethrows -> _AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _dropFirst(_ n: Int) -> _AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _dropLast(_ n: Int) -> _AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _prefix(_ maxLength: Int) -> _AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _prefix(while predicate: (Element) throws -> Bool) rethrows -> _AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _suffix(_ maxLength: Int) -> _AnyBidirectionalCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal subscript(start start: _AnyIndexBox, end end: _AnyIndexBox) -> _AnyBidirectionalCollectionBox<Element> {
    get { _abstract() }
  }
  @inlinable internal func _index(before i: _AnyIndexBox) -> _AnyIndexBox { _abstract() }
  @inlinable internal func _formIndex(before i: _AnyIndexBox) { _abstract() }
  @inlinable override internal init(_startIndex: _AnyIndexBox, endIndex: _AnyIndexBox)
}
@usableFromInline
@_fixed_layout internal class _AnyRandomAccessCollectionBox<Element> : _AnyBidirectionalCollectionBox<Element> {
  @objc @inlinable deinit {}
  @inlinable override internal func _drop(while predicate: (Element) throws -> Bool) rethrows -> _AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _dropFirst(_ n: Int) -> _AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _dropLast(_ n: Int) -> _AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _prefix(_ maxLength: Int) -> _AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _prefix(while predicate: (Element) throws -> Bool) rethrows -> _AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal func _suffix(_ maxLength: Int) -> _AnyRandomAccessCollectionBox<Element> {
    _abstract()
  }
  @inlinable override internal subscript(start start: _AnyIndexBox, end end: _AnyIndexBox) -> _AnyRandomAccessCollectionBox<Element> {
    get { _abstract() }
  }
  @inlinable override internal init(_startIndex: _AnyIndexBox, endIndex: _AnyIndexBox)
}
@usableFromInline
@_fixed_layout final internal class _SequenceBox<S> : _AnySequenceBox<S.Element> where S : Swift.Sequence {
  @usableFromInline
  internal typealias Element = S.Element
  @inline(__always) @inlinable override final internal func _makeIterator() -> AnyIterator<Element> {
    return AnyIterator(_base.makeIterator())
  }
  @inlinable override final internal var _underestimatedCount: Int {
    get {
    return _base.underestimatedCount
  }
  }
  @inlinable override final internal func _map<T>(_ transform: (Element) throws -> T) rethrows -> [T] {
    return try _base.map(transform)
  }
  @inlinable override final internal func _filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element] {
    return try _base.filter(isIncluded)
  }
  @inlinable override final internal func _forEach(_ body: (Element) throws -> Void) rethrows {
    return try _base.forEach(body)
  }
  @inlinable override final internal func __customContainsEquatableElement(_ element: Element) -> Bool? {
    return _base._customContainsEquatableElement(element)
  }
  @inlinable override final internal func __copyToContiguousArray() -> ContiguousArray<Element> {
    return _base._copyToContiguousArray()
  }
  @inlinable override final internal func __copyContents(initializing buf: UnsafeMutableBufferPointer<Element>) -> (AnyIterator<Element>, UnsafeMutableBufferPointer<Element>.Index) {
    let (it,idx) = _base._copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
  @inlinable override final internal func _dropFirst(_ n: Int) -> _AnySequenceBox<Element> {
    return _SequenceBox<DropFirstSequence<S>>(_base: _base.dropFirst(n))
  }
  @inlinable override final internal func _drop(while predicate: (Element) throws -> Bool) rethrows -> _AnySequenceBox<Element> {
    return try _SequenceBox<DropWhileSequence<S>>(_base: _base.drop(while: predicate))
  }
  @inlinable override final internal func _dropLast(_ n: Int) -> [Element] {
    return _base.dropLast(n)
  }
  @inlinable override final internal func _prefix(_ n: Int) -> _AnySequenceBox<Element> {
    return _SequenceBox<PrefixSequence<S>>(_base: _base.prefix(n))
  }
  @inlinable override final internal func _prefix(while predicate: (Element) throws -> Bool) rethrows -> [Element] {
    return try _base.prefix(while: predicate)
  }
  @inlinable override final internal func _suffix(_ maxLength: Int) -> [Element] {
    return _base.suffix(maxLength)
  }
  @objc @inlinable deinit {}
  @inlinable internal init(_base: S) {
    self._base = _base
  }
  @usableFromInline
  final internal var _base: S
  @inlinable override internal init()
}
@usableFromInline
@_fixed_layout final internal class _CollectionBox<S> : _AnyCollectionBox<S.Element> where S : Swift.Collection {
  @usableFromInline
  internal typealias Element = S.Element
  @inline(__always) @inlinable override final internal func _makeIterator() -> AnyIterator<Element> {
    return AnyIterator(_base.makeIterator())
  }
  @inlinable override final internal var _underestimatedCount: Int {
    get {
    return _base.underestimatedCount
  }
  }
  @inlinable override final internal func _map<T>(_ transform: (Element) throws -> T) rethrows -> [T] {
    return try _base.map(transform)
  }
  @inlinable override final internal func _filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element] {
    return try _base.filter(isIncluded)
  }
  @inlinable override final internal func _forEach(_ body: (Element) throws -> Void) rethrows {
    return try _base.forEach(body)
  }
  @inlinable override final internal func __customContainsEquatableElement(_ element: Element) -> Bool? {
    return _base._customContainsEquatableElement(element)
  }
  @inlinable override final internal func __copyToContiguousArray() -> ContiguousArray<Element> {
    return _base._copyToContiguousArray()
  }
  @inlinable override final internal func __copyContents(initializing buf: UnsafeMutableBufferPointer<Element>) -> (AnyIterator<Element>, UnsafeMutableBufferPointer<Element>.Index) {
    let (it,idx) = _base._copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
  @inline(__always) @inlinable override final internal func _drop(while predicate: (Element) throws -> Bool) rethrows -> _AnyCollectionBox<Element> {
    return try _CollectionBox<S.SubSequence>(_base: _base.drop(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _dropFirst(_ n: Int) -> _AnyCollectionBox<Element> {
    return _CollectionBox<S.SubSequence>(_base: _base.dropFirst(n))
  }
  @inline(__always) @inlinable override final internal func _dropLast(_ n: Int) -> _AnyCollectionBox<Element> {
    return _CollectionBox<S.SubSequence>(_base: _base.dropLast(n))
  }
  @inline(__always) @inlinable override final internal func _prefix(while predicate: (Element) throws -> Bool) rethrows -> _AnyCollectionBox<Element> {
    return try _CollectionBox<S.SubSequence>(_base: _base.prefix(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _prefix(_ maxLength: Int) -> _AnyCollectionBox<Element> {
    return _CollectionBox<S.SubSequence>(_base: _base.prefix(maxLength))
  }
  @inline(__always) @inlinable override final internal func _suffix(_ maxLength: Int) -> _AnyCollectionBox<Element> {
    return _CollectionBox<S.SubSequence>(_base: _base.suffix(maxLength))
  }
  @objc @inlinable deinit {}
  @inlinable internal init(_base: S) {
    self._base = _base
    super.init(
      _startIndex: _IndexBox(_base: _base.startIndex),
      endIndex: _IndexBox(_base: _base.endIndex))
  }
  @inlinable final internal func _unbox(_ position: _AnyIndexBox, file: StaticString = #file, line: UInt = #line) -> S.Index {
    if let i = position._unbox() as S.Index? {
      return i
    }
    fatalError("Index type mismatch!", file: file, line: line)
  }
  @inlinable override final internal subscript(position: _AnyIndexBox) -> Element {
    get {
    return _base[_unbox(position)]
  }
  }
  @inlinable override final internal subscript(start start: _AnyIndexBox, end end: _AnyIndexBox) -> _AnyCollectionBox<Element> {
    get {
    return _CollectionBox<S.SubSequence>(_base:
      _base[_unbox(start)..<_unbox(end)]
    )
  }
  }
  @inlinable override final internal func _index(after position: _AnyIndexBox) -> _AnyIndexBox {
    return _IndexBox(_base: _base.index(after: _unbox(position)))
  }
  @inlinable override final internal func _formIndex(after position: _AnyIndexBox) {
    if let p = position as? _IndexBox<S.Index> {
      return _base.formIndex(after: &p._base)
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _index(_ i: _AnyIndexBox, offsetBy n: Int) -> _AnyIndexBox {
    return _IndexBox(_base: _base.index(_unbox(i), offsetBy: numericCast(n)))
  }
  @inlinable override final internal func _index(_ i: _AnyIndexBox, offsetBy n: Int, limitedBy limit: _AnyIndexBox) -> _AnyIndexBox? {
    return _base.index(
        _unbox(i),
        offsetBy: numericCast(n),
        limitedBy: _unbox(limit))
      .map { _IndexBox(_base: $0) }
  }
  @inlinable override final internal func _formIndex(_ i: inout _AnyIndexBox, offsetBy n: Int) {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(&box._base, offsetBy: numericCast(n))
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _formIndex(_ i: inout _AnyIndexBox, offsetBy n: Int, limitedBy limit: _AnyIndexBox) -> Bool {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(
        &box._base,
        offsetBy: numericCast(n),
        limitedBy: _unbox(limit))
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _distance(from start: _AnyIndexBox, to end: _AnyIndexBox) -> Int {
    return numericCast(_base.distance(from: _unbox(start), to: _unbox(end)))
  }
  @inlinable override final internal var _count: Int {
    get {
    return numericCast(_base.count)
  }
  }
  @usableFromInline
  final internal var _base: S
  @inlinable override internal init(_startIndex: _AnyIndexBox, endIndex: _AnyIndexBox)
}
@usableFromInline
@_fixed_layout final internal class _BidirectionalCollectionBox<S> : _AnyBidirectionalCollectionBox<S.Element> where S : Swift.BidirectionalCollection {
  @usableFromInline
  internal typealias Element = S.Element
  @inline(__always) @inlinable override final internal func _makeIterator() -> AnyIterator<Element> {
    return AnyIterator(_base.makeIterator())
  }
  @inlinable override final internal var _underestimatedCount: Int {
    get {
    return _base.underestimatedCount
  }
  }
  @inlinable override final internal func _map<T>(_ transform: (Element) throws -> T) rethrows -> [T] {
    return try _base.map(transform)
  }
  @inlinable override final internal func _filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element] {
    return try _base.filter(isIncluded)
  }
  @inlinable override final internal func _forEach(_ body: (Element) throws -> Void) rethrows {
    return try _base.forEach(body)
  }
  @inlinable override final internal func __customContainsEquatableElement(_ element: Element) -> Bool? {
    return _base._customContainsEquatableElement(element)
  }
  @inlinable override final internal func __copyToContiguousArray() -> ContiguousArray<Element> {
    return _base._copyToContiguousArray()
  }
  @inlinable override final internal func __copyContents(initializing buf: UnsafeMutableBufferPointer<Element>) -> (AnyIterator<Element>, UnsafeMutableBufferPointer<Element>.Index) {
    let (it,idx) = _base._copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
  @inline(__always) @inlinable override final internal func _drop(while predicate: (Element) throws -> Bool) rethrows -> _AnyBidirectionalCollectionBox<Element> {
    return try _BidirectionalCollectionBox<S.SubSequence>(_base: _base.drop(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _dropFirst(_ n: Int) -> _AnyBidirectionalCollectionBox<Element> {
    return _BidirectionalCollectionBox<S.SubSequence>(_base: _base.dropFirst(n))
  }
  @inline(__always) @inlinable override final internal func _dropLast(_ n: Int) -> _AnyBidirectionalCollectionBox<Element> {
    return _BidirectionalCollectionBox<S.SubSequence>(_base: _base.dropLast(n))
  }
  @inline(__always) @inlinable override final internal func _prefix(while predicate: (Element) throws -> Bool) rethrows -> _AnyBidirectionalCollectionBox<Element> {
    return try _BidirectionalCollectionBox<S.SubSequence>(_base: _base.prefix(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _prefix(_ maxLength: Int) -> _AnyBidirectionalCollectionBox<Element> {
    return _BidirectionalCollectionBox<S.SubSequence>(_base: _base.prefix(maxLength))
  }
  @inline(__always) @inlinable override final internal func _suffix(_ maxLength: Int) -> _AnyBidirectionalCollectionBox<Element> {
    return _BidirectionalCollectionBox<S.SubSequence>(_base: _base.suffix(maxLength))
  }
  @objc @inlinable deinit {}
  @inlinable internal init(_base: S) {
    self._base = _base
    super.init(
      _startIndex: _IndexBox(_base: _base.startIndex),
      endIndex: _IndexBox(_base: _base.endIndex))
  }
  @inlinable final internal func _unbox(_ position: _AnyIndexBox, file: StaticString = #file, line: UInt = #line) -> S.Index {
    if let i = position._unbox() as S.Index? {
      return i
    }
    fatalError("Index type mismatch!", file: file, line: line)
  }
  @inlinable override final internal subscript(position: _AnyIndexBox) -> Element {
    get {
    return _base[_unbox(position)]
  }
  }
  @inlinable override final internal subscript(start start: _AnyIndexBox, end end: _AnyIndexBox) -> _AnyBidirectionalCollectionBox<Element> {
    get {
    return _BidirectionalCollectionBox<S.SubSequence>(_base:
      _base[_unbox(start)..<_unbox(end)]
    )
  }
  }
  @inlinable override final internal func _index(after position: _AnyIndexBox) -> _AnyIndexBox {
    return _IndexBox(_base: _base.index(after: _unbox(position)))
  }
  @inlinable override final internal func _formIndex(after position: _AnyIndexBox) {
    if let p = position as? _IndexBox<S.Index> {
      return _base.formIndex(after: &p._base)
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _index(_ i: _AnyIndexBox, offsetBy n: Int) -> _AnyIndexBox {
    return _IndexBox(_base: _base.index(_unbox(i), offsetBy: numericCast(n)))
  }
  @inlinable override final internal func _index(_ i: _AnyIndexBox, offsetBy n: Int, limitedBy limit: _AnyIndexBox) -> _AnyIndexBox? {
    return _base.index(
        _unbox(i),
        offsetBy: numericCast(n),
        limitedBy: _unbox(limit))
      .map { _IndexBox(_base: $0) }
  }
  @inlinable override final internal func _formIndex(_ i: inout _AnyIndexBox, offsetBy n: Int) {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(&box._base, offsetBy: numericCast(n))
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _formIndex(_ i: inout _AnyIndexBox, offsetBy n: Int, limitedBy limit: _AnyIndexBox) -> Bool {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(
        &box._base,
        offsetBy: numericCast(n),
        limitedBy: _unbox(limit))
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _distance(from start: _AnyIndexBox, to end: _AnyIndexBox) -> Int {
    return numericCast(_base.distance(from: _unbox(start), to: _unbox(end)))
  }
  @inlinable override final internal var _count: Int {
    get {
    return numericCast(_base.count)
  }
  }
  @inlinable override final internal func _index(before position: _AnyIndexBox) -> _AnyIndexBox {
    return _IndexBox(_base: _base.index(before: _unbox(position)))
  }
  @inlinable override final internal func _formIndex(before position: _AnyIndexBox) {
    if let p = position as? _IndexBox<S.Index> {
      return _base.formIndex(before: &p._base)
    }
    fatalError("Index type mismatch!")
  }
  @usableFromInline
  final internal var _base: S
  @inlinable override internal init(_startIndex: _AnyIndexBox, endIndex: _AnyIndexBox)
}
@usableFromInline
@_fixed_layout final internal class _RandomAccessCollectionBox<S> : _AnyRandomAccessCollectionBox<S.Element> where S : Swift.RandomAccessCollection {
  @usableFromInline
  internal typealias Element = S.Element
  @inline(__always) @inlinable override final internal func _makeIterator() -> AnyIterator<Element> {
    return AnyIterator(_base.makeIterator())
  }
  @inlinable override final internal var _underestimatedCount: Int {
    get {
    return _base.underestimatedCount
  }
  }
  @inlinable override final internal func _map<T>(_ transform: (Element) throws -> T) rethrows -> [T] {
    return try _base.map(transform)
  }
  @inlinable override final internal func _filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element] {
    return try _base.filter(isIncluded)
  }
  @inlinable override final internal func _forEach(_ body: (Element) throws -> Void) rethrows {
    return try _base.forEach(body)
  }
  @inlinable override final internal func __customContainsEquatableElement(_ element: Element) -> Bool? {
    return _base._customContainsEquatableElement(element)
  }
  @inlinable override final internal func __copyToContiguousArray() -> ContiguousArray<Element> {
    return _base._copyToContiguousArray()
  }
  @inlinable override final internal func __copyContents(initializing buf: UnsafeMutableBufferPointer<Element>) -> (AnyIterator<Element>, UnsafeMutableBufferPointer<Element>.Index) {
    let (it,idx) = _base._copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
  @inline(__always) @inlinable override final internal func _drop(while predicate: (Element) throws -> Bool) rethrows -> _AnyRandomAccessCollectionBox<Element> {
    return try _RandomAccessCollectionBox<S.SubSequence>(_base: _base.drop(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _dropFirst(_ n: Int) -> _AnyRandomAccessCollectionBox<Element> {
    return _RandomAccessCollectionBox<S.SubSequence>(_base: _base.dropFirst(n))
  }
  @inline(__always) @inlinable override final internal func _dropLast(_ n: Int) -> _AnyRandomAccessCollectionBox<Element> {
    return _RandomAccessCollectionBox<S.SubSequence>(_base: _base.dropLast(n))
  }
  @inline(__always) @inlinable override final internal func _prefix(while predicate: (Element) throws -> Bool) rethrows -> _AnyRandomAccessCollectionBox<Element> {
    return try _RandomAccessCollectionBox<S.SubSequence>(_base: _base.prefix(while: predicate))
  }
  @inline(__always) @inlinable override final internal func _prefix(_ maxLength: Int) -> _AnyRandomAccessCollectionBox<Element> {
    return _RandomAccessCollectionBox<S.SubSequence>(_base: _base.prefix(maxLength))
  }
  @inline(__always) @inlinable override final internal func _suffix(_ maxLength: Int) -> _AnyRandomAccessCollectionBox<Element> {
    return _RandomAccessCollectionBox<S.SubSequence>(_base: _base.suffix(maxLength))
  }
  @objc @inlinable deinit {}
  @inlinable internal init(_base: S) {
    self._base = _base
    super.init(
      _startIndex: _IndexBox(_base: _base.startIndex),
      endIndex: _IndexBox(_base: _base.endIndex))
  }
  @inlinable final internal func _unbox(_ position: _AnyIndexBox, file: StaticString = #file, line: UInt = #line) -> S.Index {
    if let i = position._unbox() as S.Index? {
      return i
    }
    fatalError("Index type mismatch!", file: file, line: line)
  }
  @inlinable override final internal subscript(position: _AnyIndexBox) -> Element {
    get {
    return _base[_unbox(position)]
  }
  }
  @inlinable override final internal subscript(start start: _AnyIndexBox, end end: _AnyIndexBox) -> _AnyRandomAccessCollectionBox<Element> {
    get {
    return _RandomAccessCollectionBox<S.SubSequence>(_base:
      _base[_unbox(start)..<_unbox(end)]
    )
  }
  }
  @inlinable override final internal func _index(after position: _AnyIndexBox) -> _AnyIndexBox {
    return _IndexBox(_base: _base.index(after: _unbox(position)))
  }
  @inlinable override final internal func _formIndex(after position: _AnyIndexBox) {
    if let p = position as? _IndexBox<S.Index> {
      return _base.formIndex(after: &p._base)
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _index(_ i: _AnyIndexBox, offsetBy n: Int) -> _AnyIndexBox {
    return _IndexBox(_base: _base.index(_unbox(i), offsetBy: numericCast(n)))
  }
  @inlinable override final internal func _index(_ i: _AnyIndexBox, offsetBy n: Int, limitedBy limit: _AnyIndexBox) -> _AnyIndexBox? {
    return _base.index(
        _unbox(i),
        offsetBy: numericCast(n),
        limitedBy: _unbox(limit))
      .map { _IndexBox(_base: $0) }
  }
  @inlinable override final internal func _formIndex(_ i: inout _AnyIndexBox, offsetBy n: Int) {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(&box._base, offsetBy: numericCast(n))
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _formIndex(_ i: inout _AnyIndexBox, offsetBy n: Int, limitedBy limit: _AnyIndexBox) -> Bool {
    if let box = i as? _IndexBox<S.Index> {
      return _base.formIndex(
        &box._base,
        offsetBy: numericCast(n),
        limitedBy: _unbox(limit))
    }
    fatalError("Index type mismatch!")
  }
  @inlinable override final internal func _distance(from start: _AnyIndexBox, to end: _AnyIndexBox) -> Int {
    return numericCast(_base.distance(from: _unbox(start), to: _unbox(end)))
  }
  @inlinable override final internal var _count: Int {
    get {
    return numericCast(_base.count)
  }
  }
  @inlinable override final internal func _index(before position: _AnyIndexBox) -> _AnyIndexBox {
    return _IndexBox(_base: _base.index(before: _unbox(position)))
  }
  @inlinable override final internal func _formIndex(before position: _AnyIndexBox) {
    if let p = position as? _IndexBox<S.Index> {
      return _base.formIndex(before: &p._base)
    }
    fatalError("Index type mismatch!")
  }
  @usableFromInline
  final internal var _base: S
  @inlinable override internal init(_startIndex: _AnyIndexBox, endIndex: _AnyIndexBox)
}
@usableFromInline
@_fixed_layout internal struct _ClosureBasedSequence<Iterator> where Iterator : Swift.IteratorProtocol {
  @usableFromInline
  internal var _makeUnderlyingIterator: () -> Iterator
  @inlinable internal init(_ makeUnderlyingIterator: @escaping () -> Iterator) {
    self._makeUnderlyingIterator = makeUnderlyingIterator
  }
}
extension _ClosureBasedSequence : Sequence {
  @inlinable internal func makeIterator() -> Iterator {
    return _makeUnderlyingIterator()
  }
  @usableFromInline
  internal typealias Element = Iterator.Element
}
@_fixed_layout public struct AnySequence<Element> {
  @usableFromInline
  internal let _box: _AnySequenceBox<Element>
  @inlinable public init<I>(_ makeUnderlyingIterator: @escaping () -> I) where Element == I.Element, I : Swift.IteratorProtocol {
    self.init(_ClosureBasedSequence(makeUnderlyingIterator))
  }
  @inlinable internal init(_box: _AnySequenceBox<Element>) {
    self._box = _box
  }
}
extension AnySequence : Sequence {
  public typealias Iterator = AnyIterator<Element>
  @inlinable public init<S>(_ base: S) where Element == S.Element, S : Swift.Sequence {
    self._box = _SequenceBox(_base: base)
  }
}
extension AnySequence {
  @inline(__always) @inlinable __consuming public func makeIterator() -> Iterator {
    return _box._makeIterator()
  }
  @inlinable __consuming public func dropLast(_ n: Int = 1) -> [Element] {
    return _box._dropLast(n)
  }
  @inlinable __consuming public func prefix(while predicate: (Element) throws -> Bool) rethrows -> [Element] {
    return try _box._prefix(while: predicate)
  }
  @inlinable __consuming public func suffix(_ maxLength: Int) -> [Element] {
    return _box._suffix(maxLength)
  }
  @inlinable public var underestimatedCount: Int {
    get {
    return _box._underestimatedCount
  }
  }
  @inlinable public func map<T>(_ transform: (Element) throws -> T) rethrows -> [T] {
    return try _box._map(transform)
  }
  @inlinable __consuming public func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element] {
    return try _box._filter(isIncluded)
  }
  @inlinable __consuming public func forEach(_ body: (Element) throws -> Void) rethrows {
    return try _box._forEach(body)
  }
  @inlinable __consuming public func drop(while predicate: (Element) throws -> Bool) rethrows -> AnySequence<Element> {
    return try AnySequence(_box: _box._drop(while: predicate))
  }
  @inlinable __consuming public func dropFirst(_ n: Int = 1) -> AnySequence<Element> {
    return AnySequence(_box: _box._dropFirst(n))
  }
  @inlinable __consuming public func prefix(_ maxLength: Int = 1) -> AnySequence<Element> {
    return AnySequence(_box: _box._prefix(maxLength))
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Bool? {
    return _box.__customContainsEquatableElement(element)
  }
  @inlinable __consuming public func _copyToContiguousArray() -> ContiguousArray<Element> {
    return self._box.__copyToContiguousArray()
  }
  @inlinable __consuming public func _copyContents(initializing buf: UnsafeMutableBufferPointer<Element>) -> (AnyIterator<Element>, UnsafeMutableBufferPointer<Element>.Index) {
    let (it,idx) = _box.__copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
}
extension AnyCollection {
  @inline(__always) @inlinable __consuming public func makeIterator() -> Iterator {
    return _box._makeIterator()
  }
  @inlinable __consuming public func dropLast(_ n: Int = 1) -> AnyCollection<Element> {
    return AnyCollection(_box: _box._dropLast(n))
  }
  @inlinable __consuming public func prefix(while predicate: (Element) throws -> Bool) rethrows -> AnyCollection<Element> {
    return try AnyCollection(_box: _box._prefix(while: predicate))
  }
  @inlinable __consuming public func suffix(_ maxLength: Int) -> AnyCollection<Element> {
    return AnyCollection(_box: _box._suffix(maxLength))
  }
  @inlinable public var underestimatedCount: Int {
    get {
    return _box._underestimatedCount
  }
  }
  @inlinable public func map<T>(_ transform: (Element) throws -> T) rethrows -> [T] {
    return try _box._map(transform)
  }
  @inlinable __consuming public func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element] {
    return try _box._filter(isIncluded)
  }
  @inlinable __consuming public func forEach(_ body: (Element) throws -> Void) rethrows {
    return try _box._forEach(body)
  }
  @inlinable __consuming public func drop(while predicate: (Element) throws -> Bool) rethrows -> AnyCollection<Element> {
    return try AnyCollection(_box: _box._drop(while: predicate))
  }
  @inlinable __consuming public func dropFirst(_ n: Int = 1) -> AnyCollection<Element> {
    return AnyCollection(_box: _box._dropFirst(n))
  }
  @inlinable __consuming public func prefix(_ maxLength: Int = 1) -> AnyCollection<Element> {
    return AnyCollection(_box: _box._prefix(maxLength))
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Bool? {
    return _box.__customContainsEquatableElement(element)
  }
  @inlinable __consuming public func _copyToContiguousArray() -> ContiguousArray<Element> {
    return self._box.__copyToContiguousArray()
  }
  @inlinable __consuming public func _copyContents(initializing buf: UnsafeMutableBufferPointer<Element>) -> (AnyIterator<Element>, UnsafeMutableBufferPointer<Element>.Index) {
    let (it,idx) = _box.__copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
}
extension AnyBidirectionalCollection {
  @inline(__always) @inlinable __consuming public func makeIterator() -> Iterator {
    return _box._makeIterator()
  }
  @inlinable __consuming public func dropLast(_ n: Int = 1) -> AnyBidirectionalCollection<Element> {
    return AnyBidirectionalCollection(_box: _box._dropLast(n))
  }
  @inlinable __consuming public func prefix(while predicate: (Element) throws -> Bool) rethrows -> AnyBidirectionalCollection<Element> {
    return try AnyBidirectionalCollection(_box: _box._prefix(while: predicate))
  }
  @inlinable __consuming public func suffix(_ maxLength: Int) -> AnyBidirectionalCollection<Element> {
    return AnyBidirectionalCollection(_box: _box._suffix(maxLength))
  }
  @inlinable public var underestimatedCount: Int {
    get {
    return _box._underestimatedCount
  }
  }
  @inlinable public func map<T>(_ transform: (Element) throws -> T) rethrows -> [T] {
    return try _box._map(transform)
  }
  @inlinable __consuming public func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element] {
    return try _box._filter(isIncluded)
  }
  @inlinable __consuming public func forEach(_ body: (Element) throws -> Void) rethrows {
    return try _box._forEach(body)
  }
  @inlinable __consuming public func drop(while predicate: (Element) throws -> Bool) rethrows -> AnyBidirectionalCollection<Element> {
    return try AnyBidirectionalCollection(_box: _box._drop(while: predicate))
  }
  @inlinable __consuming public func dropFirst(_ n: Int = 1) -> AnyBidirectionalCollection<Element> {
    return AnyBidirectionalCollection(_box: _box._dropFirst(n))
  }
  @inlinable __consuming public func prefix(_ maxLength: Int = 1) -> AnyBidirectionalCollection<Element> {
    return AnyBidirectionalCollection(_box: _box._prefix(maxLength))
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Bool? {
    return _box.__customContainsEquatableElement(element)
  }
  @inlinable __consuming public func _copyToContiguousArray() -> ContiguousArray<Element> {
    return self._box.__copyToContiguousArray()
  }
  @inlinable __consuming public func _copyContents(initializing buf: UnsafeMutableBufferPointer<Element>) -> (AnyIterator<Element>, UnsafeMutableBufferPointer<Element>.Index) {
    let (it,idx) = _box.__copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
}
extension AnyRandomAccessCollection {
  @inline(__always) @inlinable __consuming public func makeIterator() -> Iterator {
    return _box._makeIterator()
  }
  @inlinable __consuming public func dropLast(_ n: Int = 1) -> AnyRandomAccessCollection<Element> {
    return AnyRandomAccessCollection(_box: _box._dropLast(n))
  }
  @inlinable __consuming public func prefix(while predicate: (Element) throws -> Bool) rethrows -> AnyRandomAccessCollection<Element> {
    return try AnyRandomAccessCollection(_box: _box._prefix(while: predicate))
  }
  @inlinable __consuming public func suffix(_ maxLength: Int) -> AnyRandomAccessCollection<Element> {
    return AnyRandomAccessCollection(_box: _box._suffix(maxLength))
  }
  @inlinable public var underestimatedCount: Int {
    get {
    return _box._underestimatedCount
  }
  }
  @inlinable public func map<T>(_ transform: (Element) throws -> T) rethrows -> [T] {
    return try _box._map(transform)
  }
  @inlinable __consuming public func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element] {
    return try _box._filter(isIncluded)
  }
  @inlinable __consuming public func forEach(_ body: (Element) throws -> Void) rethrows {
    return try _box._forEach(body)
  }
  @inlinable __consuming public func drop(while predicate: (Element) throws -> Bool) rethrows -> AnyRandomAccessCollection<Element> {
    return try AnyRandomAccessCollection(_box: _box._drop(while: predicate))
  }
  @inlinable __consuming public func dropFirst(_ n: Int = 1) -> AnyRandomAccessCollection<Element> {
    return AnyRandomAccessCollection(_box: _box._dropFirst(n))
  }
  @inlinable __consuming public func prefix(_ maxLength: Int = 1) -> AnyRandomAccessCollection<Element> {
    return AnyRandomAccessCollection(_box: _box._prefix(maxLength))
  }
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Bool? {
    return _box.__customContainsEquatableElement(element)
  }
  @inlinable __consuming public func _copyToContiguousArray() -> ContiguousArray<Element> {
    return self._box.__copyToContiguousArray()
  }
  @inlinable __consuming public func _copyContents(initializing buf: UnsafeMutableBufferPointer<Element>) -> (AnyIterator<Element>, UnsafeMutableBufferPointer<Element>.Index) {
    let (it,idx) = _box.__copyContents(initializing: buf)
    return (AnyIterator(it),idx)
  }
}
@usableFromInline
internal protocol _AnyIndexBox : AnyObject {
  var _typeID: ObjectIdentifier { get }
  func _unbox<T>() -> T? where T : Swift.Comparable
  func _isEqual(to rhs: _AnyIndexBox) -> Bool
  func _isLess(than rhs: _AnyIndexBox) -> Bool
}
@usableFromInline
@_fixed_layout final internal class _IndexBox<BaseIndex> : _AnyIndexBox where BaseIndex : Swift.Comparable {
  @usableFromInline
  final internal var _base: BaseIndex
  @inlinable internal init(_base: BaseIndex) {
    self._base = _base
  }
  @inlinable final internal func _unsafeUnbox(_ other: _AnyIndexBox) -> BaseIndex {
    return unsafeDowncast(other, to: _IndexBox.self)._base
  }
  @inlinable final internal var _typeID: ObjectIdentifier {
    get {
    return ObjectIdentifier(type(of: self))
  }
  }
  @inlinable final internal func _unbox<T>() -> T? where T : Swift.Comparable {
    return (self as _AnyIndexBox as? _IndexBox<T>)?._base
  }
  @inlinable final internal func _isEqual(to rhs: _AnyIndexBox) -> Bool {
    return _base == _unsafeUnbox(rhs)
  }
  @inlinable final internal func _isLess(than rhs: _AnyIndexBox) -> Bool {
    return _base < _unsafeUnbox(rhs)
  }
  @objc @usableFromInline
  deinit
}
@_fixed_layout public struct AnyIndex {
  @usableFromInline
  internal var _box: _AnyIndexBox
  @inlinable public init<BaseIndex>(_ base: BaseIndex) where BaseIndex : Swift.Comparable {
    self._box = _IndexBox(_base: base)
  }
  @inlinable internal init(_box: _AnyIndexBox) {
    self._box = _box
  }
  @inlinable internal var _typeID: ObjectIdentifier {
    get {
    return _box._typeID
  }
  }
}
extension AnyIndex : Comparable {
  @inlinable public static func == (lhs: AnyIndex, rhs: AnyIndex) -> Bool {
    _precondition(lhs._typeID == rhs._typeID, "Base index types differ")
    return lhs._box._isEqual(to: rhs._box)
  }
  @inlinable public static func < (lhs: AnyIndex, rhs: AnyIndex) -> Bool {
    _precondition(lhs._typeID == rhs._typeID, "Base index types differ")
    return lhs._box._isLess(than: rhs._box)
  }
}
public protocol _AnyCollectionProtocol : Swift.Collection {
  var _boxID: ObjectIdentifier { get }
}
@_fixed_layout public struct AnyCollection<Element> {
  @usableFromInline
  internal let _box: _AnyCollectionBox<Element>
  @inlinable internal init(_box: _AnyCollectionBox<Element>) {
    self._box = _box
  }
}
extension AnyCollection : Collection {
  public typealias Indices = DefaultIndices<AnyCollection>
  public typealias Iterator = AnyIterator<Element>
  public typealias Index = AnyIndex
  public typealias SubSequence = AnyCollection<Element>
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.Collection {
    // Traversal: Forward
    // SubTraversal: Forward
    self._box = _CollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: AnyCollection<Element>) {
    self._box = other._box
  }
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.BidirectionalCollection {
    // Traversal: Forward
    // SubTraversal: Bidirectional
    self._box = _BidirectionalCollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: AnyBidirectionalCollection<Element>) {
    self._box = other._box
  }
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.RandomAccessCollection {
    // Traversal: Forward
    // SubTraversal: RandomAccess
    self._box = _RandomAccessCollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: AnyRandomAccessCollection<Element>) {
    self._box = other._box
  }
  @inlinable public var startIndex: Index {
    get {
    return AnyIndex(_box: _box._startIndex)
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return AnyIndex(_box: _box._endIndex)
  }
  }
  @inlinable public subscript(position: Index) -> Element {
    get {
    return _box[position._box]
  }
  }
  @inlinable public subscript(bounds: Range<Index>) -> SubSequence {
    get {
    return AnyCollection(_box:
      _box[start: bounds.lowerBound._box, end: bounds.upperBound._box])
  }
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Index, bounds: Range<Index>) {
    // Do nothing.  Doing a range check would involve unboxing indices,
    // performing dynamic dispatch etc.  This seems to be too costly for a fast
    // range check for QoI purposes.
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Range<Index>, bounds: Range<Index>) {
    // Do nothing.  Doing a range check would involve unboxing indices,
    // performing dynamic dispatch etc.  This seems to be too costly for a fast
    // range check for QoI purposes.
  }
  @inlinable public func index(after i: Index) -> Index {
    return AnyIndex(_box: _box._index(after: i._box))
  }
  @inlinable public func formIndex(after i: inout Index) {
    if _isUnique(&i._box) {
      _box._formIndex(after: i._box)
    }
    else {
      i = index(after: i)
    }
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int) -> Index {
    return AnyIndex(_box: _box._index(i._box, offsetBy: n))
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index? {
    return _box._index(i._box, offsetBy: n, limitedBy: limit._box)
      .map { AnyIndex(_box:$0) }
  }
  @inlinable public func formIndex(_ i: inout Index, offsetBy n: Int) {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n)
    } else {
      i = index(i, offsetBy: n)
    }
  }
  @inlinable public func formIndex(_ i: inout Index, offsetBy n: Int, limitedBy limit: Index) -> Bool {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n, limitedBy: limit._box)
    }
    if let advanced = index(i, offsetBy: n, limitedBy: limit) {
      i = advanced
      return true
    }
    i = limit
    return false
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    return _box._distance(from: start._box, to: end._box)
  }
  @inlinable public var count: Int {
    get {
    return _box._count
  }
  }
}
extension AnyCollection : _AnyCollectionProtocol {
  @inlinable public var _boxID: ObjectIdentifier {
    get {
    return ObjectIdentifier(_box)
  }
  }
}
@_fixed_layout public struct AnyBidirectionalCollection<Element> {
  @usableFromInline
  internal let _box: _AnyBidirectionalCollectionBox<Element>
  @inlinable internal init(_box: _AnyBidirectionalCollectionBox<Element>) {
    self._box = _box
  }
}
extension AnyBidirectionalCollection : BidirectionalCollection {
  public typealias Indices = DefaultIndices<AnyBidirectionalCollection>
  public typealias Iterator = AnyIterator<Element>
  public typealias Index = AnyIndex
  public typealias SubSequence = AnyBidirectionalCollection<Element>
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.BidirectionalCollection {
    // Traversal: Bidirectional
    // SubTraversal: Bidirectional
    self._box = _BidirectionalCollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: AnyBidirectionalCollection<Element>) {
    self._box = other._box
  }
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.RandomAccessCollection {
    // Traversal: Bidirectional
    // SubTraversal: RandomAccess
    self._box = _RandomAccessCollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: AnyRandomAccessCollection<Element>) {
    self._box = other._box
  }
  @inlinable public init?(_ other: AnyCollection<Element>) {
    guard let box =
      other._box as? _AnyBidirectionalCollectionBox<Element> else {
      return nil
    }
    self._box = box
  }
  @inlinable public var startIndex: Index {
    get {
    return AnyIndex(_box: _box._startIndex)
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return AnyIndex(_box: _box._endIndex)
  }
  }
  @inlinable public subscript(position: Index) -> Element {
    get {
    return _box[position._box]
  }
  }
  @inlinable public subscript(bounds: Range<Index>) -> SubSequence {
    get {
    return AnyBidirectionalCollection(_box:
      _box[start: bounds.lowerBound._box, end: bounds.upperBound._box])
  }
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Index, bounds: Range<Index>) {
    // Do nothing.  Doing a range check would involve unboxing indices,
    // performing dynamic dispatch etc.  This seems to be too costly for a fast
    // range check for QoI purposes.
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Range<Index>, bounds: Range<Index>) {
    // Do nothing.  Doing a range check would involve unboxing indices,
    // performing dynamic dispatch etc.  This seems to be too costly for a fast
    // range check for QoI purposes.
  }
  @inlinable public func index(after i: Index) -> Index {
    return AnyIndex(_box: _box._index(after: i._box))
  }
  @inlinable public func formIndex(after i: inout Index) {
    if _isUnique(&i._box) {
      _box._formIndex(after: i._box)
    }
    else {
      i = index(after: i)
    }
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int) -> Index {
    return AnyIndex(_box: _box._index(i._box, offsetBy: n))
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index? {
    return _box._index(i._box, offsetBy: n, limitedBy: limit._box)
      .map { AnyIndex(_box:$0) }
  }
  @inlinable public func formIndex(_ i: inout Index, offsetBy n: Int) {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n)
    } else {
      i = index(i, offsetBy: n)
    }
  }
  @inlinable public func formIndex(_ i: inout Index, offsetBy n: Int, limitedBy limit: Index) -> Bool {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n, limitedBy: limit._box)
    }
    if let advanced = index(i, offsetBy: n, limitedBy: limit) {
      i = advanced
      return true
    }
    i = limit
    return false
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    return _box._distance(from: start._box, to: end._box)
  }
  @inlinable public var count: Int {
    get {
    return _box._count
  }
  }
  @inlinable public func index(before i: Index) -> Index {
    return AnyIndex(_box: _box._index(before: i._box))
  }
  @inlinable public func formIndex(before i: inout Index) {
    if _isUnique(&i._box) {
      _box._formIndex(before: i._box)
    }
    else {
      i = index(before: i)
    }
  }
}
extension AnyBidirectionalCollection : _AnyCollectionProtocol {
  @inlinable public var _boxID: ObjectIdentifier {
    get {
    return ObjectIdentifier(_box)
  }
  }
}
@_fixed_layout public struct AnyRandomAccessCollection<Element> {
  @usableFromInline
  internal let _box: _AnyRandomAccessCollectionBox<Element>
  @inlinable internal init(_box: _AnyRandomAccessCollectionBox<Element>) {
    self._box = _box
  }
}
extension AnyRandomAccessCollection : RandomAccessCollection {
  public typealias Indices = DefaultIndices<AnyRandomAccessCollection>
  public typealias Iterator = AnyIterator<Element>
  public typealias Index = AnyIndex
  public typealias SubSequence = AnyRandomAccessCollection<Element>
  @inline(__always) @inlinable public init<C>(_ base: C) where Element == C.Element, C : Swift.RandomAccessCollection {
    // Traversal: RandomAccess
    // SubTraversal: RandomAccess
    self._box = _RandomAccessCollectionBox<C>(
      _base: base)
  }
  @inlinable public init(_ other: AnyRandomAccessCollection<Element>) {
    self._box = other._box
  }
  @inlinable public init?(_ other: AnyCollection<Element>) {
    guard let box =
      other._box as? _AnyRandomAccessCollectionBox<Element> else {
      return nil
    }
    self._box = box
  }
  @inlinable public init?(_ other: AnyBidirectionalCollection<Element>) {
    guard let box =
      other._box as? _AnyRandomAccessCollectionBox<Element> else {
      return nil
    }
    self._box = box
  }
  @inlinable public var startIndex: Index {
    get {
    return AnyIndex(_box: _box._startIndex)
  }
  }
  @inlinable public var endIndex: Index {
    get {
    return AnyIndex(_box: _box._endIndex)
  }
  }
  @inlinable public subscript(position: Index) -> Element {
    get {
    return _box[position._box]
  }
  }
  @inlinable public subscript(bounds: Range<Index>) -> SubSequence {
    get {
    return AnyRandomAccessCollection(_box:
      _box[start: bounds.lowerBound._box, end: bounds.upperBound._box])
  }
  }
  @inlinable public func _failEarlyRangeCheck(_ index: Index, bounds: Range<Index>) {
    // Do nothing.  Doing a range check would involve unboxing indices,
    // performing dynamic dispatch etc.  This seems to be too costly for a fast
    // range check for QoI purposes.
  }
  @inlinable public func _failEarlyRangeCheck(_ range: Range<Index>, bounds: Range<Index>) {
    // Do nothing.  Doing a range check would involve unboxing indices,
    // performing dynamic dispatch etc.  This seems to be too costly for a fast
    // range check for QoI purposes.
  }
  @inlinable public func index(after i: Index) -> Index {
    return AnyIndex(_box: _box._index(after: i._box))
  }
  @inlinable public func formIndex(after i: inout Index) {
    if _isUnique(&i._box) {
      _box._formIndex(after: i._box)
    }
    else {
      i = index(after: i)
    }
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int) -> Index {
    return AnyIndex(_box: _box._index(i._box, offsetBy: n))
  }
  @inlinable public func index(_ i: Index, offsetBy n: Int, limitedBy limit: Index) -> Index? {
    return _box._index(i._box, offsetBy: n, limitedBy: limit._box)
      .map { AnyIndex(_box:$0) }
  }
  @inlinable public func formIndex(_ i: inout Index, offsetBy n: Int) {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n)
    } else {
      i = index(i, offsetBy: n)
    }
  }
  @inlinable public func formIndex(_ i: inout Index, offsetBy n: Int, limitedBy limit: Index) -> Bool {
    if _isUnique(&i._box) {
      return _box._formIndex(&i._box, offsetBy: n, limitedBy: limit._box)
    }
    if let advanced = index(i, offsetBy: n, limitedBy: limit) {
      i = advanced
      return true
    }
    i = limit
    return false
  }
  @inlinable public func distance(from start: Index, to end: Index) -> Int {
    return _box._distance(from: start._box, to: end._box)
  }
  @inlinable public var count: Int {
    get {
    return _box._count
  }
  }
  @inlinable public func index(before i: Index) -> Index {
    return AnyIndex(_box: _box._index(before: i._box))
  }
  @inlinable public func formIndex(before i: inout Index) {
    if _isUnique(&i._box) {
      _box._formIndex(before: i._box)
    }
    else {
      i = index(before: i)
    }
  }
}
extension AnyRandomAccessCollection : _AnyCollectionProtocol {
  @inlinable public var _boxID: ObjectIdentifier {
    get {
    return ObjectIdentifier(_box)
  }
  }
}
public struct Mirror {
  public enum AncestorRepresentation {
    case generated
    case customized(() -> Mirror)
    case suppressed
  }
  public init(reflecting subject: Any)
  public typealias Child = (label: String?, value: Any)
  public typealias Children = AnyCollection<Child>
  public enum DisplayStyle {
    case `struct`, `class`, `enum`, tuple, optional, collection
    case dictionary, set
    public static func == (a: Swift.Mirror.DisplayStyle, b: Swift.Mirror.DisplayStyle) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init<Subject, C>(_ subject: Subject, children: C, displayStyle: DisplayStyle? = nil, ancestorRepresentation: AncestorRepresentation = .generated) where C : Swift.Collection, C.Element == Swift.Mirror.Child
  public init<Subject, C>(_ subject: Subject, unlabeledChildren: C, displayStyle: DisplayStyle? = nil, ancestorRepresentation: AncestorRepresentation = .generated) where C : Swift.Collection
  public init<Subject>(_ subject: Subject, children: KeyValuePairs<String, Any>, displayStyle: DisplayStyle? = nil, ancestorRepresentation: AncestorRepresentation = .generated)
  public let subjectType: Any.Type
  public let children: Children
  public let displayStyle: DisplayStyle?
  public var superclassMirror: Mirror? {
    get
  }
}
public protocol CustomReflectable {
  var customMirror: Mirror { get }
}
public protocol CustomLeafReflectable : Swift.CustomReflectable {
}
public protocol MirrorPath {
}
extension Int : MirrorPath {
}
extension String : MirrorPath {
}
extension Mirror {
  public func descendant(_ first: MirrorPath, _ rest: MirrorPath...) -> Any?
}
extension String {
  public init<Subject>(describing instance: Subject)
  @inlinable public init<Subject>(describing instance: Subject) where Subject : Swift.CustomStringConvertible {
    self = instance.description
  }
  @inlinable public init<Subject>(describing instance: Subject) where Subject : Swift.TextOutputStreamable {
    self.init()
    instance.write(to: &self)
  }
  @inlinable public init<Subject>(describing instance: Subject) where Subject : Swift.CustomStringConvertible, Subject : Swift.TextOutputStreamable {
    self = instance.description
  }
  public init<Subject>(reflecting subject: Subject)
}
extension Mirror : CustomStringConvertible {
  public var description: String {
    get
  }
}
extension Mirror : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
public protocol CustomPlaygroundDisplayConvertible {
  var playgroundDescription: Any { get }
}
@_frozen public enum CommandLine {
  @usableFromInline
  internal static var _argc: Int32
  @usableFromInline
  internal static var _unsafeArgv: UnsafeMutablePointer<UnsafeMutablePointer<Int8>?>
  public static var argc: Int32 {
    get
  }
  public static var unsafeArgv: UnsafeMutablePointer<UnsafeMutablePointer<Int8>?> {
    get
  }
  public static var arguments: [String]
}
@usableFromInline
@_fixed_layout internal struct _SliceBuffer<Element> : _ArrayBufferProtocol, RandomAccessCollection {
  @usableFromInline
  internal typealias NativeBuffer = _ContiguousArrayBuffer<Element>
  @usableFromInline
  internal var owner: AnyObject
  @usableFromInline
  internal let subscriptBaseAddress: UnsafeMutablePointer<Element>
  @usableFromInline
  internal var startIndex: Int
  @usableFromInline
  internal var endIndexAndFlags: UInt
  @inlinable internal init(owner: AnyObject, subscriptBaseAddress: UnsafeMutablePointer<Element>, startIndex: Int, endIndexAndFlags: UInt) {
    self.owner = owner
    self.subscriptBaseAddress = subscriptBaseAddress
    self.startIndex = startIndex
    self.endIndexAndFlags = endIndexAndFlags
  }
  @inlinable internal init(owner: AnyObject, subscriptBaseAddress: UnsafeMutablePointer<Element>, indices: Range<Int>, hasNativeBuffer: Bool) {
    self.owner = owner
    self.subscriptBaseAddress = subscriptBaseAddress
    self.startIndex = indices.lowerBound
    let bufferFlag = UInt(hasNativeBuffer ? 1 : 0)
    self.endIndexAndFlags = (UInt(indices.upperBound) << 1) | bufferFlag
    _invariantCheck()
  }
  @inlinable internal init() {
    let empty = _ContiguousArrayBuffer<Element>()
    self.owner = empty.owner
    self.subscriptBaseAddress = empty.firstElementAddress
    self.startIndex = empty.startIndex
    self.endIndexAndFlags = 1
    _invariantCheck()
  }
  @inlinable internal init(_buffer buffer: NativeBuffer, shiftedToStartIndex: Int) {
    let shift = buffer.startIndex - shiftedToStartIndex
    self.init(
      owner: buffer.owner,
      subscriptBaseAddress: buffer.subscriptBaseAddress + shift,
      indices: shiftedToStartIndex..<shiftedToStartIndex + buffer.count,
      hasNativeBuffer: true)
  }
  @inlinable internal func _invariantCheck() {
    let isNative = _hasNativeBuffer
    let isNativeStorage: Bool = owner is __ContiguousArrayStorageBase
    _internalInvariant(isNativeStorage == isNative)
    if isNative {
      _internalInvariant(count <= nativeBuffer.count)
    }
  }
  @inlinable internal var _hasNativeBuffer: Bool {
    get {
    return (endIndexAndFlags & 1) != 0
  }
  }
  @inlinable internal var nativeBuffer: NativeBuffer {
    get {
    _internalInvariant(_hasNativeBuffer)
    return NativeBuffer(
      owner as? __ContiguousArrayStorageBase ?? _emptyArrayStorage)
  }
  }
  @inlinable internal var nativeOwner: AnyObject {
    get {
    _internalInvariant(_hasNativeBuffer, "Expect a native array")
    return owner
  }
  }
  @inlinable mutating internal func replaceSubrange<C>(_ subrange: Range<Int>, with insertCount: Int, elementsOf newValues: __owned C) where Element == C.Element, C : Swift.Collection {

    _invariantCheck()
    _internalInvariant(insertCount <= numericCast(newValues.count))

    _internalInvariant(_hasNativeBuffer)
    _internalInvariant(isUniquelyReferenced())

    let eraseCount = subrange.count
    let growth = insertCount - eraseCount
    let oldCount = count

    var native = nativeBuffer
    let hiddenElementCount = firstElementAddress - native.firstElementAddress

    _internalInvariant(native.count + growth <= native.capacity)

    let start = subrange.lowerBound - startIndex + hiddenElementCount
    let end = subrange.upperBound - startIndex + hiddenElementCount
    native.replaceSubrange(
      start..<end,
      with: insertCount,
      elementsOf: newValues)

    self.endIndex = self.startIndex + oldCount + growth

    _invariantCheck()
  }
  @inlinable internal var identity: UnsafeRawPointer {
    get {
    return UnsafeRawPointer(firstElementAddress)
  }
  }
  @inlinable internal var firstElementAddress: UnsafeMutablePointer<Element> {
    get {
    return subscriptBaseAddress + startIndex
  }
  }
  @inlinable internal var firstElementAddressIfContiguous: UnsafeMutablePointer<Element>? {
    get {
    return firstElementAddress
  }
  }
  @inlinable mutating internal func requestUniqueMutableBackingBuffer(minimumCapacity: Int) -> NativeBuffer? {
    _invariantCheck()
    // This is a performance optimization that was put in to ensure that at
    // -Onone, copy of self we make to call _hasNativeBuffer is destroyed before
    // we call isUniquelyReferenced. Otherwise, isUniquelyReferenced will always
    // fail causing us to always copy.
    //
    // if _fastPath(_hasNativeBuffer && isUniquelyReferenced) {
    //
    // SR-6437
    let native = _hasNativeBuffer
    let unique = isUniquelyReferenced()
    if _fastPath(native && unique) {
      if capacity >= minimumCapacity {
        // Since we have the last reference, drop any inaccessible
        // trailing elements in the underlying storage.  That will
        // tend to reduce shuffling of later elements.  Since this
        // function isn't called for subscripting, this won't slow
        // down that case.
        var native = nativeBuffer
        let offset = self.firstElementAddress - native.firstElementAddress
        let backingCount = native.count
        let myCount = count

        if _slowPath(backingCount > myCount + offset) {
          native.replaceSubrange(
            (myCount+offset)..<backingCount,
            with: 0,
            elementsOf: EmptyCollection())
        }
        _invariantCheck()
        return native
      }
    }
    return nil
  }
  @inlinable mutating internal func isMutableAndUniquelyReferenced() -> Bool {
    // This is a performance optimization that ensures that the copy of self
    // that occurs at -Onone is destroyed before we call
    // isUniquelyReferenced. This code used to be:
    //
    //   return _hasNativeBuffer && isUniquelyReferenced()
    //
    // SR-6437
    if !_hasNativeBuffer {
      return false
    }
    return isUniquelyReferenced()
  }
  @inlinable internal func requestNativeBuffer() -> _ContiguousArrayBuffer<Element>? {
    _invariantCheck()
    if _fastPath(_hasNativeBuffer && nativeBuffer.count == count) {
      return nativeBuffer
    }
    return nil
  }
  @discardableResult
  @inlinable __consuming internal func _copyContents(subRange bounds: Range<Int>, initializing target: UnsafeMutablePointer<Element>) -> UnsafeMutablePointer<Element> {
    _invariantCheck()
    _internalInvariant(bounds.lowerBound >= startIndex)
    _internalInvariant(bounds.upperBound >= bounds.lowerBound)
    _internalInvariant(bounds.upperBound <= endIndex)
    let c = bounds.count
    target.initialize(from: subscriptBaseAddress + bounds.lowerBound, count: c)
    return target + c
  }
  __consuming public func _copyContents(initializing buffer: UnsafeMutableBufferPointer<Element>) -> (Iterator, UnsafeMutableBufferPointer<Element>.Index)
  @inlinable internal var arrayPropertyIsNativeTypeChecked: Bool {
    get {
    return _hasNativeBuffer
  }
  }
  @inlinable internal var count: Int {
    get {
      return endIndex - startIndex
    }
    set {
      let growth = newValue - count
      if growth != 0 {
        nativeBuffer.count += growth
        self.endIndex += growth
      }
      _invariantCheck()
    }
  }
  @inlinable internal func _checkValidSubscript(_ index: Int) {
    _precondition(
      index >= startIndex && index < endIndex, "Index out of bounds")
  }
  @inlinable internal var capacity: Int {
    get {
    let count = self.count
    if _slowPath(!_hasNativeBuffer) {
      return count
    }
    let n = nativeBuffer
    let nativeEnd = n.firstElementAddress + n.count
    if (firstElementAddress + count) == nativeEnd {
      return count + (n.capacity - n.count)
    }
    return count
  }
  }
  @inlinable mutating internal func isUniquelyReferenced() -> Bool {
    return isKnownUniquelyReferenced(&owner)
  }
  @inlinable internal func getElement(_ i: Int) -> Element {
    _internalInvariant(i >= startIndex, "slice index is out of range (before startIndex)")
    _internalInvariant(i < endIndex, "slice index is out of range")
    return subscriptBaseAddress[i]
  }
  @inlinable internal subscript(position: Int) -> Element {
    get {
      return getElement(position)
    }
    nonmutating set {
      _internalInvariant(position >= startIndex, "slice index is out of range (before startIndex)")
      _internalInvariant(position < endIndex, "slice index is out of range")
      subscriptBaseAddress[position] = newValue
    }
  }
  @inlinable internal subscript(bounds: Range<Int>) -> _SliceBuffer {
    get {
      _internalInvariant(bounds.lowerBound >= startIndex)
      _internalInvariant(bounds.upperBound >= bounds.lowerBound)
      _internalInvariant(bounds.upperBound <= endIndex)
      return _SliceBuffer(
        owner: owner,
        subscriptBaseAddress: subscriptBaseAddress,
        indices: bounds,
        hasNativeBuffer: _hasNativeBuffer)
    }
    set {
      fatalError("not implemented")
    }
  }
  @inlinable internal var endIndex: Int {
    get {
      return Int(endIndexAndFlags >> 1)
    }
    set {
      endIndexAndFlags = (UInt(newValue) << 1) | (_hasNativeBuffer ? 1 : 0)
    }
  }
  @usableFromInline
  internal typealias Indices = Range<Int>
  @inlinable internal func withUnsafeBufferPointer<R>(_ body: (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(UnsafeBufferPointer(start: firstElementAddress,
      count: count))
  }
  @inlinable mutating internal func withUnsafeMutableBufferPointer<R>(_ body: (UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(
      UnsafeMutableBufferPointer(start: firstElementAddress, count: count))
  }
  @inlinable internal func unsafeCastElements<T>(to type: T.Type) -> _SliceBuffer<T> {
    _internalInvariant(_isClassOrObjCExistential(T.self))
    let baseAddress = UnsafeMutableRawPointer(self.subscriptBaseAddress)
      .assumingMemoryBound(to: T.self)
    return _SliceBuffer<T>(
      owner: self.owner,
      subscriptBaseAddress: baseAddress,
      startIndex: self.startIndex,
      endIndexAndFlags: self.endIndexAndFlags)
  }
  @usableFromInline
  internal typealias Index = Swift.Int
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<Swift._SliceBuffer<Element>>
  @usableFromInline
  internal typealias SubSequence = Swift._SliceBuffer<Element>
}
extension _SliceBuffer {
  @inlinable __consuming internal func _copyToContiguousArray() -> ContiguousArray<Element> {
    if _hasNativeBuffer {
      let n = nativeBuffer
      if count == n.count {
        return ContiguousArray(_buffer: n)
      }
    }

    let result = _ContiguousArrayBuffer<Element>(
      _uninitializedCount: count,
      minimumCapacity: 0)
    result.firstElementAddress.initialize(
      from: firstElementAddress, count: count)
    return ContiguousArray(_buffer: result)
  }
}
infix operator .== : ComparisonPrecedence
infix operator .!= : ComparisonPrecedence
infix operator .< : ComparisonPrecedence
infix operator .<= : ComparisonPrecedence
infix operator .> : ComparisonPrecedence
infix operator .>= : ComparisonPrecedence
infix operator .& : LogicalConjunctionPrecedence
infix operator .^ : LogicalDisjunctionPrecedence
infix operator .| : LogicalDisjunctionPrecedence
infix operator .&= : AssignmentPrecedence
infix operator .^= : AssignmentPrecedence
infix operator .|= : AssignmentPrecedence
prefix operator .!
public protocol SIMDStorage {
  associatedtype Scalar : Swift.Decodable, Swift.Encodable, Swift.Hashable
  var scalarCount: Int { get }
  init()
  subscript(index: Int) -> Scalar { get set }
}
extension SIMDStorage {
  @_alwaysEmitIntoClient public static var scalarCount: Int {
    get {
    // Wouldn't it make more sense to define the instance var in terms of the
    // static var? Yes, probably, but by doing it this way we make the static
    // var backdeployable.
    return Self().scalarCount
  }
  }
}
public protocol SIMDScalar {
  associatedtype SIMDMaskScalar : Swift.FixedWidthInteger, Swift.SIMDScalar, Swift.SignedInteger
  associatedtype SIMD2Storage : Swift.SIMDStorage where Self.SIMD2Storage.Scalar == Self.SIMD32Storage.Scalar
  associatedtype SIMD4Storage : Swift.SIMDStorage where Self.SIMD4Storage.Scalar == Self.SIMD64Storage.Scalar
  associatedtype SIMD8Storage : Swift.SIMDStorage
  associatedtype SIMD16Storage : Swift.SIMDStorage where Self == Self.SIMD16Storage.Scalar, Self.SIMD16Storage.Scalar == Self.SIMD2Storage.Scalar
  associatedtype SIMD32Storage : Swift.SIMDStorage where Self.SIMD32Storage.Scalar == Self.SIMD4Storage.Scalar
  associatedtype SIMD64Storage : Swift.SIMDStorage where Self.SIMD64Storage.Scalar == Self.SIMD8Storage.Scalar
}
public protocol SIMD : Swift.CustomStringConvertible, Swift.Decodable, Swift.Encodable, Swift.ExpressibleByArrayLiteral, Swift.Hashable, Swift.SIMDStorage {
  associatedtype MaskStorage : Swift.SIMD where Self.MaskStorage.Scalar : Swift.FixedWidthInteger, Self.MaskStorage.Scalar : Swift.SignedInteger
}
extension SIMD {
  @_transparent public var indices: Range<Int> {
    get {
    return 0 ..< scalarCount
  }
  }
  @_transparent public init(repeating value: Scalar) {
    self.init()
    for i in indices { self[i] = value }
  }
  @_transparent public static func == (lhs: Self, rhs: Self) -> Bool {
    var result = true
    for i in lhs.indices { result = result && lhs[i] == rhs[i] }
    return result
  }
  @inlinable public func hash(into hasher: inout Hasher) {
    for i in indices { hasher.combine(self[i]) }
  }
  public func encode(to encoder: Encoder) throws
  public init(from decoder: Decoder) throws
  public var description: String {
    get
  }
  @_transparent public static func .== (lhs: Self, rhs: Self) -> SIMDMask<MaskStorage> {
    var result = SIMDMask<MaskStorage>()
    for i in result.indices { result[i] = lhs[i] == rhs[i] }
    return result
  }
  @_transparent public static func .!= (lhs: Self, rhs: Self) -> SIMDMask<MaskStorage> {
    var result = SIMDMask<MaskStorage>()
    for i in result.indices { result[i] = lhs[i] != rhs[i] }
    return result
  }
  @_transparent mutating public func replace(with other: Self, where mask: SIMDMask<MaskStorage>) {
    for i in indices { self[i] = mask[i] ? other[i] : self[i] }
  }
  @inlinable public init(arrayLiteral scalars: Scalar...) {
    self.init(scalars)
  }
  @inlinable public init<S>(_ scalars: S) where S : Swift.Sequence, Self.Scalar == S.Element {
    self.init()
    var index = 0
    for scalar in scalars {
      if index == scalarCount {
        _preconditionFailure("Too many elements in sequence.")
      }
      self[index] = scalar
      index += 1
    }
    if index < scalarCount {
      _preconditionFailure("Not enough elements in sequence.")
    }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: SIMD2<Index>) -> SIMD2<Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar {
    get {
    var result = SIMD2<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: SIMD3<Index>) -> SIMD3<Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar {
    get {
    var result = SIMD3<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: SIMD4<Index>) -> SIMD4<Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar {
    get {
    var result = SIMD4<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: SIMD8<Index>) -> SIMD8<Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar {
    get {
    var result = SIMD8<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: SIMD16<Index>) -> SIMD16<Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar {
    get {
    var result = SIMD16<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: SIMD32<Index>) -> SIMD32<Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar {
    get {
    var result = SIMD32<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
  @_alwaysEmitIntoClient public subscript<Index>(index: SIMD64<Index>) -> SIMD64<Scalar> where Index : Swift.FixedWidthInteger, Index : Swift.SIMDScalar {
    get {
    var result = SIMD64<Scalar>()
    for i in result.indices {
      result[i] = self[Int(index[i]) % scalarCount]
    }
    return result
  }
  }
}
extension SIMD where Self.Scalar : Swift.Comparable {
  @_transparent public static func .< (lhs: Self, rhs: Self) -> SIMDMask<MaskStorage> {
    var result = SIMDMask<MaskStorage>()
    for i in result.indices { result[i] = lhs[i] < rhs[i] }
    return result
  }
  @_transparent public static func .<= (lhs: Self, rhs: Self) -> SIMDMask<MaskStorage> {
    var result = SIMDMask<MaskStorage>()
    for i in result.indices { result[i] = lhs[i] <= rhs[i] }
    return result
  }
  @_alwaysEmitIntoClient public func min() -> Scalar {
    return indices.reduce(into: self[0]) { $0 = Swift.min($0, self[$1]) }
  }
  @_alwaysEmitIntoClient public func max() -> Scalar {
    return indices.reduce(into: self[0]) { $0 = Swift.max($0, self[$1]) }
  }
}
extension SIMD {
  @_transparent public static func .== (lhs: Scalar, rhs: Self) -> SIMDMask<MaskStorage> {
    return Self(repeating: lhs) .== rhs
  }
  @_transparent public static func .!= (lhs: Scalar, rhs: Self) -> SIMDMask<MaskStorage> {
    return Self(repeating: lhs) .!= rhs
  }
  @_transparent public static func .== (lhs: Self, rhs: Scalar) -> SIMDMask<MaskStorage> {
    return lhs .== Self(repeating: rhs)
  }
  @_transparent public static func .!= (lhs: Self, rhs: Scalar) -> SIMDMask<MaskStorage> {
    return lhs .!= Self(repeating: rhs)
  }
  @_transparent mutating public func replace(with other: Scalar, where mask: SIMDMask<MaskStorage>) {
    replace(with: Self(repeating: other), where: mask)
  }
  @_transparent public func replacing(with other: Self, where mask: SIMDMask<MaskStorage>) -> Self {
    var result = self
    result.replace(with: other, where: mask)
    return result
  }
  @_transparent public func replacing(with other: Scalar, where mask: SIMDMask<MaskStorage>) -> Self {
    return replacing(with: Self(repeating: other), where: mask)
  }
}
extension SIMD where Self.Scalar : Swift.Comparable {
  @_transparent public static func .>= (lhs: Self, rhs: Self) -> SIMDMask<MaskStorage> {
    return rhs .<= lhs
  }
  @_transparent public static func .> (lhs: Self, rhs: Self) -> SIMDMask<MaskStorage> {
    return rhs .< lhs
  }
  @_transparent public static func .< (lhs: Scalar, rhs: Self) -> SIMDMask<MaskStorage> {
    return Self(repeating: lhs) .< rhs
  }
  @_transparent public static func .<= (lhs: Scalar, rhs: Self) -> SIMDMask<MaskStorage> {
    return Self(repeating: lhs) .<= rhs
  }
  @_transparent public static func .>= (lhs: Scalar, rhs: Self) -> SIMDMask<MaskStorage> {
    return Self(repeating: lhs) .>= rhs
  }
  @_transparent public static func .> (lhs: Scalar, rhs: Self) -> SIMDMask<MaskStorage> {
    return Self(repeating: lhs) .> rhs
  }
  @_transparent public static func .< (lhs: Self, rhs: Scalar) -> SIMDMask<MaskStorage> {
    return lhs .< Self(repeating: rhs)
  }
  @_transparent public static func .<= (lhs: Self, rhs: Scalar) -> SIMDMask<MaskStorage> {
    return lhs .<= Self(repeating: rhs)
  }
  @_transparent public static func .>= (lhs: Self, rhs: Scalar) -> SIMDMask<MaskStorage> {
    return lhs .>= Self(repeating: rhs)
  }
  @_transparent public static func .> (lhs: Self, rhs: Scalar) -> SIMDMask<MaskStorage> {
    return lhs .> Self(repeating: rhs)
  }
}
extension SIMD where Self.Scalar : Swift.FixedWidthInteger {
  @_transparent public static var zero: Self {
    get {
    return Self()
  }
  }
  @_alwaysEmitIntoClient public static var one: Self {
    get {
    return Self(repeating: 1)
  }
  }
  @inlinable public static func random<T>(in range: Range<Scalar>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    var result = Self()
    for i in result.indices {
      result[i] = Scalar.random(in: range, using: &generator)
    }
    return result
  }
  @inlinable public static func random(in range: Range<Scalar>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
  @inlinable public static func random<T>(in range: ClosedRange<Scalar>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    var result = Self()
    for i in result.indices {
      result[i] = Scalar.random(in: range, using: &generator)
    }
    return result
  }
  @inlinable public static func random(in range: ClosedRange<Scalar>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}
extension SIMD where Self.Scalar : Swift.FloatingPoint {
  @_transparent public static var zero: Self {
    get {
    return Self()
  }
  }
  @_alwaysEmitIntoClient public static var one: Self {
    get {
    return Self(repeating: 1)
  }
  }
}
extension SIMD where Self.Scalar : Swift.BinaryFloatingPoint, Self.Scalar.RawSignificand : Swift.FixedWidthInteger {
  @inlinable public static func random<T>(in range: Range<Scalar>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    var result = Self()
    for i in result.indices {
      result[i] = Scalar.random(in: range, using: &generator)
    }
    return result
  }
  @inlinable public static func random(in range: Range<Scalar>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
  @inlinable public static func random<T>(in range: ClosedRange<Scalar>, using generator: inout T) -> Self where T : Swift.RandomNumberGenerator {
    var result = Self()
    for i in result.indices {
      result[i] = Scalar.random(in: range, using: &generator)
    }
    return result
  }
  @inlinable public static func random(in range: ClosedRange<Scalar>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}
@_fixed_layout public struct SIMDMask<Storage> : SIMD where Storage : Swift.SIMD, Storage.Scalar : Swift.FixedWidthInteger, Storage.Scalar : Swift.SignedInteger {
  public var _storage: Storage
  public typealias MaskStorage = Storage
  public typealias Scalar = Bool
  @_transparent public var scalarCount: Int {
    get {
    return _storage.scalarCount
  }
  }
  @_transparent public init() {
    _storage = Storage()
  }
  @_transparent public init(_ _storage: Storage) {
    self._storage = _storage
  }
  public subscript(index: Int) -> Bool {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index] < 0
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue ? -1 : 0
    }
  }
  public var hashValue: Swift.Int {
    get
  }
  public typealias ArrayLiteralElement = Swift.SIMDMask<Storage>.Scalar
}
extension SIMDMask {
  @inlinable public static func random<T>(using generator: inout T) -> SIMDMask where T : Swift.RandomNumberGenerator {
    var result = SIMDMask()
    for i in result.indices { result[i] = Bool.random(using: &generator) }
    return result
  }
  @inlinable public static func random() -> SIMDMask {
    var g = SystemRandomNumberGenerator()
    return SIMDMask.random(using: &g)
  }
}
extension SIMD where Self.Scalar : Swift.FixedWidthInteger {
  @_transparent public var leadingZeroBitCount: Self {
    get {
    var result = Self()
    for i in indices { result[i] = Scalar(self[i].leadingZeroBitCount) }
    return result
  }
  }
  @_transparent public var trailingZeroBitCount: Self {
    get {
    var result = Self()
    for i in indices { result[i] = Scalar(self[i].trailingZeroBitCount) }
    return result
  }
  }
  @_transparent public var nonzeroBitCount: Self {
    get {
    var result = Self()
    for i in indices { result[i] = Scalar(self[i].nonzeroBitCount) }
    return result
  }
  }
  @_transparent prefix public static func ~ (rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = ~rhs[i] }
    return result
  }
  @_transparent public static func & (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] & rhs[i] }
    return result
  }
  @_transparent public static func ^ (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] ^ rhs[i] }
    return result
  }
  @_transparent public static func | (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] | rhs[i] }
    return result
  }
  @_transparent public static func &<< (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] &<< rhs[i] }
    return result
  }
  @_transparent public static func &>> (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] &>> rhs[i] }
    return result
  }
  @_transparent public static func &+ (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] &+ rhs[i] }
    return result
  }
  @_transparent public static func &- (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] &- rhs[i] }
    return result
  }
  @_transparent public static func &* (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] &* rhs[i] }
    return result
  }
  @_transparent public static func / (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] / rhs[i] }
    return result
  }
  @_transparent public static func % (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] % rhs[i] }
    return result
  }
  @_alwaysEmitIntoClient public func wrappedSum() -> Scalar {
    return indices.reduce(into: 0) { $0 &+= self[$1] }
  }
}
extension SIMD where Self.Scalar : Swift.FloatingPoint {
  @_transparent public static func + (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] + rhs[i] }
    return result
  }
  @_transparent public static func - (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] - rhs[i] }
    return result
  }
  @_transparent public static func * (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] * rhs[i] }
    return result
  }
  @_transparent public static func / (lhs: Self, rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = lhs[i] / rhs[i] }
    return result
  }
  @_transparent public func addingProduct(_ lhs: Self, _ rhs: Self) -> Self {
    var result = Self()
    for i in result.indices { result[i] = self[i].addingProduct(lhs[i], rhs[i]) }
    return result
  }
  @_transparent public func squareRoot() -> Self {
    var result = Self()
    for i in result.indices { result[i] = self[i].squareRoot() }
    return result
  }
  @_transparent public func rounded(_ rule: FloatingPointRoundingRule) -> Self {
    var result = Self()
    for i in result.indices { result[i] = self[i].rounded(rule) }
    return result
  }
  @_alwaysEmitIntoClient public func min() -> Scalar {
    return indices.reduce(into: self[0]) { $0 = Scalar.minimum($0, self[$1]) }
  }
  @_alwaysEmitIntoClient public func max() -> Scalar {
    return indices.reduce(into: self[0]) { $0 = Scalar.maximum($0, self[$1]) }
  }
  @_alwaysEmitIntoClient public func sum() -> Scalar {
    // Implementation note: this eventually be defined to lower to either
    // llvm.experimental.vector.reduce.fadd or an explicit tree-sum. Open-
    // coding the tree sum is problematic, we probably need to define a
    // Swift Builtin to support it.
    return indices.reduce(into: 0) { $0 += self[$1] }
  }
}
extension SIMDMask {
  @_transparent prefix public static func .! (rhs: SIMDMask) -> SIMDMask {
    return SIMDMask(~rhs._storage)
  }
  @_transparent public static func .& (lhs: SIMDMask, rhs: SIMDMask) -> SIMDMask {
    return SIMDMask(lhs._storage & rhs._storage)
  }
  @_transparent public static func .^ (lhs: SIMDMask, rhs: SIMDMask) -> SIMDMask {
    return SIMDMask(lhs._storage ^ rhs._storage)
  }
  @_transparent public static func .| (lhs: SIMDMask, rhs: SIMDMask) -> SIMDMask {
    return SIMDMask(lhs._storage | rhs._storage)
  }
}
extension SIMD where Self.Scalar : Swift.FixedWidthInteger {
  @_transparent public static func & (lhs: Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) & rhs
  }
  @_transparent public static func ^ (lhs: Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) ^ rhs
  }
  @_transparent public static func | (lhs: Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) | rhs
  }
  @_transparent public static func &<< (lhs: Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) &<< rhs
  }
  @_transparent public static func &>> (lhs: Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) &>> rhs
  }
  @_transparent public static func &+ (lhs: Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) &+ rhs
  }
  @_transparent public static func &- (lhs: Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) &- rhs
  }
  @_transparent public static func &* (lhs: Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) &* rhs
  }
  @_transparent public static func / (lhs: Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) / rhs
  }
  @_transparent public static func % (lhs: Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) % rhs
  }
  @_transparent public static func & (lhs: Self, rhs: Scalar) -> Self {
    return lhs & Self(repeating: rhs)
  }
  @_transparent public static func ^ (lhs: Self, rhs: Scalar) -> Self {
    return lhs ^ Self(repeating: rhs)
  }
  @_transparent public static func | (lhs: Self, rhs: Scalar) -> Self {
    return lhs | Self(repeating: rhs)
  }
  @_transparent public static func &<< (lhs: Self, rhs: Scalar) -> Self {
    return lhs &<< Self(repeating: rhs)
  }
  @_transparent public static func &>> (lhs: Self, rhs: Scalar) -> Self {
    return lhs &>> Self(repeating: rhs)
  }
  @_transparent public static func &+ (lhs: Self, rhs: Scalar) -> Self {
    return lhs &+ Self(repeating: rhs)
  }
  @_transparent public static func &- (lhs: Self, rhs: Scalar) -> Self {
    return lhs &- Self(repeating: rhs)
  }
  @_transparent public static func &* (lhs: Self, rhs: Scalar) -> Self {
    return lhs &* Self(repeating: rhs)
  }
  @_transparent public static func / (lhs: Self, rhs: Scalar) -> Self {
    return lhs / Self(repeating: rhs)
  }
  @_transparent public static func % (lhs: Self, rhs: Scalar) -> Self {
    return lhs % Self(repeating: rhs)
  }
  @_transparent public static func &= (lhs: inout Self, rhs: Self) {
    lhs = lhs & rhs
  }
  @_transparent public static func ^= (lhs: inout Self, rhs: Self) {
    lhs = lhs ^ rhs
  }
  @_transparent public static func |= (lhs: inout Self, rhs: Self) {
    lhs = lhs | rhs
  }
  @_transparent public static func &<<= (lhs: inout Self, rhs: Self) {
    lhs = lhs &<< rhs
  }
  @_transparent public static func &>>= (lhs: inout Self, rhs: Self) {
    lhs = lhs &>> rhs
  }
  @_transparent public static func &+= (lhs: inout Self, rhs: Self) {
    lhs = lhs &+ rhs
  }
  @_transparent public static func &-= (lhs: inout Self, rhs: Self) {
    lhs = lhs &- rhs
  }
  @_transparent public static func &*= (lhs: inout Self, rhs: Self) {
    lhs = lhs &* rhs
  }
  @_transparent public static func /= (lhs: inout Self, rhs: Self) {
    lhs = lhs / rhs
  }
  @_transparent public static func %= (lhs: inout Self, rhs: Self) {
    lhs = lhs % rhs
  }
  @_transparent public static func &= (lhs: inout Self, rhs: Scalar) {
    lhs = lhs & rhs
  }
  @_transparent public static func ^= (lhs: inout Self, rhs: Scalar) {
    lhs = lhs ^ rhs
  }
  @_transparent public static func |= (lhs: inout Self, rhs: Scalar) {
    lhs = lhs | rhs
  }
  @_transparent public static func &<<= (lhs: inout Self, rhs: Scalar) {
    lhs = lhs &<< rhs
  }
  @_transparent public static func &>>= (lhs: inout Self, rhs: Scalar) {
    lhs = lhs &>> rhs
  }
  @_transparent public static func &+= (lhs: inout Self, rhs: Scalar) {
    lhs = lhs &+ rhs
  }
  @_transparent public static func &-= (lhs: inout Self, rhs: Scalar) {
    lhs = lhs &- rhs
  }
  @_transparent public static func &*= (lhs: inout Self, rhs: Scalar) {
    lhs = lhs &* rhs
  }
  @_transparent public static func /= (lhs: inout Self, rhs: Scalar) {
    lhs = lhs / rhs
  }
  @_transparent public static func %= (lhs: inout Self, rhs: Scalar) {
    lhs = lhs % rhs
  }
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&+' instead")
  public static func + (lhs: Self, rhs: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&-' instead")
  public static func - (lhs: Self, rhs: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&*' instead")
  public static func * (lhs: Self, rhs: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&+' instead")
  public static func + (lhs: Self, rhs: Scalar) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&-' instead")
  public static func - (lhs: Self, rhs: Scalar) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&*' instead")
  public static func * (lhs: Self, rhs: Scalar) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&+' instead")
  public static func + (lhs: Scalar, rhs: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&-' instead")
  public static func - (lhs: Scalar, rhs: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&*' instead")
  public static func * (lhs: Scalar, rhs: Self) -> Self
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&+=' instead")
  public static func += (lhs: inout Self, rhs: Self)
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&-=' instead")
  public static func -= (lhs: inout Self, rhs: Self)
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&*=' instead")
  public static func *= (lhs: inout Self, rhs: Self)
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&+=' instead")
  public static func += (lhs: inout Self, rhs: Scalar)
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&-=' instead")
  public static func -= (lhs: inout Self, rhs: Scalar)
  @available(*, unavailable, message: "integer vector types do not support checked arithmetic; use the wrapping operator '&*=' instead")
  public static func *= (lhs: inout Self, rhs: Scalar)
}
extension SIMD where Self.Scalar : Swift.FloatingPoint {
  @_transparent prefix public static func - (rhs: Self) -> Self {
    return 0 - rhs
  }
  @_transparent public static func + (lhs: Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) + rhs
  }
  @_transparent public static func - (lhs: Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) - rhs
  }
  @_transparent public static func * (lhs: Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) * rhs
  }
  @_transparent public static func / (lhs: Scalar, rhs: Self) -> Self {
    return Self(repeating: lhs) / rhs
  }
  @_transparent public static func + (lhs: Self, rhs: Scalar) -> Self {
    return lhs + Self(repeating: rhs)
  }
  @_transparent public static func - (lhs: Self, rhs: Scalar) -> Self {
    return lhs - Self(repeating: rhs)
  }
  @_transparent public static func * (lhs: Self, rhs: Scalar) -> Self {
    return lhs * Self(repeating: rhs)
  }
  @_transparent public static func / (lhs: Self, rhs: Scalar) -> Self {
    return lhs / Self(repeating: rhs)
  }
  @_transparent public static func += (lhs: inout Self, rhs: Self) {
    lhs = lhs + rhs
  }
  @_transparent public static func -= (lhs: inout Self, rhs: Self) {
    lhs = lhs - rhs
  }
  @_transparent public static func *= (lhs: inout Self, rhs: Self) {
    lhs = lhs * rhs
  }
  @_transparent public static func /= (lhs: inout Self, rhs: Self) {
    lhs = lhs / rhs
  }
  @_transparent public static func += (lhs: inout Self, rhs: Scalar) {
    lhs = lhs + rhs
  }
  @_transparent public static func -= (lhs: inout Self, rhs: Scalar) {
    lhs = lhs - rhs
  }
  @_transparent public static func *= (lhs: inout Self, rhs: Scalar) {
    lhs = lhs * rhs
  }
  @_transparent public static func /= (lhs: inout Self, rhs: Scalar) {
    lhs = lhs / rhs
  }
  @_transparent public func addingProduct(_ lhs: Scalar, _ rhs: Self) -> Self {
    return self.addingProduct(Self(repeating: lhs), rhs)
  }
  @_transparent public func addingProduct(_ lhs: Self, _ rhs: Scalar) -> Self {
    return self.addingProduct(lhs, Self(repeating: rhs))
  }
  @_transparent mutating public func addProduct(_ lhs: Self, _ rhs: Self) {
    self = self.addingProduct(lhs, rhs)
  }
  @_transparent mutating public func addProduct(_ lhs: Scalar, _ rhs: Self) {
    self = self.addingProduct(lhs, rhs)
  }
  @_transparent mutating public func addProduct(_ lhs: Self, _ rhs: Scalar) {
    self = self.addingProduct(lhs, rhs)
  }
  @_transparent mutating public func formSquareRoot() {
    self = self.squareRoot()
  }
  @_transparent mutating public func round(_ rule: FloatingPointRoundingRule) {
    self = self.rounded(rule)
  }
}
extension SIMDMask {
  @_transparent public static func .& (lhs: Bool, rhs: SIMDMask) -> SIMDMask {
    return SIMDMask(repeating: lhs) .& rhs
  }
  @_transparent public static func .^ (lhs: Bool, rhs: SIMDMask) -> SIMDMask {
    return SIMDMask(repeating: lhs) .^ rhs
  }
  @_transparent public static func .| (lhs: Bool, rhs: SIMDMask) -> SIMDMask {
    return SIMDMask(repeating: lhs) .| rhs
  }
  @_transparent public static func .& (lhs: SIMDMask, rhs: Bool) -> SIMDMask {
    return lhs .& SIMDMask(repeating: rhs)
  }
  @_transparent public static func .^ (lhs: SIMDMask, rhs: Bool) -> SIMDMask {
    return lhs .^ SIMDMask(repeating: rhs)
  }
  @_transparent public static func .| (lhs: SIMDMask, rhs: Bool) -> SIMDMask {
    return lhs .| SIMDMask(repeating: rhs)
  }
  @_transparent public static func .&= (lhs: inout SIMDMask, rhs: SIMDMask) {
    lhs = lhs .& rhs
  }
  @_transparent public static func .^= (lhs: inout SIMDMask, rhs: SIMDMask) {
    lhs = lhs .^ rhs
  }
  @_transparent public static func .|= (lhs: inout SIMDMask, rhs: SIMDMask) {
    lhs = lhs .| rhs
  }
  @_transparent public static func .&= (lhs: inout SIMDMask, rhs: Bool) {
    lhs = lhs .& rhs
  }
  @_transparent public static func .^= (lhs: inout SIMDMask, rhs: Bool) {
    lhs = lhs .^ rhs
  }
  @_transparent public static func .|= (lhs: inout SIMDMask, rhs: Bool) {
    lhs = lhs .| rhs
  }
}
@_alwaysEmitIntoClient public func any<Storage>(_ mask: SIMDMask<Storage>) -> Bool where Storage : Swift.SIMD, Storage.Scalar : Swift.FixedWidthInteger, Storage.Scalar : Swift.SignedInteger {
  return mask._storage.min() < 0
}
@_alwaysEmitIntoClient public func all<Storage>(_ mask: SIMDMask<Storage>) -> Bool where Storage : Swift.SIMD, Storage.Scalar : Swift.FixedWidthInteger, Storage.Scalar : Swift.SignedInteger {
  return mask._storage.max() < 0
}
@_fixed_layout public struct SIMD2<Scalar> : SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD2Storage
  public typealias MaskStorage = SIMD2<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Int {
    get {
    return 2
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD2Storage()
  }
  public subscript(index: Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar) {
    self.init()
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[0] = v0
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[1] = v1
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 66)
  }
  @_transparent public init(x: Scalar, y: Scalar) {
    self.init(x, y)
  }
  @_transparent public var x: Scalar {
    @_transparent get { return self[0]}
    @_transparent set { self[0] = newValue }
  }
  @_transparent public var y: Scalar {
    @_transparent get { return self[1]}
    @_transparent set { self[1] = newValue }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension SIMD2 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: SIMD2<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: SIMD2<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: SIMD2<Other>, rounding rule: FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    // TODO: this should clamp
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension SIMD2 : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension SIMD2 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: SIMD2<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: SIMD2<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
@_fixed_layout public struct SIMD4<Scalar> : SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD4Storage
  public typealias MaskStorage = SIMD4<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Int {
    get {
    return 4
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD4Storage()
  }
  public subscript(index: Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar, _ v3: Scalar) {
    self.init()
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[0] = v0
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[1] = v1
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[2] = v2
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[3] = v3
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 66)
  }
  @_transparent public init(x: Scalar, y: Scalar, z: Scalar, w: Scalar) {
    self.init(x, y, z, w)
  }
  @_transparent public var x: Scalar {
    @_transparent get { return self[0]}
    @_transparent set { self[0] = newValue }
  }
  @_transparent public var y: Scalar {
    @_transparent get { return self[1]}
    @_transparent set { self[1] = newValue }
  }
  @_transparent public var z: Scalar {
    @_transparent get { return self[2]}
    @_transparent set { self[2] = newValue }
  }
  @_transparent public var w: Scalar {
    @_transparent get { return self[3]}
    @_transparent set { self[3] = newValue }
  }
  @_transparent public init(lowHalf: SIMD2<Scalar>, highHalf: SIMD2<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }
  public var lowHalf: SIMD2<Scalar> {
    @inlinable get {
      var result = SIMD2<Scalar>()
      for i in result.indices { result[i] = self[i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[i] = newValue[i] }
    }
  }
  public var highHalf: SIMD2<Scalar> {
    @inlinable get {
      var result = SIMD2<Scalar>()
      for i in result.indices { result[i] = self[2+i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2+i] = newValue[i] }
    }
  }
  public var evenHalf: SIMD2<Scalar> {
    @inlinable get {
      var result = SIMD2<Scalar>()
      for i in result.indices { result[i] = self[2*i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i] = newValue[i] }
    }
  }
  public var oddHalf: SIMD2<Scalar> {
    @inlinable get {
      var result = SIMD2<Scalar>()
      for i in result.indices { result[i] = self[2*i+1] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i+1] = newValue[i] }
    }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension SIMD4 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: SIMD4<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: SIMD4<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: SIMD4<Other>, rounding rule: FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    // TODO: this should clamp
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension SIMD4 : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension SIMD4 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: SIMD4<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: SIMD4<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
@_fixed_layout public struct SIMD8<Scalar> : SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD8Storage
  public typealias MaskStorage = SIMD8<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Int {
    get {
    return 8
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD8Storage()
  }
  public subscript(index: Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar, _ v3: Scalar, _ v4: Scalar, _ v5: Scalar, _ v6: Scalar, _ v7: Scalar) {
    self.init()
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[0] = v0
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[1] = v1
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[2] = v2
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[3] = v3
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[4] = v4
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[5] = v5
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[6] = v6
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[7] = v7
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 66)
  }
  @_transparent public init(lowHalf: SIMD4<Scalar>, highHalf: SIMD4<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }
  public var lowHalf: SIMD4<Scalar> {
    @inlinable get {
      var result = SIMD4<Scalar>()
      for i in result.indices { result[i] = self[i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[i] = newValue[i] }
    }
  }
  public var highHalf: SIMD4<Scalar> {
    @inlinable get {
      var result = SIMD4<Scalar>()
      for i in result.indices { result[i] = self[4+i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[4+i] = newValue[i] }
    }
  }
  public var evenHalf: SIMD4<Scalar> {
    @inlinable get {
      var result = SIMD4<Scalar>()
      for i in result.indices { result[i] = self[2*i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i] = newValue[i] }
    }
  }
  public var oddHalf: SIMD4<Scalar> {
    @inlinable get {
      var result = SIMD4<Scalar>()
      for i in result.indices { result[i] = self[2*i+1] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i+1] = newValue[i] }
    }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension SIMD8 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: SIMD8<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: SIMD8<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: SIMD8<Other>, rounding rule: FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    // TODO: this should clamp
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension SIMD8 : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension SIMD8 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: SIMD8<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: SIMD8<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
@_fixed_layout public struct SIMD16<Scalar> : SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD16Storage
  public typealias MaskStorage = SIMD16<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Int {
    get {
    return 16
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD16Storage()
  }
  public subscript(index: Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar, _ v3: Scalar, _ v4: Scalar, _ v5: Scalar, _ v6: Scalar, _ v7: Scalar, _ v8: Scalar, _ v9: Scalar, _ v10: Scalar, _ v11: Scalar, _ v12: Scalar, _ v13: Scalar, _ v14: Scalar, _ v15: Scalar) {
    self.init()
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[0] = v0
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[1] = v1
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[2] = v2
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[3] = v3
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[4] = v4
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[5] = v5
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[6] = v6
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[7] = v7
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[8] = v8
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[9] = v9
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[10] = v10
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[11] = v11
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[12] = v12
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[13] = v13
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[14] = v14
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[15] = v15
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 66)
  }
  @_transparent public init(lowHalf: SIMD8<Scalar>, highHalf: SIMD8<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }
  public var lowHalf: SIMD8<Scalar> {
    @inlinable get {
      var result = SIMD8<Scalar>()
      for i in result.indices { result[i] = self[i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[i] = newValue[i] }
    }
  }
  public var highHalf: SIMD8<Scalar> {
    @inlinable get {
      var result = SIMD8<Scalar>()
      for i in result.indices { result[i] = self[8+i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[8+i] = newValue[i] }
    }
  }
  public var evenHalf: SIMD8<Scalar> {
    @inlinable get {
      var result = SIMD8<Scalar>()
      for i in result.indices { result[i] = self[2*i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i] = newValue[i] }
    }
  }
  public var oddHalf: SIMD8<Scalar> {
    @inlinable get {
      var result = SIMD8<Scalar>()
      for i in result.indices { result[i] = self[2*i+1] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i+1] = newValue[i] }
    }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension SIMD16 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: SIMD16<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: SIMD16<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: SIMD16<Other>, rounding rule: FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    // TODO: this should clamp
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension SIMD16 : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension SIMD16 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: SIMD16<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: SIMD16<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
@_fixed_layout public struct SIMD32<Scalar> : SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD32Storage
  public typealias MaskStorage = SIMD32<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Int {
    get {
    return 32
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD32Storage()
  }
  public subscript(index: Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar, _ v3: Scalar, _ v4: Scalar, _ v5: Scalar, _ v6: Scalar, _ v7: Scalar, _ v8: Scalar, _ v9: Scalar, _ v10: Scalar, _ v11: Scalar, _ v12: Scalar, _ v13: Scalar, _ v14: Scalar, _ v15: Scalar, _ v16: Scalar, _ v17: Scalar, _ v18: Scalar, _ v19: Scalar, _ v20: Scalar, _ v21: Scalar, _ v22: Scalar, _ v23: Scalar, _ v24: Scalar, _ v25: Scalar, _ v26: Scalar, _ v27: Scalar, _ v28: Scalar, _ v29: Scalar, _ v30: Scalar, _ v31: Scalar) {
    self.init()
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[0] = v0
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[1] = v1
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[2] = v2
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[3] = v3
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[4] = v4
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[5] = v5
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[6] = v6
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[7] = v7
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[8] = v8
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[9] = v9
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[10] = v10
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[11] = v11
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[12] = v12
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[13] = v13
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[14] = v14
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[15] = v15
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[16] = v16
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[17] = v17
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[18] = v18
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[19] = v19
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[20] = v20
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[21] = v21
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[22] = v22
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[23] = v23
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[24] = v24
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[25] = v25
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[26] = v26
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[27] = v27
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[28] = v28
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[29] = v29
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[30] = v30
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[31] = v31
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 66)
  }
  @_transparent public init(lowHalf: SIMD16<Scalar>, highHalf: SIMD16<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }
  public var lowHalf: SIMD16<Scalar> {
    @inlinable get {
      var result = SIMD16<Scalar>()
      for i in result.indices { result[i] = self[i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[i] = newValue[i] }
    }
  }
  public var highHalf: SIMD16<Scalar> {
    @inlinable get {
      var result = SIMD16<Scalar>()
      for i in result.indices { result[i] = self[16+i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[16+i] = newValue[i] }
    }
  }
  public var evenHalf: SIMD16<Scalar> {
    @inlinable get {
      var result = SIMD16<Scalar>()
      for i in result.indices { result[i] = self[2*i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i] = newValue[i] }
    }
  }
  public var oddHalf: SIMD16<Scalar> {
    @inlinable get {
      var result = SIMD16<Scalar>()
      for i in result.indices { result[i] = self[2*i+1] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i+1] = newValue[i] }
    }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension SIMD32 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: SIMD32<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: SIMD32<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: SIMD32<Other>, rounding rule: FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    // TODO: this should clamp
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension SIMD32 : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension SIMD32 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: SIMD32<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: SIMD32<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
@_fixed_layout public struct SIMD64<Scalar> : SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD64Storage
  public typealias MaskStorage = SIMD64<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Int {
    get {
    return 64
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD64Storage()
  }
  public subscript(index: Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar, _ v3: Scalar, _ v4: Scalar, _ v5: Scalar, _ v6: Scalar, _ v7: Scalar, _ v8: Scalar, _ v9: Scalar, _ v10: Scalar, _ v11: Scalar, _ v12: Scalar, _ v13: Scalar, _ v14: Scalar, _ v15: Scalar, _ v16: Scalar, _ v17: Scalar, _ v18: Scalar, _ v19: Scalar, _ v20: Scalar, _ v21: Scalar, _ v22: Scalar, _ v23: Scalar, _ v24: Scalar, _ v25: Scalar, _ v26: Scalar, _ v27: Scalar, _ v28: Scalar, _ v29: Scalar, _ v30: Scalar, _ v31: Scalar, _ v32: Scalar, _ v33: Scalar, _ v34: Scalar, _ v35: Scalar, _ v36: Scalar, _ v37: Scalar, _ v38: Scalar, _ v39: Scalar, _ v40: Scalar, _ v41: Scalar, _ v42: Scalar, _ v43: Scalar, _ v44: Scalar, _ v45: Scalar, _ v46: Scalar, _ v47: Scalar, _ v48: Scalar, _ v49: Scalar, _ v50: Scalar, _ v51: Scalar, _ v52: Scalar, _ v53: Scalar, _ v54: Scalar, _ v55: Scalar, _ v56: Scalar, _ v57: Scalar, _ v58: Scalar, _ v59: Scalar, _ v60: Scalar, _ v61: Scalar, _ v62: Scalar, _ v63: Scalar) {
    self.init()
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[0] = v0
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[1] = v1
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[2] = v2
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[3] = v3
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[4] = v4
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[5] = v5
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[6] = v6
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[7] = v7
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[8] = v8
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[9] = v9
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[10] = v10
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[11] = v11
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[12] = v12
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[13] = v13
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[14] = v14
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[15] = v15
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[16] = v16
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[17] = v17
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[18] = v18
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[19] = v19
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[20] = v20
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[21] = v21
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[22] = v22
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[23] = v23
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[24] = v24
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[25] = v25
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[26] = v26
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[27] = v27
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[28] = v28
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[29] = v29
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[30] = v30
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[31] = v31
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[32] = v32
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[33] = v33
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[34] = v34
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[35] = v35
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[36] = v36
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[37] = v37
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[38] = v38
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[39] = v39
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[40] = v40
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[41] = v41
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[42] = v42
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[43] = v43
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[44] = v44
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[45] = v45
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[46] = v46
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[47] = v47
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[48] = v48
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[49] = v49
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[50] = v50
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[51] = v51
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[52] = v52
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[53] = v53
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[54] = v54
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[55] = v55
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[56] = v56
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[57] = v57
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[58] = v58
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[59] = v59
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[60] = v60
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[61] = v61
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[62] = v62
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[63] = v63
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 66)
  }
  @_transparent public init(lowHalf: SIMD32<Scalar>, highHalf: SIMD32<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }
  public var lowHalf: SIMD32<Scalar> {
    @inlinable get {
      var result = SIMD32<Scalar>()
      for i in result.indices { result[i] = self[i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[i] = newValue[i] }
    }
  }
  public var highHalf: SIMD32<Scalar> {
    @inlinable get {
      var result = SIMD32<Scalar>()
      for i in result.indices { result[i] = self[32+i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[32+i] = newValue[i] }
    }
  }
  public var evenHalf: SIMD32<Scalar> {
    @inlinable get {
      var result = SIMD32<Scalar>()
      for i in result.indices { result[i] = self[2*i] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i] = newValue[i] }
    }
  }
  public var oddHalf: SIMD32<Scalar> {
    @inlinable get {
      var result = SIMD32<Scalar>()
      for i in result.indices { result[i] = self[2*i+1] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[2*i+1] = newValue[i] }
    }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension SIMD64 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: SIMD64<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: SIMD64<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: SIMD64<Other>, rounding rule: FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    // TODO: this should clamp
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension SIMD64 : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension SIMD64 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: SIMD64<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: SIMD64<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
@_fixed_layout public struct SIMD3<Scalar> : SIMD where Scalar : Swift.SIMDScalar {
  public var _storage: Scalar.SIMD4Storage
  public typealias MaskStorage = SIMD3<Scalar.SIMDMaskScalar>
  @_transparent public var scalarCount: Int {
    get {
    return 3
  }
  }
  @_transparent public init() {
    _storage = Scalar.SIMD4Storage()
  }
  public subscript(index: Int) -> Scalar {
    @_transparent get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @_transparent set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }
  @_transparent public init(_ v0: Scalar, _ v1: Scalar, _ v2: Scalar) {
    self.init()
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[0] = v0
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[1] = v1
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 64)
    self[2] = v2
// ###sourceLocation(file: "/BuildRoot/Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-1100.8.32.26/swift/stdlib/public/core/SIMDVectorTypes.swift.gyb", line: 66)
  }
  @_transparent public init(x: Scalar, y: Scalar, z: Scalar) {
    self.init(x, y, z)
  }
  @_transparent public var x: Scalar {
    @_transparent get { return self[0]}
    @_transparent set { self[0] = newValue }
  }
  @_transparent public var y: Scalar {
    @_transparent get { return self[1]}
    @_transparent set { self[1] = newValue }
  }
  @_transparent public var z: Scalar {
    @_transparent get { return self[2]}
    @_transparent set { self[2] = newValue }
  }
  public typealias ArrayLiteralElement = Scalar
  public var hashValue: Swift.Int {
    get
  }
}
extension SIMD3 where Scalar : Swift.FixedWidthInteger {
  @inlinable public init<Other>(truncatingIfNeeded other: SIMD3<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }
  @inlinable public init<Other>(clamping other: SIMD3<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
  @inlinable public init<Other>(_ other: SIMD3<Other>, rounding rule: FloatingPointRoundingRule = .towardZero) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    // TODO: this should clamp
    for i in indices { self[i] = Scalar(other[i].rounded(rule)) }
  }
}
extension SIMD3 : CustomDebugStringConvertible {
  public var debugDescription: String {
    get
  }
}
extension SIMD3 where Scalar : Swift.BinaryFloatingPoint {
  @inlinable public init<Other>(_ other: SIMD3<Other>) where Other : Swift.FixedWidthInteger, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
  @inlinable public init<Other>(_ other: SIMD3<Other>) where Other : Swift.BinaryFloatingPoint, Other : Swift.SIMDScalar {
    self.init()
    for i in indices { self[i] = Scalar(other[i]) }
  }
}
extension SIMD3 {
  @_alwaysEmitIntoClient public init(_ xy: SIMD2<Scalar>, _ z: Scalar) {
    self.init(xy.x, xy.y, z)
  }
}
extension SIMD4 {
  @_alwaysEmitIntoClient public init(_ xyz: SIMD3<Scalar>, _ w: Scalar) {
    self.init(xyz.x, xyz.y, xyz.z, w)
  }
}
extension UInt8 : SIMDScalar {
  public typealias SIMDMaskScalar = Int8
  @_fixed_layout @_alignment(2) public struct SIMD2Storage : SIMDStorage {
    public var _value: Builtin.Vec2xInt8
    @_transparent public var scalarCount: Int {
      get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec2xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
  @_fixed_layout @_alignment(4) public struct SIMD4Storage : SIMDStorage {
    public var _value: Builtin.Vec4xInt8
    @_transparent public var scalarCount: Int {
      get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec4xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
  @_fixed_layout @_alignment(8) public struct SIMD8Storage : SIMDStorage {
    public var _value: Builtin.Vec8xInt8
    @_transparent public var scalarCount: Int {
      get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec8xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
  @_fixed_layout @_alignment(16) public struct SIMD16Storage : SIMDStorage {
    public var _value: Builtin.Vec16xInt8
    @_transparent public var scalarCount: Int {
      get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec16xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
  @_fixed_layout @_alignment(16) public struct SIMD32Storage : SIMDStorage {
    public var _value: Builtin.Vec32xInt8
    @_transparent public var scalarCount: Int {
      get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec32xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
  @_fixed_layout @_alignment(16) public struct SIMD64Storage : SIMDStorage {
    public var _value: Builtin.Vec64xInt8
    @_transparent public var scalarCount: Int {
      get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt8 {
      @_transparent get {
        return UInt8(Builtin.extractelement_Vec64xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt8
  }
}
extension Int8 : SIMDScalar {
  public typealias SIMDMaskScalar = Int8
  @_fixed_layout @_alignment(2) public struct SIMD2Storage : SIMDStorage {
    public var _value: Builtin.Vec2xInt8
    @_transparent public var scalarCount: Int {
      get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec2xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
  @_fixed_layout @_alignment(4) public struct SIMD4Storage : SIMDStorage {
    public var _value: Builtin.Vec4xInt8
    @_transparent public var scalarCount: Int {
      get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec4xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
  @_fixed_layout @_alignment(8) public struct SIMD8Storage : SIMDStorage {
    public var _value: Builtin.Vec8xInt8
    @_transparent public var scalarCount: Int {
      get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec8xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
  @_fixed_layout @_alignment(16) public struct SIMD16Storage : SIMDStorage {
    public var _value: Builtin.Vec16xInt8
    @_transparent public var scalarCount: Int {
      get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec16xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
  @_fixed_layout @_alignment(16) public struct SIMD32Storage : SIMDStorage {
    public var _value: Builtin.Vec32xInt8
    @_transparent public var scalarCount: Int {
      get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec32xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
  @_fixed_layout @_alignment(16) public struct SIMD64Storage : SIMDStorage {
    public var _value: Builtin.Vec64xInt8
    @_transparent public var scalarCount: Int {
      get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int8 {
      @_transparent get {
        return Int8(Builtin.extractelement_Vec64xInt8_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt8_Int8_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int8
  }
}
extension UInt16 : SIMDScalar {
  public typealias SIMDMaskScalar = Int16
  @_fixed_layout @_alignment(4) public struct SIMD2Storage : SIMDStorage {
    public var _value: Builtin.Vec2xInt16
    @_transparent public var scalarCount: Int {
      get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec2xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
  @_fixed_layout @_alignment(8) public struct SIMD4Storage : SIMDStorage {
    public var _value: Builtin.Vec4xInt16
    @_transparent public var scalarCount: Int {
      get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec4xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
  @_fixed_layout @_alignment(16) public struct SIMD8Storage : SIMDStorage {
    public var _value: Builtin.Vec8xInt16
    @_transparent public var scalarCount: Int {
      get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec8xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
  @_fixed_layout @_alignment(16) public struct SIMD16Storage : SIMDStorage {
    public var _value: Builtin.Vec16xInt16
    @_transparent public var scalarCount: Int {
      get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec16xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
  @_fixed_layout @_alignment(16) public struct SIMD32Storage : SIMDStorage {
    public var _value: Builtin.Vec32xInt16
    @_transparent public var scalarCount: Int {
      get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec32xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
  @_fixed_layout @_alignment(16) public struct SIMD64Storage : SIMDStorage {
    public var _value: Builtin.Vec64xInt16
    @_transparent public var scalarCount: Int {
      get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt16 {
      @_transparent get {
        return UInt16(Builtin.extractelement_Vec64xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt16
  }
}
extension Int16 : SIMDScalar {
  public typealias SIMDMaskScalar = Int16
  @_fixed_layout @_alignment(4) public struct SIMD2Storage : SIMDStorage {
    public var _value: Builtin.Vec2xInt16
    @_transparent public var scalarCount: Int {
      get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec2xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
  @_fixed_layout @_alignment(8) public struct SIMD4Storage : SIMDStorage {
    public var _value: Builtin.Vec4xInt16
    @_transparent public var scalarCount: Int {
      get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec4xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
  @_fixed_layout @_alignment(16) public struct SIMD8Storage : SIMDStorage {
    public var _value: Builtin.Vec8xInt16
    @_transparent public var scalarCount: Int {
      get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec8xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
  @_fixed_layout @_alignment(16) public struct SIMD16Storage : SIMDStorage {
    public var _value: Builtin.Vec16xInt16
    @_transparent public var scalarCount: Int {
      get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec16xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
  @_fixed_layout @_alignment(16) public struct SIMD32Storage : SIMDStorage {
    public var _value: Builtin.Vec32xInt16
    @_transparent public var scalarCount: Int {
      get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec32xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
  @_fixed_layout @_alignment(16) public struct SIMD64Storage : SIMDStorage {
    public var _value: Builtin.Vec64xInt16
    @_transparent public var scalarCount: Int {
      get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int16 {
      @_transparent get {
        return Int16(Builtin.extractelement_Vec64xInt16_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt16_Int16_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int16
  }
}
extension UInt32 : SIMDScalar {
  public typealias SIMDMaskScalar = Int32
  @_fixed_layout @_alignment(8) public struct SIMD2Storage : SIMDStorage {
    public var _value: Builtin.Vec2xInt32
    @_transparent public var scalarCount: Int {
      get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec2xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
  @_fixed_layout @_alignment(16) public struct SIMD4Storage : SIMDStorage {
    public var _value: Builtin.Vec4xInt32
    @_transparent public var scalarCount: Int {
      get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec4xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
  @_fixed_layout @_alignment(16) public struct SIMD8Storage : SIMDStorage {
    public var _value: Builtin.Vec8xInt32
    @_transparent public var scalarCount: Int {
      get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec8xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
  @_fixed_layout @_alignment(16) public struct SIMD16Storage : SIMDStorage {
    public var _value: Builtin.Vec16xInt32
    @_transparent public var scalarCount: Int {
      get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec16xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
  @_fixed_layout @_alignment(16) public struct SIMD32Storage : SIMDStorage {
    public var _value: Builtin.Vec32xInt32
    @_transparent public var scalarCount: Int {
      get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec32xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
  @_fixed_layout @_alignment(16) public struct SIMD64Storage : SIMDStorage {
    public var _value: Builtin.Vec64xInt32
    @_transparent public var scalarCount: Int {
      get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt32 {
      @_transparent get {
        return UInt32(Builtin.extractelement_Vec64xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt32
  }
}
extension Int32 : SIMDScalar {
  public typealias SIMDMaskScalar = Int32
  @_fixed_layout @_alignment(8) public struct SIMD2Storage : SIMDStorage {
    public var _value: Builtin.Vec2xInt32
    @_transparent public var scalarCount: Int {
      get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec2xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
  @_fixed_layout @_alignment(16) public struct SIMD4Storage : SIMDStorage {
    public var _value: Builtin.Vec4xInt32
    @_transparent public var scalarCount: Int {
      get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec4xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
  @_fixed_layout @_alignment(16) public struct SIMD8Storage : SIMDStorage {
    public var _value: Builtin.Vec8xInt32
    @_transparent public var scalarCount: Int {
      get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec8xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
  @_fixed_layout @_alignment(16) public struct SIMD16Storage : SIMDStorage {
    public var _value: Builtin.Vec16xInt32
    @_transparent public var scalarCount: Int {
      get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec16xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
  @_fixed_layout @_alignment(16) public struct SIMD32Storage : SIMDStorage {
    public var _value: Builtin.Vec32xInt32
    @_transparent public var scalarCount: Int {
      get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec32xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
  @_fixed_layout @_alignment(16) public struct SIMD64Storage : SIMDStorage {
    public var _value: Builtin.Vec64xInt32
    @_transparent public var scalarCount: Int {
      get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int32 {
      @_transparent get {
        return Int32(Builtin.extractelement_Vec64xInt32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt32_Int32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int32
  }
}
extension UInt64 : SIMDScalar {
  public typealias SIMDMaskScalar = Int64
  @_fixed_layout @_alignment(16) public struct SIMD2Storage : SIMDStorage {
    public var _value: Builtin.Vec2xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec2xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
  @_fixed_layout @_alignment(16) public struct SIMD4Storage : SIMDStorage {
    public var _value: Builtin.Vec4xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec4xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
  @_fixed_layout @_alignment(16) public struct SIMD8Storage : SIMDStorage {
    public var _value: Builtin.Vec8xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec8xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
  @_fixed_layout @_alignment(16) public struct SIMD16Storage : SIMDStorage {
    public var _value: Builtin.Vec16xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec16xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
  @_fixed_layout @_alignment(16) public struct SIMD32Storage : SIMDStorage {
    public var _value: Builtin.Vec32xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec32xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
  @_fixed_layout @_alignment(16) public struct SIMD64Storage : SIMDStorage {
    public var _value: Builtin.Vec64xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt64 {
      @_transparent get {
        return UInt64(Builtin.extractelement_Vec64xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt64
  }
}
extension Int64 : SIMDScalar {
  public typealias SIMDMaskScalar = Int64
  @_fixed_layout @_alignment(16) public struct SIMD2Storage : SIMDStorage {
    public var _value: Builtin.Vec2xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec2xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
  @_fixed_layout @_alignment(16) public struct SIMD4Storage : SIMDStorage {
    public var _value: Builtin.Vec4xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec4xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
  @_fixed_layout @_alignment(16) public struct SIMD8Storage : SIMDStorage {
    public var _value: Builtin.Vec8xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec8xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
  @_fixed_layout @_alignment(16) public struct SIMD16Storage : SIMDStorage {
    public var _value: Builtin.Vec16xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec16xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
  @_fixed_layout @_alignment(16) public struct SIMD32Storage : SIMDStorage {
    public var _value: Builtin.Vec32xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec32xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
  @_fixed_layout @_alignment(16) public struct SIMD64Storage : SIMDStorage {
    public var _value: Builtin.Vec64xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int64 {
      @_transparent get {
        return Int64(Builtin.extractelement_Vec64xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int64
  }
}
extension UInt : SIMDScalar {
  public typealias SIMDMaskScalar = Int
  @_fixed_layout @_alignment(16) public struct SIMD2Storage : SIMDStorage {
    public var _value: Builtin.Vec2xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec2xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
  @_fixed_layout @_alignment(16) public struct SIMD4Storage : SIMDStorage {
    public var _value: Builtin.Vec4xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec4xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
  @_fixed_layout @_alignment(16) public struct SIMD8Storage : SIMDStorage {
    public var _value: Builtin.Vec8xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec8xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
  @_fixed_layout @_alignment(16) public struct SIMD16Storage : SIMDStorage {
    public var _value: Builtin.Vec16xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec16xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
  @_fixed_layout @_alignment(16) public struct SIMD32Storage : SIMDStorage {
    public var _value: Builtin.Vec32xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec32xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
  @_fixed_layout @_alignment(16) public struct SIMD64Storage : SIMDStorage {
    public var _value: Builtin.Vec64xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> UInt {
      @_transparent get {
        return UInt(Builtin.extractelement_Vec64xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.UInt
  }
}
extension Int : SIMDScalar {
  public typealias SIMDMaskScalar = Int
  @_fixed_layout @_alignment(16) public struct SIMD2Storage : SIMDStorage {
    public var _value: Builtin.Vec2xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec2xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
  @_fixed_layout @_alignment(16) public struct SIMD4Storage : SIMDStorage {
    public var _value: Builtin.Vec4xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec4xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
  @_fixed_layout @_alignment(16) public struct SIMD8Storage : SIMDStorage {
    public var _value: Builtin.Vec8xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec8xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
  @_fixed_layout @_alignment(16) public struct SIMD16Storage : SIMDStorage {
    public var _value: Builtin.Vec16xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec16xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
  @_fixed_layout @_alignment(16) public struct SIMD32Storage : SIMDStorage {
    public var _value: Builtin.Vec32xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec32xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
  @_fixed_layout @_alignment(16) public struct SIMD64Storage : SIMDStorage {
    public var _value: Builtin.Vec64xInt64
    @_transparent public var scalarCount: Int {
      get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Int {
      @_transparent get {
        return Int(Builtin.extractelement_Vec64xInt64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xInt64_Int64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Int
  }
}
extension Float : SIMDScalar {
  public typealias SIMDMaskScalar = Int32
  @_fixed_layout @_alignment(8) public struct SIMD2Storage : SIMDStorage {
    public var _value: Builtin.Vec2xFPIEEE32
    @_transparent public var scalarCount: Int {
      get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec2xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
  @_fixed_layout @_alignment(16) public struct SIMD4Storage : SIMDStorage {
    public var _value: Builtin.Vec4xFPIEEE32
    @_transparent public var scalarCount: Int {
      get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec4xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
  @_fixed_layout @_alignment(16) public struct SIMD8Storage : SIMDStorage {
    public var _value: Builtin.Vec8xFPIEEE32
    @_transparent public var scalarCount: Int {
      get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec8xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
  @_fixed_layout @_alignment(16) public struct SIMD16Storage : SIMDStorage {
    public var _value: Builtin.Vec16xFPIEEE32
    @_transparent public var scalarCount: Int {
      get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec16xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
  @_fixed_layout @_alignment(16) public struct SIMD32Storage : SIMDStorage {
    public var _value: Builtin.Vec32xFPIEEE32
    @_transparent public var scalarCount: Int {
      get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec32xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
  @_fixed_layout @_alignment(16) public struct SIMD64Storage : SIMDStorage {
    public var _value: Builtin.Vec64xFPIEEE32
    @_transparent public var scalarCount: Int {
      get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Float {
      @_transparent get {
        return Float(Builtin.extractelement_Vec64xFPIEEE32_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xFPIEEE32_FPIEEE32_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Float
  }
}
extension Double : SIMDScalar {
  public typealias SIMDMaskScalar = Int64
  @_fixed_layout @_alignment(16) public struct SIMD2Storage : SIMDStorage {
    public var _value: Builtin.Vec2xFPIEEE64
    @_transparent public var scalarCount: Int {
      get {
      return 2
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec2xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec2xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
  @_fixed_layout @_alignment(16) public struct SIMD4Storage : SIMDStorage {
    public var _value: Builtin.Vec4xFPIEEE64
    @_transparent public var scalarCount: Int {
      get {
      return 4
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec4xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec4xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
  @_fixed_layout @_alignment(16) public struct SIMD8Storage : SIMDStorage {
    public var _value: Builtin.Vec8xFPIEEE64
    @_transparent public var scalarCount: Int {
      get {
      return 8
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec8xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec8xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
  @_fixed_layout @_alignment(16) public struct SIMD16Storage : SIMDStorage {
    public var _value: Builtin.Vec16xFPIEEE64
    @_transparent public var scalarCount: Int {
      get {
      return 16
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec16xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec16xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
  @_fixed_layout @_alignment(16) public struct SIMD32Storage : SIMDStorage {
    public var _value: Builtin.Vec32xFPIEEE64
    @_transparent public var scalarCount: Int {
      get {
      return 32
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec32xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec32xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
  @_fixed_layout @_alignment(16) public struct SIMD64Storage : SIMDStorage {
    public var _value: Builtin.Vec64xFPIEEE64
    @_transparent public var scalarCount: Int {
      get {
      return 64
    }
    }
    @_transparent public init() {
      _value = Builtin.zeroInitializer()
    }
    public subscript(index: Int) -> Double {
      @_transparent get {
        return Double(Builtin.extractelement_Vec64xFPIEEE64_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent set {
        _value = Builtin.insertelement_Vec64xFPIEEE64_FPIEEE64_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
    public typealias Scalar = Swift.Double
  }
}
@inlinable public func == (lhs: (), rhs: ()) -> Bool {
  return true
}
@inlinable public func != (lhs: (), rhs: ()) -> Bool {
    return false
}
@inlinable public func < (lhs: (), rhs: ()) -> Bool {
    return false
}
@inlinable public func <= (lhs: (), rhs: ()) -> Bool {
    return true
}
@inlinable public func > (lhs: (), rhs: ()) -> Bool {
    return false
}
@inlinable public func >= (lhs: (), rhs: ()) -> Bool {
    return true
}
@inlinable public func == <A, B>(lhs: (A, B), rhs: (A, B)) -> Bool where A : Swift.Equatable, B : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return false }
  /*tail*/ return (
    lhs.1
  ) == (
    rhs.1
  )
}
@inlinable public func != <A, B>(lhs: (A, B), rhs: (A, B)) -> Bool where A : Swift.Equatable, B : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return true }
  /*tail*/ return (
    lhs.1
  ) != (
    rhs.1
  )
}
@inlinable public func < <A, B>(lhs: (A, B), rhs: (A, B)) -> Bool where A : Swift.Comparable, B : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 < rhs.0 }
  /*tail*/ return (
    lhs.1
  ) < (
    rhs.1
  )
}
@inlinable public func <= <A, B>(lhs: (A, B), rhs: (A, B)) -> Bool where A : Swift.Comparable, B : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 <= rhs.0 }
  /*tail*/ return (
    lhs.1
  ) <= (
    rhs.1
  )
}
@inlinable public func > <A, B>(lhs: (A, B), rhs: (A, B)) -> Bool where A : Swift.Comparable, B : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 > rhs.0 }
  /*tail*/ return (
    lhs.1
  ) > (
    rhs.1
  )
}
@inlinable public func >= <A, B>(lhs: (A, B), rhs: (A, B)) -> Bool where A : Swift.Comparable, B : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 >= rhs.0 }
  /*tail*/ return (
    lhs.1
  ) >= (
    rhs.1
  )
}
@inlinable public func == <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return false }
  /*tail*/ return (
    lhs.1, lhs.2
  ) == (
    rhs.1, rhs.2
  )
}
@inlinable public func != <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return true }
  /*tail*/ return (
    lhs.1, lhs.2
  ) != (
    rhs.1, rhs.2
  )
}
@inlinable public func < <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 < rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2
  ) < (
    rhs.1, rhs.2
  )
}
@inlinable public func <= <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 <= rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2
  ) <= (
    rhs.1, rhs.2
  )
}
@inlinable public func > <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 > rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2
  ) > (
    rhs.1, rhs.2
  )
}
@inlinable public func >= <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 >= rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2
  ) >= (
    rhs.1, rhs.2
  )
}
@inlinable public func == <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return false }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3
  ) == (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func != <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return true }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3
  ) != (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func < <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 < rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3
  ) < (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func <= <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 <= rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3
  ) <= (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func > <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 > rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3
  ) > (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func >= <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 >= rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3
  ) >= (
    rhs.1, rhs.2, rhs.3
  )
}
@inlinable public func == <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable, E : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return false }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) == (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func != <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable, E : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return true }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) != (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func < <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 < rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) < (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func <= <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 <= rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) <= (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func > <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 > rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) > (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func >= <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 >= rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4
  ) >= (
    rhs.1, rhs.2, rhs.3, rhs.4
  )
}
@inlinable public func == <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable, E : Swift.Equatable, F : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return false }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) == (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
@inlinable public func != <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool where A : Swift.Equatable, B : Swift.Equatable, C : Swift.Equatable, D : Swift.Equatable, E : Swift.Equatable, F : Swift.Equatable {
  guard lhs.0 == rhs.0 else { return true }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) != (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
@inlinable public func < <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable, F : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 < rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) < (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
@inlinable public func <= <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable, F : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 <= rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) <= (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
@inlinable public func > <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable, F : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 > rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) > (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
@inlinable public func >= <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool where A : Swift.Comparable, B : Swift.Comparable, C : Swift.Comparable, D : Swift.Comparable, E : Swift.Comparable, F : Swift.Comparable {
  if lhs.0 != rhs.0 { return lhs.0 >= rhs.0 }
  /*tail*/ return (
    lhs.1, lhs.2, lhs.3, lhs.4, lhs.5
  ) >= (
    rhs.1, rhs.2, rhs.3, rhs.4, rhs.5
  )
}
@inlinable public func sequence<T>(first: T, next: @escaping (T) -> T?) -> UnfoldFirstSequence<T> {
  // The trivial implementation where the state is the next value to return
  // has the downside of being unnecessarily eager (it evaluates `next` one
  // step in advance). We solve this by using a boolean value to disambiguate
  // between the first value (that's computed in advance) and the rest.
  return sequence(state: (first, true), next: { (state: inout (T?, Bool)) -> T? in
    switch state {
    case (let value, true):
      state.1 = false
      return value
    case (let value?, _):
      let nextValue = next(value)
      state.0 = nextValue
      return nextValue
    case (nil, _):
      return nil
    }
  })
}
@inlinable public func sequence<T, State>(state: State, next: @escaping (inout State) -> T?) -> UnfoldSequence<T, State> {
  return UnfoldSequence(_state: state, _next: next)
}
public typealias UnfoldFirstSequence<T> = UnfoldSequence<T, (T?, Bool)>
@_fixed_layout public struct UnfoldSequence<Element, State> : Sequence, IteratorProtocol {
  @inlinable mutating public func next() -> Element? {
    guard !_done else { return nil }
    if let elt = _next(&_state) {
        return elt
    } else {
        _done = true
        return nil
    }
  }
  @inlinable internal init(_state: State, _next: @escaping (inout State) -> Element?) {
    self._state = _state
    self._next = _next
  }
  @usableFromInline
  internal var _state: State
  @usableFromInline
  internal let _next: (inout State) -> Element?
  @usableFromInline
  internal var _done: Swift.Bool = false
  public typealias Iterator = Swift.UnfoldSequence<Element, State>
}
public protocol CVarArg {
  var _cVarArgEncoding: [Int] { get }
}
public protocol _CVarArgPassedAsDouble : Swift.CVarArg {
}
public protocol _CVarArgAligned : Swift.CVarArg {
  var _cVarArgAlignment: Int { get }
}
@usableFromInline
internal let _countGPRegisters: Swift.Int
@usableFromInline
internal let _countFPRegisters: Swift.Int
@usableFromInline
internal let _fpRegisterWords: Swift.Int
@usableFromInline
internal let _registerSaveWords: Swift.Int
@usableFromInline
internal typealias _VAUInt = CUnsignedInt
@usableFromInline
internal typealias _VAInt = Int32
@inlinable public func withVaList<R>(_ args: [CVarArg], _ body: (CVaListPointer) -> R) -> R {
  let builder = __VaListBuilder()
  for a in args {
    builder.append(a)
  }
  return _withVaList(builder, body)
}
@inlinable internal func _withVaList<R>(_ builder: __VaListBuilder, _ body: (CVaListPointer) -> R) -> R {
  let result = body(builder.va_list())
  _fixLifetime(builder)
  return result
}
@inlinable public func getVaList(_ args: [CVarArg]) -> CVaListPointer {
  let builder = __VaListBuilder()
  for a in args {
    builder.append(a)
  }
  // FIXME: Use some Swift equivalent of NS_RETURNS_INNER_POINTER if we get one.
  Builtin.retain(builder)
  Builtin.autorelease(builder)
  return builder.va_list()
}
@inlinable public func _encodeBitsAsWords<T>(_ x: T) -> [Int] {
  let result = [Int](
    repeating: 0,
    count: (MemoryLayout<T>.size + MemoryLayout<Int>.size - 1) / MemoryLayout<Int>.size)
  _internalInvariant(result.count > 0)
  var tmp = x
  // FIXME: use UnsafeMutablePointer.assign(from:) instead of memcpy.
  _memcpy(dest: UnsafeMutablePointer(result._baseAddressIfContiguous!),
          src: UnsafeMutablePointer(Builtin.addressof(&tmp)),
          size: UInt(MemoryLayout<T>.size))
  return result
}
extension Int : CVarArg {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
extension Bool : CVarArg {
  public var _cVarArgEncoding: [Int] {
    get
  }
}
extension Int64 : CVarArg, _CVarArgAligned {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
  @inlinable public var _cVarArgAlignment: Int {
    get {
    // FIXME: alignof differs from the ABI alignment on some architectures
    return MemoryLayout.alignment(ofValue: self)
  }
  }
}
extension Int32 : CVarArg {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(_VAInt(self))
  }
  }
}
extension Int16 : CVarArg {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(_VAInt(self))
  }
  }
}
extension Int8 : CVarArg {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(_VAInt(self))
  }
  }
}
extension UInt : CVarArg {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
extension UInt64 : CVarArg, _CVarArgAligned {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
  @inlinable public var _cVarArgAlignment: Int {
    get {
    // FIXME: alignof differs from the ABI alignment on some architectures
    return MemoryLayout.alignment(ofValue: self)
  }
  }
}
extension UInt32 : CVarArg {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(_VAUInt(self))
  }
  }
}
extension UInt16 : CVarArg {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(_VAUInt(self))
  }
  }
}
extension UInt8 : CVarArg {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(_VAUInt(self))
  }
  }
}
extension OpaquePointer : CVarArg {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
extension UnsafePointer : CVarArg {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
extension UnsafeMutablePointer : CVarArg {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
extension AutoreleasingUnsafeMutablePointer : CVarArg {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
}
extension Float : _CVarArgPassedAsDouble, _CVarArgAligned {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(Double(self))
  }
  }
  @inlinable public var _cVarArgAlignment: Int {
    get {
    // FIXME: alignof differs from the ABI alignment on some architectures
    return MemoryLayout.alignment(ofValue: Double(self))
  }
  }
}
extension Double : _CVarArgPassedAsDouble, _CVarArgAligned {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
  @inlinable public var _cVarArgAlignment: Int {
    get {
    // FIXME: alignof differs from the ABI alignment on some architectures
    return MemoryLayout.alignment(ofValue: self)
  }
  }
}
extension Float80 : CVarArg, _CVarArgAligned {
  @inlinable public var _cVarArgEncoding: [Int] {
    get {
    return _encodeBitsAsWords(self)
  }
  }
  @inlinable public var _cVarArgAlignment: Int {
    get {
    // FIXME: alignof differs from the ABI alignment on some architectures
    return MemoryLayout.alignment(ofValue: self)
  }
  }
}
@usableFromInline
@_fixed_layout final internal class __VaListBuilder {
  @usableFromInline
  @_fixed_layout internal struct Header {
    @inlinable internal init() {}
    @usableFromInline
    internal var gp_offset: Swift.CUnsignedInt = CUnsignedInt(0)
    @usableFromInline
    internal var fp_offset: Swift.CUnsignedInt = CUnsignedInt(_countGPRegisters * MemoryLayout<Int>.stride)
    @usableFromInline
    internal var overflow_arg_area: UnsafeMutablePointer<Int>?
    @usableFromInline
    internal var reg_save_area: UnsafeMutablePointer<Int>?
  }
  @usableFromInline
  final internal var gpRegistersUsed: Swift.Int = 0
  @usableFromInline
  final internal var fpRegistersUsed: Swift.Int = 0
  @usableFromInline
  final internal var header: Swift.__VaListBuilder.Header = Header()
  @usableFromInline
  final internal var storage: ContiguousArray<Int>
  @inlinable internal init() {
    // prepare the register save area
    storage = ContiguousArray(repeating: 0, count: _registerSaveWords)
  }
  @objc @inlinable deinit {}
  @inlinable final internal func append(_ arg: CVarArg) {
    var encoded = arg._cVarArgEncoding

    let isDouble = arg is _CVarArgPassedAsDouble

    if isDouble && fpRegistersUsed < _countFPRegisters {
        var startIndex = _countGPRegisters
             + (fpRegistersUsed * _fpRegisterWords)
      for w in encoded {
        storage[startIndex] = w
        startIndex += 1
      }
      fpRegistersUsed += 1
    }
    else if encoded.count == 1
      && !isDouble
      && gpRegistersUsed < _countGPRegisters {
        let startIndex = gpRegistersUsed
      storage[startIndex] = encoded[0]
      gpRegistersUsed += 1
    }
    else {
      for w in encoded {
        storage.append(w)
      }
    }

  }
  @inlinable final internal func va_list() -> CVaListPointer {
      header.reg_save_area = storage._baseAddress
      header.overflow_arg_area
        = storage._baseAddress + _registerSaveWords
      return CVaListPointer(
               _fromUnsafeMutablePointer: UnsafeMutableRawPointer(
                 Builtin.addressof(&self.header)))
  }
}
@inlinable public func zip<Sequence1, Sequence2>(_ sequence1: Sequence1, _ sequence2: Sequence2) -> Zip2Sequence<Sequence1, Sequence2> where Sequence1 : Swift.Sequence, Sequence2 : Swift.Sequence {
  return Zip2Sequence(sequence1, sequence2)
}
@_fixed_layout public struct Zip2Sequence<Sequence1, Sequence2> where Sequence1 : Swift.Sequence, Sequence2 : Swift.Sequence {
  @usableFromInline
  internal let _sequence1: Sequence1
  @usableFromInline
  internal let _sequence2: Sequence2
  @inlinable internal init(_ sequence1: Sequence1, _ sequence2: Sequence2) {
    (_sequence1, _sequence2) = (sequence1, sequence2)
  }
}
extension Zip2Sequence {
  @_fixed_layout public struct Iterator {
    @usableFromInline
    internal var _baseStream1: Sequence1.Iterator
    @usableFromInline
    internal var _baseStream2: Sequence2.Iterator
    @usableFromInline
    internal var _reachedEnd: Bool = false
    @inlinable internal init(_ iterator1: Sequence1.Iterator, _ iterator2: Sequence2.Iterator) {
      (_baseStream1, _baseStream2) = (iterator1, iterator2)
    }
  }
}
extension Zip2Sequence.Iterator : IteratorProtocol {
  public typealias Element = (Sequence1.Element, Sequence2.Element)
  @inlinable mutating public func next() -> Element? {
    // The next() function needs to track if it has reached the end.  If we
    // didn't, and the first sequence is longer than the second, then when we
    // have already exhausted the second sequence, on every subsequent call to
    // next() we would consume and discard one additional element from the
    // first sequence, even though next() had already returned nil.

    if _reachedEnd {
      return nil
    }

    guard let element1 = _baseStream1.next(),
          let element2 = _baseStream2.next() else {
      _reachedEnd = true
      return nil
    }

    return (element1, element2)
  }
}
extension Zip2Sequence : Sequence {
  public typealias Element = (Sequence1.Element, Sequence2.Element)
  @inlinable __consuming public func makeIterator() -> Iterator {
    return Iterator(
      _sequence1.makeIterator(),
      _sequence2.makeIterator())
  }
  @inlinable public var underestimatedCount: Int {
    get {
    return Swift.min(
      _sequence1.underestimatedCount,
      _sequence2.underestimatedCount
    )
  }
  }
}
