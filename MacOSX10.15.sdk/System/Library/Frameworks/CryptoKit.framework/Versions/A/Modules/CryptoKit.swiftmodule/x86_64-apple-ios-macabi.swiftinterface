// swift-interface-format-version: 1.0
// swift-tools-version: Apple Swift version 5.1 (swiftlang-1100.8.32.26 clang-1100.0.18.2)
// swift-module-flags: -target x86_64-apple-ios13.0-macabi -enable-objc-interop -swift-version 5 -enforce-exclusivity=checked -O -enable-resilience -module-name CryptoKit
import Foundation
import LocalAuthentication
import Security.SecAccessControl
import Security
import Swift
extension Curve25519.Signing.PublicKey {
  public func isValidSignature<S, D>(_ signature: S, for data: D) -> Bool where S : Foundation.DataProtocol, D : Foundation.DataProtocol
}
extension Curve25519.Signing.PrivateKey {
  public func signature<D>(for data: D) throws -> Data where D : Foundation.DataProtocol
}
extension P256 {
  public enum Signing {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Data? {
        get
      }
      public var rawRepresentation: Data {
        get
      }
      public var x963Representation: Data {
        get
      }
    }
    public struct PrivateKey {
      public init()
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: P256.Signing.PublicKey {
        get
      }
      public var rawRepresentation: Data {
        get
      }
      public var x963Representation: Data {
        get
      }
    }
  }
}
extension P256 {
  public enum KeyAgreement {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Data? {
        get
      }
      public var rawRepresentation: Data {
        get
      }
      public var x963Representation: Data {
        get
      }
    }
    public struct PrivateKey {
      public init()
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: P256.KeyAgreement.PublicKey {
        get
      }
      public var rawRepresentation: Data {
        get
      }
      public var x963Representation: Data {
        get
      }
    }
  }
}
extension P384 {
  public enum Signing {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Data? {
        get
      }
      public var rawRepresentation: Data {
        get
      }
      public var x963Representation: Data {
        get
      }
    }
    public struct PrivateKey {
      public init()
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: P384.Signing.PublicKey {
        get
      }
      public var rawRepresentation: Data {
        get
      }
      public var x963Representation: Data {
        get
      }
    }
  }
}
extension P384 {
  public enum KeyAgreement {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Data? {
        get
      }
      public var rawRepresentation: Data {
        get
      }
      public var x963Representation: Data {
        get
      }
    }
    public struct PrivateKey {
      public init()
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: P384.KeyAgreement.PublicKey {
        get
      }
      public var rawRepresentation: Data {
        get
      }
      public var x963Representation: Data {
        get
      }
    }
  }
}
extension P521 {
  public enum Signing {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Data? {
        get
      }
      public var rawRepresentation: Data {
        get
      }
      public var x963Representation: Data {
        get
      }
    }
    public struct PrivateKey {
      public init()
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: P521.Signing.PublicKey {
        get
      }
      public var rawRepresentation: Data {
        get
      }
      public var x963Representation: Data {
        get
      }
    }
  }
}
extension P521 {
  public enum KeyAgreement {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public init<Bytes>(compactRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var compactRepresentation: Data? {
        get
      }
      public var rawRepresentation: Data {
        get
      }
      public var x963Representation: Data {
        get
      }
    }
    public struct PrivateKey {
      public init()
      public init<Bytes>(x963Representation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public init<Bytes>(rawRepresentation: Bytes) throws where Bytes : Foundation.ContiguousBytes
      public var publicKey: P521.KeyAgreement.PublicKey {
        get
      }
      public var rawRepresentation: Data {
        get
      }
      public var x963Representation: Data {
        get
      }
    }
  }
}
extension P256.KeyAgreement.PrivateKey {
  public func sharedSecretFromKeyAgreement(with publicKeyShare: P256.KeyAgreement.PublicKey) throws -> SharedSecret
}
extension P384.KeyAgreement.PrivateKey {
  public func sharedSecretFromKeyAgreement(with publicKeyShare: P384.KeyAgreement.PublicKey) throws -> SharedSecret
}
extension P521.KeyAgreement.PrivateKey {
  public func sharedSecretFromKeyAgreement(with publicKeyShare: P521.KeyAgreement.PublicKey) throws -> SharedSecret
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum Curve25519 {
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum P256 {
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum P384 {
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum P521 {
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public protocol Digest : Foundation.ContiguousBytes, Swift.CustomStringConvertible, Swift.Hashable, Swift.Sequence where Self.Element == Swift.UInt8 {
  static var byteCount: Int { get }
}
extension Digest {
  public func makeIterator() -> Array<UInt8>.Iterator
}
extension Digest {
  public static func == (lhs: Self, rhs: Self) -> Bool
  public static func == (lhs: Self, rhs: ContiguousBytes) -> Bool
  public var description: String {
    get
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA256Digest {
  public init?(bufferPointer: UnsafeRawBufferPointer)
  public static var byteCount: Int {
    get
  }
  public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public var description: String {
    get
  }
  public func hash(into hasher: inout Hasher)
  public typealias Element = Swift.UInt8
  public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA384Digest {
  public init?(bufferPointer: UnsafeRawBufferPointer)
  public static var byteCount: Int {
    get
  }
  public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public var description: String {
    get
  }
  public func hash(into hasher: inout Hasher)
  public typealias Element = Swift.UInt8
  public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA512Digest {
  public init?(bufferPointer: UnsafeRawBufferPointer)
  public static var byteCount: Int {
    get
  }
  public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public var description: String {
    get
  }
  public func hash(into hasher: inout Hasher)
  public typealias Element = Swift.UInt8
  public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  public var hashValue: Swift.Int {
    get
  }
}
extension Insecure {
  @available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
  public struct SHA1Digest {
    public init?(bufferPointer: UnsafeRawBufferPointer)
    public static var byteCount: Int {
      get
    }
    public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public var description: String {
      get
    }
    public func hash(into hasher: inout Hasher)
    public typealias Element = Swift.UInt8
    public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Insecure {
  @available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
  public struct MD5Digest {
    public init?(bufferPointer: UnsafeRawBufferPointer)
    public static var byteCount: Int {
      get
    }
    public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public var description: String {
      get
    }
    public func hash(into hasher: inout Hasher)
    public typealias Element = Swift.UInt8
    public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SecureEnclave.P256.Signing.PrivateKey {
  public func signature<D>(for digest: D) throws -> P256.Signing.ECDSASignature where D : CryptoKit.Digest
}
extension SecureEnclave.P256.Signing.PrivateKey {
  public func signature<D>(for data: D) throws -> P256.Signing.ECDSASignature where D : Foundation.DataProtocol
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum SecureEnclave {
}
extension SecureEnclave {
  public static var isAvailable: Bool {
    get
  }
  public enum P256 {
    public enum Signing {
      public struct PrivateKey {
        public let publicKey: CryptoKit.P256.Signing.PublicKey
        public let dataRepresentation: Data
        @available(iOS 13.0, OSX 10.15, *)
        public init(dataRepresentation: Data, authenticationContext: LAContext? = nil) throws
        @available(iOS 13.0, OSX 10.15, *)
        public init(accessControl: SecAccessControl = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly, [], nil)!, authenticationContext: LAContext? = nil) throws
      }
    }
    public enum KeyAgreement {
      public struct PrivateKey {
        public let publicKey: CryptoKit.P256.KeyAgreement.PublicKey
        public let dataRepresentation: Data
        @available(iOS 13.0, OSX 10.15, *)
        public init(dataRepresentation: Data, authenticationContext: LAContext? = nil) throws
        @available(iOS 13.0, OSX 10.15, *)
        public init(accessControl: SecAccessControl = SecAccessControlCreateWithFlags(nil, kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly, [], nil)!, authenticationContext: LAContext? = nil) throws
      }
    }
  }
}
extension SecureEnclave.P256.KeyAgreement.PrivateKey {
  public func sharedSecretFromKeyAgreement(with publicKeyShare: P256.KeyAgreement.PublicKey) throws -> SharedSecret
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct HMAC<H> where H : CryptoKit.HashFunction {
  public typealias Key = SymmetricKey
  public typealias MAC = HashedAuthenticationCode<H>
  public static func isValidAuthenticationCode(_ mac: MAC, authenticating bufferPointer: UnsafeRawBufferPointer, using key: SymmetricKey) -> Bool
  public init(key: SymmetricKey)
  public static func authenticationCode<D>(for data: D, using key: SymmetricKey) -> MAC where D : Foundation.DataProtocol
  public static func isValidAuthenticationCode<D>(_ authenticationCode: MAC, authenticating authenticatedData: D, using key: SymmetricKey) -> Bool where D : Foundation.DataProtocol
  public static func isValidAuthenticationCode<D>(_ authenticationCode: ContiguousBytes, authenticating authenticatedData: D, using key: SymmetricKey) -> Bool where D : Foundation.DataProtocol
  mutating public func update<D>(data: D) where D : Foundation.DataProtocol
  public func finalize() -> MAC
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA256 {
  public typealias Digest = SHA256Digest
  public static var byteCount: Swift.Int
  public init()
  mutating public func update(bufferPointer: UnsafeRawBufferPointer)
  public func finalize() -> `Self`.Digest
  public static func hash(bufferPointer: UnsafeRawBufferPointer) -> `Self`.Digest
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA384 {
  public typealias Digest = SHA384Digest
  public static var byteCount: Swift.Int
  public init()
  mutating public func update(bufferPointer: UnsafeRawBufferPointer)
  public func finalize() -> `Self`.Digest
  public static func hash(bufferPointer: UnsafeRawBufferPointer) -> `Self`.Digest
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SHA512 {
  public typealias Digest = SHA512Digest
  public static var byteCount: Swift.Int
  public init()
  mutating public func update(bufferPointer: UnsafeRawBufferPointer)
  public func finalize() -> `Self`.Digest
  public static func hash(bufferPointer: UnsafeRawBufferPointer) -> `Self`.Digest
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum Insecure {
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum ChaChaPoly {
  public static func seal<Plaintext, AuthenticatedData>(_ message: Plaintext, using key: SymmetricKey, nonce: Nonce? = nil, authenticating authenticatedData: AuthenticatedData) throws -> SealedBox where Plaintext : Foundation.DataProtocol, AuthenticatedData : Foundation.DataProtocol
  public static func seal<Plaintext>(_ message: Plaintext, using key: SymmetricKey, nonce: Nonce? = nil) throws -> SealedBox where Plaintext : Foundation.DataProtocol
  public static func open<AuthenticatedData>(_ sealedBox: SealedBox, using key: SymmetricKey, authenticating authenticatedData: AuthenticatedData) throws -> Data where AuthenticatedData : Foundation.DataProtocol
  public static func open(_ sealedBox: SealedBox, using key: SymmetricKey) throws -> Data
}
extension ChaChaPoly.SealedBox {
  public var combined: Data {
    get
  }
  public init?<D>(combined: D) where D : Foundation.DataProtocol
}
extension AES.GCM {
  @available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
  public struct SealedBox {
    public let tag: Data
    public let ciphertext: Data
    public let nonce: AES.GCM.Nonce
    public init?<C, T>(nonce: AES.GCM.Nonce, ciphertext: C, tag: T) where C : Foundation.DataProtocol, T : Foundation.DataProtocol
  }
}
extension AES.GCM {
  public struct Nonce : ContiguousBytes, Sequence {
    public init()
    public init<D>(data: D) throws where D : Foundation.DataProtocol
    public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public func makeIterator() -> Array<UInt8>.Iterator
    public typealias Element = Swift.UInt8
    public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  }
}
extension ChaChaPoly {
  @available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
  public struct SealedBox {
    public let tag: Data
    public let ciphertext: Data
    public let nonce: ChaChaPoly.Nonce
    public init?<C, T>(nonce: ChaChaPoly.Nonce, ciphertext: C, tag: T) where C : Foundation.DataProtocol, T : Foundation.DataProtocol
  }
}
extension ChaChaPoly {
  public struct Nonce : ContiguousBytes, Sequence {
    public init()
    public init<D>(data: D) throws where D : Foundation.DataProtocol
    public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public func makeIterator() -> Array<UInt8>.Iterator
    public typealias Element = Swift.UInt8
    public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum AES {
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SymmetricKeySize {
  public let bitCount: Int
  public static var bits128: SymmetricKeySize {
    get
  }
  public static var bits192: SymmetricKeySize {
    get
  }
  public static var bits256: SymmetricKeySize {
    get
  }
  public init(bitCount: Int)
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SymmetricKey : ContiguousBytes {
  public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public init<D>(data: D) where D : Foundation.ContiguousBytes
  public init(size: SymmetricKeySize)
  public var bitCount: Int {
    get
  }
}
extension SymmetricKey : Equatable {
  public static func == (lhs: `Self`, rhs: `Self`) -> Bool
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public protocol HashFunction {
  associatedtype Digest : CryptoKit.Digest
  static func hash(bufferPointer: UnsafeRawBufferPointer) -> Digest
  init()
  mutating func update(bufferPointer: UnsafeRawBufferPointer)
  func finalize() -> Digest
}
extension HashFunction {
  @inlinable public static func hash<D>(data: D) -> Self.Digest where D : Foundation.DataProtocol {
        var hasher = Self()
        hasher.update(data: data)
        return hasher.finalize()
    }
  @inlinable mutating public func update<D>(data: D) where D : Foundation.DataProtocol {
        data.regions.forEach { (regionData) in
            regionData.withUnsafeBytes({ (dataPtr) in
                self.update(bufferPointer: dataPtr)
            })
        }
    }
}
extension P256.Signing {
  public struct ECDSASignature : ContiguousBytes {
    public var rawRepresentation: Data
    public init?<D>(rawRepresentation: D) where D : Foundation.DataProtocol
    public init?<D>(derRepresentation: D) where D : Foundation.DataProtocol
    public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public var derRepresentation: Data {
      get
    }
  }
}
extension P256.Signing {
}
extension P256.Signing.PrivateKey {
  public func signature<D>(for digest: D) throws -> P256.Signing.ECDSASignature where D : CryptoKit.Digest
}
extension P256.Signing.PrivateKey {
  public func signature<D>(for data: D) throws -> P256.Signing.ECDSASignature where D : Foundation.DataProtocol
}
extension P256.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: P256.Signing.ECDSASignature, for digest: D) -> Bool where D : CryptoKit.Digest
}
extension P256.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: P256.Signing.ECDSASignature, for data: D) -> Bool where D : Foundation.DataProtocol
}
extension P384.Signing {
  public struct ECDSASignature : ContiguousBytes {
    public var rawRepresentation: Data
    public init?<D>(rawRepresentation: D) where D : Foundation.DataProtocol
    public init?<D>(derRepresentation: D) where D : Foundation.DataProtocol
    public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public var derRepresentation: Data {
      get
    }
  }
}
extension P384.Signing {
}
extension P384.Signing.PrivateKey {
  public func signature<D>(for digest: D) throws -> P384.Signing.ECDSASignature where D : CryptoKit.Digest
}
extension P384.Signing.PrivateKey {
  public func signature<D>(for data: D) throws -> P384.Signing.ECDSASignature where D : Foundation.DataProtocol
}
extension P384.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: P384.Signing.ECDSASignature, for digest: D) -> Bool where D : CryptoKit.Digest
}
extension P384.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: P384.Signing.ECDSASignature, for data: D) -> Bool where D : Foundation.DataProtocol
}
extension P521.Signing {
  public struct ECDSASignature : ContiguousBytes {
    public var rawRepresentation: Data
    public init?<D>(rawRepresentation: D) where D : Foundation.DataProtocol
    public init?<D>(derRepresentation: D) where D : Foundation.DataProtocol
    public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
    public var derRepresentation: Data {
      get
    }
  }
}
extension P521.Signing {
}
extension P521.Signing.PrivateKey {
  public func signature<D>(for digest: D) throws -> P521.Signing.ECDSASignature where D : CryptoKit.Digest
}
extension P521.Signing.PrivateKey {
  public func signature<D>(for data: D) throws -> P521.Signing.ECDSASignature where D : Foundation.DataProtocol
}
extension P521.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: P521.Signing.ECDSASignature, for digest: D) -> Bool where D : CryptoKit.Digest
}
extension P521.Signing.PublicKey {
  public func isValidSignature<D>(_ signature: P521.Signing.ECDSASignature, for data: D) -> Bool where D : Foundation.DataProtocol
}
extension AES {
  public enum GCM {
    public static func seal<Plaintext, AuthenticatedData>(_ message: Plaintext, using key: SymmetricKey, nonce: Nonce? = nil, authenticating authenticatedData: AuthenticatedData) throws -> SealedBox where Plaintext : Foundation.DataProtocol, AuthenticatedData : Foundation.DataProtocol
    public static func seal<Plaintext>(_ message: Plaintext, using key: SymmetricKey, nonce: Nonce? = nil) throws -> SealedBox where Plaintext : Foundation.DataProtocol
    public static func open<AuthenticatedData>(_ sealedBox: SealedBox, using key: SymmetricKey, authenticating authenticatedData: AuthenticatedData) throws -> Data where AuthenticatedData : Foundation.DataProtocol
    public static func open(_ sealedBox: SealedBox, using key: SymmetricKey) throws -> Data
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct SharedSecret : ContiguousBytes {
  public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public func x963DerivedSymmetricKey<H, SI>(using hashFunction: H.Type, sharedInfo: SI, outputByteCount: Int) -> SymmetricKey where H : CryptoKit.HashFunction, SI : Foundation.DataProtocol
  public func hkdfDerivedSymmetricKey<H, Salt, SI>(using hashFunction: H.Type, salt: Salt, sharedInfo: SI, outputByteCount: Int) -> SymmetricKey where H : CryptoKit.HashFunction, Salt : Foundation.DataProtocol, SI : Foundation.DataProtocol
}
extension SharedSecret : Hashable {
  public func hash(into hasher: inout Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SharedSecret : CustomStringConvertible, Equatable {
  public static func == (lhs: `Self`, rhs: `Self`) -> Bool
  public var description: String {
    get
  }
}
extension Insecure {
  public struct SHA1 {
    public typealias Digest = Insecure.SHA1Digest
    public static var byteCount: Swift.Int
    public init()
    mutating public func update(bufferPointer: UnsafeRawBufferPointer)
    public func finalize() -> `Self`.Digest
    public static func hash(bufferPointer: UnsafeRawBufferPointer) -> `Self`.Digest
  }
  public struct MD5 {
    public typealias Digest = Insecure.MD5Digest
    public static var byteCount: Swift.Int
    public init()
    mutating public func update(bufferPointer: UnsafeRawBufferPointer)
    public func finalize() -> `Self`.Digest
    public static func hash(bufferPointer: UnsafeRawBufferPointer) -> `Self`.Digest
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public protocol MessageAuthenticationCode : Foundation.ContiguousBytes, Swift.CustomStringConvertible, Swift.Hashable, Swift.Sequence where Self.Element == Swift.UInt8 {
  static var byteCount: Int { get }
}
extension MessageAuthenticationCode {
  public static func == (lhs: Self, rhs: Self) -> Bool
  public static func == (lhs: Self, rhs: ContiguousBytes) -> Bool
  public func makeIterator() -> Array<UInt8>.Iterator
  public var description: String {
    get
  }
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public struct HashedAuthenticationCode<H> : MessageAuthenticationCode where H : CryptoKit.HashFunction {
  public static var byteCount: Int {
    get
  }
  public var description: String {
    get
  }
  public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public typealias Element = Swift.UInt8
  public typealias Iterator = Swift.Array<Swift.UInt8>.Iterator
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum CryptoKitError : Error {
  case incorrectKeySize
  case incorrectParameterSize
  case underlyingCoreCryptoError(error: Int32)
}
@available(iOS 13.0, OSX 10.15, watchOS 6.0, tvOS 13.0, *)
public enum CipherError : Error {
  case internalError
  case incorrectTag
  public static func == (a: CryptoKit.CipherError, b: CryptoKit.CipherError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension Curve25519 {
  public enum KeyAgreement {
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public var rawRepresentation: Data {
        get
      }
    }
    public struct PrivateKey {
      public init()
      public var publicKey: PublicKey {
        get
      }
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public func sharedSecretFromKeyAgreement(with publicKeyShare: PublicKey) throws -> SharedSecret
    }
  }
}
extension Curve25519 {
  public enum Signing {
    public struct PrivateKey {
      public init()
      public var publicKey: PublicKey {
        get
      }
      public init<D>(rawRepresentation data: D) throws where D : Foundation.ContiguousBytes
    }
    public struct PublicKey {
      public init<D>(rawRepresentation: D) throws where D : Foundation.ContiguousBytes
      public var rawRepresentation: Data {
        get
      }
    }
  }
}
extension CryptoKit.SHA256Digest : CryptoKit.Digest {}
extension CryptoKit.SHA384Digest : CryptoKit.Digest {}
extension CryptoKit.SHA512Digest : CryptoKit.Digest {}
extension CryptoKit.Insecure.SHA1Digest : CryptoKit.Digest {}
extension CryptoKit.Insecure.MD5Digest : CryptoKit.Digest {}
extension CryptoKit.SHA256 : CryptoKit.HashFunction {}
extension CryptoKit.SHA384 : CryptoKit.HashFunction {}
extension CryptoKit.SHA512 : CryptoKit.HashFunction {}
extension CryptoKit.Insecure.SHA1 : CryptoKit.HashFunction {}
extension CryptoKit.Insecure.MD5 : CryptoKit.HashFunction {}
