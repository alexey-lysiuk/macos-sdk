// swift-interface-format-version: 1.0
// swift-tools-version: Apple Swift version 5.1 effective-4.1.50 (swiftlang-1100.8.32.26 clang-1100.0.18.2)
// swift-module-flags: -target x86_64-apple-macosx10.15 -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftGLKit -swift-version 4 -O -enforce-exclusivity=unchecked -module-name GLKit
@_exported import GLKit
import Swift
@inlinable @inline(__always) public func _indexHomogeneousValue<TTT, T>(_ aggregate: UnsafePointer<TTT>, _ index: Int) -> T {
  return UnsafeRawPointer(aggregate).load(
    fromByteOffset: index * MemoryLayout<T>.stride, as: T.self)
}
extension _GLKMatrix2 {
  @inlinable public subscript(i: Int) -> Float {
    @inline(__always) get {
      precondition(i >= 0, "Negative GLKMatrix2 index out of range")
      precondition(i < 4, "GLKMatrix2 index out of range")

      // We can't derive an UnsafePointer from a let binding. Lame.
      var clone = self
      return _indexHomogeneousValue(&clone, i)
    }
  }
}
extension _GLKVector2 {
  @inlinable public subscript(i: Int) -> Float {
    @inline(__always) get {
      precondition(i >= 0, "Negative GLKVector2 index out of range")
      precondition(i < 2, "GLKVector2 index out of range")

      // We can't derive an UnsafePointer from a let binding. Lame.
      var clone = self
      return _indexHomogeneousValue(&clone, i)
    }
  }
}
extension _GLKMatrix3 {
  @inlinable public subscript(i: Int) -> Float {
    @inline(__always) get {
      precondition(i >= 0, "Negative GLKMatrix3 index out of range")
      precondition(i < 9, "GLKMatrix3 index out of range")

      // We can't derive an UnsafePointer from a let binding. Lame.
      var clone = self
      return _indexHomogeneousValue(&clone, i)
    }
  }
}
extension _GLKVector3 {
  @inlinable public subscript(i: Int) -> Float {
    @inline(__always) get {
      precondition(i >= 0, "Negative GLKVector3 index out of range")
      precondition(i < 3, "GLKVector3 index out of range")

      // We can't derive an UnsafePointer from a let binding. Lame.
      var clone = self
      return _indexHomogeneousValue(&clone, i)
    }
  }
}
extension _GLKMatrix4 {
  @inlinable public subscript(i: Int) -> Float {
    @inline(__always) get {
      precondition(i >= 0, "Negative GLKMatrix4 index out of range")
      precondition(i < 16, "GLKMatrix4 index out of range")

      // We can't derive an UnsafePointer from a let binding. Lame.
      var clone = self
      return _indexHomogeneousValue(&clone, i)
    }
  }
}
extension _GLKVector4 {
  @inlinable public subscript(i: Int) -> Float {
    @inline(__always) get {
      precondition(i >= 0, "Negative GLKVector4 index out of range")
      precondition(i < 4, "GLKVector4 index out of range")

      // We can't derive an UnsafePointer from a let binding. Lame.
      var clone = self
      return _indexHomogeneousValue(&clone, i)
    }
  }
}
extension _GLKQuaternion {
  @inlinable public subscript(i: Int) -> Float {
    @inline(__always) get {
      precondition(i >= 0, "Negative GLKQuaternion index out of range")
      precondition(i < 4, "GLKQuaternion index out of range")

      // We can't derive an UnsafePointer from a let binding. Lame.
      var clone = self
      return _indexHomogeneousValue(&clone, i)
    }
  }
}
