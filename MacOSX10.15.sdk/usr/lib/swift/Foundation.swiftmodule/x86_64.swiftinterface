// swift-interface-format-version: 1.0
// swift-tools-version: Apple Swift version 5.1 (swiftlang-1100.8.32.26 clang-1100.0.18.2)
// swift-module-flags: -target x86_64-apple-macosx10.15 -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftFoundation -swift-version 5 -O -enforce-exclusivity=unchecked -module-name Foundation
import CoreFoundation
import CoreGraphics
import Darwin
import Dispatch
@_exported import Foundation
import ObjectiveC
import Swift
import _SwiftCoreFoundationOverlayShims
import _SwiftFoundationOverlayShims
import Darwin.uuid
public struct AffineTransform : ReferenceConvertible, Hashable, CustomStringConvertible {
  public var m11: CGFloat, m12: CGFloat, m21: CGFloat, m22: CGFloat, tX: CGFloat, tY: CGFloat
  public typealias ReferenceType = NSAffineTransform
  public init(m11: CGFloat, m12: CGFloat, m21: CGFloat, m22: CGFloat, tX: CGFloat, tY: CGFloat)
  public init()
  public init(translationByX x: CGFloat, byY y: CGFloat)
  public init(scaleByX x: CGFloat, byY y: CGFloat)
  public init(scale factor: CGFloat)
  public init(rotationByRadians angle: CGFloat)
  public init(rotationByDegrees angle: CGFloat)
  public static let identity: Foundation.AffineTransform
  mutating public func translate(x: CGFloat, y: CGFloat)
  mutating public func rotate(byDegrees angle: CGFloat)
  mutating public func rotate(byRadians angle: CGFloat)
  mutating public func scale(_ scale: CGFloat)
  mutating public func scale(x: CGFloat, y: CGFloat)
  mutating public func invert()
  public func inverted() -> AffineTransform?
  mutating public func append(_ transform: AffineTransform)
  mutating public func prepend(_ transform: AffineTransform)
  public func transform(_ point: NSPoint) -> NSPoint
  public func transform(_ size: NSSize) -> NSSize
  public func hash(into hasher: inout Hasher)
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
  public static func == (lhs: AffineTransform, rhs: AffineTransform) -> Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension AffineTransform : _ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSAffineTransform
  public static func _forceBridgeFromObjectiveC(_ x: NSAffineTransform, result: inout AffineTransform?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSAffineTransform, result: inout AffineTransform?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ x: NSAffineTransform?) -> AffineTransform
  public typealias _ObjectiveCType = Foundation.NSAffineTransform
}
extension NSAffineTransform : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension AffineTransform : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
public struct Calendar : Hashable, Equatable, ReferenceConvertible {
  public typealias ReferenceType = NSCalendar
  public enum Identifier {
    case gregorian
    case buddhist
    case chinese
    case coptic
    case ethiopicAmeteMihret
    case ethiopicAmeteAlem
    case hebrew
    case iso8601
    case indian
    case islamic
    case islamicCivil
    case japanese
    case persian
    case republicOfChina
    case islamicTabular
    case islamicUmmAlQura
    public static func == (a: Foundation.Calendar.Identifier, b: Foundation.Calendar.Identifier) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Component {
    case era
    case year
    case month
    case day
    case hour
    case minute
    case second
    case weekday
    case weekdayOrdinal
    case quarter
    case weekOfMonth
    case weekOfYear
    case yearForWeekOfYear
    case nanosecond
    case calendar
    case timeZone
    public static func == (a: Foundation.Calendar.Component, b: Foundation.Calendar.Component) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static var current: Calendar {
    get
  }
  public static var autoupdatingCurrent: Calendar {
    get
  }
  public init(identifier: __shared Identifier)
  public var identifier: Identifier {
    get
  }
  public var locale: Locale? {
    get
    set
  }
  public var timeZone: TimeZone {
    get
    set
  }
  public var firstWeekday: Int {
    get
    set
  }
  public var minimumDaysInFirstWeek: Int {
    get
    set
  }
  public var eraSymbols: [String] {
    get
  }
  public var longEraSymbols: [String] {
    get
  }
  public var monthSymbols: [String] {
    get
  }
  public var shortMonthSymbols: [String] {
    get
  }
  public var veryShortMonthSymbols: [String] {
    get
  }
  public var standaloneMonthSymbols: [String] {
    get
  }
  public var shortStandaloneMonthSymbols: [String] {
    get
  }
  public var veryShortStandaloneMonthSymbols: [String] {
    get
  }
  public var weekdaySymbols: [String] {
    get
  }
  public var shortWeekdaySymbols: [String] {
    get
  }
  public var veryShortWeekdaySymbols: [String] {
    get
  }
  public var standaloneWeekdaySymbols: [String] {
    get
  }
  public var shortStandaloneWeekdaySymbols: [String] {
    get
  }
  public var veryShortStandaloneWeekdaySymbols: [String] {
    get
  }
  public var quarterSymbols: [String] {
    get
  }
  public var shortQuarterSymbols: [String] {
    get
  }
  public var standaloneQuarterSymbols: [String] {
    get
  }
  public var shortStandaloneQuarterSymbols: [String] {
    get
  }
  public var amSymbol: String {
    get
  }
  public var pmSymbol: String {
    get
  }
  public func minimumRange(of component: Component) -> Range<Int>?
  public func maximumRange(of component: Component) -> Range<Int>?
  @available(*, unavailable, message: "use range(of:in:for:) instead")
  public func range(of smaller: NSCalendar.Unit, in larger: NSCalendar.Unit, for date: Date) -> NSRange
  public func range(of smaller: Component, in larger: Component, for date: Date) -> Range<Int>?
  @available(*, unavailable, message: "use range(of:in:for:) instead")
  public func range(of unit: NSCalendar.Unit, start datep: AutoreleasingUnsafeMutablePointer<NSDate?>?, interval tip: UnsafeMutablePointer<TimeInterval>?, for date: Date) -> Bool
  public func dateInterval(of component: Component, start: inout Date, interval: inout TimeInterval, for date: Date) -> Bool
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func dateInterval(of component: Component, for date: Date) -> DateInterval?
  public func ordinality(of smaller: Component, in larger: Component, for date: Date) -> Int?
  @available(*, unavailable, message: "use dateComponents(_:from:) instead")
  public func getEra(_ eraValuePointer: UnsafeMutablePointer<Int>?, year yearValuePointer: UnsafeMutablePointer<Int>?, month monthValuePointer: UnsafeMutablePointer<Int>?, day dayValuePointer: UnsafeMutablePointer<Int>?, from date: Date)
  @available(*, unavailable, message: "use dateComponents(_:from:) instead")
  public func getEra(_ eraValuePointer: UnsafeMutablePointer<Int>?, yearForWeekOfYear yearValuePointer: UnsafeMutablePointer<Int>?, weekOfYear weekValuePointer: UnsafeMutablePointer<Int>?, weekday weekdayValuePointer: UnsafeMutablePointer<Int>?, from date: Date)
  @available(*, unavailable, message: "use dateComponents(_:from:) instead")
  public func getHour(_ hourValuePointer: UnsafeMutablePointer<Int>?, minute minuteValuePointer: UnsafeMutablePointer<Int>?, second secondValuePointer: UnsafeMutablePointer<Int>?, nanosecond nanosecondValuePointer: UnsafeMutablePointer<Int>?, from date: Date)
  @available(*, unavailable, message: "use date(byAdding:to:wrappingComponents:) instead")
  public func date(byAdding unit: NSCalendar.Unit, value: Int, to date: Date, options: NSCalendar.Options = []) -> Date?
  public func date(byAdding components: DateComponents, to date: Date, wrappingComponents: Bool = false) -> Date?
  @available(*, unavailable, message: "use date(byAdding:to:wrappingComponents:) instead")
  public func date(byAdding comps: DateComponents, to date: Date, options opts: NSCalendar.Options = []) -> Date?
  @available(iOS 8.0, *)
  public func date(byAdding component: Component, value: Int, to date: Date, wrappingComponents: Bool = false) -> Date?
  public func date(from components: DateComponents) -> Date?
  @available(*, unavailable, renamed: "dateComponents(_:from:)")
  public func components(_ unitFlags: NSCalendar.Unit, from date: Date) -> DateComponents
  public func dateComponents(_ components: Set<Component>, from date: Date) -> DateComponents
  @available(*, unavailable, renamed: "dateComponents(in:from:)")
  public func components(in timezone: TimeZone, from date: Date) -> DateComponents
  @available(iOS 8.0, *)
  public func dateComponents(in timeZone: TimeZone, from date: Date) -> DateComponents
  @available(*, unavailable, renamed: "dateComponents(_:from:to:)")
  public func components(_ unitFlags: NSCalendar.Unit, from startingDate: Date, to resultDate: Date, options opts: NSCalendar.Options = []) -> DateComponents
  public func dateComponents(_ components: Set<Component>, from start: Date, to end: Date) -> DateComponents
  @available(*, unavailable, renamed: "dateComponents(_:from:to:)")
  public func components(_ unitFlags: NSCalendar.Unit, from startingDateComp: DateComponents, to resultDateComp: DateComponents, options: NSCalendar.Options = []) -> DateComponents
  @available(iOS 8.0, *)
  public func dateComponents(_ components: Set<Component>, from start: DateComponents, to end: DateComponents) -> DateComponents
  @available(iOS 8.0, *)
  public func component(_ component: Component, from date: Date) -> Int
  @available(*, unavailable, message: "Use date(from:) instead")
  public func date(era: Int, year: Int, month: Int, day: Int, hour: Int, minute: Int, second: Int, nanosecond: Int) -> Date?
  @available(*, unavailable, message: "Use date(from:) instead")
  public func date(era: Int, yearForWeekOfYear: Int, weekOfYear: Int, weekday: Int, hour: Int, minute: Int, second: Int, nanosecond: Int) -> Date?
  @available(iOS 8.0, *)
  public func startOfDay(for date: Date) -> Date
  @available(*, unavailable, renamed: "compare(_:to:toGranularity:)")
  public func compare(_ date1: Date, to date2: Date, toUnitGranularity unit: NSCalendar.Unit) -> ComparisonResult
  @available(iOS 8.0, *)
  public func compare(_ date1: Date, to date2: Date, toGranularity component: Component) -> ComparisonResult
  @available(*, unavailable, renamed: "isDate(_:equalTo:toGranularity:)")
  public func isDate(_ date1: Date, equalTo date2: Date, toUnitGranularity unit: NSCalendar.Unit) -> Bool
  @available(iOS 8.0, *)
  public func isDate(_ date1: Date, equalTo date2: Date, toGranularity component: Component) -> Bool
  @available(iOS 8.0, *)
  public func isDate(_ date1: Date, inSameDayAs date2: Date) -> Bool
  @available(iOS 8.0, *)
  public func isDateInToday(_ date: Date) -> Bool
  @available(iOS 8.0, *)
  public func isDateInYesterday(_ date: Date) -> Bool
  @available(iOS 8.0, *)
  public func isDateInTomorrow(_ date: Date) -> Bool
  @available(iOS 8.0, *)
  public func isDateInWeekend(_ date: Date) -> Bool
  @available(*, unavailable, message: "use dateIntervalOfWeekend(containing:start:interval:) instead")
  public func range(ofWeekendStart datep: AutoreleasingUnsafeMutablePointer<NSDate?>?, interval tip: UnsafeMutablePointer<TimeInterval>?, containing date: Date) -> Bool
  @available(iOS 8.0, *)
  public func dateIntervalOfWeekend(containing date: Date, start: inout Date, interval: inout TimeInterval) -> Bool
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func dateIntervalOfWeekend(containing date: Date) -> DateInterval?
  @available(*, unavailable, message: "use nextWeekend(startingAfter:start:interval:direction:) instead")
  public func nextWeekendStart(_ datep: AutoreleasingUnsafeMutablePointer<NSDate?>?, interval tip: UnsafeMutablePointer<TimeInterval>?, options: NSCalendar.Options = [], after date: Date) -> Bool
  @available(iOS 8.0, *)
  public func nextWeekend(startingAfter date: Date, start: inout Date, interval: inout TimeInterval, direction: SearchDirection = .forward) -> Bool
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func nextWeekend(startingAfter date: Date, direction: SearchDirection = .forward) -> DateInterval?
  public enum SearchDirection {
    case forward
    case backward
    public static func == (a: Foundation.Calendar.SearchDirection, b: Foundation.Calendar.SearchDirection) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum RepeatedTimePolicy {
    case first
    case last
    public static func == (a: Foundation.Calendar.RepeatedTimePolicy, b: Foundation.Calendar.RepeatedTimePolicy) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum MatchingPolicy {
    case nextTime
    case nextTimePreservingSmallerComponents
    case previousTimePreservingSmallerComponents
    case strict
    public static func == (a: Foundation.Calendar.MatchingPolicy, b: Foundation.Calendar.MatchingPolicy) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  @available(*, unavailable, message: "use nextWeekend(startingAfter:matching:matchingPolicy:repeatedTimePolicy:direction:using:) instead")
  public func enumerateDates(startingAfter start: Date, matching comps: DateComponents, options opts: NSCalendar.Options = [], using block: (Date?, Bool, UnsafeMutablePointer<ObjCBool>) -> Swift.Void)
  @available(iOS 8.0, *)
  public func enumerateDates(startingAfter start: Date, matching components: DateComponents, matchingPolicy: MatchingPolicy, repeatedTimePolicy: RepeatedTimePolicy = .first, direction: SearchDirection = .forward, using block: (_ result: Date?, _ exactMatch: Bool, _ stop: inout Bool) -> Void)
  @available(*, unavailable, message: "use nextDate(after:matching:matchingPolicy:repeatedTimePolicy:direction:) instead")
  public func nextDate(after date: Date, matching comps: DateComponents, options: NSCalendar.Options = []) -> Date?
  @available(iOS 8.0, *)
  public func nextDate(after date: Date, matching components: DateComponents, matchingPolicy: MatchingPolicy, repeatedTimePolicy: RepeatedTimePolicy = .first, direction: SearchDirection = .forward) -> Date?
  @available(*, unavailable, message: "use nextDate(after:matching:matchingPolicy:repeatedTimePolicy:direction:) instead")
  public func nextDate(after date: Date, matchingHour hourValue: Int, minute minuteValue: Int, second secondValue: Int, options: NSCalendar.Options = []) -> Date?
  @available(*, unavailable, renamed: "date(bySetting:value:of:)")
  public func date(bySettingUnit unit: NSCalendar.Unit, value v: Int, of date: Date, options opts: NSCalendar.Options = []) -> Date?
  @available(iOS 8.0, *)
  public func date(bySetting component: Component, value: Int, of date: Date) -> Date?
  @available(*, unavailable, message: "use date(bySettingHour:minute:second:of:matchingPolicy:repeatedTimePolicy:direction:) instead")
  public func date(bySettingHour h: Int, minute m: Int, second s: Int, of date: Date, options opts: NSCalendar.Options = []) -> Date?
  @available(iOS 8.0, *)
  public func date(bySettingHour hour: Int, minute: Int, second: Int, of date: Date, matchingPolicy: MatchingPolicy = .nextTime, repeatedTimePolicy: RepeatedTimePolicy = .first, direction: SearchDirection = .forward) -> Date?
  @available(iOS 8.0, *)
  public func date(_ date: Date, matchesComponents components: DateComponents) -> Bool
  public func hash(into hasher: inout Hasher)
  public static func == (lhs: Calendar, rhs: Calendar) -> Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Calendar : CustomDebugStringConvertible, CustomStringConvertible, CustomReflectable {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
  public var customMirror: Mirror {
    get
  }
}
extension Calendar : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSCalendar
  public static func _forceBridgeFromObjectiveC(_ input: NSCalendar, result: inout Calendar?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: NSCalendar, result: inout Calendar?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSCalendar?) -> Calendar
  public typealias _ObjectiveCType = Foundation.NSCalendar
}
extension NSCalendar : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension Calendar : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
public struct CharacterSet : ReferenceConvertible, Equatable, Hashable, SetAlgebra {
  public typealias ReferenceType = NSCharacterSet
  public init()
  public init(charactersIn range: Range<Unicode.Scalar>)
  public init(charactersIn range: ClosedRange<Unicode.Scalar>)
  public init(charactersIn string: __shared String)
  public init(bitmapRepresentation data: __shared Data)
  public init?(contentsOfFile file: __shared String)
  public static var controlCharacters: CharacterSet {
    get
  }
  public static var whitespaces: CharacterSet {
    get
  }
  public static var whitespacesAndNewlines: CharacterSet {
    get
  }
  public static var decimalDigits: CharacterSet {
    get
  }
  public static var letters: CharacterSet {
    get
  }
  public static var lowercaseLetters: CharacterSet {
    get
  }
  public static var uppercaseLetters: CharacterSet {
    get
  }
  public static var nonBaseCharacters: CharacterSet {
    get
  }
  public static var alphanumerics: CharacterSet {
    get
  }
  public static var decomposables: CharacterSet {
    get
  }
  public static var illegalCharacters: CharacterSet {
    get
  }
  @available(*, unavailable, renamed: "punctuationCharacters")
  public static var punctuation: CharacterSet {
    get
  }
  public static var punctuationCharacters: CharacterSet {
    get
  }
  public static var capitalizedLetters: CharacterSet {
    get
  }
  public static var symbols: CharacterSet {
    get
  }
  public static var newlines: CharacterSet {
    get
  }
  public static var urlUserAllowed: CharacterSet {
    get
  }
  public static var urlPasswordAllowed: CharacterSet {
    get
  }
  public static var urlHostAllowed: CharacterSet {
    get
  }
  public static var urlPathAllowed: CharacterSet {
    get
  }
  public static var urlQueryAllowed: CharacterSet {
    get
  }
  public static var urlFragmentAllowed: CharacterSet {
    get
  }
  @nonobjc public var bitmapRepresentation: Data {
    get
  }
  @nonobjc public var inverted: CharacterSet {
    get
  }
  public func hasMember(inPlane plane: UInt8) -> Bool
  mutating public func insert(charactersIn range: Range<Unicode.Scalar>)
  mutating public func insert(charactersIn range: ClosedRange<Unicode.Scalar>)
  mutating public func remove(charactersIn range: Range<Unicode.Scalar>)
  mutating public func remove(charactersIn range: ClosedRange<Unicode.Scalar>)
  mutating public func insert(charactersIn string: String)
  mutating public func remove(charactersIn string: String)
  mutating public func invert()
  @discardableResult
  mutating public func insert(_ character: Unicode.Scalar) -> (inserted: Bool, memberAfterInsert: Unicode.Scalar)
  @discardableResult
  mutating public func update(with character: Unicode.Scalar) -> Unicode.Scalar?
  @discardableResult
  mutating public func remove(_ character: Unicode.Scalar) -> Unicode.Scalar?
  public func contains(_ member: Unicode.Scalar) -> Bool
  public func union(_ other: CharacterSet) -> CharacterSet
  mutating public func formUnion(_ other: CharacterSet)
  public func intersection(_ other: CharacterSet) -> CharacterSet
  mutating public func formIntersection(_ other: CharacterSet)
  public func subtracting(_ other: CharacterSet) -> CharacterSet
  mutating public func subtract(_ other: CharacterSet)
  public func symmetricDifference(_ other: CharacterSet) -> CharacterSet
  mutating public func formSymmetricDifference(_ other: CharacterSet)
  public func isSuperset(of other: CharacterSet) -> Bool
  public func hash(into hasher: inout Hasher)
  public static func == (lhs: CharacterSet, rhs: CharacterSet) -> Bool
  public var hashValue: Swift.Int {
    get
  }
  public typealias Element = Swift.Unicode.Scalar
  public typealias ArrayLiteralElement = Swift.Unicode.Scalar
}
extension CharacterSet : _ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSCharacterSet
  public static func _forceBridgeFromObjectiveC(_ input: NSCharacterSet, result: inout CharacterSet?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: NSCharacterSet, result: inout CharacterSet?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSCharacterSet?) -> CharacterSet
  public typealias _ObjectiveCType = Foundation.NSCharacterSet
}
extension CharacterSet : CustomStringConvertible, CustomDebugStringConvertible {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
}
extension NSCharacterSet : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension CharacterSet : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension EncodingError : LocalizedError {
}
extension DecodingError : LocalizedError {
}
extension Array : DataProtocol where Element == Swift.UInt8 {
  public var regions: CollectionOfOne<Array<UInt8>> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.Array<Swift.UInt8>>
}
extension ArraySlice : DataProtocol where Element == Swift.UInt8 {
  public var regions: CollectionOfOne<ArraySlice<UInt8>> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.ArraySlice<Swift.UInt8>>
}
extension ContiguousArray : DataProtocol where Element == Swift.UInt8 {
  public var regions: CollectionOfOne<ContiguousArray<UInt8>> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.ContiguousArray<Swift.UInt8>>
}
extension EmptyCollection : DataProtocol where Element == Swift.UInt8 {
  public var regions: EmptyCollection<Data> {
    get
  }
  public typealias Regions = Swift.EmptyCollection<Foundation.Data>
}
extension Repeated : DataProtocol where Element == Swift.UInt8 {
  public typealias Regions = Repeated<Data>
  public var regions: Repeated<Data> {
    get
  }
}
extension Array : MutableDataProtocol where Element == Swift.UInt8 {
}
extension ContiguousArray : MutableDataProtocol where Element == Swift.UInt8 {
}
public protocol ContiguousBytes {
  func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}
extension Array : ContiguousBytes where Element == Swift.UInt8 {
}
extension ArraySlice : ContiguousBytes where Element == Swift.UInt8 {
}
extension ContiguousArray : ContiguousBytes where Element == Swift.UInt8 {
}
extension UnsafeRawBufferPointer : ContiguousBytes {
  @inlinable public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(self)
    }
}
extension UnsafeMutableRawBufferPointer : ContiguousBytes {
  @inlinable public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(self))
    }
}
extension UnsafeBufferPointer : ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(self))
    }
}
extension UnsafeMutableBufferPointer : ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(self))
    }
}
extension EmptyCollection : ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(start: nil, count: 0))
    }
}
extension CollectionOfOne : ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        let element = self.first!
        return try Swift.withUnsafeBytes(of: element) {
            return try body($0)
        }
    }
}
extension Slice : ContiguousBytes where Base : Foundation.ContiguousBytes {
  public func withUnsafeBytes<ResultType>(_ body: (UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType
}
@usableFromInline
final internal class __DataStorage {
  @usableFromInline
  internal static let maxSize: Swift.Int
  @usableFromInline
  internal static let vmOpsThreshold: Swift.Int
  @inlinable internal static func allocate(_ size: Int, _ clear: Bool) -> UnsafeMutableRawPointer? {
        if clear {
            return calloc(1, size)
        } else {
            return malloc(size)
        }
    }
  @usableFromInline
  internal static func move(_ dest_: UnsafeMutableRawPointer, _ source_: UnsafeRawPointer?, _ num_: Int)
  @inlinable internal static func shouldAllocateCleared(_ size: Int) -> Bool {
        return (size > (128 * 1024))
    }
  @usableFromInline
  final internal var _bytes: UnsafeMutableRawPointer?
  @usableFromInline
  final internal var _length: Int
  @usableFromInline
  final internal var _capacity: Int
  @usableFromInline
  final internal var _needToZero: Bool
  @usableFromInline
  final internal var _deallocator: ((UnsafeMutableRawPointer, Int) -> Void)?
  @usableFromInline
  final internal var _offset: Int
  @inlinable final internal var bytes: UnsafeRawPointer? {
    get {
        return UnsafeRawPointer(_bytes)?.advanced(by: -_offset)
    }
  }
  @discardableResult
  @inlinable final internal func withUnsafeBytes<Result>(in range: Range<Int>, apply: (UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
        return try apply(UnsafeRawBufferPointer(start: _bytes?.advanced(by: range.lowerBound - _offset), count: Swift.min(range.upperBound - range.lowerBound, _length)))
    }
  @discardableResult
  @inlinable final internal func withUnsafeMutableBytes<Result>(in range: Range<Int>, apply: (UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
        return try apply(UnsafeMutableRawBufferPointer(start: _bytes!.advanced(by:range.lowerBound - _offset), count: Swift.min(range.upperBound - range.lowerBound, _length)))
    }
  @inlinable final internal var mutableBytes: UnsafeMutableRawPointer? {
    get {
        return _bytes?.advanced(by: -_offset)
    }
  }
  @inlinable final internal var capacity: Int {
    get {
        return _capacity
    }
  }
  @inlinable final internal var length: Int {
    get {
            return _length
        }
    set {
            setLength(newValue)
        }
  }
  @inlinable final internal var isExternallyOwned: Bool {
    get {
        // all __DataStorages will have some sort of capacity, because empty cases hit the .empty enum _Representation
        // anything with 0 capacity means that we have not allocated this pointer and concequently mutation is not ours to make.
        return _capacity == 0
    }
  }
  @usableFromInline
  final internal func ensureUniqueBufferReference(growingTo newLength: Int = 0, clear: Bool = false)
  @inlinable final internal func _freeBytes() {
        if let bytes = _bytes {
            if let dealloc = _deallocator {
                dealloc(bytes, length)
            } else {
                free(bytes)
            }
        }
        _deallocator = nil
    }
  @inlinable final internal func enumerateBytes(in range: Range<Int>, _ block: (_ buffer: UnsafeBufferPointer<UInt8>, _ byteIndex: Data.Index, _ stop: inout Bool) -> Void) {
        var stopv: Bool = false
        block(UnsafeBufferPointer<UInt8>(start: _bytes?.advanced(by: range.lowerBound - _offset).assumingMemoryBound(to: UInt8.self), count: Swift.min(range.upperBound - range.lowerBound, _length)), 0, &stopv)
    }
  @inlinable final internal func setLength(_ length: Int) {
        let origLength = _length
        let newLength = length
        if _capacity < newLength || _bytes == nil {
            ensureUniqueBufferReference(growingTo: newLength, clear: true)
        } else if origLength < newLength && _needToZero {
            memset(_bytes! + origLength, 0, newLength - origLength)
        } else if newLength < origLength {
            _needToZero = true
        }
        _length = newLength
    }
  @inlinable final internal func append(_ bytes: UnsafeRawPointer, length: Int) {
        precondition(length >= 0, "Length of appending bytes must not be negative")
        let origLength = _length
        let newLength = origLength + length
        if _capacity < newLength || _bytes == nil {
            ensureUniqueBufferReference(growingTo: newLength, clear: false)
        }
        _length = newLength
        __DataStorage.move(_bytes!.advanced(by: origLength), bytes, length)
    }
  @inlinable final internal func get(_ index: Int) -> UInt8 {
        return _bytes!.advanced(by: index - _offset).assumingMemoryBound(to: UInt8.self).pointee
    }
  @inlinable final internal func set(_ index: Int, to value: UInt8) {
        ensureUniqueBufferReference()
        _bytes!.advanced(by: index - _offset).assumingMemoryBound(to: UInt8.self).pointee = value
    }
  @inlinable final internal func copyBytes(to pointer: UnsafeMutableRawPointer, from range: Range<Int>) {
        let offsetPointer = UnsafeRawBufferPointer(start: _bytes?.advanced(by: range.lowerBound - _offset), count: Swift.min(range.upperBound - range.lowerBound, _length))
        UnsafeMutableRawBufferPointer(start: pointer, count: range.upperBound - range.lowerBound).copyMemory(from: offsetPointer)
    }
  @usableFromInline
  final internal func replaceBytes(in range_: NSRange, with replacementBytes: UnsafeRawPointer?, length replacementLength: Int)
  @usableFromInline
  final internal func resetBytes(in range_: Range<Int>)
  @usableFromInline
  internal init(length: Int)
  @usableFromInline
  internal init(capacity capacity_: Int = 0)
  @usableFromInline
  internal init(bytes: UnsafeRawPointer?, length: Int)
  @usableFromInline
  internal init(bytes: UnsafeMutableRawPointer?, length: Int, copy: Bool, deallocator: ((UnsafeMutableRawPointer, Int) -> Void)?, offset: Int)
  @usableFromInline
  internal init(immutableReference: NSData, offset: Int)
  @usableFromInline
  internal init(mutableReference: NSMutableData, offset: Int)
  @usableFromInline
  internal init(customReference: NSData, offset: Int)
  @usableFromInline
  internal init(customMutableReference: NSMutableData, offset: Int)
  @objc deinit
  @inlinable final internal func mutableCopy(_ range: Range<Int>) -> __DataStorage {
        return __DataStorage(bytes: _bytes?.advanced(by: range.lowerBound - _offset), length: range.upperBound - range.lowerBound, copy: true, deallocator: nil, offset: range.lowerBound)
    }
  @inlinable final internal func withInteriorPointerReference<T>(_ range: Range<Int>, _ work: (NSData) throws -> T) rethrows -> T {
        if range.isEmpty {
            return try work(NSData()) // zero length data can be optimized as a singleton
        }
        return try work(NSData(bytesNoCopy: _bytes!.advanced(by: range.lowerBound - _offset), length: range.upperBound - range.lowerBound, freeWhenDone: false))
    }
  @usableFromInline
  @inline(never) final internal func bridgedReference(_ range: Range<Int>) -> NSData
}
@_fixed_layout public struct Data : ReferenceConvertible, Equatable, Hashable, RandomAccessCollection, MutableCollection, RangeReplaceableCollection, MutableDataProtocol, ContiguousBytes {
  public typealias ReferenceType = NSData
  public typealias ReadingOptions = NSData.ReadingOptions
  public typealias WritingOptions = NSData.WritingOptions
  public typealias SearchOptions = NSData.SearchOptions
  public typealias Base64EncodingOptions = NSData.Base64EncodingOptions
  public typealias Base64DecodingOptions = NSData.Base64DecodingOptions
  public typealias Index = Int
  public typealias Indices = Range<Int>
  @usableFromInline
  @_fixed_layout internal struct InlineData {
    @usableFromInline
    internal typealias Buffer = (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8)
    @usableFromInline
    internal var bytes: Buffer
    @usableFromInline
    internal var length: UInt8
    @inlinable internal static func canStore(count: Int) -> Bool {
            return count <= MemoryLayout<Buffer>.size
        }
    @inlinable internal init(_ srcBuffer: UnsafeRawBufferPointer) {
            self.init(count: srcBuffer.count)
            if srcBuffer.count > 0 {
                Swift.withUnsafeMutableBytes(of: &bytes) { dstBuffer in
                    dstBuffer.baseAddress?.copyMemory(from: srcBuffer.baseAddress!, byteCount: srcBuffer.count)
                }
            }
        }
    @inlinable internal init(count: Int = 0) {
            assert(count <= MemoryLayout<Buffer>.size)
            bytes = (UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0))
            length = UInt8(count)
        }
    @inlinable internal init(_ slice: InlineSlice, count: Int) {
            self.init(count: count)
            Swift.withUnsafeMutableBytes(of: &bytes) { dstBuffer in
                slice.withUnsafeBytes { srcBuffer in
                    dstBuffer.copyMemory(from: UnsafeRawBufferPointer(start: srcBuffer.baseAddress, count: count))
                }
            }
        }
    @inlinable internal init(_ slice: LargeSlice, count: Int) {
            self.init(count: count)
            Swift.withUnsafeMutableBytes(of: &bytes) { dstBuffer in
                slice.withUnsafeBytes { srcBuffer in
                    dstBuffer.copyMemory(from: UnsafeRawBufferPointer(start: srcBuffer.baseAddress, count: count))
                }
            }
        }
    @inlinable internal var capacity: Int {
      get {
            return MemoryLayout<Buffer>.size
        }
    }
    @inlinable internal var count: Int {
      get {
                return Int(length)
            }
      set(newValue) {
                precondition(newValue <= MemoryLayout<Buffer>.size)
                length = UInt8(newValue)
            }
    }
    @inlinable internal var startIndex: Int {
      get {
            return 0
        }
    }
    @inlinable internal var endIndex: Int {
      get {
            return count
        }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            let count = Int(length)
            return try Swift.withUnsafeBytes(of: bytes) { (rawBuffer) throws -> Result in
                return try apply(UnsafeRawBufferPointer(start: rawBuffer.baseAddress, count: count))
            }
        }
    @inlinable mutating internal func withUnsafeMutableBytes<Result>(_ apply: (UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            let count = Int(length)
            return try Swift.withUnsafeMutableBytes(of: &bytes) { (rawBuffer) throws -> Result in
                return try apply(UnsafeMutableRawBufferPointer(start: rawBuffer.baseAddress, count: count))
            }
        }
    @inlinable mutating internal func append(byte: UInt8) {
            let count = self.count
            assert(count + 1 <= MemoryLayout<Buffer>.size)
            Swift.withUnsafeMutableBytes(of: &bytes) { $0[count] = byte }
            self.length += 1
        }
    @inlinable mutating internal func append(contentsOf buffer: UnsafeRawBufferPointer) {
            guard buffer.count > 0 else { return }
            assert(count + buffer.count <= MemoryLayout<Buffer>.size)
            let cnt = count
            _ = Swift.withUnsafeMutableBytes(of: &bytes) { rawBuffer in
                rawBuffer.baseAddress?.advanced(by: cnt).copyMemory(from: buffer.baseAddress!, byteCount: buffer.count)
            }

            length += UInt8(buffer.count)
        }
    @inlinable internal subscript(index: Index) -> UInt8 {
      get {
                assert(index <= MemoryLayout<Buffer>.size)
                precondition(index < length, "index \(index) is out of bounds of 0..<\(length)")
                return Swift.withUnsafeBytes(of: bytes) { rawBuffer -> UInt8 in
                    return rawBuffer[index]
                }
            }
      set(newValue) {
                assert(index <= MemoryLayout<Buffer>.size)
                precondition(index < length, "index \(index) is out of bounds of 0..<\(length)")
                Swift.withUnsafeMutableBytes(of: &bytes) { rawBuffer in
                    rawBuffer[index] = newValue
                }
            }
    }
    @inlinable mutating internal func resetBytes(in range: Range<Index>) {
            assert(range.lowerBound <= MemoryLayout<Buffer>.size)
            assert(range.upperBound <= MemoryLayout<Buffer>.size)
            precondition(range.lowerBound <= length, "index \(range.lowerBound) is out of bounds of 0..<\(length)")
            if count < range.upperBound {
                count = range.upperBound
            }

            let _ = Swift.withUnsafeMutableBytes(of: &bytes) { rawBuffer in
              memset(rawBuffer.baseAddress?.advanced(by: range.lowerBound), 0, range.upperBound - range.lowerBound)
            }
        }
    @usableFromInline
    mutating internal func replaceSubrange(_ subrange: Range<Index>, with replacementBytes: UnsafeRawPointer?, count replacementLength: Int)
    @inlinable internal func copyBytes(to pointer: UnsafeMutableRawPointer, from range: Range<Int>) {
            precondition(startIndex <= range.lowerBound, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= range.upperBound, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.upperBound <= endIndex, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")

            Swift.withUnsafeBytes(of: bytes) {
                let cnt = Swift.min($0.count, range.upperBound - range.lowerBound)
                guard cnt > 0 else { return }
                pointer.copyMemory(from: $0.baseAddress!.advanced(by: range.lowerBound), byteCount: cnt)
            }
        }
  }
  @usableFromInline
  internal typealias HalfInt = Int32
  @usableFromInline
  @_fixed_layout internal struct InlineSlice {
    @usableFromInline
    internal var slice: Range<HalfInt>
    @usableFromInline
    internal var storage: __DataStorage
    @inlinable internal static func canStore(count: Int) -> Bool {
            return count < HalfInt.max
        }
    @inlinable internal init(_ buffer: UnsafeRawBufferPointer) {
            assert(buffer.count < HalfInt.max)
            self.init(__DataStorage(bytes: buffer.baseAddress, length: buffer.count), count: buffer.count)
        }
    @inlinable internal init(capacity: Int) {
            assert(capacity < HalfInt.max)
            self.init(__DataStorage(capacity: capacity), count: 0)
        }
    @inlinable internal init(count: Int) {
            assert(count < HalfInt.max)
            self.init(__DataStorage(length: count), count: count)
        }
    @inlinable internal init(_ inline: InlineData) {
            assert(inline.count < HalfInt.max)
            self.init(inline.withUnsafeBytes { return __DataStorage(bytes: $0.baseAddress, length: $0.count) }, count: inline.count)
        }
    @inlinable internal init(_ inline: InlineData, range: Range<Int>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            self.init(inline.withUnsafeBytes { return __DataStorage(bytes: $0.baseAddress, length: $0.count) }, range: range)
        }
    @inlinable internal init(_ large: LargeSlice) {
            assert(large.range.lowerBound < HalfInt.max)
            assert(large.range.upperBound < HalfInt.max)
            self.init(large.storage, range: large.range)
        }
    @inlinable internal init(_ large: LargeSlice, range: Range<Int>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            self.init(large.storage, range: range)
        }
    @inlinable internal init(_ storage: __DataStorage, count: Int) {
            assert(count < HalfInt.max)
            self.storage = storage
            slice = 0..<HalfInt(count)
        }
    @inlinable internal init(_ storage: __DataStorage, range: Range<Int>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            self.storage = storage
            slice = HalfInt(range.lowerBound)..<HalfInt(range.upperBound)
        }
    @inlinable mutating internal func ensureUniqueReference() {
            if !isKnownUniquelyReferenced(&storage) {
                storage = storage.mutableCopy(self.range)
            }
        }
    @inlinable internal var startIndex: Int {
      get {
            return Int(slice.lowerBound)
        }
    }
    @inlinable internal var endIndex: Int {
      get {
            return Int(slice.upperBound)
        }
    }
    @inlinable internal var capacity: Int {
      get {
            return storage.capacity
        }
    }
    @inlinable mutating internal func reserveCapacity(_ minimumCapacity: Int) {
            ensureUniqueReference()
            // the current capacity can be zero (representing externally owned buffer), and count can be greater than the capacity
            storage.ensureUniqueBufferReference(growingTo: Swift.max(minimumCapacity, count))
        }
    @inlinable internal var count: Int {
      get {
                return Int(slice.upperBound - slice.lowerBound)
            }
      set(newValue) {
                assert(newValue < HalfInt.max)
                ensureUniqueReference()
                storage.length = newValue
                slice = slice.lowerBound..<(slice.lowerBound + HalfInt(newValue))
            }
    }
    @inlinable internal var range: Range<Int> {
      get {
                return Int(slice.lowerBound)..<Int(slice.upperBound)
            }
      set(newValue) {
                assert(newValue.lowerBound < HalfInt.max)
                assert(newValue.upperBound < HalfInt.max)
                slice = HalfInt(newValue.lowerBound)..<HalfInt(newValue.upperBound)
            }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            return try storage.withUnsafeBytes(in: range, apply: apply)
        }
    @inlinable mutating internal func withUnsafeMutableBytes<Result>(_ apply: (UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            ensureUniqueReference()
            return try storage.withUnsafeMutableBytes(in: range, apply: apply)
        }
    @inlinable mutating internal func append(contentsOf buffer: UnsafeRawBufferPointer) {
            assert(endIndex + buffer.count < HalfInt.max)
            ensureUniqueReference()
            storage.replaceBytes(in: NSRange(location: range.upperBound, length: storage.length - (range.upperBound - storage._offset)), with: buffer.baseAddress, length: buffer.count)
            slice = slice.lowerBound..<HalfInt(Int(slice.upperBound) + buffer.count)
        }
    @inlinable internal subscript(index: Index) -> UInt8 {
      get {
                assert(index < HalfInt.max)
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                return storage.get(index)
            }
      set(newValue) {
                assert(index < HalfInt.max)
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                ensureUniqueReference()
                storage.set(index, to: newValue)
            }
    }
    @inlinable internal func bridgedReference() -> NSData {
            return storage.bridgedReference(self.range)
        }
    @inlinable mutating internal func resetBytes(in range: Range<Index>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            ensureUniqueReference()
            storage.resetBytes(in: range)
            if slice.upperBound < range.upperBound {
                slice = slice.lowerBound..<HalfInt(range.upperBound)
            }
        }
    @inlinable mutating internal func replaceSubrange(_ subrange: Range<Index>, with bytes: UnsafeRawPointer?, count cnt: Int) {
            precondition(startIndex <= subrange.lowerBound, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.lowerBound <= endIndex, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= subrange.upperBound, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.upperBound <= endIndex, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")

            let nsRange = NSRange(location: subrange.lowerBound, length: subrange.upperBound - subrange.lowerBound)
            ensureUniqueReference()
            let upper = range.upperBound
            storage.replaceBytes(in: nsRange, with: bytes, length: cnt)
            let resultingUpper = upper - nsRange.length + cnt
            slice = slice.lowerBound..<HalfInt(resultingUpper)
        }
    @inlinable internal func copyBytes(to pointer: UnsafeMutableRawPointer, from range: Range<Int>) {
            precondition(startIndex <= range.lowerBound, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= range.upperBound, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.upperBound <= endIndex, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            storage.copyBytes(to: pointer, from: range)
        }
  }
  @usableFromInline
  @_fixed_layout final internal class RangeReference {
    @usableFromInline
    final internal var range: Range<Int>
    @inlinable @inline(__always) final internal var lowerBound: Int {
      get {
            return range.lowerBound
        }
    }
    @inlinable @inline(__always) final internal var upperBound: Int {
      get {
            return range.upperBound
        }
    }
    @inlinable @inline(__always) final internal var count: Int {
      get {
            return range.upperBound - range.lowerBound
        }
    }
    @inlinable @inline(__always) internal init(_ range: Range<Int>) {
            self.range = range
        }
    @objc @usableFromInline
    deinit
  }
  @usableFromInline
  @_fixed_layout internal struct LargeSlice {
    @usableFromInline
    internal var slice: RangeReference
    @usableFromInline
    internal var storage: __DataStorage
    @inlinable internal init(_ buffer: UnsafeRawBufferPointer) {
            self.init(__DataStorage(bytes: buffer.baseAddress, length: buffer.count), count: buffer.count)
        }
    @inlinable internal init(capacity: Int) {
            self.init(__DataStorage(capacity: capacity), count: 0)
        }
    @inlinable internal init(count: Int) {
            self.init(__DataStorage(length: count), count: count)
        }
    @inlinable internal init(_ inline: InlineData) {
            let storage = inline.withUnsafeBytes { return __DataStorage(bytes: $0.baseAddress, length: $0.count) }
            self.init(storage, count: inline.count)
        }
    @inlinable internal init(_ slice: InlineSlice) {
            self.storage = slice.storage
            self.slice = RangeReference(slice.range)
        }
    @inlinable internal init(_ storage: __DataStorage, count: Int) {
            self.storage = storage
            self.slice = RangeReference(0..<count)
        }
    @inlinable mutating internal func ensureUniqueReference() {
            if !isKnownUniquelyReferenced(&storage) {
                storage = storage.mutableCopy(range)
            }
            if !isKnownUniquelyReferenced(&slice) {
                slice = RangeReference(range)
            }
        }
    @inlinable internal var startIndex: Int {
      get {
            return slice.range.lowerBound
        }
    }
    @inlinable internal var endIndex: Int {
      get {
          return slice.range.upperBound
        }
    }
    @inlinable internal var capacity: Int {
      get {
            return storage.capacity
        }
    }
    @inlinable mutating internal func reserveCapacity(_ minimumCapacity: Int) {
            ensureUniqueReference()
            // the current capacity can be zero (representing externally owned buffer), and count can be greater than the capacity
            storage.ensureUniqueBufferReference(growingTo: Swift.max(minimumCapacity, count))
        }
    @inlinable internal var count: Int {
      get {
                return slice.count
            }
      set(newValue) {
                ensureUniqueReference()
                storage.length = newValue
                slice.range = slice.range.lowerBound..<(slice.range.lowerBound + newValue)
            }
    }
    @inlinable internal var range: Range<Int> {
      get {
            return slice.range
        }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            return try storage.withUnsafeBytes(in: range, apply: apply)
        }
    @inlinable mutating internal func withUnsafeMutableBytes<Result>(_ apply: (UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            ensureUniqueReference()
            return try storage.withUnsafeMutableBytes(in: range, apply: apply)
        }
    @inlinable mutating internal func append(contentsOf buffer: UnsafeRawBufferPointer) {
            ensureUniqueReference()
            storage.replaceBytes(in: NSRange(location: range.upperBound, length: storage.length - (range.upperBound - storage._offset)), with: buffer.baseAddress, length: buffer.count)
            slice.range = slice.range.lowerBound..<slice.range.upperBound + buffer.count
        }
    @inlinable internal subscript(index: Index) -> UInt8 {
      get {
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                return storage.get(index)
            }
      set(newValue) {
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                ensureUniqueReference()
                storage.set(index, to: newValue)
            }
    }
    @inlinable internal func bridgedReference() -> NSData {
            return storage.bridgedReference(self.range)
        }
    @inlinable mutating internal func resetBytes(in range: Range<Int>) {
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            ensureUniqueReference()
            storage.resetBytes(in: range)
            if slice.range.upperBound < range.upperBound {
                slice.range = slice.range.lowerBound..<range.upperBound
            }
        }
    @inlinable mutating internal func replaceSubrange(_ subrange: Range<Index>, with bytes: UnsafeRawPointer?, count cnt: Int) {
            precondition(startIndex <= subrange.lowerBound, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.lowerBound <= endIndex, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= subrange.upperBound, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.upperBound <= endIndex, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")

            let nsRange = NSRange(location: subrange.lowerBound, length: subrange.upperBound - subrange.lowerBound)
            ensureUniqueReference()
            let upper = range.upperBound
            storage.replaceBytes(in: nsRange, with: bytes, length: cnt)
            let resultingUpper = upper - nsRange.length + cnt
            slice.range = slice.range.lowerBound..<resultingUpper
        }
    @inlinable internal func copyBytes(to pointer: UnsafeMutableRawPointer, from range: Range<Int>) {
            precondition(startIndex <= range.lowerBound, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= range.upperBound, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.upperBound <= endIndex, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            storage.copyBytes(to: pointer, from: range)
        }
  }
  @usableFromInline
  @_frozen internal enum _Representation {
    case empty
    case inline(InlineData)
    case slice(InlineSlice)
    case large(LargeSlice)
    @inlinable internal init(_ buffer: UnsafeRawBufferPointer) {
            if buffer.count == 0 {
                self = .empty
            } else if InlineData.canStore(count: buffer.count) {
                self = .inline(InlineData(buffer))
            } else if InlineSlice.canStore(count: buffer.count) {
                self = .slice(InlineSlice(buffer))
            } else {
                self = .large(LargeSlice(buffer))
            }
        }
    @inlinable internal init(_ buffer: UnsafeRawBufferPointer, owner: AnyObject) {
            if buffer.count == 0 {
                self = .empty
            } else if InlineData.canStore(count: buffer.count) {
                self = .inline(InlineData(buffer))
            } else {
                let count = buffer.count
                let storage = __DataStorage(bytes: UnsafeMutableRawPointer(mutating: buffer.baseAddress), length: count, copy: false, deallocator: { _, _ in
                    _fixLifetime(owner)
                }, offset: 0)
                if InlineSlice.canStore(count: count) {
                    self = .slice(InlineSlice(storage, count: count))
                } else {
                    self = .large(LargeSlice(storage, count: count))
                }
            }
        }
    @inlinable internal init(capacity: Int) {
            if capacity == 0 {
                self = .empty
            } else if InlineData.canStore(count: capacity) {
                self = .inline(InlineData())
            } else if InlineSlice.canStore(count: capacity) {
                self = .slice(InlineSlice(capacity: capacity))
            } else {
                self = .large(LargeSlice(capacity: capacity))
            }
        }
    @inlinable internal init(count: Int) {
            if count == 0 {
                self = .empty
            } else if InlineData.canStore(count: count) {
                self = .inline(InlineData(count: count))
            } else if InlineSlice.canStore(count: count) {
                self = .slice(InlineSlice(count: count))
            } else {
                self = .large(LargeSlice(count: count))
            }
        }
    @inlinable internal init(_ storage: __DataStorage, count: Int) {
            if count == 0 {
                self = .empty
            } else if InlineData.canStore(count: count) {
                self = .inline(storage.withUnsafeBytes(in: 0..<count) { InlineData($0) })
            } else if InlineSlice.canStore(count: count) {
                self = .slice(InlineSlice(storage, count: count))
            } else {
                self = .large(LargeSlice(storage, count: count))
            }
        }
    @usableFromInline
    mutating internal func reserveCapacity(_ minimumCapacity: Int)
    @inlinable internal var count: Int {
      get {
                switch self {
                case .empty: return 0
                case .inline(let inline): return inline.count
                case .slice(let slice): return slice.count
                case .large(let slice): return slice.count
                }
            }
      set(newValue) {
                // HACK: The definition of this inline function takes an inout reference to self, giving the optimizer a unique referencing guarantee.
                //       This allows us to avoid excessive retain-release traffic around modifying enum values, and inlining the function then avoids the additional frame.
                @inline(__always)
                func apply(_ representation: inout _Representation, _ newValue: Int) -> _Representation? {
                    switch representation {
                    case .empty:
                        if newValue == 0 {
                            return nil
                        } else if InlineData.canStore(count: newValue) {
                            return .inline(InlineData())
                        } else if InlineSlice.canStore(count: newValue) {
                            return .slice(InlineSlice(count: newValue))
                        } else {
                            return .large(LargeSlice(count: newValue))
                        }
                    case .inline(var inline):
                        if newValue == 0 {
                            return .empty
                        } else if InlineData.canStore(count: newValue) {
                            guard inline.count != newValue else { return nil }
                            inline.count = newValue
                            return .inline(inline)
                        } else if InlineSlice.canStore(count: newValue) {
                            var slice = InlineSlice(inline)
                            slice.count = newValue
                            return .slice(slice)
                        } else {
                            var slice = LargeSlice(inline)
                            slice.count = newValue
                            return .large(slice)
                        }
                    case .slice(var slice):
                        if newValue == 0 && slice.startIndex == 0 {
                            return .empty
                        } else if slice.startIndex == 0 && InlineData.canStore(count: newValue) {
                            return .inline(InlineData(slice, count: newValue))
                        } else if InlineSlice.canStore(count: newValue + slice.startIndex) {
                            guard slice.count != newValue else { return nil }
                            representation = .empty // TODO: remove this when mgottesman lands optimizations
                            slice.count = newValue
                            return .slice(slice)
                        } else {
                            var newSlice = LargeSlice(slice)
                            newSlice.count = newValue
                            return .large(newSlice)
                        }
                    case .large(var slice):
                        if newValue == 0 && slice.startIndex == 0 {
                            return .empty
                        } else if slice.startIndex == 0 && InlineData.canStore(count: newValue) {
                            return .inline(InlineData(slice, count: newValue))
                        } else {
                            guard slice.count != newValue else { return nil}
                            representation = .empty // TODO: remove this when mgottesman lands optimizations
                            slice.count = newValue
                            return .large(slice)
                        }
                    }
                }

                if let rep = apply(&self, newValue) {
                    self = rep
                }
            }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            switch self {
            case .empty:
                let empty = InlineData()
                return try empty.withUnsafeBytes(apply)
            case .inline(let inline):
                return try inline.withUnsafeBytes(apply)
            case .slice(let slice):
                return try slice.withUnsafeBytes(apply)
            case .large(let slice):
                return try slice.withUnsafeBytes(apply)
            }
        }
    @inlinable mutating internal func withUnsafeMutableBytes<Result>(_ apply: (UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            switch self {
            case .empty:
                var empty = InlineData()
                return try empty.withUnsafeMutableBytes(apply)
            case .inline(var inline):
                defer { self = .inline(inline) }
                return try inline.withUnsafeMutableBytes(apply)
            case .slice(var slice):
                self = .empty
                defer { self = .slice(slice) }
                return try slice.withUnsafeMutableBytes(apply)
            case .large(var slice):
                self = .empty
                defer { self = .large(slice) }
                return try slice.withUnsafeMutableBytes(apply)
            }
        }
    @inlinable internal func withInteriorPointerReference<T>(_ work: (NSData) throws -> T) rethrows -> T {
            switch self {
            case .empty:
                return try work(NSData())
            case .inline(let inline):
                return try inline.withUnsafeBytes {
                    return try work(NSData(bytesNoCopy: UnsafeMutableRawPointer(mutating: $0.baseAddress ?? UnsafeRawPointer(bitPattern: 0xBAD0)!), length: $0.count, freeWhenDone: false))
                }
            case .slice(let slice):
                return try slice.storage.withInteriorPointerReference(slice.range, work)
            case .large(let slice):
                return try slice.storage.withInteriorPointerReference(slice.range, work)
            }
        }
    @usableFromInline
    internal func enumerateBytes(_ block: (_ buffer: UnsafeBufferPointer<UInt8>, _ byteIndex: Index, _ stop: inout Bool) -> Void)
    @inlinable mutating internal func append(contentsOf buffer: UnsafeRawBufferPointer) {
            switch self {
            case .empty:
                self = _Representation(buffer)
            case .inline(var inline):
                if InlineData.canStore(count: inline.count + buffer.count) {
                    inline.append(contentsOf: buffer)
                    self = .inline(inline)
                } else if InlineSlice.canStore(count: inline.count + buffer.count) {
                    var newSlice = InlineSlice(inline)
                    newSlice.append(contentsOf: buffer)
                    self = .slice(newSlice)
                } else {
                    var newSlice = LargeSlice(inline)
                    newSlice.append(contentsOf: buffer)
                    self = .large(newSlice)
                }
            case .slice(var slice):
                if InlineSlice.canStore(count: slice.range.upperBound + buffer.count) {
                    self = .empty
                    defer { self = .slice(slice) }
                    slice.append(contentsOf: buffer)
                } else {
                    self = .empty
                    var newSlice = LargeSlice(slice)
                    newSlice.append(contentsOf: buffer)
                    self = .large(newSlice)
                }
            case .large(var slice):
                self = .empty
                defer { self = .large(slice) }
                slice.append(contentsOf: buffer)
            }
        }
    @inlinable mutating internal func resetBytes(in range: Range<Index>) {
            switch self {
            case .empty:
                if range.upperBound == 0 {
                    self = .empty
                } else if InlineData.canStore(count: range.upperBound) {
                    precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
                    self = .inline(InlineData(count: range.upperBound))
                } else if InlineSlice.canStore(count: range.upperBound) {
                    precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
                    self = .slice(InlineSlice(count: range.upperBound))
                } else {
                    precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
                    self = .large(LargeSlice(count: range.upperBound))
                }
                break
            case .inline(var inline):
                if inline.count < range.upperBound {
                    if InlineSlice.canStore(count: range.upperBound) {
                        var slice = InlineSlice(inline)
                        slice.resetBytes(in: range)
                        self = .slice(slice)
                    } else {
                        var slice = LargeSlice(inline)
                        slice.resetBytes(in: range)
                        self = .large(slice)
                    }
                } else {
                    inline.resetBytes(in: range)
                    self = .inline(inline)
                }
                break
            case .slice(var slice):
                if InlineSlice.canStore(count: range.upperBound) {
                    self = .empty
                    slice.resetBytes(in: range)
                    self = .slice(slice)
                } else {
                    self = .empty
                    var newSlice = LargeSlice(slice)
                    newSlice.resetBytes(in: range)
                    self = .large(newSlice)
                }
                break
            case .large(var slice):
                self = .empty
                slice.resetBytes(in: range)
                self = .large(slice)
            }
        }
    @usableFromInline
    mutating internal func replaceSubrange(_ subrange: Range<Index>, with bytes: UnsafeRawPointer?, count cnt: Int)
    @inlinable internal subscript(index: Index) -> UInt8 {
      get {
                switch self {
                case .empty: preconditionFailure("index \(index) out of range of 0")
                case .inline(let inline): return inline[index]
                case .slice(let slice): return slice[index]
                case .large(let slice): return slice[index]
                }
            }
      set(newValue) {
                switch self {
                case .empty: preconditionFailure("index \(index) out of range of 0")
                case .inline(var inline):
                    inline[index] = newValue
                    self = .inline(inline)
                case .slice(var slice):
                    self = .empty
                    slice[index] = newValue
                    self = .slice(slice)
                case .large(var slice):
                    self = .empty
                    slice[index] = newValue
                    self = .large(slice)
                }
            }
    }
    @inlinable internal subscript(bounds: Range<Index>) -> Data {
      get {
                switch self {
                case .empty:
                    precondition(bounds.lowerBound == 0 && (bounds.upperBound - bounds.lowerBound) == 0, "Range \(bounds) out of bounds 0..<0")
                    return Data()
                case .inline(let inline):
                    precondition(bounds.upperBound <= inline.count, "Range \(bounds) out of bounds 0..<\(inline.count)")
                    if bounds.lowerBound == 0 {
                        var newInline = inline
                        newInline.count = bounds.upperBound
                        return Data(representation: .inline(newInline))
                    } else {
                        return Data(representation: .slice(InlineSlice(inline, range: bounds)))
                    }
                case .slice(let slice):
                    precondition(slice.startIndex <= bounds.lowerBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.lowerBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(slice.startIndex <= bounds.upperBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.upperBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    if bounds.lowerBound == 0 && bounds.upperBound == 0 {
                        return Data()
                    } else if bounds.lowerBound == 0 && InlineData.canStore(count: bounds.count) {
                        return Data(representation: .inline(InlineData(slice, count: bounds.count)))
                    } else {
                        var newSlice = slice
                        newSlice.range = bounds
                        return Data(representation: .slice(newSlice))
                    }
                case .large(let slice):
                    precondition(slice.startIndex <= bounds.lowerBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.lowerBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(slice.startIndex <= bounds.upperBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.upperBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    if bounds.lowerBound == 0 && bounds.upperBound == 0 {
                        return Data()
                    } else if bounds.lowerBound == 0 && InlineData.canStore(count: bounds.upperBound) {
                        return Data(representation: .inline(InlineData(slice, count: bounds.upperBound)))
                    } else if InlineSlice.canStore(count: bounds.lowerBound) && InlineSlice.canStore(count: bounds.upperBound) {
                        return Data(representation: .slice(InlineSlice(slice, range: bounds)))
                    } else {
                        var newSlice = slice
                        newSlice.slice = RangeReference(bounds)
                        return Data(representation: .large(newSlice))
                    }
                }
            }
    }
    @inlinable internal var startIndex: Int {
      get {
            switch self {
            case .empty: return 0
            case .inline: return 0
            case .slice(let slice): return slice.startIndex
            case .large(let slice): return slice.startIndex
            }
        }
    }
    @inlinable internal var endIndex: Int {
      get {
            switch self {
            case .empty: return 0
            case .inline(let inline): return inline.count
            case .slice(let slice): return slice.endIndex
            case .large(let slice): return slice.endIndex
            }
        }
    }
    @inlinable internal func bridgedReference() -> NSData {
            switch self {
            case .empty: return NSData()
            case .inline(let inline):
                return inline.withUnsafeBytes {
                    return NSData(bytes: $0.baseAddress, length: $0.count)
                }
            case .slice(let slice):
                return slice.bridgedReference()
            case .large(let slice):
                return slice.bridgedReference()
            }
        }
    @inlinable internal func copyBytes(to pointer: UnsafeMutableRawPointer, from range: Range<Int>) {
            switch self {
            case .empty:
                precondition(range.lowerBound == 0 && range.upperBound == 0, "Range \(range) out of bounds 0..<0")
                return
            case .inline(let inline):
                inline.copyBytes(to: pointer, from: range)
                break
            case .slice(let slice):
                slice.copyBytes(to: pointer, from: range)
            case .large(let slice):
                slice.copyBytes(to: pointer, from: range)
            }
        }
  }
  @usableFromInline
  internal var _representation: _Representation
  public enum Deallocator {
    case virtualMemory
    case unmap
    case free
    case none
    case custom((UnsafeMutableRawPointer, Int) -> Void)
    @usableFromInline
    internal var _deallocator: ((UnsafeMutableRawPointer, Int) -> Void) {
      get
    }
  }
  @inlinable public init(bytes: UnsafeRawPointer, count: Int) {
        _representation = _Representation(UnsafeRawBufferPointer(start: bytes, count: count))
    }
  @inlinable public init<SourceType>(buffer: UnsafeBufferPointer<SourceType>) {
        _representation = _Representation(UnsafeRawBufferPointer(buffer))
    }
  @inlinable public init<SourceType>(buffer: UnsafeMutableBufferPointer<SourceType>) {
        _representation = _Representation(UnsafeRawBufferPointer(buffer))
    }
  @inlinable public init(repeating repeatedValue: UInt8, count: Int) {
        self.init(count: count)
        withUnsafeMutableBytes { (buffer: UnsafeMutableRawBufferPointer) -> Void in
            memset(buffer.baseAddress, Int32(repeatedValue), buffer.count)
        }
    }
  @inlinable public init(capacity: Int) {
        _representation = _Representation(capacity: capacity)
    }
  @inlinable public init(count: Int) {
        _representation = _Representation(count: count)
    }
  @inlinable public init() {
        _representation = .empty
    }
  @inlinable public init(bytesNoCopy bytes: UnsafeMutableRawPointer, count: Int, deallocator: Deallocator) {
        let whichDeallocator = deallocator._deallocator
        if count == 0 {
            deallocator._deallocator(bytes, count)
            _representation = .empty
        } else {
            _representation = _Representation(__DataStorage(bytes: bytes, length: count, copy: false, deallocator: whichDeallocator, offset: 0), count: count)
        }
    }
  @inlinable public init(contentsOf url: __shared URL, options: Data.ReadingOptions = []) throws {
        let d = try NSData(contentsOf: url, options: ReadingOptions(rawValue: options.rawValue))
        self.init(bytes: d.bytes, count: d.length)
    }
  @inlinable public init?(base64Encoded base64String: __shared String, options: Data.Base64DecodingOptions = []) {
        if let d = NSData(base64Encoded: base64String, options: Base64DecodingOptions(rawValue: options.rawValue)) {
            self.init(bytes: d.bytes, count: d.length)
        } else {
            return nil
        }
    }
  @inlinable public init?(base64Encoded base64Data: __shared Data, options: Data.Base64DecodingOptions = []) {
        if let d = NSData(base64Encoded: base64Data, options: Base64DecodingOptions(rawValue: options.rawValue)) {
            self.init(bytes: d.bytes, count: d.length)
        } else {
            return nil
        }
    }
  public init(referencing reference: __shared NSData)
  @inlinable public init<S>(_ elements: S) where S : Swift.Sequence, S.Element == Swift.UInt8 {
        // If the sequence is already contiguous, access the underlying raw memory directly.
        if let contiguous = elements as? ContiguousBytes {
            _representation = contiguous.withUnsafeBytes { return _Representation($0) }
            return
        }

        // The sequence might still be able to provide direct access to typed memory.
        // NOTE: It's safe to do this because we're already guarding on S's element as `UInt8`. This would not be safe on arbitrary sequences.
        let representation = elements.withContiguousStorageIfAvailable {
            return _Representation(UnsafeRawBufferPointer($0))
        }

        if let representation = representation {
            _representation = representation
        } else {
            // Dummy assignment so we can capture below.
            _representation = _Representation(capacity: 0)

            // Copy as much as we can in one shot from the sequence.
            let underestimatedCount = Swift.max(elements.underestimatedCount, 1)
            _withStackOrHeapBuffer(underestimatedCount) { (buffer) in
                // In order to copy from the sequence, we have to bind the buffer to UInt8.
                // This is safe since we'll copy out of this buffer as raw memory later.
                let capacity = buffer.pointee.capacity
                let base = buffer.pointee.memory.bindMemory(to: UInt8.self, capacity: capacity)
                var (iter, endIndex) = elements._copyContents(initializing: UnsafeMutableBufferPointer(start: base, count: capacity))

                // Copy the contents of buffer...
                _representation = _Representation(UnsafeRawBufferPointer(start: base, count: endIndex))

                // ... and append the rest byte-wise, buffering through an InlineData.
                var buffer = InlineData()
                while let element = iter.next() {
                    buffer.append(byte: element)
                    if buffer.count == buffer.capacity {
                        buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
                        buffer.count = 0
                    }
                }

                // If we've still got bytes left in the buffer (i.e. the loop ended before we filled up the buffer and cleared it out), append them.
                if buffer.count > 0 {
                    buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
                    buffer.count = 0
                }
            }
        }
    }
  @available(swift 4.2)
  @available(swift, deprecated: 5, message: "use `init(_:)` instead")
  public init<S>(bytes elements: S) where S : Swift.Sequence, S.Element == Swift.UInt8
  @available(swift, obsoleted: 4.2)
  public init(bytes: Array<UInt8>)
  @available(swift, obsoleted: 4.2)
  public init(bytes: ArraySlice<UInt8>)
  @inlinable internal init(representation: _Representation) {
        _representation = representation
    }
  @inlinable mutating public func reserveCapacity(_ minimumCapacity: Int) {
        _representation.reserveCapacity(minimumCapacity)
    }
  @inlinable public var count: Int {
    get {
            return _representation.count
        }
    set(newValue) {
            precondition(newValue >= 0, "count must not be negative")
            _representation.count = newValue
        }
  }
  @inlinable public var regions: CollectionOfOne<Data> {
    get {
        return CollectionOfOne(self)
    }
  }
  @available(swift, deprecated: 5, message: "use `withUnsafeBytes<R>(_: (UnsafeRawBufferPointer) throws -> R) rethrows -> R` instead")
  public func withUnsafeBytes<ResultType, ContentType>(_ body: (UnsafePointer<ContentType>) throws -> ResultType) rethrows -> ResultType
  @inlinable public func withUnsafeBytes<ResultType>(_ body: (UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType {
        return try _representation.withUnsafeBytes(body)
    }
  @available(swift, deprecated: 5, message: "use `withUnsafeMutableBytes<R>(_: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R` instead")
  mutating public func withUnsafeMutableBytes<ResultType, ContentType>(_ body: (UnsafeMutablePointer<ContentType>) throws -> ResultType) rethrows -> ResultType
  @inlinable mutating public func withUnsafeMutableBytes<ResultType>(_ body: (UnsafeMutableRawBufferPointer) throws -> ResultType) rethrows -> ResultType {
        return try _representation.withUnsafeMutableBytes(body)
    }
  @inlinable public func copyBytes(to pointer: UnsafeMutablePointer<UInt8>, count: Int) {
        precondition(count >= 0, "count of bytes to copy must not be negative")
        if count == 0 { return }
        _copyBytesHelper(to: UnsafeMutableRawPointer(pointer), from: startIndex..<(startIndex + count))
    }
  @inlinable internal func _copyBytesHelper(to pointer: UnsafeMutableRawPointer, from range: Range<Int>) {
        if range.upperBound - range.lowerBound == 0 { return }
        _representation.copyBytes(to: pointer, from: range)
    }
  @inlinable public func copyBytes(to pointer: UnsafeMutablePointer<UInt8>, from range: Range<Index>) {
        _copyBytesHelper(to: pointer, from: range)
    }
  @inlinable public func copyBytes<DestinationType>(to buffer: UnsafeMutableBufferPointer<DestinationType>, from range: Range<Index>? = nil) -> Int {
        let cnt = count
        guard cnt > 0 else { return 0 }
        
        let copyRange : Range<Index>
        if let r = range {
            guard !r.isEmpty else { return 0 }
            copyRange = r.lowerBound..<(r.lowerBound + Swift.min(buffer.count * MemoryLayout<DestinationType>.stride, r.upperBound - r.lowerBound))
        } else {
            copyRange = 0..<Swift.min(buffer.count * MemoryLayout<DestinationType>.stride, cnt)
        }
        
        guard !copyRange.isEmpty else { return 0 }
        
        _copyBytesHelper(to: buffer.baseAddress!, from: copyRange)
        return copyRange.upperBound - copyRange.lowerBound
    }
  public func write(to url: URL, options: Data.WritingOptions = []) throws
  public func range(of dataToFind: Data, options: Data.SearchOptions = [], in range: Range<Index>? = nil) -> Range<Index>?
  @available(swift, deprecated: 5, message: "use `regions` or `for-in` instead")
  public func enumerateBytes(_ block: (_ buffer: UnsafeBufferPointer<UInt8>, _ byteIndex: Index, _ stop: inout Bool) -> Void)
  @inlinable mutating internal func _append<SourceType>(_ buffer: UnsafeBufferPointer<SourceType>) {
        if buffer.isEmpty { return }
        _representation.append(contentsOf: UnsafeRawBufferPointer(buffer))
    }
  @inlinable mutating public func append(_ bytes: UnsafePointer<UInt8>, count: Int) {
        if count == 0 { return }
        _append(UnsafeBufferPointer(start: bytes, count: count))
    }
  mutating public func append(_ other: Data)
  @inlinable mutating public func append<SourceType>(_ buffer: UnsafeBufferPointer<SourceType>) {
        _append(buffer)
    }
  @inlinable mutating public func append(contentsOf bytes: [UInt8]) {
        bytes.withUnsafeBufferPointer { (buffer: UnsafeBufferPointer<UInt8>) -> Void in
            _append(buffer)
        }
    }
  @inlinable mutating public func append<S>(contentsOf elements: S) where S : Swift.Sequence, S.Element == Foundation.Data.Element {
        // If the sequence is already contiguous, access the underlying raw memory directly.
        if let contiguous = elements as? ContiguousBytes {
            contiguous.withUnsafeBytes {
                _representation.append(contentsOf: $0)
            }

            return
        }

        // The sequence might still be able to provide direct access to typed memory.
        // NOTE: It's safe to do this because we're already guarding on S's element as `UInt8`. This would not be safe on arbitrary sequences.
        var appended = false
        elements.withContiguousStorageIfAvailable {
            _representation.append(contentsOf: UnsafeRawBufferPointer($0))
            appended = true
        }

        guard !appended else { return }

        // The sequence is really not contiguous.
        // Copy as much as we can in one shot.
        let underestimatedCount = Swift.max(elements.underestimatedCount, 1)
        _withStackOrHeapBuffer(underestimatedCount) { (buffer) in
            // In order to copy from the sequence, we have to bind the temporary buffer to `UInt8`.
            // This is safe since we're the only owners of the buffer and we copy out as raw memory below anyway.
            let capacity = buffer.pointee.capacity
            let base = buffer.pointee.memory.bindMemory(to: UInt8.self, capacity: capacity)
            var (iter, endIndex) = elements._copyContents(initializing: UnsafeMutableBufferPointer(start: base, count: capacity))

            // Copy the contents of the buffer...
            _representation.append(contentsOf: UnsafeRawBufferPointer(start: base, count: endIndex))

            // ... and append the rest byte-wise, buffering through an InlineData.
            var buffer = InlineData()
            while let element = iter.next() {
                buffer.append(byte: element)
                if buffer.count == buffer.capacity {
                    buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
                    buffer.count = 0
                }
            }

            // If we've still got bytes left in the buffer (i.e. the loop ended before we filled up the buffer and cleared it out), append them.
            if buffer.count > 0 {
                buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
                buffer.count = 0
            }
        }
    }
  @inlinable mutating public func resetBytes(in range: Range<Index>) {
        // it is worth noting that the range here may be out of bounds of the Data itself (which triggers a growth)
        precondition(range.lowerBound >= 0, "Ranges must not be negative bounds")
        precondition(range.upperBound >= 0, "Ranges must not be negative bounds")
        _representation.resetBytes(in: range)
    }
  @inlinable mutating public func replaceSubrange(_ subrange: Range<Index>, with data: Data) {
        data.withUnsafeBytes { (buffer: UnsafeRawBufferPointer) in
            _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: buffer.count)
        }
    }
  @inlinable mutating public func replaceSubrange<SourceType>(_ subrange: Range<Index>, with buffer: UnsafeBufferPointer<SourceType>) {
        guard !buffer.isEmpty  else { return }
        replaceSubrange(subrange, with: buffer.baseAddress!, count: buffer.count * MemoryLayout<SourceType>.stride)
    }
  @inlinable mutating public func replaceSubrange<ByteCollection>(_ subrange: Range<Index>, with newElements: ByteCollection) where ByteCollection : Swift.Collection, ByteCollection.Element == Foundation.Data.Iterator.Element {
        let totalCount = Int(newElements.count)
        _withStackOrHeapBuffer(totalCount) { conditionalBuffer in
            let buffer = UnsafeMutableBufferPointer(start: conditionalBuffer.pointee.memory.assumingMemoryBound(to: UInt8.self), count: totalCount)
            var (iterator, index) = newElements._copyContents(initializing: buffer)
            while let byte = iterator.next() {
                buffer[index] = byte
                index = buffer.index(after: index)
            }
            replaceSubrange(subrange, with: conditionalBuffer.pointee.memory, count: totalCount)
        }
    }
  @inlinable mutating public func replaceSubrange(_ subrange: Range<Index>, with bytes: UnsafeRawPointer, count cnt: Int) {
        _representation.replaceSubrange(subrange, with: bytes, count: cnt)
    }
  public func subdata(in range: Range<Index>) -> Data
  @inlinable public func base64EncodedString(options: Data.Base64EncodingOptions = []) -> String {
        return _representation.withInteriorPointerReference {
            return $0.base64EncodedString(options: options)
        }
    }
  @inlinable public func base64EncodedData(options: Data.Base64EncodingOptions = []) -> Data {
        return _representation.withInteriorPointerReference {
            return $0.base64EncodedData(options: options)
        }
    }
  @inline(never) public func hash(into hasher: inout Hasher)
  public func advanced(by amount: Int) -> Data
  @inlinable public subscript(index: Index) -> UInt8 {
    get {
            return _representation[index]
        }
    set(newValue) {
            _representation[index] = newValue
        }
  }
  @inlinable public subscript(bounds: Range<Index>) -> Data {
    get {
            return _representation[bounds]
        }
    set {
            replaceSubrange(bounds, with: newValue)
        }
  }
  @inlinable public subscript<R>(rangeExpression: R) -> Data where R : Swift.RangeExpression, R.Bound : Swift.FixedWidthInteger {
    get {
            let lower = R.Bound(startIndex)
            let upper = R.Bound(endIndex)
            let range = rangeExpression.relative(to: lower..<upper)
            let start = Int(range.lowerBound)
            let end = Int(range.upperBound)
            let r: Range<Int> = start..<end
            return _representation[r]
        }
    set {
            let lower = R.Bound(startIndex)
            let upper = R.Bound(endIndex)
            let range = rangeExpression.relative(to: lower..<upper)
            let start = Int(range.lowerBound)
            let end = Int(range.upperBound)
            let r: Range<Int> = start..<end
            replaceSubrange(r, with: newValue)
        }
  }
  @inlinable public var startIndex: Index {
    get {
            return _representation.startIndex
        }
  }
  @inlinable public var endIndex: Index {
    get {
            return _representation.endIndex
        }
  }
  @inlinable public func index(before i: Index) -> Index {
        return i - 1
    }
  @inlinable public func index(after i: Index) -> Index {
        return i + 1
    }
  @inlinable public var indices: Range<Int> {
    get {
            return startIndex..<endIndex
        }
  }
  @inlinable public func _copyContents(initializing buffer: UnsafeMutableBufferPointer<UInt8>) -> (Iterator, UnsafeMutableBufferPointer<UInt8>.Index) {
        guard !isEmpty else { return (makeIterator(), buffer.startIndex) }
        let cnt = Swift.min(count, buffer.count)
        
        withUnsafeBytes { (bytes: UnsafeRawBufferPointer) in
            _ = memcpy(UnsafeMutableRawPointer(buffer.baseAddress), bytes.baseAddress, cnt)
        }
        
        return (Iterator(self, at: startIndex + cnt), buffer.index(buffer.startIndex, offsetBy: cnt))
    }
  @inlinable public func makeIterator() -> Data.Iterator {
        return Iterator(self, at: startIndex)
    }
  public struct Iterator : IteratorProtocol {
    @usableFromInline
    internal typealias Buffer = (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8)
    @usableFromInline
    internal let _data: Data
    @usableFromInline
    internal var _buffer: Buffer
    @usableFromInline
    internal var _idx: Data.Index
    @usableFromInline
    internal let _endIdx: Data.Index
    @usableFromInline
    internal init(_ data: Data, at loc: Data.Index)
    mutating public func next() -> UInt8?
    public typealias Element = Swift.UInt8
  }
  @available(*, unavailable, renamed: "count")
  public var length: Int {
    get
    set
  }
  @available(*, unavailable, message: "use withUnsafeBytes instead")
  public var bytes: UnsafeRawPointer {
    get
  }
  @available(*, unavailable, message: "use withUnsafeMutableBytes instead")
  public var mutableBytes: UnsafeMutableRawPointer {
    get
  }
  @inlinable public static func == (d1: Data, d2: Data) -> Bool {
        let length1 = d1.count
        if length1 != d2.count {
            return false
        }
        if length1 > 0 {
            return d1.withUnsafeBytes { (b1: UnsafeRawBufferPointer) in
                return d2.withUnsafeBytes { (b2: UnsafeRawBufferPointer) in
                    return memcmp(b1.baseAddress!, b2.baseAddress!, b2.count) == 0
                }
            }
        }
        return true
    }
  public typealias SubSequence = Foundation.Data
  public typealias Element = Swift.UInt8
  public typealias Regions = Swift.CollectionOfOne<Foundation.Data>
  public var hashValue: Swift.Int {
    get
  }
}
extension Data : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
  public var customMirror: Mirror {
    get
  }
}
extension Data {
  @available(*, unavailable, renamed: "copyBytes(to:count:)")
  public func getBytes<UnsafeMutablePointerVoid>(_ buffer: UnsafeMutablePointerVoid, length: Int) where UnsafeMutablePointerVoid : Swift._Pointer
  @available(*, unavailable, renamed: "copyBytes(to:from:)")
  public func getBytes<UnsafeMutablePointerVoid>(_ buffer: UnsafeMutablePointerVoid, range: NSRange) where UnsafeMutablePointerVoid : Swift._Pointer
}
extension Data : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSData
  public static func _forceBridgeFromObjectiveC(_ input: NSData, result: inout Data?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: NSData, result: inout Data?) -> Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: NSData?) -> Data
  public typealias _ObjectiveCType = Foundation.NSData
}
extension NSData : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension Data : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
public protocol DataProtocol : Swift.RandomAccessCollection where Self.Element == Swift.UInt8, Self.SubSequence : Foundation.DataProtocol {
  associatedtype Regions : Swift.BidirectionalCollection where Self.Regions.Element : Foundation.ContiguousBytes, Self.Regions.Element : Foundation.DataProtocol, Self.Regions.Element.SubSequence : Foundation.ContiguousBytes
  var regions: Regions { get }
  func firstRange<D, R>(of: D, in: R) -> Range<Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
  func lastRange<D, R>(of: D, in: R) -> Range<Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
  @discardableResult
  func copyBytes(to: UnsafeMutableRawBufferPointer, count: Int) -> Int
  @discardableResult
  func copyBytes<DestinationType>(to: UnsafeMutableBufferPointer<DestinationType>, count: Int) -> Int
  @discardableResult
  func copyBytes<R>(to: UnsafeMutableRawBufferPointer, from: R) -> Int where R : Swift.RangeExpression, Self.Index == R.Bound
  @discardableResult
  func copyBytes<DestinationType, R>(to: UnsafeMutableBufferPointer<DestinationType>, from: R) -> Int where R : Swift.RangeExpression, Self.Index == R.Bound
}
public protocol MutableDataProtocol : Foundation.DataProtocol, Swift.MutableCollection, Swift.RangeReplaceableCollection {
  mutating func resetBytes<R>(in range: R) where R : Swift.RangeExpression, Self.Index == R.Bound
}
extension DataProtocol {
  public func firstRange<D>(of data: D) -> Range<Index>? where D : Foundation.DataProtocol
  public func lastRange<D>(of data: D) -> Range<Index>? where D : Foundation.DataProtocol
  @discardableResult
  public func copyBytes(to ptr: UnsafeMutableRawBufferPointer) -> Int
  @discardableResult
  public func copyBytes<DestinationType>(to ptr: UnsafeMutableBufferPointer<DestinationType>) -> Int
  @discardableResult
  public func copyBytes(to ptr: UnsafeMutableRawBufferPointer, count: Int) -> Int
  @discardableResult
  public func copyBytes<DestinationType>(to ptr: UnsafeMutableBufferPointer<DestinationType>, count: Int) -> Int
  @discardableResult
  public func copyBytes<R>(to ptr: UnsafeMutableRawBufferPointer, from range: R) -> Int where R : Swift.RangeExpression, Self.Index == R.Bound
  @discardableResult
  public func copyBytes<DestinationType, R>(to ptr: UnsafeMutableBufferPointer<DestinationType>, from range: R) -> Int where R : Swift.RangeExpression, Self.Index == R.Bound
  public func firstRange<D, R>(of data: D, in range: R) -> Range<Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
  public func lastRange<D, R>(of data: D, in range: R) -> Range<Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
}
extension DataProtocol where Self : Foundation.ContiguousBytes {
  public func copyBytes<DestinationType, R>(to ptr: UnsafeMutableBufferPointer<DestinationType>, from range: R) where R : Swift.RangeExpression, Self.Index == R.Bound
}
extension MutableDataProtocol {
  mutating public func resetBytes<R>(in range: R) where R : Swift.RangeExpression, Self.Index == R.Bound
}
extension Slice : DataProtocol where Base : Foundation.DataProtocol {
  public typealias Regions = [Base.Regions.Element.SubSequence]
  public var regions: [Base.Regions.Element.SubSequence] {
    get
  }
}
extension DispatchData : DataProtocol {
  public struct Region : DataProtocol, ContiguousBytes {
    public var regions: CollectionOfOne<Region> {
      get
    }
    public subscript(position: DispatchData.Index) -> UInt8 {
      get
    }
    public var startIndex: DispatchData.Index {
      get
    }
    public var endIndex: DispatchData.Index {
      get
    }
    public func withUnsafeBytes<ResultType>(_ body: (UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType
    public typealias Element = Swift.UInt8
    public typealias Index = Dispatch.DispatchData.Index
    public typealias Iterator = Swift.IndexingIterator<Dispatch.DispatchData.Region>
    public typealias SubSequence = Swift.Slice<Dispatch.DispatchData.Region>
    public typealias Indices = Swift.Range<Dispatch.DispatchData.Index>
    public typealias Regions = Swift.CollectionOfOne<Dispatch.DispatchData.Region>
  }
  public var regions: [Region] {
    get
  }
  public typealias Regions = [Dispatch.DispatchData.Region]
}
extension NSData : DataProtocol {
  @nonobjc public var startIndex: Int {
    get
  }
  @nonobjc public var endIndex: Int {
    get
  }
  @nonobjc public func lastRange<D, R>(of data: D, in r: R) -> Range<Int>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, R.Bound == Foundation.NSData.Index
  @nonobjc public func firstRange<D, R>(of data: D, in r: R) -> Range<Int>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, R.Bound == Foundation.NSData.Index
  @nonobjc public var regions: [Data] {
    get
  }
  @nonobjc public subscript(position: Int) -> UInt8 {
    get
  }
  public typealias Element = Swift.UInt8
  public typealias Index = Swift.Int
  public typealias SubSequence = Swift.Slice<Foundation.NSData>
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Regions = [Foundation.Data]
  public typealias Iterator = Swift.IndexingIterator<Foundation.NSData>
}
extension UnsafeRawBufferPointer : DataProtocol {
  public var regions: CollectionOfOne<UnsafeRawBufferPointer> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.UnsafeRawBufferPointer>
}
extension UnsafeBufferPointer : DataProtocol where Element == Swift.UInt8 {
  public var regions: CollectionOfOne<UnsafeBufferPointer<Element>> {
    get
  }
  public typealias Regions = Swift.CollectionOfOne<Swift.UnsafeBufferPointer<Swift.UInt8>>
}
public struct Date : ReferenceConvertible, Comparable, Equatable {
  public typealias ReferenceType = NSDate
  public static let timeIntervalBetween1970AndReferenceDate: TimeInterval
  public static var timeIntervalSinceReferenceDate: TimeInterval {
    get
  }
  public init()
  public init(timeIntervalSinceNow: TimeInterval)
  public init(timeIntervalSince1970: TimeInterval)
  public init(timeInterval: TimeInterval, since date: Date)
  public init(timeIntervalSinceReferenceDate ti: TimeInterval)
  public var timeIntervalSinceReferenceDate: TimeInterval {
    get
  }
  public func timeIntervalSince(_ date: Date) -> TimeInterval
  public var timeIntervalSinceNow: TimeInterval {
    get
  }
  public var timeIntervalSince1970: TimeInterval {
    get
  }
  public func addingTimeInterval(_ timeInterval: TimeInterval) -> Date
  mutating public func addTimeInterval(_ timeInterval: TimeInterval)
  public static let distantFuture: Foundation.Date
  public static let distantPast: Foundation.Date
  public func hash(into hasher: inout Hasher)
  public func compare(_ other: Date) -> ComparisonResult
  public static func == (lhs: Date, rhs: Date) -> Bool
  public static func < (lhs: Date, rhs: Date) -> Bool
  public static func > (lhs: Date, rhs: Date) -> Bool
  public static func + (lhs: Date, rhs: TimeInterval) -> Date
  public static func - (lhs: Date, rhs: TimeInterval) -> Date
  public static func += (lhs: inout Date, rhs: TimeInterval)
  public static func -= (lhs: inout Date, rhs: TimeInterval)
  public var hashValue: Swift.Int {
    get
  }
}
extension Date : CustomDebugStringConvertible, CustomStringConvertible, CustomReflectable {
  public var description: String {
    get
  }
  public func description(with locale: Locale?) -> String
  public var debugDescription: String {
    get
  }
  public var customMirror: Mirror {
    get
  }
}
extension Date : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSDate
  public static func _forceBridgeFromObjectiveC(_ x: NSDate, result: inout Date?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSDate, result: inout Date?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSDate?) -> Date
  public typealias _ObjectiveCType = Foundation.NSDate
}
extension NSDate : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension Date : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Date.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: PlaygroundQuickLook {
    get
  }
}
extension Date : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
public struct DateComponents : ReferenceConvertible, Hashable, Equatable {
  public typealias ReferenceType = NSDateComponents
  public init(calendar: Calendar? = nil, timeZone: TimeZone? = nil, era: Int? = nil, year: Int? = nil, month: Int? = nil, day: Int? = nil, hour: Int? = nil, minute: Int? = nil, second: Int? = nil, nanosecond: Int? = nil, weekday: Int? = nil, weekdayOrdinal: Int? = nil, quarter: Int? = nil, weekOfMonth: Int? = nil, weekOfYear: Int? = nil, yearForWeekOfYear: Int? = nil)
  public var calendar: Calendar? {
    get
    set
  }
  public var timeZone: TimeZone? {
    get
    set
  }
  public var era: Int? {
    get
    set
  }
  public var year: Int? {
    get
    set
  }
  public var month: Int? {
    get
    set
  }
  public var day: Int? {
    get
    set
  }
  public var hour: Int? {
    get
    set
  }
  public var minute: Int? {
    get
    set
  }
  public var second: Int? {
    get
    set
  }
  public var nanosecond: Int? {
    get
    set
  }
  public var weekday: Int? {
    get
    set
  }
  public var weekdayOrdinal: Int? {
    get
    set
  }
  public var quarter: Int? {
    get
    set
  }
  public var weekOfMonth: Int? {
    get
    set
  }
  public var weekOfYear: Int? {
    get
    set
  }
  public var yearForWeekOfYear: Int? {
    get
    set
  }
  public var isLeapMonth: Bool? {
    get
    set
  }
  public var date: Date? {
    get
  }
  @available(OSX 10.9, iOS 8.0, *)
  mutating public func setValue(_ value: Int?, for component: Calendar.Component)
  @available(OSX 10.9, iOS 8.0, *)
  public func value(for component: Calendar.Component) -> Int?
  @available(OSX 10.9, iOS 8.0, *)
  public var isValidDate: Bool {
    get
  }
  @available(OSX 10.9, iOS 8.0, *)
  public func isValidDate(in calendar: Calendar) -> Bool
  public func hash(into hasher: inout Hasher)
  public static func == (lhs: DateComponents, rhs: DateComponents) -> Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension DateComponents : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
  public var customMirror: Mirror {
    get
  }
}
extension DateComponents : _ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSDateComponents
  public static func _forceBridgeFromObjectiveC(_ dateComponents: NSDateComponents, result: inout DateComponents?)
  public static func _conditionallyBridgeFromObjectiveC(_ dateComponents: NSDateComponents, result: inout DateComponents?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSDateComponents?) -> DateComponents
  public typealias _ObjectiveCType = Foundation.NSDateComponents
}
extension NSDateComponents : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension DateComponents : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
@available(OSX 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
public struct DateInterval : ReferenceConvertible, Comparable, Hashable, Codable {
  public typealias ReferenceType = NSDateInterval
  public var start: Date
  public var end: Date {
    get
    set
  }
  public var duration: TimeInterval {
    get
    set
  }
  public init()
  public init(start: Date, end: Date)
  public init(start: Date, duration: TimeInterval)
  public func compare(_ dateInterval: DateInterval) -> ComparisonResult
  public func intersects(_ dateInterval: DateInterval) -> Bool
  public func intersection(with dateInterval: DateInterval) -> DateInterval?
  public func contains(_ date: Date) -> Bool
  public func hash(into hasher: inout Hasher)
  @available(OSX 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static func == (lhs: DateInterval, rhs: DateInterval) -> Bool
  @available(OSX 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static func < (lhs: DateInterval, rhs: DateInterval) -> Bool
  public init(from decoder: Swift.Decoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public func encode(to encoder: Swift.Encoder) throws
}
@available(OSX 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension DateInterval : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
  public var customMirror: Mirror {
    get
  }
}
@available(OSX 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension DateInterval : _ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSDateInterval
  public static func _forceBridgeFromObjectiveC(_ dateInterval: NSDateInterval, result: inout DateInterval?)
  public static func _conditionallyBridgeFromObjectiveC(_ dateInterval: NSDateInterval, result: inout DateInterval?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSDateInterval?) -> DateInterval
  public typealias _ObjectiveCType = Foundation.NSDateInterval
}
@available(OSX 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension NSDateInterval : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension Decimal {
  public typealias RoundingMode = NSDecimalNumber.RoundingMode
  public typealias CalculationError = NSDecimalNumber.CalculationError
  public static let leastFiniteMagnitude: Foundation.Decimal
  public static let greatestFiniteMagnitude: Foundation.Decimal
  public static let leastNormalMagnitude: Foundation.Decimal
  public static let leastNonzeroMagnitude: Foundation.Decimal
  public static let pi: Foundation.Decimal
  public var exponent: Int {
    get
  }
  public var significand: Decimal {
    get
  }
  public init(sign: FloatingPointSign, exponent: Int, significand: Decimal)
  public init(signOf: Decimal, magnitudeOf magnitude: Decimal)
  public var sign: FloatingPointSign {
    get
  }
  public static var radix: Int {
    get
  }
  public var ulp: Decimal {
    get
  }
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  mutating public func formTruncatingRemainder(dividingBy other: Decimal)
  mutating public func negate()
  public func isEqual(to other: Decimal) -> Bool
  public func isLess(than other: Decimal) -> Bool
  public func isLessThanOrEqualTo(_ other: Decimal) -> Bool
  public func isTotallyOrdered(belowOrEqualTo other: Decimal) -> Bool
  public var isCanonical: Bool {
    get
  }
  public var nextUp: Decimal {
    get
  }
  public var nextDown: Decimal {
    get
  }
  public static func + (lhs: Decimal, rhs: Decimal) -> Decimal
  public static func - (lhs: Decimal, rhs: Decimal) -> Decimal
  public static func / (lhs: Decimal, rhs: Decimal) -> Decimal
  public static func * (lhs: Decimal, rhs: Decimal) -> Decimal
}
public func pow(_ x: Decimal, _ y: Int) -> Decimal
extension Decimal : Hashable, Comparable {
  public func hash(into hasher: inout Hasher)
  public static func == (lhs: Decimal, rhs: Decimal) -> Bool
  public static func < (lhs: Decimal, rhs: Decimal) -> Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Decimal : ExpressibleByFloatLiteral {
  public init(floatLiteral value: Double)
  public typealias FloatLiteralType = Swift.Double
}
extension Decimal : ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Int)
  public typealias IntegerLiteralType = Swift.Int
}
extension Decimal : SignedNumeric {
  public var magnitude: Decimal {
    get
  }
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public static func += (lhs: inout Decimal, rhs: Decimal)
  public static func -= (lhs: inout Decimal, rhs: Decimal)
  public static func *= (lhs: inout Decimal, rhs: Decimal)
  public static func /= (lhs: inout Decimal, rhs: Decimal)
  public typealias Magnitude = Foundation.Decimal
}
extension Decimal {
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent mutating public func add(_ other: Decimal) {
      self += other
  }
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent mutating public func subtract(_ other: Decimal) {
      self -= other
  }
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent mutating public func multiply(by other: Decimal) {
      self *= other
  }
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent mutating public func divide(by other: Decimal) {
      self /= other
  }
}
extension Decimal : Strideable {
  public func distance(to other: Decimal) -> Decimal
  public func advanced(by n: Decimal) -> Decimal
  public typealias Stride = Foundation.Decimal
}
extension Decimal {
  public init(_ value: UInt8)
  public init(_ value: Int8)
  public init(_ value: UInt16)
  public init(_ value: Int16)
  public init(_ value: UInt32)
  public init(_ value: Int32)
  public init(_ value: Double)
  public init(_ value: UInt64)
  public init(_ value: Int64)
  public init(_ value: UInt)
  public init(_ value: Int)
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  public static var infinity: Decimal {
    get
  }
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  public static var signalingNaN: Decimal {
    get
  }
  public var isSignalingNaN: Bool {
    get
  }
  public static var nan: Decimal {
    get
  }
  public static var quietNaN: Decimal {
    get
  }
  public var floatingPointClass: FloatingPointClassification {
    get
  }
  public var isSignMinus: Bool {
    get
  }
  public var isNormal: Bool {
    get
  }
  public var isFinite: Bool {
    get
  }
  public var isZero: Bool {
    get
  }
  public var isSubnormal: Bool {
    get
  }
  public var isInfinite: Bool {
    get
  }
  public var isNaN: Bool {
    get
  }
  public var isSignaling: Bool {
    get
  }
}
extension Decimal : CustomStringConvertible {
  public init?(string: __shared String, locale: __shared Locale? = nil)
  public var description: String {
    get
  }
}
extension Decimal : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSDecimalNumber
  public static func _forceBridgeFromObjectiveC(_ x: NSDecimalNumber, result: inout Decimal?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: NSDecimalNumber, result: inout Decimal?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSDecimalNumber?) -> Decimal
  public typealias _ObjectiveCType = Foundation.NSDecimalNumber
}
extension Decimal : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension FileManager {
  @available(*, deprecated, renamed: "replaceItemAt(_:withItemAt:backupItemName:options:)")
  public func replaceItemAtURL(originalItemURL: NSURL, withItemAtURL newItemURL: NSURL, backupItemName: String? = nil, options: FileManager.ItemReplacementOptions = []) throws -> NSURL?
  @available(OSX 10.6, iOS 4.0, *)
  @available(swift, obsoleted: 4)
  public func replaceItemAt(_ originalItemURL: URL, withItemAt newItemURL: URL, backupItemName: String? = nil, options: FileManager.ItemReplacementOptions = []) throws -> NSURL?
  @available(swift 4)
  @available(OSX 10.6, iOS 4.0, *)
  public func replaceItemAt(_ originalItemURL: URL, withItemAt newItemURL: URL, backupItemName: String? = nil, options: FileManager.ItemReplacementOptions = []) throws -> URL?
  @available(OSX 10.6, iOS 4.0, *)
  @nonobjc public func enumerator(at url: URL, includingPropertiesForKeys keys: [URLResourceKey]?, options mask: FileManager.DirectoryEnumerationOptions = [], errorHandler handler: ((URL, Error) -> Bool)? = nil) -> FileManager.DirectoryEnumerator?
}
extension NSObject : CustomStringConvertible {
}
extension NSObject : CustomDebugStringConvertible {
}
public let NSNotFound: Int
public func NSLocalizedString(_ key: String, tableName: String? = nil, bundle: Bundle = Bundle.main, value: String = "", comment: String) -> String
public func NSLog(_ format: String, _ args: CVarArg...)
extension AnyHashable : _ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> NSObject
  public static func _forceBridgeFromObjectiveC(_ x: NSObject, result: inout AnyHashable?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSObject, result: inout AnyHashable?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSObject?) -> AnyHashable
  public typealias _ObjectiveCType = ObjectiveC.NSObject
}
extension CVarArg where Self : Swift._ObjectiveCBridgeable {
  public var _cVarArgEncoding: [Int] {
    get
  }
}
public struct IndexPath : ReferenceConvertible, Equatable, Hashable, MutableCollection, RandomAccessCollection, Comparable, ExpressibleByArrayLiteral {
  public typealias ReferenceType = NSIndexPath
  public typealias Element = Int
  public typealias Index = Array<Int>.Index
  public typealias Indices = DefaultIndices<IndexPath>
  public init()
  public init<ElementSequence>(indexes: ElementSequence) where ElementSequence : Swift.Sequence, ElementSequence.Element == Foundation.IndexPath.Element
  public init(arrayLiteral indexes: Element...)
  public init(indexes: Array<Element>)
  public init(index: Element)
  public func dropLast() -> IndexPath
  mutating public func append(_ other: IndexPath)
  mutating public func append(_ other: Element)
  mutating public func append(_ other: Array<Element>)
  public func appending(_ other: Element) -> IndexPath
  public func appending(_ other: IndexPath) -> IndexPath
  public func appending(_ other: Array<Element>) -> IndexPath
  public subscript(index: Index) -> Element {
    get
    set
  }
  public subscript(range: Range<Index>) -> IndexPath {
    get
    set
  }
  public func makeIterator() -> IndexingIterator<IndexPath>
  public var count: Int {
    get
  }
  public var startIndex: Index {
    get
  }
  public var endIndex: Index {
    get
  }
  public func index(before i: Index) -> Index
  public func index(after i: Index) -> Index
  public func compare(_ other: IndexPath) -> ComparisonResult
  public func hash(into hasher: inout Hasher)
  public static func == (lhs: IndexPath, rhs: IndexPath) -> Bool
  public static func + (lhs: IndexPath, rhs: IndexPath) -> IndexPath
  public static func += (lhs: inout IndexPath, rhs: IndexPath)
  public static func < (lhs: IndexPath, rhs: IndexPath) -> Bool
  public static func <= (lhs: IndexPath, rhs: IndexPath) -> Bool
  public static func > (lhs: IndexPath, rhs: IndexPath) -> Bool
  public static func >= (lhs: IndexPath, rhs: IndexPath) -> Bool
  public var hashValue: Swift.Int {
    get
  }
  public typealias SubSequence = Foundation.IndexPath
  public typealias ArrayLiteralElement = Foundation.IndexPath.Element
  public typealias Iterator = Swift.IndexingIterator<Foundation.IndexPath>
}
extension IndexPath : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
  public var customMirror: Mirror {
    get
  }
}
extension IndexPath : _ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSIndexPath
  public static func _forceBridgeFromObjectiveC(_ x: NSIndexPath, result: inout IndexPath?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSIndexPath, result: inout IndexPath?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSIndexPath?) -> IndexPath
  public typealias _ObjectiveCType = Foundation.NSIndexPath
}
extension NSIndexPath : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension IndexPath : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension IndexSet.Index {
  public static func == (lhs: IndexSet.Index, rhs: IndexSet.Index) -> Bool
  public static func < (lhs: IndexSet.Index, rhs: IndexSet.Index) -> Bool
  public static func <= (lhs: IndexSet.Index, rhs: IndexSet.Index) -> Bool
  public static func > (lhs: IndexSet.Index, rhs: IndexSet.Index) -> Bool
  public static func >= (lhs: IndexSet.Index, rhs: IndexSet.Index) -> Bool
}
extension IndexSet.RangeView {
  public static func == (lhs: IndexSet.RangeView, rhs: IndexSet.RangeView) -> Bool
}
public struct IndexSet : ReferenceConvertible, Equatable, BidirectionalCollection, SetAlgebra {
  public struct RangeView : Equatable, BidirectionalCollection {
    public typealias Index = Int
    public let startIndex: Index
    public let endIndex: Index
    public func makeIterator() -> IndexingIterator<RangeView>
    public subscript(index: Index) -> Range<IndexSet.Element> {
      get
    }
    public subscript(bounds: Range<Index>) -> Slice<RangeView> {
      get
    }
    public func index(after i: Index) -> Index
    public func index(before i: Index) -> Index
    public typealias Element = Swift.Range<Foundation.IndexSet.Element>
    public typealias Iterator = Swift.IndexingIterator<Foundation.IndexSet.RangeView>
    public typealias SubSequence = Swift.Slice<Foundation.IndexSet.RangeView>
    public typealias Indices = Swift.DefaultIndices<Foundation.IndexSet.RangeView>
  }
  public struct Index : CustomStringConvertible, Comparable {
    public var description: String {
      get
    }
  }
  public typealias ReferenceType = NSIndexSet
  public typealias Element = Int
  public init(integersIn range: Range<Element>)
  public init<R>(integersIn range: R) where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public init(integer: Element)
  public init()
  public func hash(into hasher: inout Hasher)
  public var count: Int {
    get
  }
  public func makeIterator() -> IndexingIterator<IndexSet>
  public var rangeView: RangeView {
    get
  }
  public func rangeView(of range: Range<Element>) -> RangeView
  public func rangeView<R>(of range: R) -> RangeView where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public var startIndex: Index {
    get
  }
  public var endIndex: Index {
    get
  }
  public subscript(index: Index) -> Element {
    get
  }
  public subscript(bounds: Range<Index>) -> Slice<IndexSet> {
    get
  }
  public var first: Element? {
    get
  }
  public var last: Element? {
    get
  }
  public func integerGreaterThan(_ integer: Element) -> Element?
  public func integerLessThan(_ integer: Element) -> Element?
  public func integerGreaterThanOrEqualTo(_ integer: Element) -> Element?
  public func integerLessThanOrEqualTo(_ integer: Element) -> Element?
  public func indexRange(in range: Range<Element>) -> Range<Index>
  public func indexRange<R>(in range: R) -> Range<Index> where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public func count(in range: Range<Element>) -> Int
  public func count<R>(in range: R) -> Int where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public func contains(_ integer: Element) -> Bool
  public func contains(integersIn range: Range<Element>) -> Bool
  public func contains<R>(integersIn range: R) -> Bool where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public func contains(integersIn indexSet: IndexSet) -> Bool
  public func intersects(integersIn range: Range<Element>) -> Bool
  public func intersects<R>(integersIn range: R) -> Bool where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  public func index(after i: Index) -> Index
  public func formIndex(after i: inout Index)
  public func index(before i: Index) -> Index
  public func formIndex(before i: inout Index)
  mutating public func formUnion(_ other: IndexSet)
  public func union(_ other: IndexSet) -> IndexSet
  public func symmetricDifference(_ other: IndexSet) -> IndexSet
  mutating public func formSymmetricDifference(_ other: IndexSet)
  public func intersection(_ other: IndexSet) -> IndexSet
  mutating public func formIntersection(_ other: IndexSet)
  @discardableResult
  mutating public func insert(_ integer: Element) -> (inserted: Bool, memberAfterInsert: Element)
  @discardableResult
  mutating public func update(with integer: Element) -> Element?
  @discardableResult
  mutating public func remove(_ integer: Element) -> Element?
  mutating public func removeAll()
  mutating public func insert(integersIn range: Range<Element>)
  mutating public func insert<R>(integersIn range: R) where R : Swift.RangeExpression, R.Bound == Foundation.IndexSet.Element
  mutating public func remove(integersIn range: Range<Element>)
  mutating public func remove(integersIn range: ClosedRange<Element>)
  public var isEmpty: Bool {
    get
  }
  public func filteredIndexSet(in range: Range<Element>, includeInteger: (Element) throws -> Bool) rethrows -> IndexSet
  public func filteredIndexSet(in range: ClosedRange<Element>, includeInteger: (Element) throws -> Bool) rethrows -> IndexSet
  public func filteredIndexSet(includeInteger: (Element) throws -> Bool) rethrows -> IndexSet
  mutating public func shift(startingAt integer: Element, by delta: Int)
  public typealias SubSequence = Swift.Slice<Foundation.IndexSet>
  public typealias Indices = Swift.DefaultIndices<Foundation.IndexSet>
  public var hashValue: Swift.Int {
    get
  }
  public typealias Iterator = Swift.IndexingIterator<Foundation.IndexSet>
  public typealias ArrayLiteralElement = Foundation.IndexSet.Element
}
extension IndexSet : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
  public var customMirror: Mirror {
    get
  }
}
extension IndexSet {
  public static func == (lhs: IndexSet, rhs: IndexSet) -> Bool
}
extension IndexSet : _ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSIndexSet
  public static func _forceBridgeFromObjectiveC(_ x: NSIndexSet, result: inout IndexSet?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSIndexSet, result: inout IndexSet?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSIndexSet?) -> IndexSet
  public typealias _ObjectiveCType = Foundation.NSIndexSet
}
extension NSIndexSet : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension IndexSet : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension Dictionary where Key == Swift.String, Value : Swift.Encodable {
}
extension Dictionary where Key == Swift.String, Value : Swift.Decodable {
}
@_objcRuntimeName(_TtC10Foundation13__JSONEncoder) open class JSONEncoder {
  public struct OutputFormatting : OptionSet {
    public let rawValue: UInt
    public init(rawValue: UInt)
    public static let prettyPrinted: Foundation.JSONEncoder.OutputFormatting
    @available(OSX 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
    public static let sortedKeys: Foundation.JSONEncoder.OutputFormatting
    public typealias Element = Foundation.JSONEncoder.OutputFormatting
    public typealias ArrayLiteralElement = Foundation.JSONEncoder.OutputFormatting
    public typealias RawValue = Swift.UInt
  }
  public enum DateEncodingStrategy {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    case iso8601
    case formatted(DateFormatter)
    case custom((Date, Encoder) throws -> Void)
  }
  public enum DataEncodingStrategy {
    case deferredToData
    case base64
    case custom((Data, Encoder) throws -> Void)
  }
  public enum NonConformingFloatEncodingStrategy {
    case `throw`
    case convertToString(positiveInfinity: String, negativeInfinity: String, nan: String)
  }
  public enum KeyEncodingStrategy {
    case useDefaultKeys
    case convertToSnakeCase
    case custom((_ codingPath: [CodingKey]) -> CodingKey)
  }
  open var outputFormatting: OutputFormatting
  open var dateEncodingStrategy: DateEncodingStrategy
  open var dataEncodingStrategy: DataEncodingStrategy
  open var nonConformingFloatEncodingStrategy: NonConformingFloatEncodingStrategy
  open var keyEncodingStrategy: KeyEncodingStrategy
  open var userInfo: [CodingUserInfoKey : Any]
  public init()
  open func encode<T>(_ value: T) throws -> Data where T : Swift.Encodable
  @objc deinit
}
@_objcRuntimeName(_TtC10Foundation13__JSONDecoder) open class JSONDecoder {
  public enum DateDecodingStrategy {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    case iso8601
    case formatted(DateFormatter)
    case custom((_ decoder: Decoder) throws -> Date)
  }
  public enum DataDecodingStrategy {
    case deferredToData
    case base64
    case custom((_ decoder: Decoder) throws -> Data)
  }
  public enum NonConformingFloatDecodingStrategy {
    case `throw`
    case convertFromString(positiveInfinity: String, negativeInfinity: String, nan: String)
  }
  public enum KeyDecodingStrategy {
    case useDefaultKeys
    case convertFromSnakeCase
    case custom((_ codingPath: [CodingKey]) -> CodingKey)
  }
  open var dateDecodingStrategy: DateDecodingStrategy
  open var dataDecodingStrategy: DataDecodingStrategy
  open var nonConformingFloatDecodingStrategy: NonConformingFloatDecodingStrategy
  open var keyDecodingStrategy: KeyDecodingStrategy
  open var userInfo: [CodingUserInfoKey : Any]
  public init()
  open func decode<T>(_ type: T.Type, from data: Data) throws -> T where T : Swift.Decodable
  @objc deinit
}
public struct Locale : Hashable, Equatable, ReferenceConvertible {
  public typealias ReferenceType = NSLocale
  public typealias LanguageDirection = NSLocale.LanguageDirection
  public static var autoupdatingCurrent: Locale {
    get
  }
  public static var current: Locale {
    get
  }
  @available(*, unavailable, message: "Consider using the user's locale or nil instead, depending on use case")
  public static var system: Locale {
    get
  }
  public init(identifier: String)
  public func localizedString(forIdentifier identifier: String) -> String?
  public func localizedString(forLanguageCode languageCode: String) -> String?
  public func localizedString(forRegionCode regionCode: String) -> String?
  public func localizedString(forScriptCode scriptCode: String) -> String?
  public func localizedString(forVariantCode variantCode: String) -> String?
  public func localizedString(for calendarIdentifier: Calendar.Identifier) -> String?
  public func localizedString(forCurrencyCode currencyCode: String) -> String?
  public func localizedString(forCollationIdentifier collationIdentifier: String) -> String?
  public func localizedString(forCollatorIdentifier collatorIdentifier: String) -> String?
  public var identifier: String {
    get
  }
  public var languageCode: String? {
    get
  }
  public var regionCode: String? {
    get
  }
  public var scriptCode: String? {
    get
  }
  public var variantCode: String? {
    get
  }
  public var exemplarCharacterSet: CharacterSet? {
    get
  }
  public var calendar: Calendar {
    get
  }
  public var collationIdentifier: String? {
    get
  }
  public var usesMetricSystem: Bool {
    get
  }
  public var decimalSeparator: String? {
    get
  }
  public var groupingSeparator: String? {
    get
  }
  public var currencySymbol: String? {
    get
  }
  public var currencyCode: String? {
    get
  }
  public var collatorIdentifier: String? {
    get
  }
  public var quotationBeginDelimiter: String? {
    get
  }
  public var quotationEndDelimiter: String? {
    get
  }
  public var alternateQuotationBeginDelimiter: String? {
    get
  }
  public var alternateQuotationEndDelimiter: String? {
    get
  }
  public static var availableIdentifiers: [String] {
    get
  }
  public static var isoLanguageCodes: [String] {
    get
  }
  public static var isoRegionCodes: [String] {
    get
  }
  public static var isoCurrencyCodes: [String] {
    get
  }
  public static var commonISOCurrencyCodes: [String] {
    get
  }
  public static var preferredLanguages: [String] {
    get
  }
  public static func components(fromIdentifier string: String) -> [String : String]
  public static func identifier(fromComponents components: [String : String]) -> String
  public static func canonicalIdentifier(from string: String) -> String
  public static func canonicalLanguageIdentifier(from string: String) -> String
  public static func identifier(fromWindowsLocaleCode code: Int) -> String?
  public static func windowsLocaleCode(fromIdentifier identifier: String) -> Int?
  public static func characterDirection(forLanguage isoLangCode: String) -> Locale.LanguageDirection
  public static func lineDirection(forLanguage isoLangCode: String) -> Locale.LanguageDirection
  @available(*, unavailable, renamed: "init(identifier:)")
  public init(localeIdentifier: String)
  @available(*, unavailable, renamed: "identifier")
  public var localeIdentifier: String {
    get
  }
  @available(*, unavailable, renamed: "localizedString(forIdentifier:)")
  public func localizedString(forLocaleIdentifier localeIdentifier: String) -> String
  @available(*, unavailable, renamed: "availableIdentifiers")
  public static var availableLocaleIdentifiers: [String] {
    get
  }
  @available(*, unavailable, renamed: "components(fromIdentifier:)")
  public static func components(fromLocaleIdentifier string: String) -> [String : String]
  @available(*, unavailable, renamed: "identifier(fromComponents:)")
  public static func localeIdentifier(fromComponents dict: [String : String]) -> String
  @available(*, unavailable, renamed: "canonicalIdentifier(from:)")
  public static func canonicalLocaleIdentifier(from string: String) -> String
  @available(*, unavailable, renamed: "identifier(fromWindowsLocaleCode:)")
  public static func localeIdentifier(fromWindowsLocaleCode lcid: UInt32) -> String?
  @available(*, unavailable, renamed: "windowsLocaleCode(fromIdentifier:)")
  public static func windowsLocaleCode(fromLocaleIdentifier localeIdentifier: String) -> UInt32
  @available(*, unavailable, message: "use regionCode instead")
  public var countryCode: String {
    get
  }
  @available(*, unavailable, message: "use localizedString(forRegionCode:) instead")
  public func localizedString(forCountryCode countryCode: String) -> String
  @available(*, unavailable, renamed: "isoRegionCodes")
  public static var isoCountryCodes: [String] {
    get
  }
  public func hash(into hasher: inout Hasher)
  public static func == (lhs: Locale, rhs: Locale) -> Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Locale : CustomDebugStringConvertible, CustomStringConvertible, CustomReflectable {
  public var customMirror: Mirror {
    get
  }
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
}
extension Locale : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSLocale
  public static func _forceBridgeFromObjectiveC(_ input: NSLocale, result: inout Locale?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: NSLocale, result: inout Locale?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSLocale?) -> Locale
  public typealias _ObjectiveCType = Foundation.NSLocale
}
extension NSLocale : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension Locale : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
@available(OSX 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
public struct Measurement<UnitType> : ReferenceConvertible, Comparable, Equatable where UnitType : Foundation.Unit {
  public typealias ReferenceType = NSMeasurement
  public let unit: UnitType
  public var value: Double
  public init(value: Double, unit: UnitType)
  public func hash(into hasher: inout Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(OSX 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
  public var customMirror: Mirror {
    get
  }
}
@available(OSX 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement where UnitType : Foundation.Dimension {
  public func converted(to otherUnit: UnitType) -> Measurement<UnitType>
  mutating public func convert(to otherUnit: UnitType)
  public static func + (lhs: Measurement<UnitType>, rhs: Measurement<UnitType>) -> Measurement<UnitType>
  public static func - (lhs: Measurement<UnitType>, rhs: Measurement<UnitType>) -> Measurement<UnitType>
}
@available(OSX 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement {
  public static func + (lhs: Measurement<UnitType>, rhs: Measurement<UnitType>) -> Measurement<UnitType>
  public static func - (lhs: Measurement<UnitType>, rhs: Measurement<UnitType>) -> Measurement<UnitType>
  public static func * (lhs: Measurement<UnitType>, rhs: Double) -> Measurement<UnitType>
  public static func * (lhs: Double, rhs: Measurement<UnitType>) -> Measurement<UnitType>
  public static func / (lhs: Measurement<UnitType>, rhs: Double) -> Measurement<UnitType>
  public static func / (lhs: Double, rhs: Measurement<UnitType>) -> Measurement<UnitType>
  public static func == <LeftHandSideType, RightHandSideType>(lhs: Measurement<LeftHandSideType>, rhs: Measurement<RightHandSideType>) -> Bool where LeftHandSideType : Foundation.Unit, RightHandSideType : Foundation.Unit
  public static func < <LeftHandSideType, RightHandSideType>(lhs: Measurement<LeftHandSideType>, rhs: Measurement<RightHandSideType>) -> Bool where LeftHandSideType : Foundation.Unit, RightHandSideType : Foundation.Unit
}
@usableFromInline
internal typealias MeasurementBridgeType = _ObjectiveCBridgeable
@available(OSX 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement : MeasurementBridgeType {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSMeasurement
  public static func _forceBridgeFromObjectiveC(_ source: NSMeasurement, result: inout Measurement?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: NSMeasurement, result: inout Measurement?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSMeasurement?) -> Measurement
  public typealias _ObjectiveCType = Foundation.NSMeasurement
}
@available(OSX 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension NSMeasurement : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
@available(OSX 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension MeasurementFormatter {
  public func string<UnitType>(from measurement: Measurement<UnitType>) -> String where UnitType : Foundation.Unit
}
@available(OSX 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
public struct Notification : ReferenceConvertible, Equatable, Hashable {
  public typealias ReferenceType = NSNotification
  public var name: Name
  public var object: Any?
  public var userInfo: [AnyHashable : Any]?
  public init(name: Name, object: Any? = nil, userInfo: [AnyHashable : Any]? = nil)
  public func hash(into hasher: inout Hasher)
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
  public typealias Name = NSNotification.Name
  public static func == (lhs: Notification, rhs: Notification) -> Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Notification : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Notification : _ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSNotification
  public static func _forceBridgeFromObjectiveC(_ x: NSNotification, result: inout Notification?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSNotification, result: inout Notification?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSNotification?) -> Notification
  public typealias _ObjectiveCType = Foundation.NSNotification
}
extension NSNotification : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension NSArray : ExpressibleByArrayLiteral {
  required convenience public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension Array : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSArray
  public static func _forceBridgeFromObjectiveC(_ source: NSArray, result: inout Array?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: NSArray, result: inout Array?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSArray?) -> Array
  public typealias _ObjectiveCType = Foundation.NSArray
}
extension NSArray : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension NSArray : Sequence {
  final public func makeIterator() -> NSFastEnumerationIterator
  public typealias Element = Any
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
extension NSArray {
  convenience public init(objects elements: Any...)
}
extension NSArray {
  @nonobjc convenience public init(array anArray: __shared NSArray)
}
extension NSArray : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Array : CVarArg {
}
extension NSCoder {
  @available(*, unavailable, renamed: "decodeObject(of:forKey:)")
  public func decodeObjectOfClass<DecodedObjectType>(_ cls: DecodedObjectType.Type, forKey key: String) -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  public func decodeObject<DecodedObjectType>(of cls: DecodedObjectType.Type, forKey key: String) -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @available(*, unavailable, renamed: "decodeObject(of:forKey:)")
  @nonobjc public func decodeObjectOfClasses(_ classes: NSSet?, forKey key: String) -> AnyObject?
  @nonobjc public func decodeObject(of classes: [AnyClass]?, forKey key: String) -> Any?
  @available(OSX 10.11, iOS 9.0, *)
  @nonobjc public func decodeTopLevelObject() throws -> Any?
  @available(*, unavailable, renamed: "decodeTopLevelObject(forKey:)")
  public func decodeTopLevelObjectForKey(_ key: String) throws -> AnyObject?
  @available(OSX 10.11, iOS 9.0, *)
  @available(swift, obsoleted: 4)
  @nonobjc public func decodeTopLevelObject(forKey key: String) throws -> AnyObject?
  @available(swift 4)
  @available(OSX 10.11, iOS 9.0, *)
  @nonobjc public func decodeTopLevelObject(forKey key: String) throws -> Any?
  @available(*, unavailable, renamed: "decodeTopLevelObject(of:forKey:)")
  public func decodeTopLevelObjectOfClass<DecodedObjectType>(_ cls: DecodedObjectType.Type, forKey key: String) throws -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @available(OSX 10.11, iOS 9.0, *)
  public func decodeTopLevelObject<DecodedObjectType>(of cls: DecodedObjectType.Type, forKey key: String) throws -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @available(*, unavailable, renamed: "decodeTopLevelObject(of:forKey:)")
  @nonobjc public func decodeTopLevelObjectOfClasses(_ classes: NSSet?, forKey key: String) throws -> AnyObject?
  @available(OSX 10.11, iOS 9.0, *)
  @nonobjc public func decodeTopLevelObject(of classes: [AnyClass]?, forKey key: String) throws -> Any?
}
extension NSKeyedArchiver {
  @available(OSX 10.11, iOS 9.0, *)
  @nonobjc public func encodeEncodable<T>(_ value: T, forKey key: String) throws where T : Swift.Encodable
}
extension NSKeyedUnarchiver {
  @available(OSX 10.11, iOS 9.0, *)
  @available(swift, obsoleted: 4)
  @nonobjc public class func unarchiveTopLevelObjectWithData(_ data: NSData) throws -> AnyObject?
  @available(swift 4)
  @available(OSX 10.11, iOS 9.0, *)
  @nonobjc public class func unarchiveTopLevelObjectWithData(_ data: Data) throws -> Any?
  @available(OSX 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  @nonobjc public static func unarchivedObject<DecodedObjectType>(ofClass cls: DecodedObjectType.Type, from data: Data) throws -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @available(OSX 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  @nonobjc public static func unarchivedObject(ofClasses classes: [AnyClass], from data: Data) throws -> Any?
  @available(OSX 10.11, iOS 9.0, *)
  @nonobjc public func decodeDecodable<T>(_ type: T.Type, forKey key: String) -> T? where T : Swift.Decodable
  @available(OSX 10.11, iOS 9.0, *)
  @nonobjc public func decodeTopLevelDecodable<T>(_ type: T.Type, forKey key: String) throws -> T? where T : Swift.Decodable
}
extension NSDate : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSDate.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: PlaygroundQuickLook {
    get
  }
}
extension NSDictionary : ExpressibleByDictionaryLiteral {
  required convenience public init(dictionaryLiteral elements: (Any, Any)...)
  public typealias Key = Any
  public typealias Value = Any
}
extension Dictionary : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSDictionary
  @_specialize(exported: false, kind: full, where Key == Swift.String, Value == Any)
  public static func _forceBridgeFromObjectiveC(_ d: NSDictionary, result: inout Dictionary?)
  @_specialize(exported: false, kind: full, where Key == Swift.String, Value == Any)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSDictionary, result: inout Dictionary?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ d: NSDictionary?) -> Dictionary
  public typealias _ObjectiveCType = Foundation.NSDictionary
}
extension NSDictionary : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension NSDictionary : Sequence {
  @_objcRuntimeName(_TtCE10FoundationCSo12NSDictionary9_Iterator) final public class Iterator : IteratorProtocol {
    final public func next() -> (key: Any, value: Any)?
    public typealias Element = (key: Any, value: Any)
    @objc deinit
  }
  @objc dynamic public subscript(key: Any) -> Any? {
    @objc(__swift_objectForKeyedSubscript:) get
  }
  public func makeIterator() -> Iterator
  public typealias Element = (key: Any, value: Any)
}
extension NSMutableDictionary {
  @objc override dynamic public subscript(key: Any) -> Any? {
    @objc(__swift_objectForKeyedSubscript:) get
    @objc(__swift_setObject:forKeyedSubscript:) set
  }
}
extension NSDictionary {
  @objc(__swiftInitWithDictionary_NSDictionary:) convenience dynamic public init(dictionary otherDictionary: __shared NSDictionary)
}
extension NSDictionary : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Dictionary : CVarArg {
}
public typealias NSErrorPointer = AutoreleasingUnsafeMutablePointer<NSError?>?
public typealias ErrorPointer = NSErrorPointer
public func _convertNSErrorToError(_ error: NSError?) -> Error
public func _convertErrorToNSError(_ error: Error) -> NSError
public protocol LocalizedError : Swift.Error {
  var errorDescription: String? { get }
  var failureReason: String? { get }
  var recoverySuggestion: String? { get }
  var helpAnchor: String? { get }
}
extension LocalizedError {
  public var errorDescription: String? {
    get
  }
  public var failureReason: String? {
    get
  }
  public var recoverySuggestion: String? {
    get
  }
  public var helpAnchor: String? {
    get
  }
}
public protocol RecoverableError : Swift.Error {
  var recoveryOptions: [String] { get }
  func attemptRecovery(optionIndex recoveryOptionIndex: Int, resultHandler handler: @escaping (_ recovered: Bool) -> Void)
  func attemptRecovery(optionIndex recoveryOptionIndex: Int) -> Bool
}
extension RecoverableError {
  public func attemptRecovery(optionIndex recoveryOptionIndex: Int, resultHandler handler: @escaping (_ recovered: Bool) -> Void)
}
public protocol CustomNSError : Swift.Error {
  static var errorDomain: String { get }
  var errorCode: Int { get }
  var errorUserInfo: [String : Any] { get }
}
extension CustomNSError {
  public static var errorDomain: String {
    get
  }
  public var errorCode: Int {
    get
  }
  public var errorUserInfo: [String : Any] {
    get
  }
}
extension CustomNSError where Self : Swift.RawRepresentable, Self.RawValue : Swift.FixedWidthInteger {
  public var errorCode: Int {
    get
  }
}
extension Error where Self : Foundation.CustomNSError {
  public var _domain: String {
    get
  }
  public var _code: Int {
    get
  }
}
extension Error where Self : Foundation.CustomNSError, Self : Swift.RawRepresentable, Self.RawValue : Swift.FixedWidthInteger {
  public var _code: Int {
    get
  }
}
extension Error {
  public var localizedDescription: String {
    get
  }
}
public func _getErrorDefaultUserInfo<T>(_ error: T) -> AnyObject? where T : Swift.Error
extension NSError : Error {
  @nonobjc public var _domain: String {
    get
  }
  @nonobjc public var _code: Int {
    get
  }
  @nonobjc public var _userInfo: AnyObject? {
    get
  }
  @nonobjc public func _getEmbeddedNSError() -> AnyObject?
}
extension CFError : Error {
  public var _domain: String {
    get
  }
  public var _code: Int {
    get
  }
  public var _userInfo: AnyObject? {
    get
  }
  public func _getEmbeddedNSError() -> AnyObject?
}
public protocol _ObjectiveCBridgeableError : Swift.Error {
  init?(_bridgedNSError: __shared NSError)
}
public func _bridgeNSErrorToError<T>(_ error: NSError, out: UnsafeMutablePointer<T>) -> Bool where T : Foundation._ObjectiveCBridgeableError
public protocol _BridgedNSError : Foundation._ObjectiveCBridgeableError, Swift.Hashable, Swift.RawRepresentable where Self.RawValue : Swift.FixedWidthInteger {
  static var _nsErrorDomain: String { get }
}
extension _BridgedNSError {
  public var _domain: String {
    get
  }
}
extension _BridgedNSError {
  public var _code: Int {
    get
  }
  public init?(_bridgedNSError: __shared NSError)
  public func hash(into hasher: inout Hasher)
}
public protocol _BridgedStoredNSError : Foundation.CustomNSError, Foundation._ObjectiveCBridgeableError, Swift.Hashable {
  associatedtype Code : Foundation._ErrorCodeProtocol, Swift.RawRepresentable where Self.Code.RawValue : Swift.FixedWidthInteger, Self.Code.RawValue.Magnitude == Self.Code.RawValue.Magnitude.Magnitude, Self.Code.RawValue.Stride.Magnitude == Self.Code.RawValue.Stride.Magnitude.Magnitude, Self.Code.RawValue.Words.Indices == Self.Code.RawValue.Words.Indices.SubSequence, Self.Code.RawValue.Words.SubSequence == Self.Code.RawValue.Words.SubSequence.SubSequence, Self.Code.RawValue.Magnitude.Stride.Magnitude == Self.Code.RawValue.Magnitude.Stride.Magnitude.Magnitude, Self.Code.RawValue.Magnitude.Words.Indices == Self.Code.RawValue.Magnitude.Words.Indices.SubSequence, Self.Code.RawValue.Magnitude.Words.SubSequence == Self.Code.RawValue.Magnitude.Words.SubSequence.SubSequence, Self.Code.RawValue.Stride.Stride.Magnitude == Self.Code.RawValue.Stride.Stride.Magnitude.Magnitude, Self.Code.RawValue.Stride.Words.Indices == Self.Code.RawValue.Stride.Words.Indices.SubSequence, Self.Code.RawValue.Stride.Words.SubSequence == Self.Code.RawValue.Stride.Words.SubSequence.SubSequence, Self.Code.RawValue.Words.Indices.Indices == Self.Code.RawValue.Words.Indices.Indices.SubSequence, Self.Code.RawValue.Words.SubSequence.Indices == Self.Code.RawValue.Words.SubSequence.Indices.SubSequence, Self.Code.RawValue.Magnitude.Stride.Stride.Magnitude == Self.Code.RawValue.Magnitude.Stride.Stride.Magnitude.Magnitude, Self.Code.RawValue.Magnitude.Stride.Words.Indices == Self.Code.RawValue.Magnitude.Stride.Words.Indices.SubSequence, Self.Code.RawValue.Magnitude.Stride.Words.SubSequence == Self.Code.RawValue.Magnitude.Stride.Words.SubSequence.SubSequence, Self.Code.RawValue.Magnitude.Words.Indices.Indices == Self.Code.RawValue.Magnitude.Words.Indices.Indices.SubSequence, Self.Code.RawValue.Magnitude.Words.SubSequence.Indices == Self.Code.RawValue.Magnitude.Words.SubSequence.Indices.SubSequence, Self.Code.RawValue.Stride.Magnitude.Stride.Magnitude == Self.Code.RawValue.Stride.Magnitude.Stride.Magnitude.Magnitude, Self.Code.RawValue.Stride.Magnitude.Words.Indices == Self.Code.RawValue.Stride.Magnitude.Words.Indices.SubSequence, Self.Code.RawValue.Stride.Magnitude.Words.SubSequence == Self.Code.RawValue.Stride.Magnitude.Words.SubSequence.SubSequence, Self.Code.RawValue.Stride.Words.Indices.Indices == Self.Code.RawValue.Stride.Words.Indices.Indices.SubSequence, Self.Code.RawValue.Stride.Words.SubSequence.Indices == Self.Code.RawValue.Stride.Words.SubSequence.Indices.SubSequence, Self.Code.RawValue.Words.SubSequence.Indices.Indices == Self.Code.RawValue.Words.SubSequence.Indices.Indices.SubSequence, Self.Code.RawValue.Magnitude.Stride.Magnitude.Stride.Magnitude == Self.Code.RawValue.Magnitude.Stride.Magnitude.Stride.Magnitude.Magnitude, Self.Code.RawValue.Magnitude.Stride.Magnitude.Words.Indices == Self.Code.RawValue.Magnitude.Stride.Magnitude.Words.Indices.SubSequence, Self.Code.RawValue.Magnitude.Stride.Magnitude.Words.SubSequence == Self.Code.RawValue.Magnitude.Stride.Magnitude.Words.SubSequence.SubSequence, Self.Code.RawValue.Magnitude.Stride.Words.Indices.Indices == Self.Code.RawValue.Magnitude.Stride.Words.Indices.Indices.SubSequence, Self.Code.RawValue.Magnitude.Stride.Words.SubSequence.Indices == Self.Code.RawValue.Magnitude.Stride.Words.SubSequence.Indices.SubSequence, Self.Code.RawValue.Magnitude.Words.SubSequence.Indices.Indices == Self.Code.RawValue.Magnitude.Words.SubSequence.Indices.Indices.SubSequence, Self.Code.RawValue.Stride.Magnitude.Words.Indices.Indices == Self.Code.RawValue.Stride.Magnitude.Words.Indices.Indices.SubSequence, Self.Code.RawValue.Stride.Magnitude.Words.SubSequence.Indices == Self.Code.RawValue.Stride.Magnitude.Words.SubSequence.Indices.SubSequence, Self.Code.RawValue.Stride.Words.SubSequence.Indices.Indices == Self.Code.RawValue.Stride.Words.SubSequence.Indices.Indices.SubSequence, Self.Code.RawValue.Magnitude.Stride.Magnitude.Words.Indices.Indices == Self.Code.RawValue.Magnitude.Stride.Magnitude.Words.Indices.Indices.SubSequence, Self.Code.RawValue.Magnitude.Stride.Magnitude.Words.SubSequence.Indices == Self.Code.RawValue.Magnitude.Stride.Magnitude.Words.SubSequence.Indices.SubSequence, Self.Code.RawValue.Magnitude.Stride.Words.SubSequence.Indices.Indices == Self.Code.RawValue.Magnitude.Stride.Words.SubSequence.Indices.Indices.SubSequence, Self.Code.RawValue.Stride.Magnitude.Words.SubSequence.Indices.Indices == Self.Code.RawValue.Stride.Magnitude.Words.SubSequence.Indices.Indices.SubSequence, Self.Code.RawValue.Magnitude.Stride.Magnitude.Words.SubSequence.Indices.Indices == Self.Code.RawValue.Magnitude.Stride.Magnitude.Words.SubSequence.Indices.Indices.SubSequence
  var _nsError: NSError { get }
  init(_nsError error: NSError)
}
extension _BridgedStoredNSError {
  public var code: Code {
    get
  }
  public init(_ code: Code, userInfo: [String : Any] = [:])
  public var userInfo: [String : Any] {
    get
  }
}
extension _BridgedStoredNSError {
  public init?(_bridgedNSError error: NSError)
}
extension _BridgedStoredNSError {
  public var errorCode: Int {
    get
  }
  public var errorUserInfo: [String : Any] {
    get
  }
}
extension _BridgedStoredNSError {
  public func hash(into hasher: inout Hasher)
}
public protocol _ErrorCodeProtocol : Swift.Equatable {
  associatedtype _ErrorType : Foundation._BridgedStoredNSError where Self == Self._ErrorType.Code
}
extension _ErrorCodeProtocol {
  public static func ~= (match: Self, error: Error) -> Bool
}
extension _BridgedStoredNSError {
  public func _getEmbeddedNSError() -> AnyObject?
  public static func == (lhs: Self, rhs: Self) -> Bool
}
extension _SwiftNewtypeWrapper where Self.RawValue == Swift.Error {
  @inlinable public func _bridgeToObjectiveC() -> NSError {
    return rawValue as NSError
  }
  @inlinable public static func _forceBridgeFromObjectiveC(_ source: NSError, result: inout Self?) {
    result = Self(rawValue: source)
  }
  @inlinable public static func _conditionallyBridgeFromObjectiveC(_ source: NSError, result: inout Self?) -> Bool {
    result = Self(rawValue: source)
    return result != nil
  }
  @inlinable @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSError?) -> Self {
    return Self(rawValue: _convertNSErrorToError(source))!
  }
}
@available(*, unavailable, renamed: "CocoaError")
public typealias NSCocoaError = CocoaError
public struct CocoaError : _BridgedStoredNSError {
  public let _nsError: NSError
  public init(_nsError error: NSError)
  public static var errorDomain: String {
    get
  }
  public struct Code : RawRepresentable, Hashable, _ErrorCodeProtocol {
    public typealias _ErrorType = CocoaError
    public let rawValue: Int
    public init(rawValue: Int)
    public typealias RawValue = Swift.Int
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension CocoaError {
  public var filePath: String? {
    get
  }
  public var stringEncoding: String.Encoding? {
    get
  }
  public var underlying: Error? {
    get
  }
  public var url: URL? {
    get
  }
}
extension CocoaError {
  public static func error(_ code: CocoaError.Code, userInfo: [AnyHashable : Any]? = nil, url: URL? = nil) -> Error
}
extension CocoaError.Code {
  public static var fileNoSuchFile: CocoaError.Code {
    get
  }
  public static var fileLocking: CocoaError.Code {
    get
  }
  public static var fileReadUnknown: CocoaError.Code {
    get
  }
  public static var fileReadNoPermission: CocoaError.Code {
    get
  }
  public static var fileReadInvalidFileName: CocoaError.Code {
    get
  }
  public static var fileReadCorruptFile: CocoaError.Code {
    get
  }
  public static var fileReadNoSuchFile: CocoaError.Code {
    get
  }
  public static var fileReadInapplicableStringEncoding: CocoaError.Code {
    get
  }
  public static var fileReadUnsupportedScheme: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public static var fileReadTooLarge: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public static var fileReadUnknownStringEncoding: CocoaError.Code {
    get
  }
  public static var fileWriteUnknown: CocoaError.Code {
    get
  }
  public static var fileWriteNoPermission: CocoaError.Code {
    get
  }
  public static var fileWriteInvalidFileName: CocoaError.Code {
    get
  }
  @available(OSX 10.7, iOS 5.0, *)
  public static var fileWriteFileExists: CocoaError.Code {
    get
  }
  public static var fileWriteInapplicableStringEncoding: CocoaError.Code {
    get
  }
  public static var fileWriteUnsupportedScheme: CocoaError.Code {
    get
  }
  public static var fileWriteOutOfSpace: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  public static var fileWriteVolumeReadOnly: CocoaError.Code {
    get
  }
  @available(OSX 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountUnknown: CocoaError.Code {
    get
  }
  @available(OSX 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountBusy: CocoaError.Code {
    get
  }
  public static var keyValueValidation: CocoaError.Code {
    get
  }
  public static var formatting: CocoaError.Code {
    get
  }
  public static var userCancelled: CocoaError.Code {
    get
  }
  @available(OSX 10.8, iOS 6.0, *)
  public static var featureUnsupported: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public static var executableNotLoadable: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public static var executableArchitectureMismatch: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public static var executableRuntimeMismatch: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public static var executableLoad: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public static var executableLink: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  public static var propertyListReadCorrupt: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  public static var propertyListReadUnknownVersion: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  public static var propertyListReadStream: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  public static var propertyListWriteStream: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public static var propertyListWriteInvalid: CocoaError.Code {
    get
  }
  @available(OSX 10.8, iOS 6.0, *)
  public static var xpcConnectionInterrupted: CocoaError.Code {
    get
  }
  @available(OSX 10.8, iOS 6.0, *)
  public static var xpcConnectionInvalid: CocoaError.Code {
    get
  }
  @available(OSX 10.8, iOS 6.0, *)
  public static var xpcConnectionReplyInvalid: CocoaError.Code {
    get
  }
  @available(OSX 10.9, iOS 7.0, *)
  public static var ubiquitousFileUnavailable: CocoaError.Code {
    get
  }
  @available(OSX 10.9, iOS 7.0, *)
  public static var ubiquitousFileNotUploadedDueToQuota: CocoaError.Code {
    get
  }
  @available(OSX 10.9, iOS 7.0, *)
  public static var ubiquitousFileUbiquityServerNotAvailable: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public static var userActivityHandoffFailed: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public static var userActivityConnectionUnavailable: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public static var userActivityRemoteApplicationTimedOut: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public static var userActivityHandoffUserInfoTooLarge: CocoaError.Code {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  public static var coderReadCorrupt: CocoaError.Code {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  public static var coderValueNotFound: CocoaError.Code {
    get
  }
  public static var coderInvalidValue: CocoaError.Code {
    get
  }
}
extension CocoaError.Code {
  @available(*, deprecated, renamed: "fileNoSuchFile")
  public static var fileNoSuchFileError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileLocking")
  public static var fileLockingError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnknown")
  public static var fileReadUnknownError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoPermission")
  public static var fileReadNoPermissionError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInvalidFileName")
  public static var fileReadInvalidFileNameError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadCorruptFile")
  public static var fileReadCorruptFileError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoSuchFile")
  public static var fileReadNoSuchFileError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInapplicableStringEncoding")
  public static var fileReadInapplicableStringEncodingError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnsupportedScheme")
  public static var fileReadUnsupportedSchemeError: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadTooLarge")
  public static var fileReadTooLargeError: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadUnknownStringEncoding")
  public static var fileReadUnknownStringEncodingError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnknown")
  public static var fileWriteUnknownError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteNoPermission")
  public static var fileWriteNoPermissionError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInvalidFileName")
  public static var fileWriteInvalidFileNameError: CocoaError.Code {
    get
  }
  @available(OSX 10.7, iOS 5.0, *)
  @available(*, deprecated, renamed: "fileWriteFileExists")
  public static var fileWriteFileExistsError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInapplicableStringEncoding")
  public static var fileWriteInapplicableStringEncodingError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnsupportedScheme")
  public static var fileWriteUnsupportedSchemeError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteOutOfSpace")
  public static var fileWriteOutOfSpaceError: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "fileWriteVolumeReadOnly")
  public static var fileWriteVolumeReadOnlyError: CocoaError.Code {
    get
  }
  @available(OSX 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountUnknown")
  public static var fileManagerUnmountUnknownError: CocoaError.Code {
    get
  }
  @available(OSX 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountBusy")
  public static var fileManagerUnmountBusyError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "keyValueValidation")
  public static var keyValueValidationError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "formatting")
  public static var formattingError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "userCancelled")
  public static var userCancelledError: CocoaError.Code {
    get
  }
  @available(OSX 10.8, iOS 6.0, *)
  @available(*, deprecated, renamed: "featureUnsupported")
  public static var featureUnsupportedError: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableNotLoadable")
  public static var executableNotLoadableError: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableArchitectureMismatch")
  public static var executableArchitectureMismatchError: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableRuntimeMismatch")
  public static var executableRuntimeMismatchError: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLoad")
  public static var executableLoadError: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLink")
  public static var executableLinkError: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadCorrupt")
  public static var propertyListReadCorruptError: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadUnknownVersion")
  public static var propertyListReadUnknownVersionError: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadStream")
  public static var propertyListReadStreamError: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListWriteStream")
  public static var propertyListWriteStreamError: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListWriteInvalid")
  public static var propertyListWriteInvalidError: CocoaError.Code {
    get
  }
  @available(OSX 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileUnavailable")
  public static var ubiquitousFileUnavailableError: CocoaError.Code {
    get
  }
  @available(OSX 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileNotUploadedDueToQuota")
  public static var ubiquitousFileNotUploadedDueToQuotaError: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffFailed")
  public static var userActivityHandoffFailedError: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityConnectionUnavailable")
  public static var userActivityConnectionUnavailableError: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityRemoteApplicationTimedOut")
  public static var userActivityRemoteApplicationTimedOutError: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffUserInfoTooLarge")
  public static var userActivityHandoffUserInfoTooLargeError: CocoaError.Code {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderReadCorrupt")
  public static var coderReadCorruptError: CocoaError.Code {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderValueNotFound")
  public static var coderValueNotFoundError: CocoaError.Code {
    get
  }
}
extension CocoaError {
  public static var fileNoSuchFile: CocoaError.Code {
    get
  }
  public static var fileLocking: CocoaError.Code {
    get
  }
  public static var fileReadUnknown: CocoaError.Code {
    get
  }
  public static var fileReadNoPermission: CocoaError.Code {
    get
  }
  public static var fileReadInvalidFileName: CocoaError.Code {
    get
  }
  public static var fileReadCorruptFile: CocoaError.Code {
    get
  }
  public static var fileReadNoSuchFile: CocoaError.Code {
    get
  }
  public static var fileReadInapplicableStringEncoding: CocoaError.Code {
    get
  }
  public static var fileReadUnsupportedScheme: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public static var fileReadTooLarge: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public static var fileReadUnknownStringEncoding: CocoaError.Code {
    get
  }
  public static var fileWriteUnknown: CocoaError.Code {
    get
  }
  public static var fileWriteNoPermission: CocoaError.Code {
    get
  }
  public static var fileWriteInvalidFileName: CocoaError.Code {
    get
  }
  @available(OSX 10.7, iOS 5.0, *)
  public static var fileWriteFileExists: CocoaError.Code {
    get
  }
  public static var fileWriteInapplicableStringEncoding: CocoaError.Code {
    get
  }
  public static var fileWriteUnsupportedScheme: CocoaError.Code {
    get
  }
  public static var fileWriteOutOfSpace: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  public static var fileWriteVolumeReadOnly: CocoaError.Code {
    get
  }
  @available(OSX 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountUnknown: CocoaError.Code {
    get
  }
  @available(OSX 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountBusy: CocoaError.Code {
    get
  }
  public static var keyValueValidation: CocoaError.Code {
    get
  }
  public static var formatting: CocoaError.Code {
    get
  }
  public static var userCancelled: CocoaError.Code {
    get
  }
  @available(OSX 10.8, iOS 6.0, *)
  public static var featureUnsupported: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public static var executableNotLoadable: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public static var executableArchitectureMismatch: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public static var executableRuntimeMismatch: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public static var executableLoad: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public static var executableLink: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  public static var propertyListReadCorrupt: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  public static var propertyListReadUnknownVersion: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  public static var propertyListReadStream: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  public static var propertyListWriteStream: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public static var propertyListWriteInvalid: CocoaError.Code {
    get
  }
  @available(OSX 10.8, iOS 6.0, *)
  public static var xpcConnectionInterrupted: CocoaError.Code {
    get
  }
  @available(OSX 10.8, iOS 6.0, *)
  public static var xpcConnectionInvalid: CocoaError.Code {
    get
  }
  @available(OSX 10.8, iOS 6.0, *)
  public static var xpcConnectionReplyInvalid: CocoaError.Code {
    get
  }
  @available(OSX 10.9, iOS 7.0, *)
  public static var ubiquitousFileUnavailable: CocoaError.Code {
    get
  }
  @available(OSX 10.9, iOS 7.0, *)
  public static var ubiquitousFileNotUploadedDueToQuota: CocoaError.Code {
    get
  }
  @available(OSX 10.9, iOS 7.0, *)
  public static var ubiquitousFileUbiquityServerNotAvailable: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public static var userActivityHandoffFailed: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public static var userActivityConnectionUnavailable: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public static var userActivityRemoteApplicationTimedOut: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public static var userActivityHandoffUserInfoTooLarge: CocoaError.Code {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  public static var coderReadCorrupt: CocoaError.Code {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  public static var coderValueNotFound: CocoaError.Code {
    get
  }
  public static var coderInvalidValue: CocoaError.Code {
    get
  }
}
extension CocoaError {
  @available(*, deprecated, renamed: "fileNoSuchFile")
  public static var fileNoSuchFileError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileLocking")
  public static var fileLockingError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnknown")
  public static var fileReadUnknownError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoPermission")
  public static var fileReadNoPermissionError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInvalidFileName")
  public static var fileReadInvalidFileNameError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadCorruptFile")
  public static var fileReadCorruptFileError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoSuchFile")
  public static var fileReadNoSuchFileError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInapplicableStringEncoding")
  public static var fileReadInapplicableStringEncodingError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnsupportedScheme")
  public static var fileReadUnsupportedSchemeError: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadTooLarge")
  public static var fileReadTooLargeError: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "fileReadUnknownStringEncoding")
  public static var fileReadUnknownStringEncodingError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnknown")
  public static var fileWriteUnknownError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteNoPermission")
  public static var fileWriteNoPermissionError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInvalidFileName")
  public static var fileWriteInvalidFileNameError: CocoaError.Code {
    get
  }
  @available(OSX 10.7, iOS 5.0, *)
  @available(*, deprecated, renamed: "fileWriteFileExists")
  public static var fileWriteFileExistsError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInapplicableStringEncoding")
  public static var fileWriteInapplicableStringEncodingError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnsupportedScheme")
  public static var fileWriteUnsupportedSchemeError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteOutOfSpace")
  public static var fileWriteOutOfSpaceError: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "fileWriteVolumeReadOnly")
  public static var fileWriteVolumeReadOnlyError: CocoaError.Code {
    get
  }
  @available(OSX 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountUnknown")
  public static var fileManagerUnmountUnknownError: CocoaError.Code {
    get
  }
  @available(OSX 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountBusy")
  public static var fileManagerUnmountBusyError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "keyValueValidation")
  public static var keyValueValidationError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "formatting")
  public static var formattingError: CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "userCancelled")
  public static var userCancelledError: CocoaError.Code {
    get
  }
  @available(OSX 10.8, iOS 6.0, *)
  @available(*, deprecated, renamed: "featureUnsupported")
  public static var featureUnsupportedError: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableNotLoadable")
  public static var executableNotLoadableError: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableArchitectureMismatch")
  public static var executableArchitectureMismatchError: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableRuntimeMismatch")
  public static var executableRuntimeMismatchError: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLoad")
  public static var executableLoadError: CocoaError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  @available(*, deprecated, renamed: "executableLink")
  public static var executableLinkError: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadCorrupt")
  public static var propertyListReadCorruptError: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadUnknownVersion")
  public static var propertyListReadUnknownVersionError: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListReadStream")
  public static var propertyListReadStreamError: CocoaError.Code {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  @available(*, deprecated, renamed: "propertyListWriteStream")
  public static var propertyListWriteStreamError: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListWriteInvalid")
  public static var propertyListWriteInvalidError: CocoaError.Code {
    get
  }
  @available(OSX 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileUnavailable")
  public static var ubiquitousFileUnavailableError: CocoaError.Code {
    get
  }
  @available(OSX 10.9, iOS 7.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileNotUploadedDueToQuota")
  public static var ubiquitousFileNotUploadedDueToQuotaError: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffFailed")
  public static var userActivityHandoffFailedError: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityConnectionUnavailable")
  public static var userActivityConnectionUnavailableError: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityRemoteApplicationTimedOut")
  public static var userActivityRemoteApplicationTimedOutError: CocoaError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffUserInfoTooLarge")
  public static var userActivityHandoffUserInfoTooLargeError: CocoaError.Code {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderReadCorrupt")
  public static var coderReadCorruptError: CocoaError.Code {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderValueNotFound")
  public static var coderValueNotFoundError: CocoaError.Code {
    get
  }
}
extension CocoaError {
  @available(OSX 10.11, iOS 9.0, *)
  public var isCoderError: Bool {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public var isExecutableError: Bool {
    get
  }
  public var isFileError: Bool {
    get
  }
  public var isFormattingError: Bool {
    get
  }
  @available(OSX 10.6, iOS 4.0, *)
  public var isPropertyListError: Bool {
    get
  }
  @available(OSX 10.9, iOS 7.0, *)
  public var isUbiquitousFileError: Bool {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public var isUserActivityError: Bool {
    get
  }
  public var isValidationError: Bool {
    get
  }
  @available(OSX 10.8, iOS 6.0, *)
  public var isXPCConnectionError: Bool {
    get
  }
}
extension CocoaError.Code {
  @available(*, unavailable, renamed: "fileNoSuchFile")
  public static var FileNoSuchFileError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileLocking")
  public static var FileLockingError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadUnknown")
  public static var FileReadUnknownError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadNoPermission")
  public static var FileReadNoPermissionError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadInvalidFileName")
  public static var FileReadInvalidFileNameError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadCorruptFile")
  public static var FileReadCorruptFileError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadNoSuchFile")
  public static var FileReadNoSuchFileError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadInapplicableStringEncoding")
  public static var FileReadInapplicableStringEncodingError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadUnsupportedScheme")
  public static var FileReadUnsupportedSchemeError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadTooLarge")
  public static var FileReadTooLargeError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileReadUnknownStringEncoding")
  public static var FileReadUnknownStringEncodingError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteUnknown")
  public static var FileWriteUnknownError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteNoPermission")
  public static var FileWriteNoPermissionError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteInvalidFileName")
  public static var FileWriteInvalidFileNameError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteFileExists")
  public static var FileWriteFileExistsError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteInapplicableStringEncoding")
  public static var FileWriteInapplicableStringEncodingError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteUnsupportedScheme")
  public static var FileWriteUnsupportedSchemeError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteOutOfSpace")
  public static var FileWriteOutOfSpaceError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileWriteVolumeReadOnly")
  public static var FileWriteVolumeReadOnlyError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileManagerUnmountUnknown")
  public static var FileManagerUnmountUnknownError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileManagerUnmountBusy")
  public static var FileManagerUnmountBusyError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "keyValueValidation")
  public static var KeyValueValidationError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "formatting")
  public static var FormattingError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "userCancelled")
  public static var UserCancelledError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "featureUnsupported")
  public static var FeatureUnsupportedError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "executableNotLoadable")
  public static var ExecutableNotLoadableError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "executableArchitectureMismatch")
  public static var ExecutableArchitectureMismatchError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "executableRuntimeMismatch")
  public static var ExecutableRuntimeMismatchError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "executableLoad")
  public static var ExecutableLoadError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "executableLink")
  public static var ExecutableLinkError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "propertyListReadCorrupt")
  public static var PropertyListReadCorruptError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "propertyListReadUnknownVersion")
  public static var PropertyListReadUnknownVersionError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "propertyListReadStream")
  public static var PropertyListReadStreamError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "propertyListWriteStream")
  public static var PropertyListWriteStreamError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "propertyListWriteInvalid")
  public static var PropertyListWriteInvalidError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "xpcConnectionInterrupted")
  public static var XPCConnectionInterrupted: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "xpcConnectionInvalid")
  public static var XPCConnectionInvalid: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "xpcConnectionReplyInvalid")
  public static var XPCConnectionReplyInvalid: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "ubiquitousFileUnavailable")
  public static var UbiquitousFileUnavailableError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "ubiquitousFileNotUploadedDueToQuota")
  public static var UbiquitousFileNotUploadedDueToQuotaError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "ubiquitousFileUbiquityServerNotAvailable")
  public static var UbiquitousFileUbiquityServerNotAvailable: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "userActivityHandoffFailed")
  public static var UserActivityHandoffFailedError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "userActivityConnectionUnavailable")
  public static var UserActivityConnectionUnavailableError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "userActivityRemoteApplicationTimedOut")
  public static var UserActivityRemoteApplicationTimedOutError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "userActivityHandoffUserInfoTooLarge")
  public static var UserActivityHandoffUserInfoTooLargeError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "coderReadCorrupt")
  public static var CoderReadCorruptError: CocoaError.Code {
    get
  }
  @available(*, unavailable, renamed: "coderValueNotFound")
  public static var CoderValueNotFoundError: CocoaError.Code {
    get
  }
}
public struct URLError : _BridgedStoredNSError {
  public let _nsError: NSError
  public init(_nsError error: NSError)
  public static var errorDomain: String {
    get
  }
  public struct Code : RawRepresentable, Hashable, _ErrorCodeProtocol {
    public typealias _ErrorType = URLError
    public let rawValue: Int
    public init(rawValue: Int)
    public typealias RawValue = Swift.Int
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension URLError.Code {
  public static var unknown: URLError.Code {
    get
  }
  public static var cancelled: URLError.Code {
    get
  }
  public static var badURL: URLError.Code {
    get
  }
  public static var timedOut: URLError.Code {
    get
  }
  public static var unsupportedURL: URLError.Code {
    get
  }
  public static var cannotFindHost: URLError.Code {
    get
  }
  public static var cannotConnectToHost: URLError.Code {
    get
  }
  public static var networkConnectionLost: URLError.Code {
    get
  }
  public static var dnsLookupFailed: URLError.Code {
    get
  }
  public static var httpTooManyRedirects: URLError.Code {
    get
  }
  public static var resourceUnavailable: URLError.Code {
    get
  }
  public static var notConnectedToInternet: URLError.Code {
    get
  }
  public static var redirectToNonExistentLocation: URLError.Code {
    get
  }
  public static var badServerResponse: URLError.Code {
    get
  }
  public static var userCancelledAuthentication: URLError.Code {
    get
  }
  public static var userAuthenticationRequired: URLError.Code {
    get
  }
  public static var zeroByteResource: URLError.Code {
    get
  }
  public static var cannotDecodeRawData: URLError.Code {
    get
  }
  public static var cannotDecodeContentData: URLError.Code {
    get
  }
  public static var cannotParseResponse: URLError.Code {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  public static var appTransportSecurityRequiresSecureConnection: URLError.Code {
    get
  }
  public static var fileDoesNotExist: URLError.Code {
    get
  }
  public static var fileIsDirectory: URLError.Code {
    get
  }
  public static var noPermissionsToReadFile: URLError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public static var dataLengthExceedsMaximum: URLError.Code {
    get
  }
  public static var secureConnectionFailed: URLError.Code {
    get
  }
  public static var serverCertificateHasBadDate: URLError.Code {
    get
  }
  public static var serverCertificateUntrusted: URLError.Code {
    get
  }
  public static var serverCertificateHasUnknownRoot: URLError.Code {
    get
  }
  public static var serverCertificateNotYetValid: URLError.Code {
    get
  }
  public static var clientCertificateRejected: URLError.Code {
    get
  }
  public static var clientCertificateRequired: URLError.Code {
    get
  }
  public static var cannotLoadFromNetwork: URLError.Code {
    get
  }
  public static var cannotCreateFile: URLError.Code {
    get
  }
  public static var cannotOpenFile: URLError.Code {
    get
  }
  public static var cannotCloseFile: URLError.Code {
    get
  }
  public static var cannotWriteToFile: URLError.Code {
    get
  }
  public static var cannotRemoveFile: URLError.Code {
    get
  }
  public static var cannotMoveFile: URLError.Code {
    get
  }
  public static var downloadDecodingFailedMidStream: URLError.Code {
    get
  }
  public static var downloadDecodingFailedToComplete: URLError.Code {
    get
  }
  @available(OSX 10.7, iOS 3.0, *)
  public static var internationalRoamingOff: URLError.Code {
    get
  }
  @available(OSX 10.7, iOS 3.0, *)
  public static var callIsActive: URLError.Code {
    get
  }
  @available(OSX 10.7, iOS 3.0, *)
  public static var dataNotAllowed: URLError.Code {
    get
  }
  @available(OSX 10.7, iOS 3.0, *)
  public static var requestBodyStreamExhausted: URLError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public static var backgroundSessionRequiresSharedContainer: URLError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public static var backgroundSessionInUseByAnotherProcess: URLError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public static var backgroundSessionWasDisconnected: URLError.Code {
    get
  }
}
extension URLError {
  public var failingURL: URL? {
    get
  }
  public var failureURLString: String? {
    get
  }
  public var failureURLPeerTrust: SecTrust? {
    get
  }
}
extension URLError {
  public static var unknown: URLError.Code {
    get
  }
  public static var cancelled: URLError.Code {
    get
  }
  public static var badURL: URLError.Code {
    get
  }
  public static var timedOut: URLError.Code {
    get
  }
  public static var unsupportedURL: URLError.Code {
    get
  }
  public static var cannotFindHost: URLError.Code {
    get
  }
  public static var cannotConnectToHost: URLError.Code {
    get
  }
  public static var networkConnectionLost: URLError.Code {
    get
  }
  public static var dnsLookupFailed: URLError.Code {
    get
  }
  public static var httpTooManyRedirects: URLError.Code {
    get
  }
  public static var resourceUnavailable: URLError.Code {
    get
  }
  public static var notConnectedToInternet: URLError.Code {
    get
  }
  public static var redirectToNonExistentLocation: URLError.Code {
    get
  }
  public static var badServerResponse: URLError.Code {
    get
  }
  public static var userCancelledAuthentication: URLError.Code {
    get
  }
  public static var userAuthenticationRequired: URLError.Code {
    get
  }
  public static var zeroByteResource: URLError.Code {
    get
  }
  public static var cannotDecodeRawData: URLError.Code {
    get
  }
  public static var cannotDecodeContentData: URLError.Code {
    get
  }
  public static var cannotParseResponse: URLError.Code {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  public static var appTransportSecurityRequiresSecureConnection: URLError.Code {
    get
  }
  public static var fileDoesNotExist: URLError.Code {
    get
  }
  public static var fileIsDirectory: URLError.Code {
    get
  }
  public static var noPermissionsToReadFile: URLError.Code {
    get
  }
  @available(OSX 10.5, iOS 2.0, *)
  public static var dataLengthExceedsMaximum: URLError.Code {
    get
  }
  public static var secureConnectionFailed: URLError.Code {
    get
  }
  public static var serverCertificateHasBadDate: URLError.Code {
    get
  }
  public static var serverCertificateUntrusted: URLError.Code {
    get
  }
  public static var serverCertificateHasUnknownRoot: URLError.Code {
    get
  }
  public static var serverCertificateNotYetValid: URLError.Code {
    get
  }
  public static var clientCertificateRejected: URLError.Code {
    get
  }
  public static var clientCertificateRequired: URLError.Code {
    get
  }
  public static var cannotLoadFromNetwork: URLError.Code {
    get
  }
  public static var cannotCreateFile: URLError.Code {
    get
  }
  public static var cannotOpenFile: URLError.Code {
    get
  }
  public static var cannotCloseFile: URLError.Code {
    get
  }
  public static var cannotWriteToFile: URLError.Code {
    get
  }
  public static var cannotRemoveFile: URLError.Code {
    get
  }
  public static var cannotMoveFile: URLError.Code {
    get
  }
  public static var downloadDecodingFailedMidStream: URLError.Code {
    get
  }
  public static var downloadDecodingFailedToComplete: URLError.Code {
    get
  }
  @available(OSX 10.7, iOS 3.0, *)
  public static var internationalRoamingOff: URLError.Code {
    get
  }
  @available(OSX 10.7, iOS 3.0, *)
  public static var callIsActive: URLError.Code {
    get
  }
  @available(OSX 10.7, iOS 3.0, *)
  public static var dataNotAllowed: URLError.Code {
    get
  }
  @available(OSX 10.7, iOS 3.0, *)
  public static var requestBodyStreamExhausted: URLError.Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public static var backgroundSessionRequiresSharedContainer: Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public static var backgroundSessionInUseByAnotherProcess: Code {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public static var backgroundSessionWasDisconnected: Code {
    get
  }
}
extension URLError {
  @available(*, unavailable, renamed: "unknown")
  public static var Unknown: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cancelled")
  public static var Cancelled: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "badURL")
  public static var BadURL: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "timedOut")
  public static var TimedOut: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "unsupportedURL")
  public static var UnsupportedURL: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotFindHost")
  public static var CannotFindHost: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotConnectToHost")
  public static var CannotConnectToHost: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "networkConnectionLost")
  public static var NetworkConnectionLost: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "dnsLookupFailed")
  public static var DNSLookupFailed: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "httpTooManyRedirects")
  public static var HTTPTooManyRedirects: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "resourceUnavailable")
  public static var ResourceUnavailable: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "notConnectedToInternet")
  public static var NotConnectedToInternet: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "redirectToNonExistentLocation")
  public static var RedirectToNonExistentLocation: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "badServerResponse")
  public static var BadServerResponse: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "userCancelledAuthentication")
  public static var UserCancelledAuthentication: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "userAuthenticationRequired")
  public static var UserAuthenticationRequired: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "zeroByteResource")
  public static var ZeroByteResource: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotDecodeRawData")
  public static var CannotDecodeRawData: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotDecodeContentData")
  public static var CannotDecodeContentData: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotParseResponse")
  public static var CannotParseResponse: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "appTransportSecurityRequiresSecureConnection")
  public static var AppTransportSecurityRequiresSecureConnection: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileDoesNotExist")
  public static var FileDoesNotExist: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "fileIsDirectory")
  public static var FileIsDirectory: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "noPermissionsToReadFile")
  public static var NoPermissionsToReadFile: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "dataLengthExceedsMaximum")
  public static var DataLengthExceedsMaximum: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "secureConnectionFailed")
  public static var SecureConnectionFailed: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "serverCertificateHasBadDate")
  public static var ServerCertificateHasBadDate: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "serverCertificateUntrusted")
  public static var ServerCertificateUntrusted: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "serverCertificateHasUnknownRoot")
  public static var ServerCertificateHasUnknownRoot: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "serverCertificateNotYetValid")
  public static var ServerCertificateNotYetValid: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "clientCertificateRejected")
  public static var ClientCertificateRejected: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "clientCertificateRequired")
  public static var ClientCertificateRequired: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotLoadFromNetwork")
  public static var CannotLoadFromNetwork: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotCreateFile")
  public static var CannotCreateFile: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotOpenFile")
  public static var CannotOpenFile: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotCloseFile")
  public static var CannotCloseFile: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotWriteToFile")
  public static var CannotWriteToFile: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotRemoveFile")
  public static var CannotRemoveFile: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "cannotMoveFile")
  public static var CannotMoveFile: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "downloadDecodingFailedMidStream")
  public static var DownloadDecodingFailedMidStream: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "downloadDecodingFailedToComplete")
  public static var DownloadDecodingFailedToComplete: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "internationalRoamingOff")
  public static var InternationalRoamingOff: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "callIsActive")
  public static var CallIsActive: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "dataNotAllowed")
  public static var DataNotAllowed: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "requestBodyStreamExhausted")
  public static var RequestBodyStreamExhausted: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "backgroundSessionRequiresSharedContainer")
  public static var BackgroundSessionRequiresSharedContainer: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "backgroundSessionInUseByAnotherProcess")
  public static var BackgroundSessionInUseByAnotherProcess: URLError.Code {
    get
  }
  @available(*, unavailable, renamed: "backgroundSessionWasDisconnected")
  public static var BackgroundSessionWasDisconnected: URLError.Code {
    get
  }
}
public struct POSIXError : _BridgedStoredNSError {
  public let _nsError: NSError
  public init(_nsError error: NSError)
  public static var errorDomain: String {
    get
  }
  public typealias Code = POSIXErrorCode
  public var hashValue: Swift.Int {
    get
  }
}
extension POSIXErrorCode : _ErrorCodeProtocol {
  public typealias _ErrorType = POSIXError
}
extension POSIXError {
  public static var EPERM: POSIXErrorCode {
    get
  }
  public static var ENOENT: POSIXErrorCode {
    get
  }
  public static var ESRCH: POSIXErrorCode {
    get
  }
  public static var EINTR: POSIXErrorCode {
    get
  }
  public static var EIO: POSIXErrorCode {
    get
  }
  public static var ENXIO: POSIXErrorCode {
    get
  }
  public static var E2BIG: POSIXErrorCode {
    get
  }
  public static var ENOEXEC: POSIXErrorCode {
    get
  }
  public static var EBADF: POSIXErrorCode {
    get
  }
  public static var ECHILD: POSIXErrorCode {
    get
  }
  public static var EDEADLK: POSIXErrorCode {
    get
  }
  public static var ENOMEM: POSIXErrorCode {
    get
  }
  public static var EACCES: POSIXErrorCode {
    get
  }
  public static var EFAULT: POSIXErrorCode {
    get
  }
  public static var ENOTBLK: POSIXErrorCode {
    get
  }
  public static var EBUSY: POSIXErrorCode {
    get
  }
  public static var EEXIST: POSIXErrorCode {
    get
  }
  public static var EXDEV: POSIXErrorCode {
    get
  }
  public static var ENODEV: POSIXErrorCode {
    get
  }
  public static var ENOTDIR: POSIXErrorCode {
    get
  }
  public static var EISDIR: POSIXErrorCode {
    get
  }
  public static var EINVAL: POSIXErrorCode {
    get
  }
  public static var ENFILE: POSIXErrorCode {
    get
  }
  public static var EMFILE: POSIXErrorCode {
    get
  }
  public static var ENOTTY: POSIXErrorCode {
    get
  }
  public static var ETXTBSY: POSIXErrorCode {
    get
  }
  public static var EFBIG: POSIXErrorCode {
    get
  }
  public static var ENOSPC: POSIXErrorCode {
    get
  }
  public static var ESPIPE: POSIXErrorCode {
    get
  }
  public static var EROFS: POSIXErrorCode {
    get
  }
  public static var EMLINK: POSIXErrorCode {
    get
  }
  public static var EPIPE: POSIXErrorCode {
    get
  }
  public static var EDOM: POSIXErrorCode {
    get
  }
  public static var ERANGE: POSIXErrorCode {
    get
  }
  public static var EAGAIN: POSIXErrorCode {
    get
  }
  public static var EWOULDBLOCK: POSIXErrorCode {
    get
  }
  public static var EINPROGRESS: POSIXErrorCode {
    get
  }
  public static var EALREADY: POSIXErrorCode {
    get
  }
  public static var ENOTSOCK: POSIXErrorCode {
    get
  }
  public static var EDESTADDRREQ: POSIXErrorCode {
    get
  }
  public static var EMSGSIZE: POSIXErrorCode {
    get
  }
  public static var EPROTOTYPE: POSIXErrorCode {
    get
  }
  public static var ENOPROTOOPT: POSIXErrorCode {
    get
  }
  public static var EPROTONOSUPPORT: POSIXErrorCode {
    get
  }
  public static var ESOCKTNOSUPPORT: POSIXErrorCode {
    get
  }
  public static var ENOTSUP: POSIXErrorCode {
    get
  }
  public static var EPFNOSUPPORT: POSIXErrorCode {
    get
  }
  public static var EAFNOSUPPORT: POSIXErrorCode {
    get
  }
  public static var EADDRINUSE: POSIXErrorCode {
    get
  }
  public static var EADDRNOTAVAIL: POSIXErrorCode {
    get
  }
  public static var ENETDOWN: POSIXErrorCode {
    get
  }
  public static var ENETUNREACH: POSIXErrorCode {
    get
  }
  public static var ENETRESET: POSIXErrorCode {
    get
  }
  public static var ECONNABORTED: POSIXErrorCode {
    get
  }
  public static var ECONNRESET: POSIXErrorCode {
    get
  }
  public static var ENOBUFS: POSIXErrorCode {
    get
  }
  public static var EISCONN: POSIXErrorCode {
    get
  }
  public static var ENOTCONN: POSIXErrorCode {
    get
  }
  public static var ESHUTDOWN: POSIXErrorCode {
    get
  }
  public static var ETOOMANYREFS: POSIXErrorCode {
    get
  }
  public static var ETIMEDOUT: POSIXErrorCode {
    get
  }
  public static var ECONNREFUSED: POSIXErrorCode {
    get
  }
  public static var ELOOP: POSIXErrorCode {
    get
  }
  public static var ENAMETOOLONG: POSIXErrorCode {
    get
  }
  public static var EHOSTDOWN: POSIXErrorCode {
    get
  }
  public static var EHOSTUNREACH: POSIXErrorCode {
    get
  }
  public static var ENOTEMPTY: POSIXErrorCode {
    get
  }
  public static var EPROCLIM: POSIXErrorCode {
    get
  }
  public static var EUSERS: POSIXErrorCode {
    get
  }
  public static var EDQUOT: POSIXErrorCode {
    get
  }
  public static var ESTALE: POSIXErrorCode {
    get
  }
  public static var EREMOTE: POSIXErrorCode {
    get
  }
  public static var EBADRPC: POSIXErrorCode {
    get
  }
  public static var ERPCMISMATCH: POSIXErrorCode {
    get
  }
  public static var EPROGUNAVAIL: POSIXErrorCode {
    get
  }
  public static var EPROGMISMATCH: POSIXErrorCode {
    get
  }
  public static var EPROCUNAVAIL: POSIXErrorCode {
    get
  }
  public static var ENOLCK: POSIXErrorCode {
    get
  }
  public static var ENOSYS: POSIXErrorCode {
    get
  }
  public static var EFTYPE: POSIXErrorCode {
    get
  }
  public static var EAUTH: POSIXErrorCode {
    get
  }
  public static var ENEEDAUTH: POSIXErrorCode {
    get
  }
  public static var EPWROFF: POSIXErrorCode {
    get
  }
  public static var EDEVERR: POSIXErrorCode {
    get
  }
  public static var EOVERFLOW: POSIXErrorCode {
    get
  }
  public static var EBADEXEC: POSIXErrorCode {
    get
  }
  public static var EBADARCH: POSIXErrorCode {
    get
  }
  public static var ESHLIBVERS: POSIXErrorCode {
    get
  }
  public static var EBADMACHO: POSIXErrorCode {
    get
  }
  public static var ECANCELED: POSIXErrorCode {
    get
  }
  public static var EIDRM: POSIXErrorCode {
    get
  }
  public static var ENOMSG: POSIXErrorCode {
    get
  }
  public static var EILSEQ: POSIXErrorCode {
    get
  }
  public static var ENOATTR: POSIXErrorCode {
    get
  }
  public static var EBADMSG: POSIXErrorCode {
    get
  }
  public static var EMULTIHOP: POSIXErrorCode {
    get
  }
  public static var ENODATA: POSIXErrorCode {
    get
  }
  public static var ENOLINK: POSIXErrorCode {
    get
  }
  public static var ENOSR: POSIXErrorCode {
    get
  }
  public static var ENOSTR: POSIXErrorCode {
    get
  }
  public static var EPROTO: POSIXErrorCode {
    get
  }
  public static var ETIME: POSIXErrorCode {
    get
  }
  public static var ENOPOLICY: POSIXErrorCode {
    get
  }
  public static var ENOTRECOVERABLE: POSIXErrorCode {
    get
  }
  public static var EOWNERDEAD: POSIXErrorCode {
    get
  }
  public static var EQFULL: POSIXErrorCode {
    get
  }
}
public struct MachError : _BridgedStoredNSError {
  public let _nsError: NSError
  public init(_nsError error: NSError)
  public static var errorDomain: String {
    get
  }
  public typealias Code = MachErrorCode
  public var hashValue: Swift.Int {
    get
  }
}
extension MachErrorCode : _ErrorCodeProtocol {
  public typealias _ErrorType = MachError
}
extension MachError {
  public static var success: MachError.Code {
    get
  }
  public static var invalidAddress: MachError.Code {
    get
  }
  public static var protectionFailure: MachError.Code {
    get
  }
  public static var noSpace: MachError.Code {
    get
  }
  public static var invalidArgument: MachError.Code {
    get
  }
  public static var failure: MachError.Code {
    get
  }
  public static var resourceShortage: MachError.Code {
    get
  }
  public static var notReceiver: MachError.Code {
    get
  }
  public static var noAccess: MachError.Code {
    get
  }
  public static var memoryFailure: MachError.Code {
    get
  }
  public static var memoryError: MachError.Code {
    get
  }
  public static var alreadyInSet: MachError.Code {
    get
  }
  public static var notInSet: MachError.Code {
    get
  }
  public static var nameExists: MachError.Code {
    get
  }
  public static var aborted: MachError.Code {
    get
  }
  public static var invalidName: MachError.Code {
    get
  }
  public static var invalidTask: MachError.Code {
    get
  }
  public static var invalidRight: MachError.Code {
    get
  }
  public static var invalidValue: MachError.Code {
    get
  }
  public static var userReferencesOverflow: MachError.Code {
    get
  }
  public static var invalidCapability: MachError.Code {
    get
  }
  public static var rightExists: MachError.Code {
    get
  }
  public static var invalidHost: MachError.Code {
    get
  }
  public static var memoryPresent: MachError.Code {
    get
  }
  public static var memoryDataMoved: MachError.Code {
    get
  }
  public static var memoryRestartCopy: MachError.Code {
    get
  }
  public static var invalidProcessorSet: MachError.Code {
    get
  }
  public static var policyLimit: MachError.Code {
    get
  }
  public static var invalidPolicy: MachError.Code {
    get
  }
  public static var invalidObject: MachError.Code {
    get
  }
  public static var alreadyWaiting: MachError.Code {
    get
  }
  public static var defaultSet: MachError.Code {
    get
  }
  public static var exceptionProtected: MachError.Code {
    get
  }
  public static var invalidLedger: MachError.Code {
    get
  }
  public static var invalidMemoryControl: MachError.Code {
    get
  }
  public static var invalidSecurity: MachError.Code {
    get
  }
  public static var notDepressed: MachError.Code {
    get
  }
  public static var terminated: MachError.Code {
    get
  }
  public static var lockSetDestroyed: MachError.Code {
    get
  }
  public static var lockUnstable: MachError.Code {
    get
  }
  public static var lockOwned: MachError.Code {
    get
  }
  public static var lockOwnedSelf: MachError.Code {
    get
  }
  public static var semaphoreDestroyed: MachError.Code {
    get
  }
  public static var rpcServerTerminated: MachError.Code {
    get
  }
  public static var rpcTerminateOrphan: MachError.Code {
    get
  }
  public static var rpcContinueOrphan: MachError.Code {
    get
  }
  public static var notSupported: MachError.Code {
    get
  }
  public static var nodeDown: MachError.Code {
    get
  }
  public static var notWaiting: MachError.Code {
    get
  }
  public static var operationTimedOut: MachError.Code {
    get
  }
  public static var codesignError: MachError.Code {
    get
  }
  public static var policyStatic: MachError.Code {
    get
  }
}
public struct ErrorUserInfoKey : RawRepresentable, _SwiftNewtypeWrapper, Equatable, Hashable, _ObjectiveCBridgeable {
  public typealias _ObjectiveCType = NSString
  public init(rawValue: String)
  public var rawValue: String
  public typealias RawValue = Swift.String
}
extension ErrorUserInfoKey {
  @available(*, deprecated, renamed: "NSUnderlyingErrorKey")
  public static let underlyingErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedDescriptionKey")
  public static let localizedDescriptionKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedFailureReasonErrorKey")
  public static let localizedFailureReasonErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedRecoverySuggestionErrorKey")
  public static let localizedRecoverySuggestionErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedRecoveryOptionsErrorKey")
  public static let localizedRecoveryOptionsErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSRecoveryAttempterErrorKey")
  public static let recoveryAttempterErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSHelpAnchorErrorKey")
  public static let helpAnchorErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSStringEncodingErrorKey")
  public static let stringEncodingErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSURLErrorKey")
  public static let NSURLErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSFilePathErrorKey")
  public static let filePathErrorKey: Foundation.ErrorUserInfoKey
}
extension NSExpression {
  convenience public init(format expressionFormat: __shared String, _ args: CVarArg...)
}
extension NSExpression {
  convenience public init<Root, Value>(forKeyPath keyPath: KeyPath<Root, Value>)
}
public struct NSFastEnumerationIterator : IteratorProtocol {
  public init(_ enumerable: NSFastEnumeration)
  mutating public func next() -> Any?
  public typealias Element = Any
}
extension NSEnumerator : Sequence {
  public func makeIterator() -> NSFastEnumerationIterator
  public typealias Element = Any
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
extension NSRectEdge {
  @inlinable public init(rectEdge: CGRectEdge) {
    self = NSRectEdge(rawValue: UInt(rectEdge.rawValue))!
  }
}
extension CGRectEdge {
  @inlinable public init(rectEdge: NSRectEdge) {
    self = CGRectEdge(rawValue: UInt32(rectEdge.rawValue))!
  }
}
public struct NSIndexSetIterator : IteratorProtocol {
  public typealias Element = Int
  mutating public func next() -> Int?
}
extension NSIndexSet : Sequence {
  public func makeIterator() -> NSIndexSetIterator
  public typealias Element = Foundation.NSIndexSetIterator.Element
  public typealias Iterator = Foundation.NSIndexSetIterator
}
@available(OSX 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
extension NSItemProvider {
  @available(OSX 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public func registerObject<T>(ofClass: T.Type, visibility: NSItemProviderRepresentationVisibility, loadHandler: @escaping ((T?, Error?) -> Void) -> Progress?) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderWriting
  @available(OSX 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public func canLoadObject<T>(ofClass: T.Type) -> Bool where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
  @available(OSX 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public func loadObject<T>(ofClass: T.Type, completionHandler: @escaping (T?, Error?) -> Void) -> Progress where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
}
extension Int8 : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared NSNumber)
  public init(truncating number: __shared NSNumber)
  public init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout Int8?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout Int8?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> Int8
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension UInt8 : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared NSNumber)
  public init(truncating number: __shared NSNumber)
  public init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt8?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt8?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> UInt8
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Int16 : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared NSNumber)
  public init(truncating number: __shared NSNumber)
  public init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout Int16?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout Int16?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> Int16
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension UInt16 : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared NSNumber)
  public init(truncating number: __shared NSNumber)
  public init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt16?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt16?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> UInt16
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Int32 : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared NSNumber)
  public init(truncating number: __shared NSNumber)
  public init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout Int32?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout Int32?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> Int32
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension UInt32 : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared NSNumber)
  public init(truncating number: __shared NSNumber)
  public init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt32?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt32?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> UInt32
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Int64 : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared NSNumber)
  public init(truncating number: __shared NSNumber)
  public init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout Int64?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout Int64?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> Int64
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension UInt64 : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared NSNumber)
  public init(truncating number: __shared NSNumber)
  public init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt64?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt64?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> UInt64
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Int : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared NSNumber)
  public init(truncating number: __shared NSNumber)
  public init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout Int?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout Int?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> Int
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension UInt : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared NSNumber)
  public init(truncating number: __shared NSNumber)
  public init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout UInt?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> UInt
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Float : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared NSNumber)
  public init(truncating number: __shared NSNumber)
  public init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout Float?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout Float?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> Float
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Double : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared NSNumber)
  public init(truncating number: __shared NSNumber)
  public init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout Double?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout Double?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> Double
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension Bool : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared NSNumber)
  public init(truncating number: __shared NSNumber)
  public init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout Bool?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout Bool?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> Bool
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension CGFloat : _ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared NSNumber)
  public init(truncating number: __shared NSNumber)
  public init?(exactly number: __shared NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: NSNumber, result: inout CGFloat?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSNumber, result: inout CGFloat?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSNumber?) -> CGFloat
  public typealias _ObjectiveCType = Foundation.NSNumber
}
extension NSNumber : ExpressibleByFloatLiteral, ExpressibleByIntegerLiteral, ExpressibleByBooleanLiteral {
  @nonobjc required convenience public init(integerLiteral value: Int)
  @nonobjc required convenience public init(floatLiteral value: Double)
  @nonobjc required convenience public init(booleanLiteral value: Bool)
  public typealias BooleanLiteralType = Swift.Bool
  public typealias IntegerLiteralType = Swift.Int
  public typealias FloatLiteralType = Swift.Double
}
extension NSNumber : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
public protocol _KeyValueCodingAndObserving {
}
extension NSObject : _KeyValueCodingAndObserving {
}
public struct NSKeyValueObservedChange<Value> {
  public typealias Kind = NSKeyValueChange
  public let kind: Kind
  public let newValue: Value?
  public let oldValue: Value?
  public let indexes: IndexSet?
  public let isPrior: Bool
}
public protocol NSKeyValueObservingCustomization : ObjectiveC.NSObjectProtocol {
  static func keyPathsAffectingValue(for key: AnyKeyPath) -> Set<AnyKeyPath>
  static func automaticallyNotifiesObservers(for key: AnyKeyPath) -> Bool
}
@objc(_NSKeyValueObservation) public class NSKeyValueObservation : NSObject {
  @objc public func invalidate()
  @objc deinit
  @objc override dynamic public init()
}
extension _KeyValueCodingAndObserving {
  public func observe<Value>(_ keyPath: KeyPath<Self, Value>, options: NSKeyValueObservingOptions = [], changeHandler: @escaping (Self, NSKeyValueObservedChange<Value>) -> Void) -> NSKeyValueObservation
  public func willChangeValue<Value>(for keyPath: __owned KeyPath<Self, Value>)
  public func willChange<Value>(_ changeKind: NSKeyValueChange, valuesAt indexes: IndexSet, for keyPath: __owned KeyPath<Self, Value>)
  public func willChangeValue<Value>(for keyPath: __owned KeyPath<Self, Value>, withSetMutation mutation: NSKeyValueSetMutationKind, using set: Set<Value>) where Value : Swift.Hashable
  public func didChangeValue<Value>(for keyPath: __owned KeyPath<Self, Value>)
  public func didChange<Value>(_ changeKind: NSKeyValueChange, valuesAt indexes: IndexSet, for keyPath: __owned KeyPath<Self, Value>)
  public func didChangeValue<Value>(for keyPath: __owned KeyPath<Self, Value>, withSetMutation mutation: NSKeyValueSetMutationKind, using set: Set<Value>) where Value : Swift.Hashable
}
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension CollectionDifference.Change : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSOrderedCollectionChange
  public static func _forceBridgeFromObjectiveC(_ input: NSOrderedCollectionChange, result: inout CollectionDifference.Change?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSOrderedCollectionChange, result: inout CollectionDifference.Change?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ s: NSOrderedCollectionChange?) -> CollectionDifference.Change
  public typealias _ObjectiveCType = Foundation.NSOrderedCollectionChange
}
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension CollectionDifference : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSOrderedCollectionDifference
  public static func _forceBridgeFromObjectiveC(_ input: NSOrderedCollectionDifference, result: inout CollectionDifference?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: NSOrderedCollectionDifference, result: inout CollectionDifference?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ s: NSOrderedCollectionDifference?) -> CollectionDifference
  public typealias _ObjectiveCType = Foundation.NSOrderedCollectionDifference
}
extension NSPredicate {
  convenience public init(format predicateFormat: __shared String, _ args: CVarArg...)
}
extension _NSRange : Hashable {
  public func hash(into hasher: inout Hasher)
  public static func == (lhs: NSRange, rhs: NSRange) -> Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension _NSRange : CustomStringConvertible, CustomDebugStringConvertible {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
}
extension _NSRange {
  public init?(_ string: __shared String)
}
extension _NSRange {
  public var lowerBound: Int {
    get
  }
  public var upperBound: Int {
    get
  }
  public func contains(_ index: Int) -> Bool
  mutating public func formUnion(_ other: NSRange)
  public func union(_ other: NSRange) -> NSRange
  public func intersection(_ other: NSRange) -> NSRange?
}
extension _NSRange {
  public init<R>(_ region: R) where R : Swift.RangeExpression, R.Bound : Swift.FixedWidthInteger
  public init<R, S>(_ region: R, in target: S) where R : Swift.RangeExpression, S : Swift.StringProtocol, R.Bound == Swift.String.Index
  @available(swift, deprecated: 4, renamed: "Range.init(_:)")
  public func toRange() -> Range<Int>?
}
extension Range where Bound : Swift.BinaryInteger {
  public init?(_ range: NSRange)
}
extension Range where Bound == Swift.Int {
  public init?(_ range: NSRange)
}
extension Range where Bound == Swift.String.Index {
  public init?(_ range: NSRange, in string: __shared String)
  @available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public init?<S>(_ range: NSRange, in string: __shared S) where S : Swift.StringProtocol
}
extension _NSRange : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension _NSRange : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSRange.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: PlaygroundQuickLook {
    get
  }
}
extension _NSRange : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension NSSet : Sequence {
  public func makeIterator() -> NSFastEnumerationIterator
  public typealias Element = Any
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
extension NSOrderedSet : Sequence {
  public func makeIterator() -> NSFastEnumerationIterator
  public typealias Element = Any
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
extension Set : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSSet
  public static func _forceBridgeFromObjectiveC(_ s: NSSet, result: inout Set?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSSet, result: inout Set?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ s: NSSet?) -> Set
  public typealias _ObjectiveCType = Foundation.NSSet
}
extension NSSet : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension NSOrderedSet {
  convenience public init(objects elements: Any...)
}
extension NSSet {
  convenience public init(objects elements: Any...)
}
extension NSSet : ExpressibleByArrayLiteral {
  required convenience public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension NSOrderedSet : ExpressibleByArrayLiteral {
  required convenience public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension NSSet {
  @nonobjc convenience public init(set anSet: __shared NSSet)
}
extension NSSet : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension Set : CVarArg {
}
extension NSSortDescriptor {
  convenience public init<Root, Value>(keyPath: KeyPath<Root, Value>, ascending: Bool)
  convenience public init<Root, Value>(keyPath: KeyPath<Root, Value>, ascending: Bool, comparator cmptr: @escaping Foundation.Comparator)
  public var keyPath: AnyKeyPath? {
    get
  }
}
extension NSString : ExpressibleByStringLiteral {
  required convenience public init(stringLiteral value: StaticString)
  public typealias StringLiteralType = Swift.StaticString
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StaticString
  public typealias UnicodeScalarLiteralType = Swift.StaticString
}
extension NSString : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension NSString {
  convenience public init(format: __shared NSString, _ args: CVarArg...)
  convenience public init(format: __shared NSString, locale: Locale?, _ args: CVarArg...)
  public class func localizedStringWithFormat(_ format: NSString, _ args: CVarArg...) -> Self
  public func appendingFormat(_ format: NSString, _ args: CVarArg...) -> NSString
}
extension NSMutableString {
  public func appendFormat(_ format: NSString, _ args: CVarArg...)
}
extension NSString {
  @nonobjc convenience public init(string aString: __shared NSString)
}
extension NSString : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSString.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: PlaygroundQuickLook {
    get
  }
}
extension String {
  public static var availableStringEncodings: [Encoding] {
    get
  }
  public static var defaultCStringEncoding: Encoding {
    get
  }
  public static func localizedName(of encoding: Encoding) -> String
  public static func localizedStringWithFormat(_ format: String, _ arguments: CVarArg...) -> String
  public init?(utf8String bytes: UnsafePointer<CChar>)
}
extension String {
  public init?<S>(bytes: __shared S, encoding: Encoding) where S : Swift.Sequence, S.Element == Swift.UInt8
  public init?(bytesNoCopy bytes: UnsafeMutableRawPointer, length: Int, encoding: Encoding, freeWhenDone flag: Bool)
  public init(utf16CodeUnits: UnsafePointer<unichar>, count: Int)
  public init(utf16CodeUnitsNoCopy: UnsafePointer<unichar>, count: Int, freeWhenDone flag: Bool)
  public init(contentsOfFile path: __shared String, encoding enc: Encoding) throws
  public init(contentsOfFile path: __shared String, usedEncoding: inout Encoding) throws
  public init(contentsOfFile path: __shared String) throws
  public init(contentsOf url: __shared URL, encoding enc: Encoding) throws
  public init(contentsOf url: __shared URL, usedEncoding: inout Encoding) throws
  public init(contentsOf url: __shared URL) throws
  public init?(cString: UnsafePointer<CChar>, encoding enc: Encoding)
  public init?(data: __shared Data, encoding: Encoding)
  public init(format: __shared String, _ arguments: CVarArg...)
  public init(format: __shared String, arguments: __shared [CVarArg])
  public init(format: __shared String, locale: __shared Locale?, _ args: CVarArg...)
  public init(format: __shared String, locale: __shared Locale?, arguments: __shared [CVarArg])
}
extension StringProtocol {
  @inlinable internal func _toRelativeNSRange(_ r: Range<String.Index>) -> NSRange {
    return NSRange(self._toUTF16Offsets(r))
  }
  public func canBeConverted(to encoding: String.Encoding) -> Bool
  public var capitalized: String {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  public var localizedCapitalized: String {
    get
  }
  public func capitalized(with locale: Locale?) -> String
  public func caseInsensitiveCompare<T>(_ aString: T) -> ComparisonResult where T : Swift.StringProtocol
  public func commonPrefix<T>(with aString: T, options: String.CompareOptions = []) -> String where T : Swift.StringProtocol
  public func compare<T>(_ aString: T, options mask: String.CompareOptions = [], range: Range<Index>? = nil, locale: Locale? = nil) -> ComparisonResult where T : Swift.StringProtocol
  public func completePath(into outputName: UnsafeMutablePointer<String>? = nil, caseSensitive: Bool, matchesInto outputArray: UnsafeMutablePointer<[String]>? = nil, filterTypes: [String]? = nil) -> Int
  public func components(separatedBy separator: CharacterSet) -> [String]
  public func components<T>(separatedBy separator: T) -> [String] where T : Swift.StringProtocol
  public func cString(using encoding: String.Encoding) -> [CChar]?
  public func data(using encoding: String.Encoding, allowLossyConversion: Bool = false) -> Data?
  public var decomposedStringWithCanonicalMapping: String {
    get
  }
  public var decomposedStringWithCompatibilityMapping: String {
    get
  }
  public func enumerateLines(invoking body: @escaping (_ line: String, _ stop: inout Bool) -> Void)
  public var fastestEncoding: String.Encoding {
    get
  }
  public func getCString(_ buffer: inout [CChar], maxLength: Int, encoding: String.Encoding) -> Bool
  public var hash: Int {
    get
  }
  public func lengthOfBytes(using encoding: String.Encoding) -> Int
  public func localizedCaseInsensitiveCompare<T>(_ aString: T) -> ComparisonResult where T : Swift.StringProtocol
  public func localizedCompare<T>(_ aString: T) -> ComparisonResult where T : Swift.StringProtocol
  public func localizedStandardCompare<T>(_ string: T) -> ComparisonResult where T : Swift.StringProtocol
  @available(OSX 10.11, iOS 9.0, *)
  public var localizedLowercase: String {
    get
  }
  public func lowercased(with locale: Locale?) -> String
  public func maximumLengthOfBytes(using encoding: String.Encoding) -> Int
  public var precomposedStringWithCanonicalMapping: String {
    get
  }
  public var precomposedStringWithCompatibilityMapping: String {
    get
  }
  public func propertyList() -> Any
  public func propertyListFromStringsFileFormat() -> [String : String]
  @available(OSX 10.11, iOS 9.0, *)
  public func localizedStandardContains<T>(_ string: T) -> Bool where T : Swift.StringProtocol
  public var smallestEncoding: String.Encoding {
    get
  }
  public func addingPercentEncoding(withAllowedCharacters allowedCharacters: CharacterSet) -> String?
  public func appendingFormat<T>(_ format: T, _ arguments: CVarArg...) -> String where T : Swift.StringProtocol
  public func appending<T>(_ aString: T) -> String where T : Swift.StringProtocol
  public func folding(options: String.CompareOptions = [], locale: Locale?) -> String
  public func padding<T>(toLength newLength: Int, withPad padString: T, startingAt padIndex: Int) -> String where T : Swift.StringProtocol
  public var removingPercentEncoding: String? {
    get
  }
  public func replacingCharacters<T, R>(in range: R, with replacement: T) -> String where T : Swift.StringProtocol, R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func replacingOccurrences<Target, Replacement>(of target: Target, with replacement: Replacement, options: String.CompareOptions = [], range searchRange: Range<Index>? = nil) -> String where Target : Swift.StringProtocol, Replacement : Swift.StringProtocol
  @available(swift, deprecated: 3.0, obsoleted: 4.0, message: "Use removingPercentEncoding instead, which always uses the recommended UTF-8 encoding.")
  public func replacingPercentEscapes(using encoding: String.Encoding) -> String?
  public func trimmingCharacters(in set: CharacterSet) -> String
  @available(OSX 10.11, iOS 9.0, *)
  public var localizedUppercase: String {
    get
  }
  public func uppercased(with locale: Locale?) -> String
  public func write<T>(toFile path: T, atomically useAuxiliaryFile: Bool, encoding enc: String.Encoding) throws where T : Swift.StringProtocol
  public func write(to url: URL, atomically useAuxiliaryFile: Bool, encoding enc: String.Encoding) throws
  @available(OSX 10.11, iOS 9.0, *)
  public func applyingTransform(_ transform: StringTransform, reverse: Bool) -> String?
  public func enumerateLinguisticTags<T, R>(in range: R, scheme tagScheme: T, options opts: NSLinguisticTagger.Options = [], orthography: NSOrthography? = nil, invoking body: (String, Range<Index>, Range<Index>, inout Bool) -> Void) where T : Swift.StringProtocol, R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func enumerateSubstrings<R>(in range: R, options opts: String.EnumerationOptions = [], _ body: @escaping (_ substring: String?, _ substringRange: Range<Index>, _ enclosingRange: Range<Index>, inout Bool) -> Void) where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func getBytes<R>(_ buffer: inout [UInt8], maxLength maxBufferCount: Int, usedLength usedBufferCount: UnsafeMutablePointer<Int>, encoding: String.Encoding, options: String.EncodingConversionOptions = [], range: R, remaining leftover: UnsafeMutablePointer<Range<Index>>) -> Bool where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func getLineStart<R>(_ start: UnsafeMutablePointer<Index>, end: UnsafeMutablePointer<Index>, contentsEnd: UnsafeMutablePointer<Index>, for range: R) where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func getParagraphStart<R>(_ start: UnsafeMutablePointer<Index>, end: UnsafeMutablePointer<Index>, contentsEnd: UnsafeMutablePointer<Index>, for range: R) where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func lineRange<R>(for aRange: R) -> Range<Index> where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func linguisticTags<T, R>(in range: R, scheme tagScheme: T, options opts: NSLinguisticTagger.Options = [], orthography: NSOrthography? = nil, tokenRanges: UnsafeMutablePointer<[Range<Index>]>? = nil) -> [String] where T : Swift.StringProtocol, R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func paragraphRange<R>(for aRange: R) -> Range<Index> where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func rangeOfCharacter(from aSet: CharacterSet, options mask: String.CompareOptions = [], range aRange: Range<Index>? = nil) -> Range<Index>?
  public func rangeOfComposedCharacterSequence(at anIndex: Index) -> Range<Index>
  public func rangeOfComposedCharacterSequences<R>(for range: R) -> Range<Index> where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func range<T>(of aString: T, options mask: String.CompareOptions = [], range searchRange: Range<Index>? = nil, locale: Locale? = nil) -> Range<Index>? where T : Swift.StringProtocol
  @available(OSX 10.11, iOS 9.0, *)
  public func localizedStandardRange<T>(of string: T) -> Range<Index>? where T : Swift.StringProtocol
  @available(swift, deprecated: 3.0, obsoleted: 4.0, message: "Use addingPercentEncoding(withAllowedCharacters:) instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid.")
  public func addingPercentEscapes(using encoding: String.Encoding) -> String?
  public func contains<T>(_ other: T) -> Bool where T : Swift.StringProtocol
  public func localizedCaseInsensitiveContains<T>(_ other: T) -> Bool where T : Swift.StringProtocol
}
extension StringProtocol {
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript with a 'partial range from' operator.")
  public func substring(from index: Index) -> String
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript with a 'partial range upto' operator.")
  public func substring(to index: Index) -> String
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript.")
  public func substring(with aRange: Range<Index>) -> String
}
extension StringProtocol {
  @available(*, unavailable, message: "Use getFileSystemRepresentation on URL instead.")
  public var fileSystemRepresentation: [CChar] {
    get
  }
  @available(*, unavailable, message: "Use getFileSystemRepresentation on URL instead.")
  public func getFileSystemRepresentation(_ buffer: inout [CChar], maxLength: Int) -> Bool
  @available(*, unavailable, message: "Use lastPathComponent on URL instead.")
  public var lastPathComponent: String {
    get
  }
  @available(*, unavailable, message: "Take the count of a UTF-16 view instead, i.e. str.utf16.count")
  public var utf16Count: Int {
    get
  }
  @available(*, unavailable, message: "Use pathComponents on URL instead.")
  public var pathComponents: [String] {
    get
  }
  @available(*, unavailable, message: "Use pathExtension on URL instead.")
  public var pathExtension: String {
    get
  }
  @available(*, unavailable, message: "Use abbreviatingWithTildeInPath on NSString instead.")
  public var abbreviatingWithTildeInPath: String {
    get
  }
  @available(*, unavailable, message: "Use appendingPathComponent on URL instead.")
  public func appendingPathComponent(_ aString: String) -> String
  @available(*, unavailable, message: "Use appendingPathExtension on URL instead.")
  public func appendingPathExtension(_ ext: String) -> String?
  @available(*, unavailable, message: "Use deletingLastPathComponent on URL instead.")
  public var deletingLastPathComponent: String {
    get
  }
  @available(*, unavailable, message: "Use deletingPathExtension on URL instead.")
  public var deletingPathExtension: String {
    get
  }
  @available(*, unavailable, message: "Use expandingTildeInPath on NSString instead.")
  public var expandingTildeInPath: String {
    get
  }
  @available(*, unavailable, renamed: "folding(options:locale:)")
  public func folding(_ options: String.CompareOptions = [], locale: Locale?) -> String
  @available(*, unavailable, message: "Use resolvingSymlinksInPath on URL instead.")
  public var resolvingSymlinksInPath: String {
    get
  }
  @available(*, unavailable, message: "Use standardizingPath on URL instead.")
  public var standardizingPath: String {
    get
  }
  @available(*, unavailable, message: "Map over paths with appendingPathComponent instead.")
  public func strings(byAppendingPaths paths: [String]) -> [String]
}
extension String {
  @available(*, unavailable, renamed: "localizedName(of:)")
  public static func localizedNameOfStringEncoding(_ encoding: String.Encoding) -> String
  @available(*, unavailable, message: "Use fileURL(withPathComponents:) on URL instead.")
  public static func pathWithComponents(_ components: [String]) -> String
  @available(*, unavailable, message: "Use fileURL(withPathComponents:) on URL instead.")
  public static func path(withComponents components: [String]) -> String
}
extension StringProtocol {
  @available(*, unavailable, renamed: "canBeConverted(to:)")
  public func canBeConvertedToEncoding(_ encoding: String.Encoding) -> Bool
  @available(*, unavailable, renamed: "capitalizedString(with:)")
  public func capitalizedStringWith(_ locale: Locale?) -> String
  @available(*, unavailable, renamed: "commonPrefix(with:options:)")
  public func commonPrefixWith(_ aString: String, options: String.CompareOptions) -> String
  @available(*, unavailable, renamed: "completePath(into:outputName:caseSensitive:matchesInto:filterTypes:)")
  public func completePathInto(_ outputName: UnsafeMutablePointer<String>? = nil, caseSensitive: Bool, matchesInto matchesIntoArray: UnsafeMutablePointer<[String]>? = nil, filterTypes: [String]? = nil) -> Int
  @available(*, unavailable, renamed: "components(separatedBy:)")
  public func componentsSeparatedByCharactersIn(_ separator: CharacterSet) -> [String]
  @available(*, unavailable, renamed: "components(separatedBy:)")
  public func componentsSeparatedBy(_ separator: String) -> [String]
  @available(*, unavailable, renamed: "cString(usingEncoding:)")
  public func cStringUsingEncoding(_ encoding: String.Encoding) -> [CChar]?
  @available(*, unavailable, renamed: "data(usingEncoding:allowLossyConversion:)")
  public func dataUsingEncoding(_ encoding: String.Encoding, allowLossyConversion: Bool = false) -> Data?
  @available(*, unavailable, renamed: "enumerateLinguisticTags(in:scheme:options:orthography:_:)")
  public func enumerateLinguisticTagsIn(_ range: Range<Index>, scheme tagScheme: String, options opts: NSLinguisticTagger.Options, orthography: NSOrthography?, _ body: (String, Range<Index>, Range<Index>, inout Bool) -> Void)
  @available(*, unavailable, renamed: "enumerateSubstrings(in:options:_:)")
  public func enumerateSubstringsIn(_ range: Range<Index>, options opts: String.EnumerationOptions = [], _ body: (_ substring: String?, _ substringRange: Range<Index>, _ enclosingRange: Range<Index>, inout Bool) -> Void)
  @available(*, unavailable, renamed: "getBytes(_:maxLength:usedLength:encoding:options:range:remaining:)")
  public func getBytes(_ buffer: inout [UInt8], maxLength maxBufferCount: Int, usedLength usedBufferCount: UnsafeMutablePointer<Int>, encoding: String.Encoding, options: String.EncodingConversionOptions = [], range: Range<Index>, remainingRange leftover: UnsafeMutablePointer<Range<Index>>) -> Bool
  @available(*, unavailable, renamed: "getLineStart(_:end:contentsEnd:for:)")
  public func getLineStart(_ start: UnsafeMutablePointer<Index>, end: UnsafeMutablePointer<Index>, contentsEnd: UnsafeMutablePointer<Index>, forRange: Range<Index>)
  @available(*, unavailable, renamed: "getParagraphStart(_:end:contentsEnd:for:)")
  public func getParagraphStart(_ start: UnsafeMutablePointer<Index>, end: UnsafeMutablePointer<Index>, contentsEnd: UnsafeMutablePointer<Index>, forRange: Range<Index>)
  @available(*, unavailable, renamed: "lengthOfBytes(using:)")
  public func lengthOfBytesUsingEncoding(_ encoding: String.Encoding) -> Int
  @available(*, unavailable, renamed: "lineRange(for:)")
  public func lineRangeFor(_ aRange: Range<Index>) -> Range<Index>
  @available(*, unavailable, renamed: "linguisticTags(in:scheme:options:orthography:tokenRanges:)")
  public func linguisticTagsIn(_ range: Range<Index>, scheme tagScheme: String, options opts: NSLinguisticTagger.Options = [], orthography: NSOrthography? = nil, tokenRanges: UnsafeMutablePointer<[Range<Index>]>? = nil) -> [String]
  @available(*, unavailable, renamed: "lowercased(with:)")
  public func lowercaseStringWith(_ locale: Locale?) -> String
  @available(*, unavailable, renamed: "maximumLengthOfBytes(using:)")
  public func maximumLengthOfBytesUsingEncoding(_ encoding: String.Encoding) -> Int
  @available(*, unavailable, renamed: "paragraphRange(for:)")
  public func paragraphRangeFor(_ aRange: Range<Index>) -> Range<Index>
  @available(*, unavailable, renamed: "rangeOfCharacter(from:options:range:)")
  public func rangeOfCharacterFrom(_ aSet: CharacterSet, options mask: String.CompareOptions = [], range aRange: Range<Index>? = nil) -> Range<Index>?
  @available(*, unavailable, renamed: "rangeOfComposedCharacterSequence(at:)")
  public func rangeOfComposedCharacterSequenceAt(_ anIndex: Index) -> Range<Index>
  @available(*, unavailable, renamed: "rangeOfComposedCharacterSequences(for:)")
  public func rangeOfComposedCharacterSequencesFor(_ range: Range<Index>) -> Range<Index>
  @available(*, unavailable, renamed: "range(of:options:range:locale:)")
  public func rangeOf(_ aString: String, options mask: String.CompareOptions = [], range searchRange: Range<Index>? = nil, locale: Locale? = nil) -> Range<Index>?
  @available(*, unavailable, renamed: "localizedStandardRange(of:)")
  public func localizedStandardRangeOf(_ string: String) -> Range<Index>?
  @available(*, unavailable, renamed: "addingPercentEncoding(withAllowedCharacters:)")
  public func addingPercentEncodingWithAllowedCharacters(_ allowedCharacters: CharacterSet) -> String?
  @available(*, unavailable, renamed: "addingPercentEscapes(using:)")
  public func addingPercentEscapesUsingEncoding(_ encoding: String.Encoding) -> String?
  @available(*, unavailable, renamed: "appendingFormat")
  public func stringByAppendingFormat(_ format: String, _ arguments: CVarArg...) -> String
  @available(*, unavailable, renamed: "padding(toLength:with:startingAt:)")
  public func byPaddingToLength(_ newLength: Int, withString padString: String, startingAt padIndex: Int) -> String
  @available(*, unavailable, renamed: "replacingCharacters(in:with:)")
  public func replacingCharactersIn(_ range: Range<Index>, withString replacement: String) -> String
  @available(*, unavailable, renamed: "replacingOccurrences(of:with:options:range:)")
  public func replacingOccurrencesOf(_ target: String, withString replacement: String, options: String.CompareOptions = [], range searchRange: Range<Index>? = nil) -> String
  @available(*, unavailable, renamed: "replacingPercentEscapes(usingEncoding:)")
  public func replacingPercentEscapesUsingEncoding(_ encoding: String.Encoding) -> String?
  @available(*, unavailable, renamed: "trimmingCharacters(in:)")
  public func byTrimmingCharactersIn(_ set: CharacterSet) -> String
  @available(*, unavailable, renamed: "strings(byAppendingPaths:)")
  public func stringsByAppendingPaths(_ paths: [String]) -> [String]
  @available(*, unavailable, renamed: "substring(from:)")
  public func substringFrom(_ index: Index) -> String
  @available(*, unavailable, renamed: "substring(to:)")
  public func substringTo(_ index: Index) -> String
  @available(*, unavailable, renamed: "substring(with:)")
  public func substringWith(_ aRange: Range<Index>) -> String
  @available(*, unavailable, renamed: "uppercased(with:)")
  public func uppercaseStringWith(_ locale: Locale?) -> String
  @available(*, unavailable, renamed: "write(toFile:atomically:encoding:)")
  public func writeToFile(_ path: String, atomically useAuxiliaryFile: Bool, encoding enc: String.Encoding) throws
  @available(*, unavailable, renamed: "write(to:atomically:encoding:)")
  public func writeToURL(_ url: URL, atomically useAuxiliaryFile: Bool, encoding enc: String.Encoding) throws
}
public var kCFStringEncodingASCII: CFStringEncoding {
  get
}
extension String {
  public struct Encoding : RawRepresentable {
    public var rawValue: UInt
    public init(rawValue: UInt)
    public static let ascii: Swift.String.Encoding
    public static let nextstep: Swift.String.Encoding
    public static let japaneseEUC: Swift.String.Encoding
    public static let utf8: Swift.String.Encoding
    public static let isoLatin1: Swift.String.Encoding
    public static let symbol: Swift.String.Encoding
    public static let nonLossyASCII: Swift.String.Encoding
    public static let shiftJIS: Swift.String.Encoding
    public static let isoLatin2: Swift.String.Encoding
    public static let unicode: Swift.String.Encoding
    public static let windowsCP1251: Swift.String.Encoding
    public static let windowsCP1252: Swift.String.Encoding
    public static let windowsCP1253: Swift.String.Encoding
    public static let windowsCP1254: Swift.String.Encoding
    public static let windowsCP1250: Swift.String.Encoding
    public static let iso2022JP: Swift.String.Encoding
    public static let macOSRoman: Swift.String.Encoding
    public static let utf16: Swift.String.Encoding
    public static let utf16BigEndian: Swift.String.Encoding
    public static let utf16LittleEndian: Swift.String.Encoding
    public static let utf32: Swift.String.Encoding
    public static let utf32BigEndian: Swift.String.Encoding
    public static let utf32LittleEndian: Swift.String.Encoding
    public typealias RawValue = Swift.UInt
  }
  public typealias EncodingConversionOptions = NSString.EncodingConversionOptions
  public typealias EnumerationOptions = NSString.EnumerationOptions
  public typealias CompareOptions = NSString.CompareOptions
}
extension String.Encoding : Hashable {
  public func hash(into hasher: inout Hasher)
  public static func == (lhs: String.Encoding, rhs: String.Encoding) -> Bool
}
extension String.Encoding : CustomStringConvertible {
  public var description: String {
    get
  }
}
@available(*, unavailable, renamed: "String.Encoding")
public typealias NSStringEncoding = UInt
@available(*, unavailable, renamed: "String.Encoding.ascii")
public var NSASCIIStringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.nextstep")
public var NSNEXTSTEPStringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.japaneseEUC")
public var NSJapaneseEUCStringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf8")
public var NSUTF8StringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.isoLatin1")
public var NSISOLatin1StringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.symbol")
public var NSSymbolStringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.nonLossyASCII")
public var NSNonLossyASCIIStringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.shiftJIS")
public var NSShiftJISStringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.isoLatin2")
public var NSISOLatin2StringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.unicode")
public var NSUnicodeStringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.windowsCP1251")
public var NSWindowsCP1251StringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.windowsCP1252")
public var NSWindowsCP1252StringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.windowsCP1253")
public var NSWindowsCP1253StringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.windowsCP1254")
public var NSWindowsCP1254StringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.windowsCP1250")
public var NSWindowsCP1250StringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.iso2022JP")
public var NSISO2022JPStringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.macOSRoman")
public var NSMacOSRomanStringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf16")
public var NSUTF16StringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf16BigEndian")
public var NSUTF16BigEndianStringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf16LittleEndian")
public var NSUTF16LittleEndianStringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf32")
public var NSUTF32StringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf32BigEndian")
public var NSUTF32BigEndianStringEncoding: String.Encoding {
  get
}
@available(*, unavailable, renamed: "String.Encoding.utf32LittleEndian")
public var NSUTF32LittleEndianStringEncoding: String.Encoding {
  get
}
extension NSTextCheckingResult.CheckingType {
  public static var allSystemTypes: NSTextCheckingResult.CheckingType {
    get
  }
  public static var allCustomTypes: NSTextCheckingResult.CheckingType {
    get
  }
  public static var allTypes: NSTextCheckingResult.CheckingType {
    get
  }
}
extension UndoManager {
  @available(*, unavailable, renamed: "registerUndo(withTarget:handler:)")
  public func registerUndoWithTarget<TargetType>(_ target: TargetType, handler: (TargetType) -> Void) where TargetType : AnyObject
  @available(OSX 10.11, iOS 9.0, *)
  public func registerUndo<TargetType>(withTarget target: TargetType, handler: @escaping (TargetType) -> Void) where TargetType : AnyObject
}
extension NSURL : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSURL.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: PlaygroundQuickLook {
    get
  }
}
extension _NSRange : _ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> NSValue
  public static func _forceBridgeFromObjectiveC(_ source: NSValue, result: inout NSRange?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: NSValue, result: inout NSRange?) -> Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: NSValue?) -> NSRange
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CGRect : _ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> NSValue
  public static func _forceBridgeFromObjectiveC(_ source: NSValue, result: inout CGRect?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: NSValue, result: inout CGRect?) -> Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: NSValue?) -> CGRect
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CGPoint : _ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> NSValue
  public static func _forceBridgeFromObjectiveC(_ source: NSValue, result: inout CGPoint?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: NSValue, result: inout CGPoint?) -> Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: NSValue?) -> CGPoint
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CGVector : _ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> NSValue
  public static func _forceBridgeFromObjectiveC(_ source: NSValue, result: inout CGVector?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: NSValue, result: inout CGVector?) -> Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: NSValue?) -> CGVector
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CGSize : _ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> NSValue
  public static func _forceBridgeFromObjectiveC(_ source: NSValue, result: inout CGSize?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: NSValue, result: inout CGSize?) -> Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: NSValue?) -> CGSize
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension CGAffineTransform : _ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> NSValue
  public static func _forceBridgeFromObjectiveC(_ source: NSValue, result: inout CGAffineTransform?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: NSValue, result: inout CGAffineTransform?) -> Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: NSValue?) -> CGAffineTransform
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension NSValue {
  public func value<StoredType>(of type: StoredType.Type) -> StoredType?
}
@available(OSX 10.11, iOS 9.0, *)
public struct PersonNameComponents : ReferenceConvertible, Hashable, Equatable {
  public typealias ReferenceType = NSPersonNameComponents
  public init()
  public var namePrefix: String? {
    get
    set
  }
  public var givenName: String? {
    get
    set
  }
  public var middleName: String? {
    get
    set
  }
  public var familyName: String? {
    get
    set
  }
  public var nameSuffix: String? {
    get
    set
  }
  public var nickname: String? {
    get
    set
  }
  public var phoneticRepresentation: PersonNameComponents? {
    get
    set
  }
  public func hash(into hasher: inout Hasher)
  @available(OSX 10.11, iOS 9.0, *)
  public static func == (lhs: PersonNameComponents, rhs: PersonNameComponents) -> Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(OSX 10.11, iOS 9.0, *)
extension PersonNameComponents : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
  public var customMirror: Mirror {
    get
  }
}
@available(OSX 10.11, iOS 9.0, *)
extension PersonNameComponents : _ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSPersonNameComponents
  public static func _forceBridgeFromObjectiveC(_ personNameComponents: NSPersonNameComponents, result: inout PersonNameComponents?)
  public static func _conditionallyBridgeFromObjectiveC(_ personNameComponents: NSPersonNameComponents, result: inout PersonNameComponents?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSPersonNameComponents?) -> PersonNameComponents
  public typealias _ObjectiveCType = Foundation.NSPersonNameComponents
}
@available(OSX 10.11, iOS 9.0, *)
extension NSPersonNameComponents : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
@available(OSX 10.11, iOS 9.0, *)
extension PersonNameComponents : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
@_objcRuntimeName(_TtC10Foundation20_PropertyListEncoder) open class PropertyListEncoder {
  open var outputFormat: PropertyListSerialization.PropertyListFormat
  open var userInfo: [CodingUserInfoKey : Any]
  public init()
  open func encode<Value>(_ value: Value) throws -> Data where Value : Swift.Encodable
  @objc deinit
}
@_objcRuntimeName(_TtC10Foundation20_PropertyListDecoder) open class PropertyListDecoder {
  open var userInfo: [CodingUserInfoKey : Any]
  public init()
  open func decode<T>(_ type: T.Type, from data: Data) throws -> T where T : Swift.Decodable
  open func decode<T>(_ type: T.Type, from data: Data, format: inout PropertyListSerialization.PropertyListFormat) throws -> T where T : Swift.Decodable
  @objc deinit
}
extension Progress {
  @available(OSX 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var estimatedTimeRemaining: TimeInterval? {
    get
    set
  }
  @available(OSX 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var throughput: Int? {
    get
    set
  }
  @available(OSX 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var fileTotalCount: Int? {
    get
    set
  }
  @available(OSX 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var fileCompletedCount: Int? {
    get
    set
  }
  public func performAsCurrent<ReturnType>(withPendingUnitCount unitCount: Int64, using work: () throws -> ReturnType) rethrows -> ReturnType
}
public protocol ReferenceConvertible : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.Hashable, Swift._ObjectiveCBridgeable {
  associatedtype ReferenceType : ObjectiveC.NSObject, Foundation.NSCopying
}
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Scanner {
  public enum NumberRepresentation {
    case decimal
    case hexadecimal
    public static func == (a: Foundation.Scanner.NumberRepresentation, b: Foundation.Scanner.NumberRepresentation) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var currentIndex: String.Index {
    get
    set
  }
  public func scanInt(representation: NumberRepresentation = .decimal) -> Int?
  public func scanInt32(representation: NumberRepresentation = .decimal) -> Int32?
  public func scanInt64(representation: NumberRepresentation = .decimal) -> Int64?
  public func scanUInt64(representation: NumberRepresentation = .decimal) -> UInt64?
  public func scanFloat(representation: NumberRepresentation = .decimal) -> Float?
  public func scanDouble(representation: NumberRepresentation = .decimal) -> Double?
  public func scanDecimal() -> Decimal?
  public func scanString(_ searchString: String) -> String?
  public func scanCharacters(from set: CharacterSet) -> String?
  public func scanUpToString(_ substring: String) -> String?
  public func scanUpToCharacters(from set: CharacterSet) -> String?
  public func scanCharacter() -> Character?
}
extension String {
  public init(_ cocoaString: NSString)
}
extension String : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSString
  public static func _forceBridgeFromObjectiveC(_ x: NSString, result: inout String?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSString, result: inout String?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSString?) -> String
  public typealias _ObjectiveCType = Foundation.NSString
}
extension Substring : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSString
  public static func _forceBridgeFromObjectiveC(_ x: NSString, result: inout Substring?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSString, result: inout Substring?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSString?) -> Substring
  public typealias _ObjectiveCType = Foundation.NSString
}
extension String : CVarArg {
}
public struct TimeZone : Hashable, Equatable, ReferenceConvertible {
  public typealias ReferenceType = NSTimeZone
  public static var current: TimeZone {
    get
  }
  public static var autoupdatingCurrent: TimeZone {
    get
  }
  public init?(identifier: __shared String)
  @available(*, unavailable, renamed: "init(secondsFromGMT:)")
  public init(forSecondsFromGMT seconds: Int)
  public init?(secondsFromGMT seconds: Int)
  public init?(abbreviation: __shared String)
  @available(*, unavailable, renamed: "identifier")
  public var name: String {
    get
  }
  public var identifier: String {
    get
  }
  @available(*, unavailable, message: "use the identifier instead")
  public var data: Data {
    get
  }
  public func secondsFromGMT(for date: Date = Date()) -> Int
  public func abbreviation(for date: Date = Date()) -> String?
  public func isDaylightSavingTime(for date: Date = Date()) -> Bool
  public func daylightSavingTimeOffset(for date: Date = Date()) -> TimeInterval
  public func nextDaylightSavingTimeTransition(after date: Date) -> Date?
  public static var knownTimeZoneIdentifiers: [String] {
    get
  }
  public static var abbreviationDictionary: [String : String] {
    get
    set
  }
  public static var timeZoneDataVersion: String {
    get
  }
  public var nextDaylightSavingTimeTransition: Date? {
    get
  }
  @available(*, unavailable, renamed: "localizedName(for:locale:)")
  public func localizedName(_ style: NSTimeZone.NameStyle, locale: Locale?) -> String?
  public func localizedName(for style: NSTimeZone.NameStyle, locale: Locale?) -> String?
  public func hash(into hasher: inout Hasher)
  public static func == (lhs: TimeZone, rhs: TimeZone) -> Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension TimeZone : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  public var customMirror: Mirror {
    get
  }
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
}
extension TimeZone : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSTimeZone
  public static func _forceBridgeFromObjectiveC(_ input: NSTimeZone, result: inout TimeZone?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: NSTimeZone, result: inout TimeZone?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSTimeZone?) -> TimeZone
  public typealias _ObjectiveCType = Foundation.NSTimeZone
}
extension NSTimeZone : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension TimeZone : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
public struct URLResourceValues {
  public init()
  public var allValues: [URLResourceKey : Any] {
    get
  }
  public var name: String? {
    get
    set
  }
  public var localizedName: String? {
    get
  }
  public var isRegularFile: Bool? {
    get
  }
  public var isDirectory: Bool? {
    get
  }
  public var isSymbolicLink: Bool? {
    get
  }
  public var isVolume: Bool? {
    get
  }
  public var isPackage: Bool? {
    get
    set
  }
  @available(OSX 10.11, iOS 9.0, *)
  public var isApplication: Bool? {
    get
  }
  @available(OSX 10.11, *)
  public var applicationIsScriptable: Bool? {
    get
  }
  public var isSystemImmutable: Bool? {
    get
  }
  public var isUserImmutable: Bool? {
    get
    set
  }
  public var isHidden: Bool? {
    get
    set
  }
  public var hasHiddenExtension: Bool? {
    get
    set
  }
  public var creationDate: Date? {
    get
    set
  }
  public var contentAccessDate: Date? {
    get
    set
  }
  public var contentModificationDate: Date? {
    get
    set
  }
  public var attributeModificationDate: Date? {
    get
  }
  public var linkCount: Int? {
    get
  }
  public var parentDirectory: URL? {
    get
  }
  public var volume: URL? {
    get
  }
  public var typeIdentifier: String? {
    get
  }
  public var localizedTypeDescription: String? {
    get
  }
  public var labelNumber: Int? {
    get
    set
  }
  public var localizedLabel: String? {
    get
  }
  public var fileResourceIdentifier: (NSCopying & NSCoding & NSSecureCoding & NSObjectProtocol)? {
    get
  }
  public var volumeIdentifier: (NSCopying & NSCoding & NSSecureCoding & NSObjectProtocol)? {
    get
  }
  public var preferredIOBlockSize: Int? {
    get
  }
  public var isReadable: Bool? {
    get
  }
  public var isWritable: Bool? {
    get
  }
  public var isExecutable: Bool? {
    get
  }
  public var fileSecurity: NSFileSecurity? {
    get
    set
  }
  public var isExcludedFromBackup: Bool? {
    get
    set
  }
  public var tagNames: [String]? {
    get
  }
  public var path: String? {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var canonicalPath: String? {
    get
  }
  public var isMountTrigger: Bool? {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public var generationIdentifier: (NSCopying & NSCoding & NSSecureCoding & NSObjectProtocol)? {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public var documentIdentifier: Int? {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public var addedToDirectoryDate: Date? {
    get
  }
  @available(OSX 10.10, *)
  public var quarantineProperties: [String : Any]? {
    get
    set
  }
  public var fileResourceType: URLFileResourceType? {
    get
  }
  public var volumeLocalizedFormatDescription: String? {
    get
  }
  public var volumeTotalCapacity: Int? {
    get
  }
  public var volumeAvailableCapacity: Int? {
    get
  }
  @available(OSX 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var volumeAvailableCapacityForImportantUsage: Int64? {
    get
  }
  @available(OSX 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var volumeAvailableCapacityForOpportunisticUsage: Int64? {
    get
  }
  public var volumeResourceCount: Int? {
    get
  }
  public var volumeSupportsPersistentIDs: Bool? {
    get
  }
  public var volumeSupportsSymbolicLinks: Bool? {
    get
  }
  public var volumeSupportsHardLinks: Bool? {
    get
  }
  public var volumeSupportsJournaling: Bool? {
    get
  }
  public var volumeIsJournaling: Bool? {
    get
  }
  public var volumeSupportsSparseFiles: Bool? {
    get
  }
  public var volumeSupportsZeroRuns: Bool? {
    get
  }
  public var volumeSupportsCaseSensitiveNames: Bool? {
    get
  }
  public var volumeSupportsCasePreservedNames: Bool? {
    get
  }
  public var volumeSupportsRootDirectoryDates: Bool? {
    get
  }
  public var volumeSupportsVolumeSizes: Bool? {
    get
  }
  public var volumeSupportsRenaming: Bool? {
    get
  }
  public var volumeSupportsAdvisoryFileLocking: Bool? {
    get
  }
  public var volumeSupportsExtendedSecurity: Bool? {
    get
  }
  public var volumeIsBrowsable: Bool? {
    get
  }
  public var volumeMaximumFileSize: Int? {
    get
  }
  public var volumeIsEjectable: Bool? {
    get
  }
  public var volumeIsRemovable: Bool? {
    get
  }
  public var volumeIsInternal: Bool? {
    get
  }
  public var volumeIsAutomounted: Bool? {
    get
  }
  public var volumeIsLocal: Bool? {
    get
  }
  public var volumeIsReadOnly: Bool? {
    get
  }
  public var volumeCreationDate: Date? {
    get
  }
  public var volumeURLForRemounting: URL? {
    get
  }
  public var volumeUUIDString: String? {
    get
  }
  public var volumeName: String? {
    get
    set
  }
  public var volumeLocalizedName: String? {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeIsEncrypted: Bool? {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeIsRootFileSystem: Bool? {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsCompression: Bool? {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsFileCloning: Bool? {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsSwapRenaming: Bool? {
    get
  }
  @available(OSX 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsExclusiveRenaming: Bool? {
    get
  }
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public var volumeSupportsImmutableFiles: Bool? {
    get
  }
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public var volumeSupportsAccessPermissions: Bool? {
    get
  }
  public var isUbiquitousItem: Bool? {
    get
  }
  public var ubiquitousItemHasUnresolvedConflicts: Bool? {
    get
  }
  public var ubiquitousItemIsDownloading: Bool? {
    get
  }
  public var ubiquitousItemIsUploaded: Bool? {
    get
  }
  public var ubiquitousItemIsUploading: Bool? {
    get
  }
  public var ubiquitousItemDownloadingStatus: URLUbiquitousItemDownloadingStatus? {
    get
  }
  public var ubiquitousItemDownloadingError: NSError? {
    get
  }
  public var ubiquitousItemUploadingError: NSError? {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public var ubiquitousItemDownloadRequested: Bool? {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public var ubiquitousItemContainerDisplayName: String? {
    get
  }
  @available(OSX 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousItemIsShared: Bool? {
    get
  }
  @available(OSX 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemCurrentUserRole: URLUbiquitousSharedItemRole? {
    get
  }
  @available(OSX 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemCurrentUserPermissions: URLUbiquitousSharedItemPermissions? {
    get
  }
  @available(OSX 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemOwnerNameComponents: PersonNameComponents? {
    get
  }
  @available(OSX 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemMostRecentEditorNameComponents: PersonNameComponents? {
    get
  }
  public var fileSize: Int? {
    get
  }
  public var fileAllocatedSize: Int? {
    get
  }
  public var totalFileSize: Int? {
    get
  }
  public var totalFileAllocatedSize: Int? {
    get
  }
  public var isAliasFile: Bool? {
    get
  }
}
public struct URL : ReferenceConvertible, Equatable {
  public typealias ReferenceType = NSURL
  public typealias BookmarkResolutionOptions = NSURL.BookmarkResolutionOptions
  public typealias BookmarkCreationOptions = NSURL.BookmarkCreationOptions
  public init?(string: __shared String)
  public init?(string: __shared String, relativeTo url: __shared URL?)
  @available(OSX 10.11, iOS 9.0, *)
  public init(fileURLWithPath path: __shared String, isDirectory: Bool, relativeTo base: __shared URL?)
  @available(OSX 10.11, iOS 9.0, *)
  public init(fileURLWithPath path: __shared String, relativeTo base: __shared URL?)
  public init(fileURLWithPath path: __shared String, isDirectory: Bool)
  public init(fileURLWithPath path: __shared String)
  @available(OSX 10.11, iOS 9.0, *)
  public init?(dataRepresentation: __shared Data, relativeTo url: __shared URL?, isAbsolute: Bool = false)
  @available(swift, obsoleted: 4.2)
  public init?(resolvingBookmarkData data: __shared Data, options: BookmarkResolutionOptions = [], relativeTo url: __shared URL? = nil, bookmarkDataIsStale: inout Bool) throws
  @available(swift 4.2)
  public init(resolvingBookmarkData data: __shared Data, options: BookmarkResolutionOptions = [], relativeTo url: __shared URL? = nil, bookmarkDataIsStale: inout Bool) throws
  @available(OSX 10.10, iOS 8.0, *)
  public init(resolvingAliasFileAt url: __shared URL, options: BookmarkResolutionOptions = []) throws
  public init(fileURLWithFileSystemRepresentation path: UnsafePointer<Int8>, isDirectory: Bool, relativeTo baseURL: __shared URL?)
  public func hash(into hasher: inout Hasher)
  @available(OSX 10.11, iOS 9.0, *)
  public var dataRepresentation: Data {
    get
  }
  public var absoluteString: String {
    get
  }
  public var relativeString: String {
    get
  }
  public var baseURL: URL? {
    get
  }
  public var absoluteURL: URL {
    get
  }
  public var scheme: String? {
    get
  }
  public var isFileURL: Bool {
    get
  }
  @available(*, unavailable, message: "Use `path`, `query`, and `fragment` instead")
  public var resourceSpecifier: String {
    get
  }
  public var host: String? {
    get
  }
  public var port: Int? {
    get
  }
  public var user: String? {
    get
  }
  public var password: String? {
    get
  }
  public var path: String {
    get
  }
  public var relativePath: String {
    get
  }
  public var fragment: String? {
    get
  }
  @available(*, unavailable, message: "use the 'path' property")
  public var parameterString: String? {
    get
  }
  public var query: String? {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  public var hasDirectoryPath: Bool {
    get
  }
  @available(OSX 10.9, iOS 7.0, *)
  public func withUnsafeFileSystemRepresentation<ResultType>(_ block: (UnsafePointer<Int8>?) throws -> ResultType) rethrows -> ResultType
  public var pathComponents: [String] {
    get
  }
  public var lastPathComponent: String {
    get
  }
  public var pathExtension: String {
    get
  }
  public func appendingPathComponent(_ pathComponent: String, isDirectory: Bool) -> URL
  public func appendingPathComponent(_ pathComponent: String) -> URL
  public func deletingLastPathComponent() -> URL
  public func appendingPathExtension(_ pathExtension: String) -> URL
  public func deletingPathExtension() -> URL
  mutating public func appendPathComponent(_ pathComponent: String, isDirectory: Bool)
  mutating public func appendPathComponent(_ pathComponent: String)
  mutating public func appendPathExtension(_ pathExtension: String)
  mutating public func deleteLastPathComponent()
  mutating public func deletePathExtension()
  public var standardized: URL {
    get
  }
  mutating public func standardize()
  public var standardizedFileURL: URL {
    get
  }
  public func resolvingSymlinksInPath() -> URL
  mutating public func resolveSymlinksInPath()
  public func checkResourceIsReachable() throws -> Bool
  @available(OSX 10.10, iOS 8.0, *)
  public func checkPromisedItemIsReachable() throws -> Bool
  mutating public func setResourceValues(_ values: URLResourceValues) throws
  public func resourceValues(forKeys keys: Set<URLResourceKey>) throws -> URLResourceValues
  mutating public func setTemporaryResourceValue(_ value: Any, forKey key: URLResourceKey)
  mutating public func removeAllCachedResourceValues()
  mutating public func removeCachedResourceValue(forKey key: URLResourceKey)
  @available(OSX 10.10, iOS 8.0, *)
  public func promisedItemResourceValues(forKeys keys: Set<URLResourceKey>) throws -> URLResourceValues
  @available(*, unavailable, message: "Use struct URLResourceValues and URL.setResourceValues(_:) instead")
  public func setResourceValue(_ value: AnyObject?, forKey key: URLResourceKey) throws
  @available(*, unavailable, message: "Use struct URLResourceValues and URL.setResourceValues(_:) instead")
  public func setResourceValues(_ keyedValues: [URLResourceKey : AnyObject]) throws
  @available(*, unavailable, message: "Use struct URLResourceValues and URL.setResourceValues(_:) instead")
  public func getResourceValue(_ value: AutoreleasingUnsafeMutablePointer<AnyObject?>, forKey key: URLResourceKey) throws
  public func bookmarkData(options: BookmarkCreationOptions = [], includingResourceValuesForKeys keys: Set<URLResourceKey>? = nil, relativeTo url: URL? = nil) throws -> Data
  public static func resourceValues(forKeys keys: Set<URLResourceKey>, fromBookmarkData data: Data) -> URLResourceValues?
  public static func writeBookmarkData(_ data: Data, to url: URL) throws
  public static func bookmarkData(withContentsOf url: URL) throws -> Data
  @available(OSX 10.7, iOS 8.0, *)
  public func startAccessingSecurityScopedResource() -> Bool
  @available(OSX 10.7, iOS 8.0, *)
  public func stopAccessingSecurityScopedResource()
  public static func == (lhs: URL, rhs: URL) -> Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension URL : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSURL
  public static func _forceBridgeFromObjectiveC(_ source: NSURL, result: inout URL?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: NSURL, result: inout URL?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSURL?) -> URL
  public typealias _ObjectiveCType = Foundation.NSURL
}
extension URL : CustomStringConvertible, CustomDebugStringConvertible {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
}
extension NSURL : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension URL : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "URL.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: PlaygroundQuickLook {
    get
  }
}
extension URL : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
extension URL : _ExpressibleByFileReferenceLiteral {
  public init(fileReferenceLiteralResourceName name: String)
}
public typealias _FileReferenceLiteralType = URL
public struct URLComponents : ReferenceConvertible, Hashable, Equatable {
  public typealias ReferenceType = NSURLComponents
  public init()
  public init?(url: __shared URL, resolvingAgainstBaseURL resolve: Bool)
  public init?(string: __shared String)
  public var url: URL? {
    get
  }
  public func url(relativeTo base: URL?) -> URL?
  @available(OSX 10.10, iOS 8.0, *)
  public var string: String? {
    get
  }
  public var scheme: String? {
    get
    set
  }
  public var user: String? {
    get
    set
  }
  public var password: String? {
    get
    set
  }
  public var host: String? {
    get
    set
  }
  public var port: Int? {
    get
    set
  }
  public var path: String {
    get
    set
  }
  public var query: String? {
    get
    set
  }
  public var fragment: String? {
    get
    set
  }
  public var percentEncodedUser: String? {
    get
    set
  }
  public var percentEncodedPassword: String? {
    get
    set
  }
  public var percentEncodedHost: String? {
    get
    set
  }
  public var percentEncodedPath: String {
    get
    set
  }
  public var percentEncodedQuery: String? {
    get
    set
  }
  public var percentEncodedFragment: String? {
    get
    set
  }
  @available(OSX 10.11, iOS 9.0, *)
  public var rangeOfScheme: Range<String.Index>? {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  public var rangeOfUser: Range<String.Index>? {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  public var rangeOfPassword: Range<String.Index>? {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  public var rangeOfHost: Range<String.Index>? {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  public var rangeOfPort: Range<String.Index>? {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  public var rangeOfPath: Range<String.Index>? {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  public var rangeOfQuery: Range<String.Index>? {
    get
  }
  @available(OSX 10.11, iOS 9.0, *)
  public var rangeOfFragment: Range<String.Index>? {
    get
  }
  @available(OSX 10.10, iOS 8.0, *)
  public var queryItems: [URLQueryItem]? {
    get
    set
  }
  @available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public var percentEncodedQueryItems: [URLQueryItem]? {
    get
    set
  }
  public func hash(into hasher: inout Hasher)
  public static func == (lhs: URLComponents, rhs: URLComponents) -> Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension URLComponents : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
  public var customMirror: Mirror {
    get
  }
}
extension URLComponents : _ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSURLComponents
  public static func _forceBridgeFromObjectiveC(_ x: NSURLComponents, result: inout URLComponents?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSURLComponents, result: inout URLComponents?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSURLComponents?) -> URLComponents
  public typealias _ObjectiveCType = Foundation.NSURLComponents
}
extension NSURLComponents : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
@available(OSX 10.10, iOS 8.0, *)
public struct URLQueryItem : ReferenceConvertible, Hashable, Equatable {
  public typealias ReferenceType = NSURLQueryItem
  public init(name: __shared String, value: __shared String?)
  public var name: String {
    get
    set
  }
  public var value: String? {
    get
    set
  }
  public func hash(into hasher: inout Hasher)
  @available(OSX 10.10, iOS 8.0, *)
  public static func == (lhs: URLQueryItem, rhs: URLQueryItem) -> Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(OSX 10.10, iOS 8.0, *)
extension URLQueryItem : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
  public var customMirror: Mirror {
    get
  }
}
@available(OSX 10.10, iOS 8.0, *)
extension URLQueryItem : _ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSURLQueryItem
  public static func _forceBridgeFromObjectiveC(_ x: NSURLQueryItem, result: inout URLQueryItem?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: NSURLQueryItem, result: inout URLQueryItem?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSURLQueryItem?) -> URLQueryItem
  public typealias _ObjectiveCType = Foundation.NSURLQueryItem
}
@available(OSX 10.10, iOS 8.0, *)
extension NSURLQueryItem : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension URLComponents : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
@available(*, deprecated, message: "Please use the struct type URLRequest")
public typealias MutableURLRequest = NSMutableURLRequest
public struct URLRequest : ReferenceConvertible, Equatable, Hashable {
  public typealias ReferenceType = NSURLRequest
  public typealias CachePolicy = NSURLRequest.CachePolicy
  public typealias NetworkServiceType = NSURLRequest.NetworkServiceType
  public init(url: URL, cachePolicy: CachePolicy = .useProtocolCachePolicy, timeoutInterval: TimeInterval = 60.0)
  public var url: URL? {
    get
    set
  }
  public var cachePolicy: CachePolicy {
    get
    set
  }
  public var timeoutInterval: TimeInterval {
    get
    set
  }
  public var mainDocumentURL: URL? {
    get
    set
  }
  @available(OSX 10.7, iOS 4.0, *)
  public var networkServiceType: NetworkServiceType {
    get
    set
  }
  @available(OSX 10.8, iOS 6.0, *)
  public var allowsCellularAccess: Bool {
    get
    set
  }
  public var httpMethod: String? {
    get
    set
  }
  public var allHTTPHeaderFields: [String : String]? {
    get
    set
  }
  public func value(forHTTPHeaderField field: String) -> String?
  mutating public func setValue(_ value: String?, forHTTPHeaderField field: String)
  mutating public func addValue(_ value: String, forHTTPHeaderField field: String)
  public var httpBody: Data? {
    get
    set
  }
  public var httpBodyStream: InputStream? {
    get
    set
  }
  public var httpShouldHandleCookies: Bool {
    get
    set
  }
  @available(OSX 10.7, iOS 4.0, *)
  public var httpShouldUsePipelining: Bool {
    get
    set
  }
  public func hash(into hasher: inout Hasher)
  public static func == (lhs: URLRequest, rhs: URLRequest) -> Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension URLRequest : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
  public var customMirror: Mirror {
    get
  }
}
extension URLRequest : _ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSURLRequest
  public static func _forceBridgeFromObjectiveC(_ input: NSURLRequest, result: inout URLRequest?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: NSURLRequest, result: inout URLRequest?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSURLRequest?) -> URLRequest
  public typealias _ObjectiveCType = Foundation.NSURLRequest
}
extension NSURLRequest : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
@available(OSX 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLSessionWebSocketTask {
  public enum Message {
    case data(Data)
    case string(String)
  }
  public func send(_ message: Message, completionHandler: @escaping (Error?) -> Void)
  public func receive(completionHandler: @escaping (Result<Message, Error>) -> Void)
}
@available(OSX 10.8, iOS 6.0, *)
public struct UUID : ReferenceConvertible, Hashable, Equatable, CustomStringConvertible {
  public typealias ReferenceType = NSUUID
  public var uuid: uuid_t {
    get
    }
  public init()
  public init?(uuidString string: __shared String)
  public init(uuid: uuid_t)
  public var uuidString: String {
    get
  }
  public func hash(into hasher: inout Hasher)
  public var description: String {
    get
  }
  public var debugDescription: String {
    get
  }
  public static func == (lhs: UUID, rhs: UUID) -> Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension UUID : CustomReflectable {
  public var customMirror: Mirror {
    get
  }
}
extension UUID : _ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> NSUUID
  public static func _forceBridgeFromObjectiveC(_ x: NSUUID, result: inout UUID?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: NSUUID, result: inout UUID?) -> Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: NSUUID?) -> UUID
  public typealias _ObjectiveCType = Foundation.NSUUID
}
extension NSUUID : _HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> AnyHashable?
}
extension UUID : Codable {
  public init(from decoder: Decoder) throws
  public func encode(to encoder: Encoder) throws
}
