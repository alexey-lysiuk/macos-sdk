// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
// swift-module-flags: -target x86_64-apple-ios18.5-macabi -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-experimental-feature VariadicGenerics -enable-experimental-feature ExtensionMacros -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 98.1 -module-name SwiftData
// swift-module-flags-ignorable:  -interface-compiler-version 6.1.2
import Foundation
@_exported import Observation
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public struct ModelConfiguration : Swift.Identifiable, Swift.Hashable {
  public let url: Foundation.URL
  public let name: Swift.String
  public let groupAppContainerIdentifier: Swift.String?
  public let cloudKitContainerIdentifier: Swift.String?
  public let groupContainer: SwiftData.ModelConfiguration.GroupContainer
  public let cloudKitDatabase: SwiftData.ModelConfiguration.CloudKitDatabase
  public var schema: SwiftData.Schema?
  public let allowsSave: Swift.Bool
  public let isStoredInMemoryOnly: Swift.Bool
  @available(swift 5.9)
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public struct CloudKitDatabase {
    public static var automatic: SwiftData.ModelConfiguration.CloudKitDatabase {
      get
    }
    public static var none: SwiftData.ModelConfiguration.CloudKitDatabase {
      get
    }
    public static func `private`(_ privateDBName: Swift.String) -> SwiftData.ModelConfiguration.CloudKitDatabase
  }
  @available(swift 5.9)
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public struct GroupContainer {
    public static var automatic: SwiftData.ModelConfiguration.GroupContainer {
      get
    }
    public static var none: SwiftData.ModelConfiguration.GroupContainer {
      get
    }
    public static func identifier(_ groupName: Swift.String) -> SwiftData.ModelConfiguration.GroupContainer
  }
  public init(isStoredInMemoryOnly: Swift.Bool = false)
  public init(for forTypes: any SwiftData.PersistentModel.Type..., isStoredInMemoryOnly: Swift.Bool = false)
  public init(_ name: Swift.String? = nil, schema: SwiftData.Schema? = nil, isStoredInMemoryOnly: Swift.Bool = false, allowsSave: Swift.Bool = true, groupContainer: SwiftData.ModelConfiguration.GroupContainer = .automatic, cloudKitDatabase: SwiftData.ModelConfiguration.CloudKitDatabase = .automatic)
  public init(_ name: Swift.String? = nil, schema: SwiftData.Schema? = nil, url: Foundation.URL, allowsSave: Swift.Bool = true, cloudKitDatabase: SwiftData.ModelConfiguration.CloudKitDatabase = .automatic)
  public var id: Foundation.URL {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: SwiftData.ModelConfiguration, rhs: SwiftData.ModelConfiguration) -> Swift.Bool
  @available(swift 5.9)
  @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
  public typealias ID = Foundation.URL
  public var hashValue: Swift.Int {
    get
  }
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension SwiftData.ModelConfiguration : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
extension SwiftData.ModelConfiguration : SwiftData.DataStoreConfiguration {
  public typealias Store = SwiftData.DefaultStore
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
  public func validate() throws
}
@_hasMissingDesignatedInitializers @available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
final public class DefaultStore : SwiftData.DataStore, SwiftData.DataStoreBatching {
  public typealias Configuration = SwiftData.ModelConfiguration
  public typealias Snapshot = SwiftData.DefaultSnapshot
  convenience public init(_ configuration: SwiftData.ModelConfiguration, migrationPlan: (any SwiftData.SchemaMigrationPlan.Type)? = nil) throws
  final public let name: Swift.String
  final public let schema: SwiftData.Schema
  final public var identifier: Swift.String {
    get
  }
  final public let configuration: SwiftData.ModelConfiguration
  final public func erase() throws
  final public func initializeState(for editingState: SwiftData.EditingState)
  final public func invalidateState(for editingState: SwiftData.EditingState)
  final public func fetch<T>(_ request: SwiftData.DataStoreFetchRequest<T>) throws -> SwiftData.DataStoreFetchResult<T, SwiftData.DefaultStore.Snapshot> where T : SwiftData.PersistentModel
  final public func fetchCount<T>(_ request: SwiftData.DataStoreFetchRequest<T>) throws -> Swift.Int where T : SwiftData.PersistentModel
  final public func fetchIdentifiers<T>(_ request: SwiftData.DataStoreFetchRequest<T>) throws -> [SwiftData.PersistentIdentifier] where T : SwiftData.PersistentModel
  final public func delete<T>(_ request: SwiftData.DataStoreBatchDeleteRequest<T>) throws where T : SwiftData.PersistentModel
  final public func save(_ request: SwiftData.DataStoreSaveChangesRequest<SwiftData.DefaultStore.Snapshot>) throws -> SwiftData.DataStoreSaveChangesResult<SwiftData.DefaultStore.Snapshot>
  final public func cachedSnapshots(for persistentIdentifiers: [SwiftData.PersistentIdentifier], editingState: SwiftData.EditingState) throws -> [SwiftData.PersistentIdentifier : SwiftData.DefaultStore.Snapshot]
  @objc deinit
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
extension SwiftData.DefaultStore : SwiftData.HistoryProviding {
  public static var historyType: SwiftData.DefaultHistoryTransaction.Type {
    get
  }
  public typealias HistoryType = SwiftData.DefaultHistoryTransaction
  public typealias TokenType = SwiftData.DefaultHistoryToken
  final public func fetchHistory(_ descriptor: SwiftData.HistoryDescriptor<SwiftData.DefaultHistoryTransaction>) throws -> [SwiftData.DefaultHistoryTransaction]
  final public func deleteHistory(_ descriptor: SwiftData.HistoryDescriptor<SwiftData.DefaultHistoryTransaction>) throws
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol ModelActor : _Concurrency.Actor {
  nonisolated var modelContainer: SwiftData.ModelContainer { get }
  nonisolated var modelExecutor: any SwiftData.ModelExecutor { get }
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol ModelExecutor : _Concurrency.Executor {
  var modelContext: SwiftData.ModelContext { get }
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol SerialModelExecutor : SwiftData.ModelExecutor, _Concurrency.SerialExecutor {
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension SwiftData.ModelActor {
  nonisolated public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
  public var modelContext: SwiftData.ModelContext {
    get
  }
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public class DefaultSerialModelExecutor : @unchecked Swift.Sendable, SwiftData.SerialModelExecutor {
  final public let modelContext: SwiftData.ModelContext
  public init(modelContext: SwiftData.ModelContext)
  @objc deinit
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension SwiftData.DefaultSerialModelExecutor : _Concurrency.SerialExecutor {
  public func enqueue(_ job: __owned _Concurrency.ExecutorJob)
  public func asUnownedSerialExecutor() -> _Concurrency.UnownedSerialExecutor
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension SwiftData.ModelActor {
  public subscript<T>(id: SwiftData.PersistentIdentifier, as as: T.Type) -> T? where T : SwiftData.PersistentModel {
    get
  }
}
@_hasMissingDesignatedInitializers @available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public class ModelContainer : Swift.Equatable, @unchecked Swift.Sendable {
  final public let schema: SwiftData.Schema
  final public let migrationPlan: (any SwiftData.SchemaMigrationPlan.Type)?
  public var configurations: Swift.Set<SwiftData.ModelConfiguration> {
    get
    set
  }
  @_Concurrency.MainActor public var mainContext: SwiftData.ModelContext {
    get
  }
  public static func == (lhs: SwiftData.ModelContainer, rhs: SwiftData.ModelContainer) -> Swift.Bool
  convenience public init(for forTypes: any SwiftData.PersistentModel.Type..., migrationPlan: (any SwiftData.SchemaMigrationPlan.Type)? = nil, configurations: SwiftData.ModelConfiguration...) throws
  convenience public init(for givenSchema: SwiftData.Schema, migrationPlan: (any SwiftData.SchemaMigrationPlan.Type)? = nil, configurations: SwiftData.ModelConfiguration...) throws
  public init(for givenSchema: SwiftData.Schema, migrationPlan: (any SwiftData.SchemaMigrationPlan.Type)? = nil, configurations: [SwiftData.ModelConfiguration]) throws
  @available(swift 5.9)
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
  convenience public init(for forTypes: any SwiftData.PersistentModel.Type..., configurations: any SwiftData.DataStoreConfiguration...) throws
  @available(swift 5.9)
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
  public init(for givenSchema: SwiftData.Schema, configurations: [any SwiftData.DataStoreConfiguration]) throws
  @objc deinit
  @available(macOS, introduced: 14.0, deprecated: 100000.0, renamed: "erase", message: "deleteAllData has been replaced by `erase`. Use `erase` to completely remove all of the data from a store.")
  @available(iOS, introduced: 17.0, deprecated: 100000.0, renamed: "erase", message: "deleteAllData has been replaced by `erase`. Use `erase` to completely remove all of the data from a store.")
  @available(watchOS, introduced: 10.0, deprecated: 100000.0, renamed: "erase", message: "deleteAllData has been replaced by `erase`. Use `erase` to completely remove all of the data from a store.")
  @available(tvOS, introduced: 17.0, deprecated: 100000.0, renamed: "erase", message: "deleteAllData has been replaced by `erase`. Use `erase` to completely remove all of the data from a store.")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, renamed: "erase", message: "deleteAllData has been replaced by `erase`. Use `erase` to completely remove all of the data from a store.")
  public func deleteAllData()
  @available(swift 5.9)
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
  public func erase() throws
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public protocol DataStore : AnyObject {
  associatedtype Configuration : SwiftData.DataStoreConfiguration where Self == Self.Configuration.Store
  associatedtype Snapshot : SwiftData.DataStoreSnapshot
  var identifier: Swift.String { get }
  var schema: SwiftData.Schema { get }
  var configuration: Self.Configuration { get }
  init(_ configuration: Self.Configuration, migrationPlan: (any SwiftData.SchemaMigrationPlan.Type)?) throws
  func erase() throws
  func fetch<T>(_ request: SwiftData.DataStoreFetchRequest<T>) throws -> SwiftData.DataStoreFetchResult<T, Self.Snapshot> where T : SwiftData.PersistentModel
  func fetchCount<T>(_ request: SwiftData.DataStoreFetchRequest<T>) throws -> Swift.Int where T : SwiftData.PersistentModel
  func fetchIdentifiers<T>(_ request: SwiftData.DataStoreFetchRequest<T>) throws -> [SwiftData.PersistentIdentifier] where T : SwiftData.PersistentModel
  func save(_ request: SwiftData.DataStoreSaveChangesRequest<Self.Snapshot>) throws -> SwiftData.DataStoreSaveChangesResult<Self.Snapshot>
  func initializeState(for editingState: SwiftData.EditingState)
  func invalidateState(for editingState: SwiftData.EditingState)
  func cachedSnapshots(for persistentIdentifiers: [SwiftData.PersistentIdentifier], editingState: SwiftData.EditingState) throws -> [SwiftData.PersistentIdentifier : Self.Snapshot]
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 10, visionOS 2, *)
public enum DataStoreError : Swift.Error {
  case unsupportedFeature
  case preferInMemoryFilter
  case preferInMemorySort
  case invalidPredicate
  public static func == (a: SwiftData.DataStoreError, b: SwiftData.DataStoreError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public protocol DataStoreConfiguration : Swift.Hashable {
  associatedtype Store : SwiftData.DataStore where Self == Self.Store.Configuration
  var name: Swift.String { get }
  var schema: SwiftData.Schema? { get set }
  func validate() throws
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public typealias DataStoreSnapshotValue = Swift.Codable & Swift.Sendable
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public protocol DataStoreSnapshot : Swift.Decodable, Swift.Encodable, Swift.Sendable {
  var persistentIdentifier: SwiftData.PersistentIdentifier { get }
  init(from: any SwiftData.BackingData, relatedBackingDatas: inout [SwiftData.PersistentIdentifier : any SwiftData.BackingData])
  func copy(persistentIdentifier: SwiftData.PersistentIdentifier, remappedIdentifiers: [SwiftData.PersistentIdentifier : SwiftData.PersistentIdentifier]?) -> Self
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public enum DataStoreSnapshotCodingKey : Swift.CodingKey {
  case persistentIdentifier
  case modeledProperty(Swift.String)
  public var stringValue: Swift.String {
    get
  }
  public init?(stringValue: Swift.String)
  public var intValue: Swift.Int? {
    get
  }
  public init?(intValue: Swift.Int)
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public struct DefaultSnapshot : SwiftData.DataStoreSnapshot {
  public let persistentIdentifier: SwiftData.PersistentIdentifier
  public init(from backingData: any SwiftData.BackingData, relatedBackingDatas: inout [SwiftData.PersistentIdentifier : any SwiftData.BackingData])
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public func copy(persistentIdentifier: SwiftData.PersistentIdentifier, remappedIdentifiers: [SwiftData.PersistentIdentifier : SwiftData.PersistentIdentifier]? = [:]) -> SwiftData.DefaultSnapshot
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public struct DataStoreFetchRequest<T> : Swift.Sendable where T : SwiftData.PersistentModel {
  public let editingState: SwiftData.EditingState
  public let descriptor: SwiftData.FetchDescriptor<T>
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public struct DataStoreFetchResult<ModelType, SnapshotType> : Swift.Sendable where ModelType : SwiftData.PersistentModel, SnapshotType : SwiftData.DataStoreSnapshot {
  public let descriptor: SwiftData.FetchDescriptor<ModelType>
  public let fetchedSnapshots: [SnapshotType]
  public let relatedSnapshots: [SwiftData.PersistentIdentifier : SnapshotType]
  public init(descriptor: SwiftData.FetchDescriptor<ModelType>, fetchedSnapshots: [SnapshotType], relatedSnapshots: [SwiftData.PersistentIdentifier : SnapshotType] = [:])
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public struct DataStoreSaveChangesRequest<SnapshotType> : Swift.Sendable where SnapshotType : SwiftData.DataStoreSnapshot {
  public let inserted: [SnapshotType]
  public let updated: [SnapshotType]
  public let deleted: [SnapshotType]
  public let editingState: SwiftData.EditingState
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
final public class DataStoreSaveChangesResult<T> : Swift.Sendable where T : SwiftData.DataStoreSnapshot {
  final public let remappedIdentifiers: [SwiftData.PersistentIdentifier : SwiftData.PersistentIdentifier]
  final public let storeIdentifier: Swift.String
  final public let snapshotsToReregister: [SwiftData.PersistentIdentifier : T]
  public init(for storeIdentifier: Swift.String, remappedIdentifiers: [SwiftData.PersistentIdentifier : SwiftData.PersistentIdentifier] = [:], snapshotsToReregister: [SwiftData.PersistentIdentifier : T] = [:])
  @objc deinit
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public protocol DataStoreBatching : SwiftData.DataStore {
  func delete<T>(_ request: SwiftData.DataStoreBatchDeleteRequest<T>) throws where T : SwiftData.PersistentModel
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public struct DataStoreBatchDeleteRequest<T> : Swift.Sendable where T : SwiftData.PersistentModel {
  public let editingState: SwiftData.EditingState
  public let predicate: Foundation.Predicate<T>?
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public struct EditingState : Swift.Identifiable, Swift.Sendable {
  public typealias ID = Foundation.UUID
  public let id: Foundation.UUID
  public var author: Swift.String?
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
extension SwiftData.DataStoreConfiguration {
  public func validate() throws
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
extension SwiftData.DataStore {
  public func fetchCount<T>(_ request: SwiftData.DataStoreFetchRequest<T>) throws -> Swift.Int where T : SwiftData.PersistentModel
  public func fetchIdentifiers<T>(_ request: SwiftData.DataStoreFetchRequest<T>) throws -> [SwiftData.PersistentIdentifier] where T : SwiftData.PersistentModel
  public func erase() throws
  public func initializeState(for editingState: SwiftData.EditingState)
  public func invalidateState(for editingState: SwiftData.EditingState)
  public func cachedSnapshots(for persistentIdentifiers: [SwiftData.PersistentIdentifier], editingState: SwiftData.EditingState) throws -> [SwiftData.PersistentIdentifier : Self.Snapshot]
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public struct SwiftDataError : Swift.Error, Swift.Hashable {
  public static func == (lhs: SwiftData.SwiftDataError, rhs: SwiftData.SwiftDataError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static let includePendingChangesWithBatchSize: SwiftData.SwiftDataError
  public static let unsupportedPredicate: SwiftData.SwiftDataError
  public static let unsupportedKeyPath: SwiftData.SwiftDataError
  public static let sortingPendingChangesWithIdentifiers: SwiftData.SwiftDataError
  public static let unsupportedSortDescriptor: SwiftData.SwiftDataError
  public static let duplicateConfiguration: SwiftData.SwiftDataError
  public static let configurationFileNameTooLong: SwiftData.SwiftDataError
  public static let configurationFileNameContainsInvalidCharacters: SwiftData.SwiftDataError
  public static let configurationSchemaNotFoundInContainerSchema: SwiftData.SwiftDataError
  public static let loadIssueModelContainer: SwiftData.SwiftDataError
  public static let modelValidationFailure: SwiftData.SwiftDataError
  public static let missingModelContext: SwiftData.SwiftDataError
  public static let backwardMigration: SwiftData.SwiftDataError
  public static let unknownSchema: SwiftData.SwiftDataError
  @available(swift 5.9)
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
  public static let historyTokenExpired: SwiftData.SwiftDataError
  @available(swift 5.9)
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
  public static let invalidTransactionFetchRequest: SwiftData.SwiftDataError
  public var hashValue: Swift.Int {
    get
  }
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
extension SwiftData.SwiftDataError {
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
  public static func ~= (lhs: SwiftData.SwiftDataError, rhs: any Swift.Error) -> Swift.Bool
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public class ModelContext : Swift.Equatable {
  @available(swift 5.9)
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
  public var author: Swift.String? {
    get
    set
  }
  public var undoManager: Foundation.UndoManager? {
    get
    set
  }
  public var insertedModelsArray: [any SwiftData.PersistentModel] {
    get
  }
  public var changedModelsArray: [any SwiftData.PersistentModel] {
    get
  }
  public var deletedModelsArray: [any SwiftData.PersistentModel] {
    get
  }
  @available(swift 5.9)
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
  public var editingState: SwiftData.EditingState
  public var container: SwiftData.ModelContainer {
    get
  }
  public var autosaveEnabled: Swift.Bool {
    get
    set
  }
  public init(_ container: SwiftData.ModelContainer)
  @objc deinit
  public static func == (lhs: SwiftData.ModelContext, rhs: SwiftData.ModelContext) -> Swift.Bool
  public var hasChanges: Swift.Bool {
    get
  }
  public func model(for persistentModelID: SwiftData.PersistentIdentifier) -> any SwiftData.PersistentModel
  public func registeredModel<T>(for persistentModelID: SwiftData.PersistentIdentifier) -> T? where T : SwiftData.PersistentModel
  public func insert<T>(_ model: T) where T : SwiftData.PersistentModel
  public func rollback()
  public func processPendingChanges()
  public func delete<T>(model: T.Type, where predicate: Foundation.Predicate<T>? = nil, includeSubclasses: Swift.Bool = true) throws where T : SwiftData.PersistentModel
  public func delete<T>(_ model: T) where T : SwiftData.PersistentModel
  public func transaction(block: () throws -> Swift.Void) throws
  public func save() throws
  public func enumerate<T>(_ fetch: SwiftData.FetchDescriptor<T>, batchSize: Swift.Int = 5000, allowEscapingMutations: Swift.Bool = false, block: (_ model: T) throws -> Swift.Void) throws where T : SwiftData.PersistentModel
  public func fetch<T>(_ descriptor: SwiftData.FetchDescriptor<T>) throws -> [T] where T : SwiftData.PersistentModel
  public func fetchCount<T>(_ descriptor: SwiftData.FetchDescriptor<T>) throws -> Swift.Int where T : SwiftData.PersistentModel
  public func fetch<T>(_ descriptor: SwiftData.FetchDescriptor<T>, batchSize: Swift.Int) throws -> SwiftData.FetchResultsCollection<T> where T : SwiftData.PersistentModel
  public func fetchIdentifiers<T>(_ descriptor: SwiftData.FetchDescriptor<T>) throws -> [SwiftData.PersistentIdentifier] where T : SwiftData.PersistentModel
  public func fetchIdentifiers<T>(_ descriptor: SwiftData.FetchDescriptor<T>, batchSize: Swift.Int) throws -> SwiftData.FetchResultsCollection<SwiftData.PersistentIdentifier> where T : SwiftData.PersistentModel
  public static let willSave: Foundation.Notification.Name
  public static let didSave: Foundation.Notification.Name
  public enum NotificationKey : Swift.String {
    case queryGeneration
    case invalidatedAllIdentifiers
    case insertedIdentifiers
    case updatedIdentifiers
    case deletedIdentifiers
    public init?(rawValue: Swift.String)
    @available(swift 5.9)
    @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @available(swift 5.9)
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
  public func fetchHistory<T>(_ descriptor: SwiftData.HistoryDescriptor<T>) throws -> [T] where T : SwiftData.HistoryTransaction
  @available(swift 5.9)
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
  public func deleteHistory<T>(_ descriptor: SwiftData.HistoryDescriptor<T>) throws where T : SwiftData.HistoryTransaction
}
@available(*, unavailable, message: "contexts cannot be shared across concurrency contexts")
extension SwiftData.ModelContext : @unchecked Swift.Sendable {
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
@attached(member, names: named(_$backingData), named(persistentBackingData), named(schemaMetadata), named(init), named(_$observationRegistrar), named(_SwiftDataNoType), named(access), named(withMutation)) @attached(memberAttribute) @attached(extension, conformances: Observation.Observable, SwiftData.PersistentModel, Swift.Sendable) public macro Model() = #externalMacro(module: "SwiftDataMacros", type: "PersistentModelMacro")
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
@attached(member, names: named(modelExecutor), named(modelContainer), named(init)) @attached(extension, conformances: SwiftData.ModelActor) public macro ModelActor() = #externalMacro(module: "SwiftDataMacros", type: "PersistentModelActorMacro")
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
@attached(peer) public macro Attribute(_ options: SwiftData.Schema.Attribute.Option..., originalName: Swift.String? = nil, hashModifier: Swift.String? = nil) = #externalMacro(module: "SwiftDataMacros", type: "AttributePropertyMacro")
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
@attached(peer) public macro Relationship(_ options: SwiftData.Schema.Relationship.Option..., deleteRule: SwiftData.Schema.Relationship.DeleteRule = .nullify, minimumModelCount: Swift.Int? = 0, maximumModelCount: Swift.Int? = 0, originalName: Swift.String? = nil, inverse: Swift.AnyKeyPath? = nil, hashModifier: Swift.String? = nil) = #externalMacro(module: "SwiftDataMacros", type: "RelationshipPropertyMacro")
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
@attached(peer) public macro Transient() = #externalMacro(module: "SwiftDataMacros", type: "TransientPropertyMacro")
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
@freestanding(declaration) public macro Unique<T>(_ constraints: [Swift.PartialKeyPath<T>]...) = #externalMacro(module: "SwiftDataMacros", type: "UniqueConstraintsMacro") where T : SwiftData.PersistentModel
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
@freestanding(declaration) public macro Index<T>(_ indices: SwiftData.Schema.Index<T>.Types<T>...) = #externalMacro(module: "SwiftDataMacros", type: "IndexMacro") where T : SwiftData.PersistentModel
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
@freestanding(declaration) public macro Index<T>(_ indices: [Swift.PartialKeyPath<T>]...) = #externalMacro(module: "SwiftDataMacros", type: "IndexMacro") where T : SwiftData.PersistentModel
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
@attached(accessor, names: named(init), named(get), named(set)) @attached(peer, names: prefixed(`_`)) public macro _PersistedProperty() = #externalMacro(module: "SwiftDataMacros", type: "PersistedPropertyMacro")
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
@attached(accessor, names: named(init), named(get), named(set)) @attached(peer, names: prefixed(`_`)) public macro _TransformablePersistedProperty() = #externalMacro(module: "SwiftDataMacros", type: "TransformablePersistedPropertyMacro")
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol PersistentModel : AnyObject, Observation.Observable, Swift.Hashable, Swift.Identifiable {
  init(backingData: any SwiftData.BackingData<Self>)
  var persistentBackingData: any SwiftData.BackingData<Self> { get set }
  static var schemaMetadata: [SwiftData.Schema.PropertyMetadata] { get }
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension SwiftData.PersistentModel {
  public static func createBackingData<P>() -> some SwiftData.BackingData<P> where P : SwiftData.PersistentModel
  
  @_disfavoredOverload public func getValue<Value>(forKey: Swift.KeyPath<Self, Value>) -> Value where Value : Swift.Decodable
  public func getValue<Value>(forKey: Swift.KeyPath<Self, Value>) -> Value where Value : SwiftData.PersistentModel
  public func getValue<Value>(forKey: Swift.KeyPath<Self, Value?>) -> Value? where Value : SwiftData.PersistentModel
  public func getValue<Value, OtherModel>(forKey: Swift.KeyPath<Self, Value>) -> Value where Value : SwiftData.RelationshipCollection, OtherModel == Value.PersistentElement
  public func getValue<Value, OtherModel>(forKey: Swift.KeyPath<Self, Value>) -> Value where Value : Swift.Decodable, Value : SwiftData.RelationshipCollection, OtherModel == Value.PersistentElement
  public func getTransformableValue<Value>(forKey: Swift.KeyPath<Self, Value>) -> Value
  @_disfavoredOverload public func setValue<Value>(forKey: Swift.KeyPath<Self, Value>, to newValue: Value) where Value : Swift.Encodable
  public func setValue<Value>(forKey: Swift.KeyPath<Self, Value>, to newValue: Value) where Value : SwiftData.PersistentModel
  public func setValue<Value>(forKey: Swift.KeyPath<Self, Value?>, to newValue: Value?) where Value : SwiftData.PersistentModel
  public func setValue<Value, OtherModel>(forKey: Swift.KeyPath<Self, Value>, to newValue: Value) where Value : SwiftData.RelationshipCollection, OtherModel == Value.PersistentElement
  public func setValue<Value, OtherModel>(forKey: Swift.KeyPath<Self, Value>, to newValue: Value) where Value : Swift.Encodable, Value : SwiftData.RelationshipCollection, OtherModel == Value.PersistentElement
  public func setTransformableValue<Value>(forKey: Swift.KeyPath<Self, Value>, to newValue: Value)
  public var modelContext: SwiftData.ModelContext? {
    get
  }
  public var persistentModelID: SwiftData.PersistentIdentifier {
    get
  }
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var id: SwiftData.PersistentIdentifier {
    get
  }
  public var hasChanges: Swift.Bool {
    get
  }
  public var isDeleted: Swift.Bool {
    get
  }
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public protocol HistoryTransaction : Swift.Hashable, Swift.Identifiable, Swift.Sendable {
  associatedtype TokenType : Swift.Comparable, Swift.Hashable, Swift.Identifiable, Swift.Sendable
  associatedtype TransactionIdentifier : Swift.Comparable, Swift.Hashable, Swift.Sendable
  var timestamp: Foundation.Date { get }
  var changes: [SwiftData.HistoryChange] { get }
  var token: Self.TokenType { get }
  var transactionIdentifier: Self.TransactionIdentifier { get }
  var storeIdentifier: Swift.String { get }
  var author: Swift.String? { get }
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public enum HistoryChange : Swift.Sendable {
  public var changedPersistentIdentifier: SwiftData.PersistentIdentifier {
    get
  }
  case insert(any SwiftData.HistoryInsert)
  case update(any SwiftData.HistoryUpdate)
  case delete(any SwiftData.HistoryDelete)
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public protocol HistoryInsert<Model> : Swift.Sendable {
  associatedtype Model : SwiftData.PersistentModel
  associatedtype TransactionIdentifier : Swift.Comparable, Swift.Hashable, Swift.Sendable
  associatedtype ChangeIdentifier : Swift.Comparable, Swift.Hashable, Swift.Sendable
  var changeIdentifier: Self.ChangeIdentifier { get }
  var transactionIdentifier: Self.TransactionIdentifier { get }
  var changedPersistentIdentifier: SwiftData.PersistentIdentifier { get }
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public protocol HistoryUpdate<Model> : Swift.Sendable {
  associatedtype Model : SwiftData.PersistentModel
  associatedtype TransactionIdentifier : Swift.Comparable, Swift.Hashable, Swift.Sendable
  associatedtype ChangeIdentifier : Swift.Comparable, Swift.Hashable, Swift.Sendable
  typealias PropertyUpdate = Swift.PartialKeyPath<Self.Model> & Swift.Sendable
  var changeIdentifier: Self.ChangeIdentifier { get }
  var transactionIdentifier: Self.TransactionIdentifier { get }
  var changedPersistentIdentifier: SwiftData.PersistentIdentifier { get }
  var updatedAttributes: [any Swift.PartialKeyPath<Self.Model> & Swift.Sendable] { get }
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public protocol HistoryDelete<Model> : Swift.Sendable {
  associatedtype Model : SwiftData.PersistentModel
  associatedtype TransactionIdentifier : Swift.Comparable, Swift.Hashable, Swift.Sendable
  associatedtype ChangeIdentifier : Swift.Comparable, Swift.Hashable, Swift.Sendable
  var changeIdentifier: Self.ChangeIdentifier { get }
  var transactionIdentifier: Self.TransactionIdentifier { get }
  var changedPersistentIdentifier: SwiftData.PersistentIdentifier { get }
  var tombstone: SwiftData.HistoryTombstone<Self.Model> { get }
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public protocol HistoryToken : Swift.Comparable, Swift.Decodable, Swift.Encodable, Swift.Hashable, Swift.Identifiable, Swift.Sendable {
  associatedtype TokenType : Swift.Decodable, Swift.Encodable, Swift.Hashable, Swift.Sendable
  var tokenValue: Self.TokenType? { get }
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public struct HistoryTombstone<Model> : Swift.Sequence, @unchecked Swift.Sendable where Model : SwiftData.PersistentModel {
  @available(swift 5.9)
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
  public struct Iterator : Swift.IteratorProtocol {
    public mutating func next() -> Any?
    @available(swift 5.9)
    @available(iOS 18, tvOS 18, watchOS 11, visionOS 2, macOS 15, *)
    public typealias Element = Any
  }
  public subscript(keyPath: Swift.PartialKeyPath<Model>) -> (any Swift.Sendable)? {
    get
  }
  public func makeIterator() -> SwiftData.HistoryTombstone<Model>.Iterator
  @available(swift 5.9)
  @available(iOS 18, tvOS 18, watchOS 11, visionOS 2, macOS 15, *)
  public typealias Element = Any
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public struct HistoryDescriptor<TransactionType> where TransactionType : SwiftData.HistoryTransaction {
  public var predicate: Foundation.Predicate<TransactionType>?
  public var fetchLimit: Swift.UInt64
  public init(predicate: Foundation.Predicate<TransactionType>? = nil)
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public protocol HistoryProviding {
  associatedtype HistoryType : SwiftData.HistoryTransaction
  static var historyType: Self.HistoryType.Type { get }
  func fetchHistory(_ descriptor: SwiftData.HistoryDescriptor<Self.HistoryType>) throws -> [Self.HistoryType]
  func deleteHistory(_ descriptor: SwiftData.HistoryDescriptor<Self.HistoryType>) throws
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public struct DefaultHistoryTransaction : SwiftData.HistoryTransaction {
  public typealias TransactionIdentifier = Swift.Int64
  public typealias TokenType = SwiftData.DefaultHistoryToken
  public var id: Swift.Int64 {
    get
  }
  public let timestamp: Foundation.Date
  public let changes: [SwiftData.HistoryChange]
  public let token: SwiftData.DefaultHistoryTransaction.TokenType
  public let transactionIdentifier: SwiftData.DefaultHistoryTransaction.TransactionIdentifier
  public let storeIdentifier: Swift.String
  public let bundleIdentifier: Swift.String
  public let processIdentifier: Swift.String
  public let author: Swift.String?
  public static func == (lhs: SwiftData.DefaultHistoryTransaction, rhs: SwiftData.DefaultHistoryTransaction) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(swift 5.9)
  @available(iOS 18, tvOS 18, watchOS 11, visionOS 2, macOS 15, *)
  public typealias ID = Swift.Int64
  public var hashValue: Swift.Int {
    get
  }
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public struct DefaultHistoryInsert<Model> : SwiftData.HistoryInsert where Model : SwiftData.PersistentModel {
  public typealias TransactionIdentifier = Swift.Int64
  public typealias ChangeIdentifier = Swift.Int64
  public let changeIdentifier: SwiftData.DefaultHistoryInsert<Model>.ChangeIdentifier
  public let transactionIdentifier: SwiftData.DefaultHistoryInsert<Model>.TransactionIdentifier
  public let changedPersistentIdentifier: SwiftData.PersistentIdentifier
  public static func == (lhs: SwiftData.DefaultHistoryInsert<Model>, rhs: SwiftData.DefaultHistoryInsert<Model>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public struct DefaultHistoryUpdate<Model> : SwiftData.HistoryUpdate where Model : SwiftData.PersistentModel {
  public typealias TransactionIdentifier = Swift.Int64
  public typealias ChangeIdentifier = Swift.Int64
  public typealias PropertyUpdate = Swift.PartialKeyPath<Model> & Swift.Sendable
  public let changeIdentifier: SwiftData.DefaultHistoryUpdate<Model>.ChangeIdentifier
  public let transactionIdentifier: SwiftData.DefaultHistoryUpdate<Model>.TransactionIdentifier
  public let changedPersistentIdentifier: SwiftData.PersistentIdentifier
  public let updatedAttributes: [any Swift.PartialKeyPath<Model> & Swift.Sendable]
  public static func == (lhs: SwiftData.DefaultHistoryUpdate<Model>, rhs: SwiftData.DefaultHistoryUpdate<Model>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public struct DefaultHistoryDelete<Model> : SwiftData.HistoryDelete where Model : SwiftData.PersistentModel {
  public typealias TransactionIdentifier = Swift.Int64
  public typealias ChangeIdentifier = Swift.Int64
  public let changeIdentifier: SwiftData.DefaultHistoryDelete<Model>.ChangeIdentifier
  public let transactionIdentifier: SwiftData.DefaultHistoryDelete<Model>.TransactionIdentifier
  public let changedPersistentIdentifier: SwiftData.PersistentIdentifier
  public let tombstone: SwiftData.HistoryTombstone<Model>
  public static func == (lhs: SwiftData.DefaultHistoryDelete<Model>, rhs: SwiftData.DefaultHistoryDelete<Model>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
public struct DefaultHistoryToken : SwiftData.HistoryToken, Swift.Comparable & Swift.Hashable & Swift.Identifiable & Swift.Sendable, Swift.Codable {
  public typealias TokenType = [Swift.String : Swift.Int64]
  public var id: Swift.Int {
    get
  }
  public var tokenValue: SwiftData.DefaultHistoryToken.TokenType? {
    get
  }
  public static func == (lhs: SwiftData.DefaultHistoryToken, rhs: SwiftData.DefaultHistoryToken) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func < (lhs: SwiftData.DefaultHistoryToken, rhs: SwiftData.DefaultHistoryToken) -> Swift.Bool
  @available(swift 5.9)
  @available(iOS 18, tvOS 18, watchOS 11, visionOS 2, macOS 15, *)
  public typealias ID = Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public enum MigrationStage {
  case lightweight(fromVersion: any SwiftData.VersionedSchema.Type, toVersion: any SwiftData.VersionedSchema.Type)
  case custom(fromVersion: any SwiftData.VersionedSchema.Type, toVersion: any SwiftData.VersionedSchema.Type, willMigrate: ((_ context: SwiftData.ModelContext) throws -> Swift.Void)?, didMigrate: ((_ context: SwiftData.ModelContext) throws -> Swift.Void)?)
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol VersionedSchema {
  static var models: [any SwiftData.PersistentModel.Type] { get }
  static var versionIdentifier: SwiftData.Schema.Version { get }
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol SchemaMigrationPlan {
  static var schemas: [any SwiftData.VersionedSchema.Type] { get }
  static var stages: [SwiftData.MigrationStage] { get }
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
final public class Schema : Swift.Codable, Swift.Hashable {
  public static let schemaEncodingVersion: SwiftData.Schema.Version
  final public let encodingVersion: SwiftData.Schema.Version
  final public let version: SwiftData.Schema.Version
  final public let entities: [SwiftData.Schema.Entity]
  final public let entitiesByName: [Swift.String : SwiftData.Schema.Entity]
  public init()
  public init(_ entities: SwiftData.Schema.Entity..., version: SwiftData.Schema.Version = Version(1, 0, 0))
  public init(_ types: [any SwiftData.PersistentModel.Type], version: SwiftData.Schema.Version = Version(1, 0, 0))
  convenience public init(versionedSchema: any SwiftData.VersionedSchema.Type)
  public init(from decoder: any Swift.Decoder) throws
  final public func encode(to encoder: any Swift.Encoder) throws
  public static func == (lhs: SwiftData.Schema, rhs: SwiftData.Schema) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public func save(to toURL: Foundation.URL) throws
  public static func load(from fromURL: Foundation.URL) throws -> SwiftData.Schema
  @available(swift 5.9)
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
  final public func entity<T>(for type: T.Type) -> SwiftData.Schema.Entity? where T : SwiftData.PersistentModel
  @available(swift 5.9)
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
  public static func entityName<T>(for type: T.Type) -> Swift.String where T : SwiftData.PersistentModel
  public struct Version : Swift.Codable, Swift.Comparable, Swift.CustomStringConvertible, Swift.Hashable {
    public let major: Swift.Int
    public let minor: Swift.Int
    public let patch: Swift.Int
    public init(_ major: Swift.Int, _ minor: Swift.Int, _ patch: Swift.Int)
    @inlinable public static func == (lhs: SwiftData.Schema.Version, rhs: SwiftData.Schema.Version) -> Swift.Bool {
            !(lhs < rhs) && !(lhs > rhs)
        }
    public static func < (lhs: SwiftData.Schema.Version, rhs: SwiftData.Schema.Version) -> Swift.Bool
    public var description: Swift.String {
      get
    }
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  @available(swift 5.9)
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public struct PropertyMetadata {
    public init(name: Swift.String, keypath: Swift.AnyKeyPath, defaultValue: Any? = nil, metadata: (any SwiftData.SchemaProperty)? = nil)
  }
  @objc deinit
  final public var hashValue: Swift.Int {
    get
  }
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension SwiftData.Schema : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public struct FetchDescriptor<T> where T : SwiftData.PersistentModel {
  public var predicate: Foundation.Predicate<T>?
  public var sortBy: [Foundation.SortDescriptor<T>]
  public var fetchLimit: Swift.Int?
  public var fetchOffset: Swift.Int?
  public var includePendingChanges: Swift.Bool
  public var propertiesToFetch: [Swift.PartialKeyPath<T>]
  public var relationshipKeyPathsForPrefetching: [Swift.PartialKeyPath<T>]
  public init(predicate: Foundation.Predicate<T>? = nil, sortBy: [Foundation.SortDescriptor<T>] = [])
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
extension SwiftData.FetchDescriptor : @unchecked Swift.Sendable {
}
extension SwiftData.Schema {
  @available(swift 5.9)
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  final public class Entity : Swift.Codable, Swift.Hashable, Swift.CustomDebugStringConvertible {
    final public var name: Swift.String
    final public var subentities: Swift.Set<SwiftData.Schema.Entity>
    final public var superentityName: Swift.String?
    final public var superentity: SwiftData.Schema.Entity? {
      get
      set
    }
    final public var storedProperties: [any SwiftData.SchemaProperty] {
      get
      set
    }
    final public var inheritedProperties: [any SwiftData.SchemaProperty] {
      get
      set
    }
    final public var properties: [any SwiftData.SchemaProperty] {
      get
    }
    final public var attributes: Swift.Set<SwiftData.Schema.Attribute>
    final public var relationships: Swift.Set<SwiftData.Schema.Relationship>
    final public var attributesByName: [Swift.String : SwiftData.Schema.Attribute]
    final public var relationshipsByName: [Swift.String : SwiftData.Schema.Relationship]
    final public var storedPropertiesByName: [Swift.String : any SwiftData.SchemaProperty]
    final public var inheritedPropertiesByName: [Swift.String : any SwiftData.SchemaProperty]
    final public var uniquenessConstraints: [[Swift.String]]
    @available(swift 5.9)
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    final public var indices: [[Swift.String]]
    public init(_ name: Swift.String)
    public init(_ name: Swift.String, subentities: SwiftData.Schema.Entity..., properties: any SwiftData.SchemaProperty...)
    public init(_ name: Swift.String, properties: any SwiftData.SchemaProperty...)
    public init(from decoder: any Swift.Decoder) throws
    final public func encode(to encoder: any Swift.Encoder) throws
    public static func == (lhs: SwiftData.Schema.Entity, rhs: SwiftData.Schema.Entity) -> Swift.Bool
    final public func hash(into hasher: inout Swift.Hasher)
    final public var debugDescription: Swift.String {
      get
    }
    @objc deinit
    final public var hashValue: Swift.Int {
      get
    }
  }
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol SchemaProperty : Swift.Decodable, Swift.Encodable, Swift.Hashable {
  var name: Swift.String { get set }
  var originalName: Swift.String { get set }
  var valueType: any Any.Type { get set }
  var isAttribute: Swift.Bool { get }
  var isRelationship: Swift.Bool { get }
  var isTransient: Swift.Bool { get }
  var isOptional: Swift.Bool { get }
  var isUnique: Swift.Bool { get }
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension SwiftData.SchemaProperty {
  public var isAttribute: Swift.Bool {
    get
  }
  public var isRelationship: Swift.Bool {
    get
  }
  public var isTransient: Swift.Bool {
    get
  }
  public var isOptional: Swift.Bool {
    get
  }
}
extension SwiftData.Schema {
  @_hasMissingDesignatedInitializers @available(swift 5.9)
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public class Attribute : SwiftData.SchemaProperty, Swift.CustomDebugStringConvertible {
    public var name: Swift.String
    public var originalName: Swift.String
    public var options: [SwiftData.Schema.Attribute.Option]
    public var valueType: any Any.Type
    public var defaultValue: Any?
    public var isOptional: Swift.Bool
    public var hashModifier: Swift.String?
    @available(swift 5.9)
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public struct Option {
      public static var unique: SwiftData.Schema.Attribute.Option {
        get
      }
      public static func transformable(by transformerType: Foundation.ValueTransformer.Type) -> SwiftData.Schema.Attribute.Option
      public static func transformable(by transformerName: Swift.String) -> SwiftData.Schema.Attribute.Option
      public static var externalStorage: SwiftData.Schema.Attribute.Option {
        get
      }
      public static var allowsCloudEncryption: SwiftData.Schema.Attribute.Option {
        get
      }
      public static var preserveValueOnDeletion: SwiftData.Schema.Attribute.Option {
        get
      }
      public static var ephemeral: SwiftData.Schema.Attribute.Option {
        get
      }
      public static var spotlight: SwiftData.Schema.Attribute.Option {
        get
      }
    }
    public init(_ options: SwiftData.Schema.Attribute.Option..., originalName: Swift.String? = nil, hashModifier: Swift.String? = nil)
    public init(name: Swift.String, originalName: Swift.String? = nil, options: [SwiftData.Schema.Attribute.Option] = [], valueType: any Any.Type, defaultValue: Any? = nil, hashModifier: Swift.String? = nil)
    required public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public static func == (lhs: SwiftData.Schema.Attribute, rhs: SwiftData.Schema.Attribute) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var isAttribute: Swift.Bool {
      get
    }
    public var isRelationship: Swift.Bool {
      get
    }
    public var isTransient: Swift.Bool {
      get
    }
    public var isUnique: Swift.Bool {
      get
    }
    public var isTransformable: Swift.Bool {
      get
    }
    public var debugDescription: Swift.String {
      get
    }
    @objc deinit
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers @available(swift 5.9)
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  final public class CompositeAttribute : SwiftData.Schema.Attribute {
    final public var properties: [SwiftData.Schema.Attribute]
    override public init(name: Swift.String, originalName: Swift.String? = nil, options: [SwiftData.Schema.Attribute.Option] = [], valueType: any Any.Type, defaultValue: Any? = nil, hashModifier: Swift.String? = nil)
    required public init(from decoder: any Swift.Decoder) throws
    override final public func encode(to encoder: any Swift.Encoder) throws
    override final public var debugDescription: Swift.String {
      get
    }
    @objc deinit
  }
  @_hasMissingDesignatedInitializers @available(swift 5.9)
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  final public class Relationship : SwiftData.SchemaProperty, Swift.CustomDebugStringConvertible {
    final public var name: Swift.String
    final public var originalName: Swift.String
    final public var keypath: Swift.AnyKeyPath?
    final public var options: [SwiftData.Schema.Relationship.Option]
    final public var valueType: any Any.Type
    final public var destination: Swift.String
    final public var deleteRule: SwiftData.Schema.Relationship.DeleteRule
    final public var inverseName: Swift.String?
    final public var inverseKeyPath: Swift.AnyKeyPath?
    final public var minimumModelCount: Swift.Int?
    final public var maximumModelCount: Swift.Int?
    final public var hashModifier: Swift.String?
    final public var isToOneRelationship: Swift.Bool {
      get
    }
    @available(swift 5.9)
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public enum DeleteRule : Swift.String, Swift.Codable {
      case noAction
      case nullify
      case cascade
      case deny
      public init?(rawValue: Swift.String)
      @available(swift 5.9)
      @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    @available(swift 5.9)
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public struct Option : Swift.Codable, Swift.Hashable, Swift.CustomDebugStringConvertible {
      public static var unique: SwiftData.Schema.Relationship.Option {
        get
      }
      public var debugDescription: Swift.String {
        get
      }
      public static func == (a: SwiftData.Schema.Relationship.Option, b: SwiftData.Schema.Relationship.Option) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public init(_ options: SwiftData.Schema.Relationship.Option..., deleteRule: SwiftData.Schema.Relationship.DeleteRule = .nullify, minimumModelCount: Swift.Int? = 0, maximumModelCount: Swift.Int? = 0, originalName: Swift.String? = nil, inverse: Swift.AnyKeyPath? = nil, hashModifier: Swift.String? = nil)
    public init(from decoder: any Swift.Decoder) throws
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var isUnique: Swift.Bool {
      get
    }
    final public var isAttribute: Swift.Bool {
      get
    }
    final public var isTransient: Swift.Bool {
      get
    }
    public static func == (lhs: SwiftData.Schema.Relationship, rhs: SwiftData.Schema.Relationship) -> Swift.Bool
    final public func hash(into hasher: inout Swift.Hasher)
    final public var debugDescription: Swift.String {
      get
    }
    @objc deinit
    final public var hashValue: Swift.Int {
      get
    }
  }
  @available(swift 5.9)
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
  final public class Index<T> : SwiftData.SchemaProperty, Swift.CustomDebugStringConvertible, Swift.Hashable, Swift.Codable where T : SwiftData.PersistentModel {
    public enum Types<P> where P : SwiftData.PersistentModel {
      case binary([Swift.PartialKeyPath<P>])
      case rtree([Swift.PartialKeyPath<P>])
    }
    final public var name: Swift.String {
      get
      set
    }
    final public var originalName: Swift.String {
      get
      set
    }
    final public var valueType: any Any.Type {
      get
      set
    }
    final public var isUnique: Swift.Bool {
      get
    }
    public static func == (lhs: SwiftData.Schema.Index<T>, rhs: SwiftData.Schema.Index<T>) -> Swift.Bool
    final public func hash(into hasher: inout Swift.Hasher)
    final public let indices: [SwiftData.Schema.Index<T>.Types<T>]
    public init(_ indices: SwiftData.Schema.Index<T>.Types<T>...)
    public init(_ binaryIndices: [Swift.PartialKeyPath<T>]...)
    final public var debugDescription: Swift.String {
      get
    }
    public enum CodingKeys : Swift.CodingKey {
      case indices
      public init?(stringValue: Swift.String)
      public init?(intValue: Swift.Int)
      public static func == (a: SwiftData.Schema.Index<T>.CodingKeys, b: SwiftData.Schema.Index<T>.CodingKeys) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public var intValue: Swift.Int? {
        get
      }
      public var stringValue: Swift.String {
        get
      }
    }
    final public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    @objc deinit
    final public var hashValue: Swift.Int {
      get
    }
  }
  @available(swift 5.9)
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
  final public class Unique<T> : SwiftData.SchemaProperty, Swift.CustomDebugStringConvertible, Swift.Hashable, Swift.Codable where T : SwiftData.PersistentModel {
    final public var name: Swift.String {
      get
      set
    }
    final public var originalName: Swift.String {
      get
      set
    }
    final public var valueType: any Any.Type {
      get
      set
    }
    final public var isUnique: Swift.Bool {
      get
    }
    public static func == (lhs: SwiftData.Schema.Unique<T>, rhs: SwiftData.Schema.Unique<T>) -> Swift.Bool
    final public func hash(into hasher: inout Swift.Hasher)
    final public let constraints: [[Swift.PartialKeyPath<T>]]
    public init(_ constraints: [Swift.PartialKeyPath<T>]...)
    final public var debugDescription: Swift.String {
      get
    }
    public enum CodingKeys : Swift.CodingKey {
      case constraints
      public init?(stringValue: Swift.String)
      public init?(intValue: Swift.Int)
      public static func == (a: SwiftData.Schema.Unique<T>.CodingKeys, b: SwiftData.Schema.Unique<T>.CodingKeys) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public var intValue: Swift.Int? {
        get
      }
      public var stringValue: Swift.String {
        get
      }
    }
    final public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    @objc deinit
    final public var hashValue: Swift.Int {
      get
    }
  }
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension SwiftData.Schema.Attribute.Option : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension SwiftData.Schema.Attribute.Option : Swift.Hashable {
  public static func == (lhs: SwiftData.Schema.Attribute.Option, rhs: SwiftData.Schema.Attribute.Option) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension SwiftData.Schema.Attribute.Option : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public struct PersistentIdentifier : Swift.Hashable, Swift.Identifiable, Swift.Equatable, Swift.Comparable, Swift.Codable, Swift.Sendable {
  public let id: SwiftData.PersistentIdentifier.ID
  public var entityName: Swift.String {
    get
  }
  public var storeIdentifier: Swift.String? {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
  public static func == (lhs: SwiftData.PersistentIdentifier, rhs: SwiftData.PersistentIdentifier) -> Swift.Bool
  public static func < (lhs: SwiftData.PersistentIdentifier, rhs: SwiftData.PersistentIdentifier) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public struct ID : Swift.Hashable, Swift.Equatable, Swift.Sendable {
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: SwiftData.PersistentIdentifier.ID, rhs: SwiftData.PersistentIdentifier.ID) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(swift 5.9)
  @available(macOS 15, iOS 18, tvOS 18, watchOS 10, visionOS 2, *)
  public static func identifier<T>(for storeIdentifier: Swift.String, entityName: Swift.String, primaryKey: T) throws -> SwiftData.PersistentIdentifier where T : Swift.Comparable, T : Swift.CustomStringConvertible, T : Swift.Decodable, T : Swift.Encodable, T : Swift.Hashable
  public var hashValue: Swift.Int {
    get
  }
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol RelationshipCollection {
  associatedtype PersistentElement : SwiftData.PersistentModel
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Swift.Array : SwiftData.RelationshipCollection where Element : SwiftData.PersistentModel {
  public typealias PersistentElement = Element
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Swift.Optional : SwiftData.RelationshipCollection where Wrapped : Swift.Sequence, Wrapped.Element : SwiftData.PersistentModel {
  public typealias PersistentElement = Wrapped.Element
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol BackingData<Model> {
  associatedtype Model : SwiftData.PersistentModel
  init(for modelType: Self.Model.Type)
  var persistentModelID: SwiftData.PersistentIdentifier? { get set }
  var metadata: Any { get }
  @_disfavoredOverload func getValue<Value>(forKey: Swift.KeyPath<Self.Model, Value>) -> Value where Value : Swift.Decodable
  func getValue<Value>(forKey: Swift.KeyPath<Self.Model, Value>) -> Value where Value : SwiftData.PersistentModel
  func getValue<Value>(forKey: Swift.KeyPath<Self.Model, Value?>) -> Value? where Value : SwiftData.PersistentModel
  func getValue<Value, OtherModel>(forKey: Swift.KeyPath<Self.Model, Value>) -> Value where Value : SwiftData.RelationshipCollection, OtherModel == Value.PersistentElement
  func getValue<Value, OtherModel>(forKey: Swift.KeyPath<Self.Model, Value>) -> Value where Value : Swift.Decodable, Value : SwiftData.RelationshipCollection, OtherModel == Value.PersistentElement
  func getTransformableValue<Value>(forKey: Swift.KeyPath<Self.Model, Value>) -> Value
  @_disfavoredOverload func setValue<Value>(forKey: Swift.KeyPath<Self.Model, Value>, to newValue: Value) where Value : Swift.Encodable
  func setValue<Value>(forKey: Swift.KeyPath<Self.Model, Value>, to newValue: Value) where Value : SwiftData.PersistentModel
  func setValue<Value>(forKey: Swift.KeyPath<Self.Model, Value?>, to newValue: Value?) where Value : SwiftData.PersistentModel
  func setValue<Value, OtherModel>(forKey: Swift.KeyPath<Self.Model, Value>, to newValue: Value) where Value : SwiftData.RelationshipCollection, OtherModel == Value.PersistentElement
  func setValue<Value, OtherModel>(forKey: Swift.KeyPath<Self.Model, Value>, to newValue: Value) where Value : Swift.Encodable, Value : SwiftData.RelationshipCollection, OtherModel == Value.PersistentElement
  func setTransformableValue<Value>(forKey: Swift.KeyPath<Self.Model, Value>, to newValue: Value)
}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public struct FetchResultsCollection<Element> : Swift.RandomAccessCollection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(position: Swift.Int) -> Element {
    get
  }
  @available(swift 5.9)
  @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
  public typealias Index = Swift.Int
  @available(swift 5.9)
  @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
  public typealias Indices = Swift.Range<Swift.Int>
  @available(swift 5.9)
  @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
  public typealias Iterator = Swift.IndexingIterator<SwiftData.FetchResultsCollection<Element>>
  @available(swift 5.9)
  @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
  public typealias SubSequence = Swift.Slice<SwiftData.FetchResultsCollection<Element>>
}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 10, visionOS 2, *)
extension SwiftData.DataStoreError : Swift.Equatable {}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 10, visionOS 2, *)
extension SwiftData.DataStoreError : Swift.Hashable {}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension SwiftData.ModelContext.NotificationKey : Swift.Equatable {}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension SwiftData.ModelContext.NotificationKey : Swift.Hashable {}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension SwiftData.ModelContext.NotificationKey : Swift.RawRepresentable {}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension SwiftData.Schema.Relationship.DeleteRule : Swift.Equatable {}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension SwiftData.Schema.Relationship.DeleteRule : Swift.Hashable {}
@available(swift 5.9)
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension SwiftData.Schema.Relationship.DeleteRule : Swift.RawRepresentable {}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension SwiftData.Schema.Index.CodingKeys : Swift.Equatable {}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension SwiftData.Schema.Index.CodingKeys : Swift.Hashable {}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension SwiftData.Schema.Unique.CodingKeys : Swift.Equatable {}
@available(swift 5.9)
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension SwiftData.Schema.Unique.CodingKeys : Swift.Hashable {}
