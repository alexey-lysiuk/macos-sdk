// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
// swift-module-flags: -target arm64e-apple-ios18.0-macabi -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 3.4.11 -module-name Charts
// swift-module-flags-ignorable:  -interface-compiler-version 6.1.2
import Foundation
import Swift
import SwiftUI
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct ScaleType {
  public static var linear: Charts.ScaleType {
    get
  }
  public static var log: Charts.ScaleType {
    get
  }
  public static var date: Charts.ScaleType {
    get
  }
  public static var category: Charts.ScaleType {
    get
  }
}
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
extension Charts.ScaleType {
  public static func power(exponent: Swift.Double) -> Charts.ScaleType
  public static var squareRoot: Charts.ScaleType {
    get
  }
  public static func symmetricLog(slopeAtZero: Swift.Double) -> Charts.ScaleType
  public static var symmetricLog: Charts.ScaleType {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _ScaleDomainOutputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public protocol ScaleDomain {
  func _makeScaleDomain() -> Charts._ScaleDomainOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _ScaleRangeOutputs<VisualValue> {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public protocol ScaleRange {
  associatedtype VisualValue
  func _makeScaleRange() -> Charts._ScaleRangeOutputs<Self.VisualValue>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public protocol PositionScaleRange : Charts.ScaleRange where Self.VisualValue == CoreFoundation.CGFloat {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.ClosedRange : Charts.ScaleDomain where Bound : Charts.Plottable {
  public func _makeScaleDomain() -> Charts._ScaleDomainOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.ClosedRange : Charts.ScaleRange where Bound : Swift.BinaryFloatingPoint {
  public typealias VisualValue = Bound
  public func _makeScaleRange() -> Charts._ScaleRangeOutputs<Swift.ClosedRange<Bound>.VisualValue>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.ClosedRange : Charts.PositionScaleRange where Bound == CoreFoundation.CGFloat {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Array : Charts.ScaleDomain where Element : Charts.Plottable {
  public func _makeScaleDomain() -> Charts._ScaleDomainOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Array : Charts.ScaleRange {
  public typealias VisualValue = Element
  public func _makeScaleRange() -> Charts._ScaleRangeOutputs<Swift.Array<Element>.VisualValue>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Array : Charts.PositionScaleRange where Element == CoreFoundation.CGFloat {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.ArraySlice : Charts.ScaleDomain where Element : Charts.Plottable {
  public func _makeScaleDomain() -> Charts._ScaleDomainOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.ArraySlice : Charts.ScaleRange {
  public typealias VisualValue = Element
  public func _makeScaleRange() -> Charts._ScaleRangeOutputs<Swift.ArraySlice<Element>.VisualValue>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.ArraySlice : Charts.PositionScaleRange where Element == CoreFoundation.CGFloat {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUICore.Gradient : Charts.ScaleRange {
  public typealias VisualValue = SwiftUICore.Color
  public func _makeScaleRange() -> Charts._ScaleRangeOutputs<SwiftUICore.Gradient.VisualValue>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUICore.AnyGradient : Charts.ScaleRange {
  public typealias VisualValue = SwiftUICore.Color
  public func _makeScaleRange() -> Charts._ScaleRangeOutputs<SwiftUICore.AnyGradient.VisualValue>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AutomaticScaleDomain : Charts.ScaleDomain {
  public func _makeScaleDomain() -> Charts._ScaleDomainOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ScaleDomain where Self == Charts.AutomaticScaleDomain {
  public static var automatic: Charts.AutomaticScaleDomain {
    get
  }
  public static func automatic(includesZero: Swift.Bool? = nil, reversed: Swift.Bool? = nil) -> Charts.AutomaticScaleDomain
  public static func automatic<DataValue>(includesZero: Swift.Bool? = nil, reversed: Swift.Bool? = nil, dataType: DataValue.Type, modifyInferredDomain: @escaping (inout [DataValue]) -> Swift.Void) -> Charts.AutomaticScaleDomain where DataValue : Charts.Plottable
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct PlotDimensionScaleRange : Charts.PositionScaleRange {
  public func _makeScaleRange() -> Charts._ScaleRangeOutputs<CoreFoundation.CGFloat>
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias VisualValue = CoreFoundation.CGFloat
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.PositionScaleRange where Self == Charts.PlotDimensionScaleRange {
  public static var plotDimension: Charts.PlotDimensionScaleRange {
    get
  }
  public static func plotDimension(padding: CoreFoundation.CGFloat) -> Charts.PlotDimensionScaleRange
  public static func plotDimension(startPadding: CoreFoundation.CGFloat = 0, endPadding: CoreFoundation.CGFloat = 0) -> Charts.PlotDimensionScaleRange
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUICore.View {
  nonisolated public func chartXScale<Domain, Range>(domain: Domain, range: Range, type: Charts.ScaleType? = nil) -> some SwiftUICore.View where Domain : Charts.ScaleDomain, Range : Charts.PositionScaleRange
  
  nonisolated public func chartXScale<Domain>(domain: Domain, type: Charts.ScaleType? = nil) -> some SwiftUICore.View where Domain : Charts.ScaleDomain
  
  nonisolated public func chartXScale<Range>(range: Range, type: Charts.ScaleType? = nil) -> some SwiftUICore.View where Range : Charts.PositionScaleRange
  
  nonisolated public func chartXScale(type: Charts.ScaleType? = nil) -> some SwiftUICore.View
  
  nonisolated public func chartYScale<Domain, Range>(domain: Domain, range: Range, type: Charts.ScaleType? = nil) -> some SwiftUICore.View where Domain : Charts.ScaleDomain, Range : Charts.PositionScaleRange
  
  nonisolated public func chartYScale<Domain>(domain: Domain, type: Charts.ScaleType? = nil) -> some SwiftUICore.View where Domain : Charts.ScaleDomain
  
  nonisolated public func chartYScale<Range>(range: Range, type: Charts.ScaleType? = nil) -> some SwiftUICore.View where Range : Charts.PositionScaleRange
  
  nonisolated public func chartYScale(type: Charts.ScaleType? = nil) -> some SwiftUICore.View
  
  nonisolated public func chartForegroundStyleScale<Domain, Range>(domain: Domain, range: Range, type: Charts.ScaleType? = nil) -> some SwiftUICore.View where Domain : Charts.ScaleDomain, Range : Charts.ScaleRange, Range.VisualValue : SwiftUICore.ShapeStyle
  
  nonisolated public func chartForegroundStyleScale<Domain>(domain: Domain, type: Charts.ScaleType? = nil) -> some SwiftUICore.View where Domain : Charts.ScaleDomain
  
  nonisolated public func chartForegroundStyleScale<Range>(range: Range, type: Charts.ScaleType? = nil) -> some SwiftUICore.View where Range : Charts.ScaleRange, Range.VisualValue : SwiftUICore.ShapeStyle
  
  nonisolated public func chartForegroundStyleScale(type: Charts.ScaleType? = nil) -> some SwiftUICore.View
  
  nonisolated public func chartForegroundStyleScale<DataValue, S>(_ mapping: Swift.KeyValuePairs<DataValue, S>) -> some SwiftUICore.View where DataValue : Charts.Plottable, S : SwiftUICore.ShapeStyle
  
  nonisolated public func chartForegroundStyleScale<Domain, S>(domain: Domain, mapping: @escaping (Domain.Element) -> S) -> some SwiftUICore.View where Domain : Swift.Collection, S : SwiftUICore.ShapeStyle, Domain.Element : Charts.Plottable
  
  nonisolated public func chartForegroundStyleScale<DataValue, S>(mapping: @escaping (DataValue) -> S) -> some SwiftUICore.View where DataValue : Charts.Plottable, S : SwiftUICore.ShapeStyle
  
  nonisolated public func chartSymbolScale<Domain, Range>(domain: Domain, range: Range) -> some SwiftUICore.View where Domain : Charts.ScaleDomain, Range : Charts.ScaleRange, Range.VisualValue : Charts.ChartSymbolShape
  
  @_disfavoredOverload nonisolated public func chartSymbolScale<Domain>(domain: Domain, range: [any Charts.ChartSymbolShape]) -> some SwiftUICore.View where Domain : Charts.ScaleDomain
  
  nonisolated public func chartSymbolScale<Domain>(domain: Domain) -> some SwiftUICore.View where Domain : Charts.ScaleDomain
  
  nonisolated public func chartSymbolScale<Range>(range: Range) -> some SwiftUICore.View where Range : Charts.ScaleRange, Range.VisualValue : Charts.ChartSymbolShape
  
  @_disfavoredOverload nonisolated public func chartSymbolScale(range: [any Charts.ChartSymbolShape]) -> some SwiftUICore.View
  
  nonisolated public func chartSymbolScale<DataValue, S>(_ mapping: Swift.KeyValuePairs<DataValue, S>) -> some SwiftUICore.View where DataValue : Charts.Plottable, S : Charts.ChartSymbolShape
  
  @_disfavoredOverload nonisolated public func chartSymbolScale<DataValue>(_ mapping: Swift.KeyValuePairs<DataValue, any Charts.ChartSymbolShape>) -> some SwiftUICore.View where DataValue : Charts.Plottable
  
  nonisolated public func chartSymbolScale<Domain, S>(domain: Domain, mapping: @escaping (Domain.Element) -> S) -> some SwiftUICore.View where Domain : Swift.Collection, S : Charts.ChartSymbolShape, Domain.Element : Charts.Plottable
  
  nonisolated public func chartSymbolScale<DataValue, S>(mapping: @escaping (DataValue) -> S) -> some SwiftUICore.View where DataValue : Charts.Plottable, S : Charts.ChartSymbolShape
  
  nonisolated public func chartLineStyleScale<Domain, Range>(domain: Domain, range: Range) -> some SwiftUICore.View where Domain : Charts.ScaleDomain, Range : Charts.ScaleRange, Range.VisualValue == SwiftUICore.StrokeStyle
  
  nonisolated public func chartLineStyleScale<Domain>(domain: Domain) -> some SwiftUICore.View where Domain : Charts.ScaleDomain
  
  nonisolated public func chartLineStyleScale<Range>(range: Range) -> some SwiftUICore.View where Range : Charts.ScaleRange, Range.VisualValue == SwiftUICore.StrokeStyle
  
  nonisolated public func chartLineStyleScale<DataValue>(_ mapping: Swift.KeyValuePairs<DataValue, SwiftUICore.StrokeStyle>) -> some SwiftUICore.View where DataValue : Charts.Plottable
  
  nonisolated public func chartLineStyleScale<Domain>(domain: Domain, mapping: @escaping (Domain.Element) -> SwiftUICore.StrokeStyle) -> some SwiftUICore.View where Domain : Swift.Collection, Domain.Element : Charts.Plottable
  
  nonisolated public func chartLineStyleScale<DataValue>(mapping: @escaping (DataValue) -> SwiftUICore.StrokeStyle) -> some SwiftUICore.View where DataValue : Charts.Plottable
  
  nonisolated public func chartSymbolSizeScale<Domain, Range>(domain: Domain, range: Range, type: Charts.ScaleType? = nil) -> some SwiftUICore.View where Domain : Charts.ScaleDomain, Range : Charts.ScaleRange, Range.VisualValue == CoreFoundation.CGFloat
  
  nonisolated public func chartSymbolSizeScale<Domain>(domain: Domain, type: Charts.ScaleType? = nil) -> some SwiftUICore.View where Domain : Charts.ScaleDomain
  
  nonisolated public func chartSymbolSizeScale<Range>(range: Range, type: Charts.ScaleType? = nil) -> some SwiftUICore.View where Range : Charts.ScaleRange, Range.VisualValue == CoreFoundation.CGFloat
  
  nonisolated public func chartSymbolSizeScale(type: Charts.ScaleType? = nil) -> some SwiftUICore.View
  
  nonisolated public func chartSymbolSizeScale<DataValue>(_ mapping: Swift.KeyValuePairs<DataValue, CoreFoundation.CGFloat>) -> some SwiftUICore.View where DataValue : Charts.Plottable
  
  nonisolated public func chartSymbolSizeScale<Domain>(domain: Domain, mapping: @escaping (Domain.Element) -> CoreFoundation.CGFloat) -> some SwiftUICore.View where Domain : Swift.Collection, Domain.Element : Charts.Plottable
  
  nonisolated public func chartSymbolSizeScale<DataValue>(mapping: @escaping (DataValue) -> CoreFoundation.CGFloat) -> some SwiftUICore.View where DataValue : Charts.Plottable
  
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
@_Concurrency.MainActor @preconcurrency public struct ChartAxisContent : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
  public typealias Body = @_opaqueReturnTypeOf("$s6Charts16ChartAxisContentV4bodyQrvp", 0) __
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension SwiftUICore.View {
  nonisolated public func chartXAxisStyle<Content>(@SwiftUICore.ViewBuilder content: @escaping (Charts.ChartAxisContent) -> Content) -> some SwiftUICore.View where Content : SwiftUICore.View
  
  nonisolated public func chartYAxisStyle<Content>(@SwiftUICore.ViewBuilder content: @escaping (Charts.ChartAxisContent) -> Content) -> some SwiftUICore.View where Content : SwiftUICore.View
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_Concurrency.MainActor @preconcurrency public struct Chart<Content> : SwiftUICore.View where Content : Charts.ChartContent {
  nonisolated public init(@Charts.ChartContentBuilder content: () -> Content)
  nonisolated public init<Data, C>(_ data: Data, @Charts.ChartContentBuilder content: @escaping (Data.Element) -> C) where Content == SwiftUICore.ForEach<Data, Data.Element.ID, C>, Data : Swift.RandomAccessCollection, C : Charts.ChartContent, Data.Element : Swift.Identifiable
  nonisolated public init<Data, ID, C>(_ data: Data, id: Swift.KeyPath<Data.Element, ID>, @Charts.ChartContentBuilder content: @escaping (Data.Element) -> C) where Content == SwiftUICore.ForEach<Data, ID, C>, Data : Swift.RandomAccessCollection, ID : Swift.Hashable, C : Charts.ChartContent
  nonisolated public static func _makeView(view: SwiftUICore._GraphValue<Charts.Chart<Content>>, inputs: SwiftUICore._ViewInputs) -> SwiftUICore._ViewOutputs
  nonisolated public static func _makeViewList(view: SwiftUICore._GraphValue<Charts.Chart<Content>>, inputs: SwiftUICore._ViewListInputs) -> SwiftUICore._ViewListOutputs
  nonisolated public static func _viewListCount(inputs: SwiftUICore._ViewListCountInputs) -> Swift.Int?
  @available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal var actualBody: some SwiftUICore.View {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Body = @_opaqueReturnTypeOf("$s6Charts5ChartV4bodyQrvp", 0) __<Content>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUICore.View {
  nonisolated public func chartXAxis(_ visibility: SwiftUICore.Visibility) -> some SwiftUICore.View
  
  nonisolated public func chartYAxis(_ visibility: SwiftUICore.Visibility) -> some SwiftUICore.View
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUICore.View {
  nonisolated public func chartXAxis<Content>(@Charts.AxisContentBuilder content: () -> Content) -> some SwiftUICore.View where Content : Charts.AxisContent
  
  nonisolated public func chartYAxis<Content>(@Charts.AxisContentBuilder content: () -> Content) -> some SwiftUICore.View where Content : Charts.AxisContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUICore.View {
  nonisolated public func chartXAxisLabel<C>(position: Charts.AnnotationPosition = .automatic, alignment: SwiftUICore.Alignment? = nil, spacing: CoreFoundation.CGFloat? = nil, @SwiftUICore.ViewBuilder content: () -> C) -> some SwiftUICore.View where C : SwiftUICore.View
  
  nonisolated public func chartXAxisLabel(_ labelKey: SwiftUICore.LocalizedStringKey, position: Charts.AnnotationPosition = .automatic, alignment: SwiftUICore.Alignment? = nil, spacing: CoreFoundation.CGFloat? = nil) -> some SwiftUICore.View
  
  nonisolated public func chartXAxisLabel<S>(_ label: S, position: Charts.AnnotationPosition = .automatic, alignment: SwiftUICore.Alignment? = nil, spacing: CoreFoundation.CGFloat? = nil) -> some SwiftUICore.View where S : Swift.StringProtocol
  
  nonisolated public func chartYAxisLabel<C>(position: Charts.AnnotationPosition = .automatic, alignment: SwiftUICore.Alignment? = nil, spacing: CoreFoundation.CGFloat? = nil, @SwiftUICore.ViewBuilder content: () -> C) -> some SwiftUICore.View where C : SwiftUICore.View
  
  nonisolated public func chartYAxisLabel(_ labelKey: SwiftUICore.LocalizedStringKey, position: Charts.AnnotationPosition = .automatic, alignment: SwiftUICore.Alignment? = nil, spacing: CoreFoundation.CGFloat? = nil) -> some SwiftUICore.View
  
  nonisolated public func chartYAxisLabel<S>(_ label: S, position: Charts.AnnotationPosition = .automatic, alignment: SwiftUICore.Alignment? = nil, spacing: CoreFoundation.CGFloat? = nil) -> some SwiftUICore.View where S : Swift.StringProtocol
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AnnotationPosition : Swift.Equatable {
  public static let automatic: Charts.AnnotationPosition
  public static let overlay: Charts.AnnotationPosition
  public static let top: Charts.AnnotationPosition
  public static let bottom: Charts.AnnotationPosition
  public static let leading: Charts.AnnotationPosition
  public static let trailing: Charts.AnnotationPosition
  public static let topLeading: Charts.AnnotationPosition
  public static let topTrailing: Charts.AnnotationPosition
  public static let bottomLeading: Charts.AnnotationPosition
  public static let bottomTrailing: Charts.AnnotationPosition
  public static func == (a: Charts.AnnotationPosition, b: Charts.AnnotationPosition) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AnnotationContext {
  public let targetSize: CoreFoundation.CGSize
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct AnnotationOverflowResolution {
  nonisolated public init(x: Charts.AnnotationOverflowResolution.Strategy = .automatic, y: Charts.AnnotationOverflowResolution.Strategy = .automatic)
  public struct Strategy {
    public static let fit: Charts.AnnotationOverflowResolution.Strategy
    public static func fit(to boundary: Charts.AnnotationOverflowResolution.Boundary) -> Charts.AnnotationOverflowResolution.Strategy
    public static let padScale: Charts.AnnotationOverflowResolution.Strategy
    public static let disabled: Charts.AnnotationOverflowResolution.Strategy
    public static let automatic: Charts.AnnotationOverflowResolution.Strategy
  }
  public struct Boundary {
    public static let plot: Charts.AnnotationOverflowResolution.Boundary
    public static let chart: Charts.AnnotationOverflowResolution.Boundary
    public static let automatic: Charts.AnnotationOverflowResolution.Boundary
  }
  public static let automatic: Charts.AnnotationOverflowResolution
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func annotation<C>(position: Charts.AnnotationPosition = .automatic, alignment: SwiftUICore.Alignment = .center, spacing: CoreFoundation.CGFloat? = nil, @SwiftUICore.ViewBuilder content: () -> C) -> some Charts.ChartContent where C : SwiftUICore.View
  
  nonisolated public func annotation<C>(position: Charts.AnnotationPosition = .automatic, alignment: SwiftUICore.Alignment = .center, spacing: CoreFoundation.CGFloat? = nil, @SwiftUICore.ViewBuilder content: @escaping (Charts.AnnotationContext) -> C) -> some Charts.ChartContent where C : SwiftUICore.View
  
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Charts.ChartContent {
  nonisolated public func annotation<C>(position: Charts.AnnotationPosition = .automatic, alignment: SwiftUICore.Alignment = .center, spacing: CoreFoundation.CGFloat? = nil, overflowResolution: Charts.AnnotationOverflowResolution, @SwiftUICore.ViewBuilder content: () -> C) -> some Charts.ChartContent where C : SwiftUICore.View
  
  nonisolated public func annotation<C>(position: Charts.AnnotationPosition = .automatic, alignment: SwiftUICore.Alignment = .center, spacing: CoreFoundation.CGFloat? = nil, overflowResolution: Charts.AnnotationOverflowResolution, @SwiftUICore.ViewBuilder content: @escaping (Charts.AnnotationContext) -> C) -> some Charts.ChartContent where C : SwiftUICore.View
  
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.BuilderPair where T0 : Charts.ChartContent, T1 : Charts.ChartContent {
  @usableFromInline
  internal static func _makeChartContent(content: SwiftUICore._GraphValue<Charts.BuilderPair<T0, T1>>, inputs: Charts._ChartContentInputs) -> Charts._ChartContentOutputs
  @usableFromInline
  internal static func _chartContentCount(inputs: Charts._ChartContentInputs) -> Swift.Int?
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
@_Concurrency.MainActor @preconcurrency public struct SectorMark {
  nonisolated public init(angle: Charts.PlottableValue<some Plottable>, innerRadius: Charts.MarkDimension = .automatic, outerRadius: Charts.MarkDimension = .automatic, angularInset: CoreFoundation.CGFloat? = nil)
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Charts.SectorMark, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Charts.SectorMark, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 17.0, tvOS 17.0, watchOS 10.0, macOS 14.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_typeEraser(AnyChartContent) @preconcurrency @_Concurrency.MainActor public protocol ChartContent {
  associatedtype Body : Charts.ChartContent
  @Charts.ChartContentBuilder @_Concurrency.MainActor @preconcurrency var body: Self.Body { get }
  @_Concurrency.MainActor @preconcurrency static func _layoutChartContent(_ content: Self, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency static func _renderChartContent(_ content: Self, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @_Concurrency.MainActor @preconcurrency static func _makeChartContent(content: SwiftUICore._GraphValue<Self>, inputs: Charts._ChartContentInputs) -> Charts._ChartContentOutputs
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @_Concurrency.MainActor @preconcurrency static func _chartContentCount(inputs: Charts._ChartContentInputs) -> Swift.Int?
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _ChartContentLayoutInputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _ChartContentRenderInputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _ChartContentRenderOutputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Self, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Self, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public protocol VectorizedChartContent<DataElement> : Charts.ChartContent {
  associatedtype DataElement
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@usableFromInline
@frozen internal struct BuilderTuple<each T> {
  @usableFromInline
  internal var elements: (repeat each T)
  @inlinable internal init(elements: (repeat each T)) {
        self.elements = elements
    }
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.BuilderTuple : Charts.ChartContent where repeat each T : Charts.ChartContent {
  @inlinable @_Concurrency.MainActor @preconcurrency internal var body: Swift.Never {
    get { fatalError() }
  }
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal static func _layoutChartContent(_ content: Charts.BuilderTuple<repeat each T>, _ inputs: Charts._ChartContentLayoutInputs)
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal static func _renderChartContent(_ content: Charts.BuilderTuple<repeat each T>, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal static func _makeChartContent(content: SwiftUICore._GraphValue<Charts.BuilderTuple<repeat each T>>, inputs: Charts._ChartContentInputs) -> Charts._ChartContentOutputs
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal static func _chartContentCount(inputs: Charts._ChartContentInputs) -> Swift.Int?
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @usableFromInline
  internal typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUICore.View {
  nonisolated public func chartLegend<Content>(position: Charts.AnnotationPosition = .automatic, alignment: SwiftUICore.Alignment? = nil, spacing: CoreFoundation.CGFloat? = nil, @SwiftUICore.ViewBuilder content: () -> Content) -> some SwiftUICore.View where Content : SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func chartLegend(position: Charts.AnnotationPosition = .automatic, alignment: SwiftUICore.Alignment? = nil, spacing: CoreFoundation.CGFloat? = nil) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func chartLegend(_ visibility: SwiftUICore.Visibility) -> some SwiftUICore.View
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct ChartBinRange<Bound> : Swift.RangeExpression where Bound : Swift.Comparable {
  public let lowerBound: Bound
  public let upperBound: Bound
  public func contains(_ element: Bound) -> Swift.Bool
  public func relative<C>(to collection: C) -> Swift.Range<Bound> where Bound == C.Index, C : Swift.Collection
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.PlottableValue {
  public static func value(_ labelKey: SwiftUICore.LocalizedStringKey, _ range: Charts.ChartBinRange<Value>) -> Charts.PlottableValue<Value> where Value : Swift.Comparable
  @_disfavoredOverload public static func value<S>(_ label: S, _ range: Charts.ChartBinRange<Value>) -> Charts.PlottableValue<Value> where Value : Swift.Comparable, S : Swift.StringProtocol
  public static func value(_ label: SwiftUICore.Text, _ range: Charts.ChartBinRange<Value>) -> Charts.PlottableValue<Value> where Value : Swift.Comparable
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct AreaPlot<Content> {
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.AreaPlot : Charts.ChartContent where Content : Charts.ChartContent {
  @_Concurrency.MainActor @preconcurrency public var body: some Charts.ChartContent {
    get
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Body = @_opaqueReturnTypeOf("$s6Charts8AreaPlotVA2A12ChartContentRzlE4bodyQrvp", 0) __<Content>
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.AreaPlot : Charts.VectorizedChartContent where Content : Charts.VectorizedChartContent {
  public typealias DataElement = Content.DataElement
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.AreaPlot {
  nonisolated public init<Data>(_ data: Data, x: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, some Plottable>, y: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, some Plottable>, stacking: Charts.MarkStackingMethod = .standard) where Content == Charts.VectorizedAreaPlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data, X>(_ data: Data, xStart: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, X>, xEnd: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, X>, y: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, some Plottable>) where Content == Charts.VectorizedAreaPlotContent<Data>, Data : Swift.RandomAccessCollection, X : Charts.Plottable
  nonisolated public init<Data, Y>(_ data: Data, x: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, some Plottable>, yStart: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, Y>, yEnd: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, Y>) where Content == Charts.VectorizedAreaPlotContent<Data>, Data : Swift.RandomAccessCollection, Y : Charts.Plottable
  nonisolated public init<Data>(_ data: Data, x: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, some Plottable>, y: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, some Plottable>, series: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, some Plottable>, stacking: Charts.MarkStackingMethod = .standard) where Content == Charts.VectorizedAreaPlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data, X>(_ data: Data, xStart: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, X>, xEnd: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, X>, y: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, some Plottable>, series: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, some Plottable>) where Content == Charts.VectorizedAreaPlotContent<Data>, Data : Swift.RandomAccessCollection, X : Charts.Plottable
  nonisolated public init<Data, Y>(_ data: Data, x: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, some Plottable>, yStart: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, Y>, yEnd: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, Y>, series: Charts.PlottableProjection<Charts.AreaPlot<Content>.DataElement, some Plottable>) where Content == Charts.VectorizedAreaPlotContent<Data>, Data : Swift.RandomAccessCollection, Y : Charts.Plottable
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.AreaPlot where Content == Charts.FunctionAreaPlotContent {
  nonisolated public init(x: SwiftUICore.Text, yStart: SwiftUICore.Text, yEnd: SwiftUICore.Text, domain: Swift.ClosedRange<Swift.Double>? = nil, function: @escaping @Sendable (Swift.Double) -> (yStart: Swift.Double, yEnd: Swift.Double))
  nonisolated public init(x: SwiftUICore.LocalizedStringKey, yStart: SwiftUICore.LocalizedStringKey, yEnd: SwiftUICore.LocalizedStringKey, domain: Swift.ClosedRange<Swift.Double>? = nil, function: @escaping @Sendable (Swift.Double) -> (yStart: Swift.Double, yEnd: Swift.Double))
  @_disfavoredOverload nonisolated public init<S1, S2, S3>(x: S1, yStart: S2, yEnd: S3, domain: Swift.ClosedRange<Swift.Double>? = nil, function: @escaping @Sendable (Swift.Double) -> (yStart: Swift.Double, yEnd: Swift.Double)) where S1 : Swift.StringProtocol, S2 : Swift.StringProtocol, S3 : Swift.StringProtocol
  nonisolated public init(x: SwiftUICore.Text, y: SwiftUICore.Text, domain: Swift.ClosedRange<Swift.Double>? = nil, function: @escaping @Sendable (Swift.Double) -> Swift.Double)
  nonisolated public init(x: SwiftUICore.LocalizedStringKey, y: SwiftUICore.LocalizedStringKey, domain: Swift.ClosedRange<Swift.Double>? = nil, function: @escaping @Sendable (Swift.Double) -> Swift.Double)
  @_disfavoredOverload nonisolated public init<S1, S2>(x: S1, y: S2, domain: Swift.ClosedRange<Swift.Double>? = nil, function: @escaping @Sendable (Swift.Double) -> Swift.Double) where S1 : Swift.StringProtocol, S2 : Swift.StringProtocol
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@_Concurrency.MainActor @preconcurrency public struct FunctionAreaPlotContent {
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Charts.FunctionAreaPlotContent, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Charts.FunctionAreaPlotContent, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@_Concurrency.MainActor @preconcurrency public struct VectorizedAreaPlotContent<Data> : Charts.VectorizedChartContent where Data : Swift.RandomAccessCollection {
  public typealias DataElement = Data.Element
  @_Concurrency.MainActor @preconcurrency public var body: some Charts.ChartContent {
    get
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Body = @_opaqueReturnTypeOf("$s6Charts25VectorizedAreaPlotContentV4bodyQrvp", 0) __<Data>
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct RectanglePlot<Content> {
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.RectanglePlot : Charts.ChartContent where Content : Charts.ChartContent {
  @_Concurrency.MainActor @preconcurrency public var body: some Charts.ChartContent {
    get
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Body = @_opaqueReturnTypeOf("$s6Charts13RectanglePlotVA2A12ChartContentRzlE4bodyQrvp", 0) __<Content>
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.RectanglePlot : Charts.VectorizedChartContent where Content : Charts.VectorizedChartContent {
  public typealias DataElement = Content.DataElement
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.RectanglePlot {
  nonisolated public init<Data>(_ data: Data, x: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, some Plottable>, y: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, some Plottable>, width: Charts.MarkDimensions<Charts.RectanglePlot<Content>.DataElement> = .automatic, height: Charts.MarkDimensions<Charts.RectanglePlot<Content>.DataElement> = .automatic) where Content == Charts.VectorizedRectanglePlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data, X>(_ data: Data, xStart: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, X>, xEnd: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, X>, y: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, some Plottable>, height: Charts.MarkDimensions<Charts.RectanglePlot<Content>.DataElement> = .automatic) where Content == Charts.VectorizedRectanglePlotContent<Data>, Data : Swift.RandomAccessCollection, X : Charts.Plottable
  nonisolated public init<Data, Y>(_ data: Data, x: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, some Plottable>, yStart: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, Y>, yEnd: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, Y>, width: Charts.MarkDimensions<Charts.RectanglePlot<Content>.DataElement> = .automatic) where Content == Charts.VectorizedRectanglePlotContent<Data>, Data : Swift.RandomAccessCollection, Y : Charts.Plottable
  nonisolated public init<Data, X, Y>(_ data: Data, xStart: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, X>, xEnd: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, X>, yStart: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, Y>, yEnd: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, Y>) where Content == Charts.VectorizedRectanglePlotContent<Data>, Data : Swift.RandomAccessCollection, X : Charts.Plottable, Y : Charts.Plottable
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.RectanglePlot {
  nonisolated public init<Data>(_ data: Data, x: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, some Plottable>, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil, width: Charts.MarkDimensions<Charts.RectanglePlot<Content>.DataElement> = .automatic) where Content == Charts.VectorizedRectanglePlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data>(_ data: Data, xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, y: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, some Plottable>, height: Charts.MarkDimensions<Charts.RectanglePlot<Content>.DataElement> = .automatic) where Content == Charts.VectorizedRectanglePlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data, X>(_ data: Data, xStart: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, X>, xEnd: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, X>, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil) where Content == Charts.VectorizedRectanglePlotContent<Data>, Data : Swift.RandomAccessCollection, X : Charts.Plottable
  nonisolated public init<Data, Y>(_ data: Data, xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, yStart: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, Y>, yEnd: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, Y>) where Content == Charts.VectorizedRectanglePlotContent<Data>, Data : Swift.RandomAccessCollection, Y : Charts.Plottable
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.RectanglePlot {
  nonisolated public init<Data>(_ data: Data, x: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, some Plottable>, yStart: Swift.KeyPath<Charts.RectanglePlot<Content>.DataElement, CoreFoundation.CGFloat>, yEnd: Swift.KeyPath<Charts.RectanglePlot<Content>.DataElement, CoreFoundation.CGFloat>, width: Charts.MarkDimensions<Charts.RectanglePlot<Content>.DataElement> = .automatic) where Content == Charts.VectorizedRectanglePlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data>(_ data: Data, xStart: Swift.KeyPath<Charts.RectanglePlot<Content>.DataElement, CoreFoundation.CGFloat>, xEnd: Swift.KeyPath<Charts.RectanglePlot<Content>.DataElement, CoreFoundation.CGFloat>, y: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, some Plottable>, height: Charts.MarkDimensions<Charts.RectanglePlot<Content>.DataElement> = .automatic) where Content == Charts.VectorizedRectanglePlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data, X>(_ data: Data, xStart: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, X>, xEnd: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, X>, yStart: Swift.KeyPath<Charts.RectanglePlot<Content>.DataElement, CoreFoundation.CGFloat>, yEnd: Swift.KeyPath<Charts.RectanglePlot<Content>.DataElement, CoreFoundation.CGFloat>) where Content == Charts.VectorizedRectanglePlotContent<Data>, Data : Swift.RandomAccessCollection, X : Charts.Plottable
  nonisolated public init<Data, Y>(_ data: Data, xStart: Swift.KeyPath<Charts.RectanglePlot<Content>.DataElement, CoreFoundation.CGFloat>, xEnd: Swift.KeyPath<Charts.RectanglePlot<Content>.DataElement, CoreFoundation.CGFloat>, yStart: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, Y>, yEnd: Charts.PlottableProjection<Charts.RectanglePlot<Content>.DataElement, Y>) where Content == Charts.VectorizedRectanglePlotContent<Data>, Data : Swift.RandomAccessCollection, Y : Charts.Plottable
  nonisolated public init<Data>(_ data: Data, xStart: Swift.KeyPath<Charts.RectanglePlot<Content>.DataElement, CoreFoundation.CGFloat>, xEnd: Swift.KeyPath<Charts.RectanglePlot<Content>.DataElement, CoreFoundation.CGFloat>, yStart: Swift.KeyPath<Charts.RectanglePlot<Content>.DataElement, CoreFoundation.CGFloat>, yEnd: Swift.KeyPath<Charts.RectanglePlot<Content>.DataElement, CoreFoundation.CGFloat>) where Content == Charts.VectorizedRectanglePlotContent<Data>, Data : Swift.RandomAccessCollection
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@_Concurrency.MainActor @preconcurrency public struct VectorizedRectanglePlotContent<Data> : Charts.VectorizedChartContent where Data : Swift.RandomAccessCollection {
  public typealias DataElement = Data.Element
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Charts.VectorizedRectanglePlotContent<Data>, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Charts.VectorizedRectanglePlotContent<Data>, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AxisValueLabel<Content> : Charts.AxisMark where Content : SwiftUICore.View {
  nonisolated public init(centered: Swift.Bool? = nil, anchor: SwiftUICore.UnitPoint? = nil, multiLabelAlignment: SwiftUICore.Alignment? = nil, collisionResolution: Charts.AxisValueLabelCollisionResolution = .automatic, offsetsMarks: Swift.Bool? = nil, orientation: Charts.AxisValueLabelOrientation = .automatic, horizontalSpacing: CoreFoundation.CGFloat? = nil, verticalSpacing: CoreFoundation.CGFloat? = nil) where Content == Swift.Never
  nonisolated public init(centered: Swift.Bool? = nil, anchor: SwiftUICore.UnitPoint? = nil, multiLabelAlignment: SwiftUICore.Alignment? = nil, collisionResolution: Charts.AxisValueLabelCollisionResolution = .automatic, offsetsMarks: Swift.Bool? = nil, orientation: Charts.AxisValueLabelOrientation = .automatic, horizontalSpacing: CoreFoundation.CGFloat? = nil, verticalSpacing: CoreFoundation.CGFloat? = nil, @SwiftUICore.ViewBuilder content: () -> Content)
  nonisolated public init(_ titleKey: SwiftUICore.LocalizedStringKey, centered: Swift.Bool? = nil, anchor: SwiftUICore.UnitPoint? = nil, multiLabelAlignment: SwiftUICore.Alignment? = nil, collisionResolution: Charts.AxisValueLabelCollisionResolution = .automatic, offsetsMarks: Swift.Bool? = nil, orientation: Charts.AxisValueLabelOrientation = .automatic, horizontalSpacing: CoreFoundation.CGFloat? = nil, verticalSpacing: CoreFoundation.CGFloat? = nil) where Content == SwiftUICore.Text
  @_disfavoredOverload nonisolated public init<S>(_ title: S, centered: Swift.Bool? = nil, anchor: SwiftUICore.UnitPoint? = nil, multiLabelAlignment: SwiftUICore.Alignment? = nil, collisionResolution: Charts.AxisValueLabelCollisionResolution = .automatic, offsetsMarks: Swift.Bool? = nil, orientation: Charts.AxisValueLabelOrientation = .automatic, horizontalSpacing: CoreFoundation.CGFloat? = nil, verticalSpacing: CoreFoundation.CGFloat? = nil) where Content == SwiftUICore.Text, S : Swift.StringProtocol
  nonisolated public init<Format>(format: Format, centered: Swift.Bool? = nil, anchor: SwiftUICore.UnitPoint? = nil, multiLabelAlignment: SwiftUICore.Alignment? = nil, collisionResolution: Charts.AxisValueLabelCollisionResolution = .automatic, offsetsMarks: Swift.Bool? = nil, orientation: Charts.AxisValueLabelOrientation = .automatic, horizontalSpacing: CoreFoundation.CGFloat? = nil, verticalSpacing: CoreFoundation.CGFloat? = nil) where Content == Swift.Never, Format : Foundation.FormatStyle, Format.FormatInput : Charts.Plottable, Format.FormatOutput == Swift.String
  public static func _layoutAxisMark(_ content: Charts.AxisValueLabel<Content>, _ inputs: Charts._AxisMarkLayoutInputs)
  public static func _renderAxisMark(_ content: Charts.AxisValueLabel<Content>, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AxisValueLabelOrientation : Swift.CustomStringConvertible {
  public static var automatic: Charts.AxisValueLabelOrientation {
    get
  }
  public static var horizontal: Charts.AxisValueLabelOrientation {
    get
  }
  public static var vertical: Charts.AxisValueLabelOrientation {
    get
  }
  public static var verticalReversed: Charts.AxisValueLabelOrientation {
    get
  }
  public var description: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AxisValueLabelCollisionResolution : Swift.CustomStringConvertible {
  public static var automatic: Charts.AxisValueLabelCollisionResolution {
    get
  }
  public static var greedy: Charts.AxisValueLabelCollisionResolution {
    get
  }
  public static func greedy(priority: Swift.Double = 0, minimumSpacing: CoreFoundation.CGFloat? = nil) -> Charts.AxisValueLabelCollisionResolution
  public static var truncate: Charts.AxisValueLabelCollisionResolution {
    get
  }
  public static var disabled: Charts.AxisValueLabelCollisionResolution {
    get
  }
  public var description: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.AxisMark {
  public func foregroundStyle<S>(_ style: S) -> some Charts.AxisMark where S : SwiftUICore.ShapeStyle
  
  public func font(_ font: SwiftUICore.Font?) -> some Charts.AxisMark
  
  public func offset(x: CoreFoundation.CGFloat = 0, y: CoreFoundation.CGFloat = 0) -> some Charts.AxisMark
  
  public func offset(_ offset: CoreFoundation.CGSize) -> some Charts.AxisMark
  
}
@available(iOS 18.0, macOS 15.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@usableFromInline
internal struct ChartModifiedContent<Content, Modifier> {
  @usableFromInline
  internal typealias Body = Swift.Never
  @usableFromInline
  internal var content: Content
  @usableFromInline
  internal var modifier: Modifier
  @usableFromInline
  nonisolated internal init(content: Content, modifier: Modifier)
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct MarkStackingMethod : Swift.Equatable {
  @usableFromInline
  internal let storage: Charts.MarkStackingMethod.Storage
  @usableFromInline
  @frozen internal enum Storage : Swift.Hashable {
    case standard
    case normalized
    case center
    case unstacked
    @usableFromInline
    internal static func == (a: Charts.MarkStackingMethod.Storage, b: Charts.MarkStackingMethod.Storage) -> Swift.Bool
    @usableFromInline
    internal func hash(into hasher: inout Swift.Hasher)
    @usableFromInline
    internal var hashValue: Swift.Int {
      @usableFromInline
      get
    }
  }
  @inlinable internal init(_ storage: Charts.MarkStackingMethod.Storage) {
        self.storage = storage
    }
  @inlinable public static var standard: Charts.MarkStackingMethod {
    get { .init(.standard) }
  }
  @inlinable public static var normalized: Charts.MarkStackingMethod {
    get { .init(.normalized) }
  }
  @inlinable public static var center: Charts.MarkStackingMethod {
    get { .init(.center) }
  }
  @inlinable public static var unstacked: Charts.MarkStackingMethod {
    get { .init(.unstacked) }
  }
  public static func == (a: Charts.MarkStackingMethod, b: Charts.MarkStackingMethod) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.MarkStackingMethod : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct MarkDimension : Swift.ExpressibleByFloatLiteral, Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
  public typealias FloatLiteralType = Swift.Double
  @usableFromInline
  internal let storage: Charts.MarkDimension.Storage
  @usableFromInline
  @frozen internal enum Storage {
    case automatic
    case fixed(CoreFoundation.CGFloat)
    case ratio(CoreFoundation.CGFloat)
    case inset(CoreFoundation.CGFloat)
  }
  @inlinable internal init(_ storage: Charts.MarkDimension.Storage) {
        self.storage = storage
    }
  @inlinable public static var automatic: Charts.MarkDimension {
    get {
        return .init(.automatic)
    }
  }
  @inlinable public static func ratio(_ value: CoreFoundation.CGFloat) -> Charts.MarkDimension {
        return .init(.ratio(value))
    }
  @inlinable public static func inset(_ value: CoreFoundation.CGFloat) -> Charts.MarkDimension {
        return .init(.inset(value))
    }
  @inlinable public static func fixed(_ value: CoreFoundation.CGFloat) -> Charts.MarkDimension {
        return .init(.fixed(value))
    }
  @inlinable nonisolated public init(floatLiteral value: Swift.Double) {
        self = .fixed(CGFloat(value))
    }
  @inlinable nonisolated public init(integerLiteral value: Swift.Int) {
        self = .fixed(CGFloat(value))
    }
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct MarkDimensions<DataElement> : Swift.ExpressibleByFloatLiteral, Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
  public typealias FloatLiteralType = Swift.Double
  public static var automatic: Charts.MarkDimensions<DataElement> {
    get
  }
  public static func ratio(_ value: CoreFoundation.CGFloat) -> Charts.MarkDimensions<DataElement>
  public static func inset(_ value: CoreFoundation.CGFloat) -> Charts.MarkDimensions<DataElement>
  public static func fixed(_ value: CoreFoundation.CGFloat) -> Charts.MarkDimensions<DataElement>
  public static func ratio(_ keyPath: Swift.KeyPath<DataElement, CoreFoundation.CGFloat>) -> Charts.MarkDimensions<DataElement>
  public static func inset(_ keyPath: Swift.KeyPath<DataElement, CoreFoundation.CGFloat>) -> Charts.MarkDimensions<DataElement>
  public static func fixed(_ keyPath: Swift.KeyPath<DataElement, CoreFoundation.CGFloat>) -> Charts.MarkDimensions<DataElement>
  @inlinable nonisolated public init(floatLiteral value: Swift.Double) {
        self = .fixed(CGFloat(value))
    }
  @inlinable nonisolated public init(integerLiteral value: Swift.Int) {
        self = .fixed(CGFloat(value))
    }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.MarkDimension : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct InterpolationMethod {
  @usableFromInline
  internal let storage: Charts.InterpolationMethod.Storage
  @usableFromInline
  @frozen internal enum Storage {
    case linear
    case cardinal(tension: CoreFoundation.CGFloat)
    case catmullRom(alpha: CoreFoundation.CGFloat)
    case step(transition: CoreFoundation.CGFloat)
    case monotone
  }
  @inlinable internal init(_ storage: Charts.InterpolationMethod.Storage) {
        self.storage = storage
    }
  @inlinable public static var linear: Charts.InterpolationMethod {
    get { .init(.linear) }
  }
  @inlinable public static var cardinal: Charts.InterpolationMethod {
    get { .init(.cardinal(tension: 0)) }
  }
  @inlinable public static func cardinal(tension: CoreFoundation.CGFloat) -> Charts.InterpolationMethod { .init(.cardinal(tension: tension)) }
  @inlinable public static var catmullRom: Charts.InterpolationMethod {
    get { .init(.catmullRom(alpha: 0.5)) }
  }
  @inlinable public static func catmullRom(alpha: CoreFoundation.CGFloat) -> Charts.InterpolationMethod { .init(.catmullRom(alpha: alpha)) }
  @inlinable public static var monotone: Charts.InterpolationMethod {
    get { .init(.monotone) }
  }
  @inlinable public static var stepStart: Charts.InterpolationMethod {
    get { .init(.step(transition: 0)) }
  }
  @inlinable public static var stepCenter: Charts.InterpolationMethod {
    get { .init(.step(transition: 0.5)) }
  }
  @inlinable public static var stepEnd: Charts.InterpolationMethod {
    get { .init(.step(transition: 1)) }
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.InterpolationMethod : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AxisValue : Swift.Sendable {
  public func `as`<P>(_ type: P.Type) -> P? where P : Charts.Plottable
  public var index: Swift.Int {
    get
  }
  public var count: Swift.Int {
    get
  }
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct _ChartContentInputs {
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct _ChartContentOutputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct ChartProxy {
  @available(iOS, deprecated: 17.0, renamed: "plotFrame")
  @available(macOS, deprecated: 14.0, renamed: "plotFrame")
  @available(tvOS, deprecated: 17.0, renamed: "plotFrame")
  @available(watchOS, deprecated: 10.0, renamed: "plotFrame")
  public var plotAreaFrame: SwiftUICore.Anchor<CoreFoundation.CGRect> {
    get
  }
  @available(iOS, deprecated: 17.0, renamed: "plotSize")
  @available(macOS, deprecated: 14.0, renamed: "plotSize")
  @available(tvOS, deprecated: 17.0, renamed: "plotSize")
  @available(watchOS, deprecated: 10.0, renamed: "plotSize")
  public var plotAreaSize: CoreFoundation.CGSize {
    get
  }
  public func position<P>(forX value: P) -> CoreFoundation.CGFloat? where P : Charts.Plottable
  public func position<P>(forY value: P) -> CoreFoundation.CGFloat? where P : Charts.Plottable
  public func position<X, Y>(for point: (x: X, y: Y)) -> CoreFoundation.CGPoint? where X : Charts.Plottable, Y : Charts.Plottable
  public func positionRange<P>(forX value: P) -> Swift.ClosedRange<CoreFoundation.CGFloat>? where P : Charts.Plottable
  public func positionRange<P>(forY value: P) -> Swift.ClosedRange<CoreFoundation.CGFloat>? where P : Charts.Plottable
  public func positionRange<X, Y>(for point: (x: X, y: Y)) -> CoreFoundation.CGRect? where X : Charts.Plottable, Y : Charts.Plottable
  public func value<P>(atX position: CoreFoundation.CGFloat, as: P.Type = P.self) -> P? where P : Charts.Plottable
  public func value<P>(atY position: CoreFoundation.CGFloat, as: P.Type = P.self) -> P? where P : Charts.Plottable
  public func value<X, Y>(at position: CoreFoundation.CGPoint, as: (X, Y).Type = (X, Y).self) -> (X, Y)? where X : Charts.Plottable, Y : Charts.Plottable
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Charts.ChartProxy {
  public var plotFrame: SwiftUICore.Anchor<CoreFoundation.CGRect>? {
    get
  }
  public var plotContainerFrame: SwiftUICore.Anchor<CoreFoundation.CGRect>? {
    get
  }
  public var plotSize: CoreFoundation.CGSize {
    get
  }
}
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
extension Charts.ChartProxy {
  public func foregroundStyle<P>(for value: P) -> SwiftUICore.AnyShapeStyle? where P : Charts.Plottable
  public func lineStyle<P>(for value: P) -> SwiftUICore.StrokeStyle? where P : Charts.Plottable
  public func symbol<P>(for value: P) -> Charts.AnyChartSymbolShape? where P : Charts.Plottable
  public func symbolSize<P>(for value: P) -> CoreFoundation.CGFloat? where P : Charts.Plottable
}
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
extension Charts.ChartProxy {
  public func xDomain<P>(dataType: P.Type) -> [P] where P : Charts.Plottable
  public func yDomain<P>(dataType: P.Type) -> [P] where P : Charts.Plottable
  public func foregroundStyleDomain<P>(dataType: P.Type) -> [P] where P : Charts.Plottable
  public func symbolDomain<P>(dataType: P.Type) -> [P] where P : Charts.Plottable
  public func symbolSizeDomain<P>(dataType: P.Type) -> [P] where P : Charts.Plottable
  public func lineStyleDomain<P>(dataType: P.Type) -> [P] where P : Charts.Plottable
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Charts.ChartProxy {
  public func selectXValue(at xPosition: CoreFoundation.CGFloat)
  public func selectYValue(at yPosition: CoreFoundation.CGFloat)
  public func selectXRange(from: CoreFoundation.CGFloat, to: CoreFoundation.CGFloat)
  public func selectYRange(from: CoreFoundation.CGFloat, to: CoreFoundation.CGFloat)
  public func selectAngleValue(at angle: SwiftUICore.Angle)
  public func angle(at position: CoreFoundation.CGPoint) -> SwiftUICore.Angle
  public func value<P>(atAngle angle: SwiftUICore.Angle, as: P.Type = P.self) -> P? where P : Charts.Plottable
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUICore.View {
  nonisolated public func chartOverlay<V>(alignment: SwiftUICore.Alignment = .center, @SwiftUICore.ViewBuilder content: @escaping (Charts.ChartProxy) -> V) -> some SwiftUICore.View where V : SwiftUICore.View
  
  nonisolated public func chartBackground<V>(alignment: SwiftUICore.Alignment = .center, @SwiftUICore.ViewBuilder content: @escaping (Charts.ChartProxy) -> V) -> some SwiftUICore.View where V : SwiftUICore.View
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func mask<C>(@Charts.ChartContentBuilder content: () -> C) -> some Charts.ChartContent where C : Charts.ChartContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AxisGridLine : Charts.AxisMark {
  nonisolated public init(centered: Swift.Bool? = nil, stroke: SwiftUICore.StrokeStyle? = nil)
  public static func _layoutAxisMark(_ content: Charts.AxisGridLine, _ inputs: Charts._AxisMarkLayoutInputs)
  public static func _renderAxisMark(_ content: Charts.AxisGridLine, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AxisMarks<Content> : Charts.AxisContent where Content : Charts.AxisMark {
  nonisolated public init(preset: Charts.AxisMarkPreset = .automatic, position: Charts.AxisMarkPosition = .automatic, values: Charts.AxisMarkValues = .automatic, @Charts.AxisMarkBuilder content: @escaping (Charts.AxisValue) -> Content)
  nonisolated public init<Value>(preset: Charts.AxisMarkPreset = .automatic, position: Charts.AxisMarkPosition = .automatic, values: [Value], @Charts.AxisMarkBuilder content: @escaping (Charts.AxisValue) -> Content) where Value : Charts.Plottable
  nonisolated public init(preset: Charts.AxisMarkPreset = .automatic, position: Charts.AxisMarkPosition = .automatic, values: Charts.AxisMarkValues = .automatic, @Charts.AxisMarkBuilder content: @escaping () -> Content)
  nonisolated public init<Value>(preset: Charts.AxisMarkPreset = .automatic, position: Charts.AxisMarkPosition = .automatic, values: [Value], @Charts.AxisMarkBuilder content: @escaping () -> Content) where Value : Charts.Plottable
  nonisolated public init<Format>(format: Format, preset: Charts.AxisMarkPreset = .automatic, position: Charts.AxisMarkPosition = .automatic, values: Charts.AxisMarkValues = .automatic, stroke: SwiftUICore.StrokeStyle? = nil) where Content == Swift.Never, Format : Foundation.FormatStyle, Format.FormatInput : Charts.Plottable, Format.FormatOutput == Swift.String
  nonisolated public init<Value, Format>(format: Format, preset: Charts.AxisMarkPreset = .automatic, position: Charts.AxisMarkPosition = .automatic, values: [Value], stroke: SwiftUICore.StrokeStyle? = nil) where Content == Swift.Never, Value : Charts.Plottable, Value == Format.FormatInput, Format : Foundation.FormatStyle, Format.FormatOutput == Swift.String
  nonisolated public init(preset: Charts.AxisMarkPreset = .automatic, position: Charts.AxisMarkPosition = .automatic, values: Charts.AxisMarkValues = .automatic, stroke: SwiftUICore.StrokeStyle? = nil) where Content == Swift.Never
  nonisolated public init<Value>(preset: Charts.AxisMarkPreset = .automatic, position: Charts.AxisMarkPosition = .automatic, values: [Value], stroke: SwiftUICore.StrokeStyle? = nil) where Content == Swift.Never, Value : Charts.Plottable
  public static func _makeAxisContent(_ content: Charts.AxisMarks<Content>, _ inputs: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AxisMarkPreset : Swift.CustomStringConvertible {
  public static var automatic: Charts.AxisMarkPreset {
    get
  }
  public static var extended: Charts.AxisMarkPreset {
    get
  }
  public static var aligned: Charts.AxisMarkPreset {
    get
  }
  public static var inset: Charts.AxisMarkPreset {
    get
  }
  public var description: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AxisMarkPosition : Swift.CustomStringConvertible {
  public static var automatic: Charts.AxisMarkPosition {
    get
  }
  public static var leading: Charts.AxisMarkPosition {
    get
  }
  public static var trailing: Charts.AxisMarkPosition {
    get
  }
  public static var top: Charts.AxisMarkPosition {
    get
  }
  public static var bottom: Charts.AxisMarkPosition {
    get
  }
  public var description: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AxisMarkValues : Swift.CustomStringConvertible {
  public static var automatic: Charts.AxisMarkValues {
    get
  }
  public static func automatic(desiredCount: Swift.Int? = nil, roundLowerBound: Swift.Bool? = nil, roundUpperBound: Swift.Bool? = nil) -> Charts.AxisMarkValues
  public static func automatic<P>(minimumStride: P, desiredCount: Swift.Int? = nil, roundLowerBound: Swift.Bool? = nil, roundUpperBound: Swift.Bool? = nil) -> Charts.AxisMarkValues where P : Swift.BinaryFloatingPoint
  public static func stride(by component: Foundation.Calendar.Component, count: Swift.Int = 1, roundLowerBound: Swift.Bool? = nil, roundUpperBound: Swift.Bool? = nil, calendar: Foundation.Calendar? = nil) -> Charts.AxisMarkValues
  public static func stride<P>(by stepSize: P, roundLowerBound: Swift.Bool? = nil, roundUpperBound: Swift.Bool? = nil) -> Charts.AxisMarkValues where P : Swift.BinaryFloatingPoint
  public var description: Swift.String {
    get
  }
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Charts.ChartContent {
  nonisolated public func compositingLayer() -> some Charts.ChartContent
  
  nonisolated public func compositingLayer<V>(style: (SwiftUICore.PlaceholderContentView<Self>) -> V) -> some Charts.ChartContent where V : SwiftUICore.View
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_Concurrency.MainActor @preconcurrency public struct AreaMark {
  nonisolated public init<X, Y>(x: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>, stacking: Charts.MarkStackingMethod = .standard) where X : Charts.Plottable, Y : Charts.Plottable
  nonisolated public init<X, Y>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>) where X : Charts.Plottable, Y : Charts.Plottable
  nonisolated public init<X, Y>(x: Charts.PlottableValue<X>, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>) where X : Charts.Plottable, Y : Charts.Plottable
  nonisolated public init<X, Y, S>(x: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>, series: Charts.PlottableValue<S>, stacking: Charts.MarkStackingMethod = .standard) where X : Charts.Plottable, Y : Charts.Plottable, S : Charts.Plottable
  nonisolated public init<X, Y, S>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>, series: Charts.PlottableValue<S>) where X : Charts.Plottable, Y : Charts.Plottable, S : Charts.Plottable
  nonisolated public init<X, Y, S>(x: Charts.PlottableValue<X>, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>, series: Charts.PlottableValue<S>) where X : Charts.Plottable, Y : Charts.Plottable, S : Charts.Plottable
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Charts.AreaMark, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Charts.AreaMark, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct DateBins {
  public var thresholds: [Foundation.Date] {
    get
  }
  nonisolated public init(thresholds: [Foundation.Date])
  nonisolated public init(timeInterval: Foundation.TimeInterval, range: Swift.ClosedRange<Foundation.Date>)
  nonisolated public init(unit: Foundation.Calendar.Component, by stride: Swift.Int = 1, range: Swift.ClosedRange<Foundation.Date>, calendar: Foundation.Calendar = .autoupdatingCurrent)
  nonisolated public init(range: Swift.ClosedRange<Foundation.Date>, desiredCount: Swift.Int = 10, calendar: Foundation.Calendar = .autoupdatingCurrent)
  nonisolated public init(data: [Foundation.Date], desiredCount: Swift.Int? = nil, calendar: Foundation.Calendar = .autoupdatingCurrent)
  public subscript(position: Swift.Int) -> Charts.ChartBinRange<Foundation.Date> {
    get
  }
  public func index(for value: Foundation.Date) -> Swift.Int
  public func index(after i: Swift.Int) -> Swift.Int
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public static func == (a: Charts.DateBins, b: Charts.DateBins) -> Swift.Bool
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Element = Charts.ChartBinRange<Foundation.Date>
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Index = Swift.Int
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Indices = Swift.DefaultIndices<Charts.DateBins>
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Iterator = Swift.IndexingIterator<Charts.DateBins>
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias SubSequence = Swift.Slice<Charts.DateBins>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct AxisTick : Charts.AxisMark {
  nonisolated public init(centered: Swift.Bool? = nil, length: Charts.AxisTick.Length = .automatic, stroke: SwiftUICore.StrokeStyle? = nil)
  nonisolated public init(centered: Swift.Bool? = nil, length: CoreFoundation.CGFloat, stroke: SwiftUICore.StrokeStyle? = nil)
  public struct Length : Swift.CustomStringConvertible {
    public static var automatic: Charts.AxisTick.Length {
      get
    }
    public static var label: Charts.AxisTick.Length {
      get
    }
    public static func label(extendPastBy: CoreFoundation.CGFloat = 0) -> Charts.AxisTick.Length
    public static var longestLabel: Charts.AxisTick.Length {
      get
    }
    public static func longestLabel(extendPastBy: CoreFoundation.CGFloat = 0) -> Charts.AxisTick.Length
    public var description: Swift.String {
      get
    }
  }
  public static func _layoutAxisMark(_ content: Charts.AxisTick, _ inputs: Charts._AxisMarkLayoutInputs)
  public static func _renderAxisMark(_ content: Charts.AxisTick, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 18.0, macOS 15.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension SwiftUICore.ForEach where Content : Charts.ChartContent {
  public static func _makeChartContent(content: SwiftUICore._GraphValue<SwiftUICore.ForEach<Data, ID, Content>>, inputs: Charts._ChartContentInputs) -> Charts._ChartContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func accessibilityLabel(_ label: SwiftUICore.Text) -> some Charts.ChartContent
  
  nonisolated public func accessibilityLabel(_ labelKey: SwiftUICore.LocalizedStringKey) -> some Charts.ChartContent
  
  @_disfavoredOverload nonisolated public func accessibilityLabel<S>(_ label: S) -> some Charts.ChartContent where S : Swift.StringProtocol
  
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedChartContent {
  nonisolated public func accessibilityLabel(_ label: Swift.KeyPath<Self.DataElement, SwiftUICore.Text>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
  nonisolated public func accessibilityLabel(_ labelKey: Swift.KeyPath<Self.DataElement, SwiftUICore.LocalizedStringKey>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
  nonisolated public func accessibilityLabel(_ label: Swift.KeyPath<Self.DataElement, some StringProtocol>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func accessibilityValue(_ valueDescription: SwiftUICore.Text) -> some Charts.ChartContent
  
  nonisolated public func accessibilityValue(_ valueKey: SwiftUICore.LocalizedStringKey) -> some Charts.ChartContent
  
  @_disfavoredOverload nonisolated public func accessibilityValue<S>(_ value: S) -> some Charts.ChartContent where S : Swift.StringProtocol
  
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedChartContent {
  nonisolated public func accessibilityValue(_ valueDescription: Swift.KeyPath<Self.DataElement, SwiftUICore.Text>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
  nonisolated public func accessibilityValue(_ valueKey: Swift.KeyPath<Self.DataElement, SwiftUICore.LocalizedStringKey>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
  nonisolated public func accessibilityValue(_ value: Swift.KeyPath<Self.DataElement, some StringProtocol>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func accessibilityIdentifier(_ identifier: Swift.String) -> some Charts.ChartContent
  
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedChartContent {
  nonisolated public func accessibilityIdentifier(_ identifier: Swift.KeyPath<Self.DataElement, Swift.String>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func accessibilityHidden(_ hidden: Swift.Bool) -> some Charts.ChartContent
  
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedChartContent {
  nonisolated public func accessibilityHidden(_ hidden: Swift.KeyPath<Self.DataElement, Swift.Bool>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct BarPlot<Content> {
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.BarPlot : Charts.ChartContent where Content : Charts.ChartContent {
  @_Concurrency.MainActor @preconcurrency public var body: some Charts.ChartContent {
    get
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Body = @_opaqueReturnTypeOf("$s6Charts7BarPlotVA2A12ChartContentRzlE4bodyQrvp", 0) __<Content>
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.BarPlot : Charts.VectorizedChartContent where Content : Charts.VectorizedChartContent {
  public typealias DataElement = Content.DataElement
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.BarPlot {
  nonisolated public init<Data>(_ data: Data, x: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, some Plottable>, y: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, some Plottable>, width: Charts.MarkDimensions<Charts.BarPlot<Content>.DataElement> = .automatic, height: Charts.MarkDimensions<Charts.BarPlot<Content>.DataElement> = .automatic, stacking: Charts.MarkStackingMethod = .standard) where Content == Charts.VectorizedBarPlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data, X>(_ data: Data, xStart: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, X>, xEnd: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, X>, y: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, some Plottable>, height: Charts.MarkDimensions<Charts.BarPlot<Content>.DataElement> = .automatic) where Content == Charts.VectorizedBarPlotContent<Data>, Data : Swift.RandomAccessCollection, X : Charts.Plottable
  nonisolated public init<Data, Y>(_ data: Data, x: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, some Plottable>, yStart: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, Y>, yEnd: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, Y>, width: Charts.MarkDimensions<Charts.BarPlot<Content>.DataElement> = .automatic) where Content == Charts.VectorizedBarPlotContent<Data>, Data : Swift.RandomAccessCollection, Y : Charts.Plottable
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.BarPlot {
  nonisolated public init<Data>(_ data: Data, x: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, some Plottable>, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil, width: Charts.MarkDimensions<Charts.BarPlot<Content>.DataElement> = .automatic, stacking: Charts.MarkStackingMethod = .standard) where Content == Charts.VectorizedBarPlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data>(_ data: Data, xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, y: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, some Plottable>, height: Charts.MarkDimensions<Charts.BarPlot<Content>.DataElement> = .automatic, stacking: Charts.MarkStackingMethod = .standard) where Content == Charts.VectorizedBarPlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data, X>(_ data: Data, xStart: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, X>, xEnd: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, X>, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil) where Content == Charts.VectorizedBarPlotContent<Data>, Data : Swift.RandomAccessCollection, X : Charts.Plottable
  nonisolated public init<Data, Y>(_ data: Data, xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, yStart: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, Y>, yEnd: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, Y>) where Content == Charts.VectorizedBarPlotContent<Data>, Data : Swift.RandomAccessCollection, Y : Charts.Plottable
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.BarPlot {
  nonisolated public init<Data>(_ data: Data, x: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, some Plottable>, yStart: Swift.KeyPath<Charts.BarPlot<Content>.DataElement, CoreFoundation.CGFloat>, yEnd: Swift.KeyPath<Charts.BarPlot<Content>.DataElement, CoreFoundation.CGFloat>, width: Charts.MarkDimensions<Charts.BarPlot<Content>.DataElement> = .automatic, stacking: Charts.MarkStackingMethod = .standard) where Content == Charts.VectorizedBarPlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data>(_ data: Data, xStart: Swift.KeyPath<Charts.BarPlot<Content>.DataElement, CoreFoundation.CGFloat>, xEnd: Swift.KeyPath<Charts.BarPlot<Content>.DataElement, CoreFoundation.CGFloat>, y: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, some Plottable>, height: Charts.MarkDimensions<Charts.BarPlot<Content>.DataElement> = .automatic, stacking: Charts.MarkStackingMethod = .standard) where Content == Charts.VectorizedBarPlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data, X>(_ data: Data, xStart: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, X>, xEnd: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, X>, yStart: Swift.KeyPath<Charts.BarPlot<Content>.DataElement, CoreFoundation.CGFloat>, yEnd: Swift.KeyPath<Charts.BarPlot<Content>.DataElement, CoreFoundation.CGFloat>) where Content == Charts.VectorizedBarPlotContent<Data>, Data : Swift.RandomAccessCollection, X : Charts.Plottable
  nonisolated public init<Data, Y>(_ data: Data, xStart: Swift.KeyPath<Charts.BarPlot<Content>.DataElement, CoreFoundation.CGFloat>, xEnd: Swift.KeyPath<Charts.BarPlot<Content>.DataElement, CoreFoundation.CGFloat>, yStart: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, Y>, yEnd: Charts.PlottableProjection<Charts.BarPlot<Content>.DataElement, Y>) where Content == Charts.VectorizedBarPlotContent<Data>, Data : Swift.RandomAccessCollection, Y : Charts.Plottable
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@_Concurrency.MainActor @preconcurrency public struct VectorizedBarPlotContent<Data> : Charts.VectorizedChartContent where Data : Swift.RandomAccessCollection {
  public typealias DataElement = Data.Element
  @_Concurrency.MainActor @preconcurrency public var body: some Charts.ChartContent {
    get
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Body = @_opaqueReturnTypeOf("$s6Charts24VectorizedBarPlotContentV4bodyQrvp", 0) __<Data>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func foregroundStyle<S>(_ style: S) -> some Charts.ChartContent where S : SwiftUICore.ShapeStyle
  
  nonisolated public func foregroundStyle<D>(by value: Charts.PlottableValue<D>) -> some Charts.ChartContent where D : Charts.Plottable
  
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedChartContent {
  nonisolated public func foregroundStyle(_ keyPath: Swift.KeyPath<Self.DataElement, some ShapeStyle>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
  nonisolated public func foregroundStyle(by value: Charts.PlottableProjection<Self.DataElement, some Plottable>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func alignsMarkStylesWithPlotArea(_ aligns: Swift.Bool = true) -> some Charts.ChartContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func position<P>(by value: Charts.PlottableValue<P>, axis: SwiftUICore.Axis? = nil, span: Charts.MarkDimension = .automatic) -> some Charts.ChartContent where P : Charts.Plottable
  
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedChartContent {
  nonisolated public func position(by value: Charts.PlottableProjection<Self.DataElement, some Plottable>, axis: SwiftUICore.Axis? = nil, span: Charts.MarkDimension = .automatic) -> some Charts.VectorizedChartContent<Self.DataElement>
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func opacity(_ value: Swift.Double) -> some Charts.ChartContent
  
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedChartContent {
  nonisolated public func opacity(_ keyPath: Swift.KeyPath<Self.DataElement, CoreFoundation.CGFloat>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func clipShape(_ shape: some Shape, style: SwiftUICore.FillStyle = FillStyle()) -> some Charts.ChartContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func lineStyle(_ style: SwiftUICore.StrokeStyle) -> some Charts.ChartContent
  
  nonisolated public func lineStyle<D>(by value: Charts.PlottableValue<D>) -> some Charts.ChartContent where D : Charts.Plottable
  
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedChartContent {
  nonisolated public func lineStyle(_ style: Swift.KeyPath<Self.DataElement, SwiftUICore.StrokeStyle>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
  nonisolated public func lineStyle(by value: Charts.PlottableProjection<Self.DataElement, some Plottable>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func symbol<S>(_ symbol: S) -> some Charts.ChartContent where S : Charts.ChartSymbolShape
  
  nonisolated public func symbol<D>(by value: Charts.PlottableValue<D>) -> some Charts.ChartContent where D : Charts.Plottable
  
  nonisolated public func symbol<V>(@SwiftUICore.ViewBuilder symbol: () -> V) -> some Charts.ChartContent where V : SwiftUICore.View
  
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedChartContent {
  nonisolated public func symbol(by value: Charts.PlottableProjection<Self.DataElement, some Plottable>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func symbolSize(_ area: CoreFoundation.CGFloat) -> some Charts.ChartContent
  
  nonisolated public func symbolSize(_ size: CoreFoundation.CGSize) -> some Charts.ChartContent
  
  nonisolated public func symbolSize<D>(by value: Charts.PlottableValue<D>) -> some Charts.ChartContent where D : Charts.Plottable
  
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedChartContent {
  nonisolated public func symbolSize(_ area: Swift.KeyPath<Self.DataElement, CoreFoundation.CGFloat>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
  nonisolated public func symbolSize(_ size: Swift.KeyPath<Self.DataElement, CoreFoundation.CGSize>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
  nonisolated public func symbolSize(by value: Charts.PlottableProjection<Self.DataElement, some Plottable>) -> some Charts.VectorizedChartContent<Self.DataElement>
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func offset(x: CoreFoundation.CGFloat = 0, y: CoreFoundation.CGFloat = 0) -> some Charts.ChartContent
  
  nonisolated public func offset(_ value: CoreFoundation.CGSize) -> some Charts.ChartContent
  
  nonisolated public func offset(x: CoreFoundation.CGFloat = 0, yStart: CoreFoundation.CGFloat = 0, yEnd: CoreFoundation.CGFloat = 0) -> some Charts.ChartContent
  
  nonisolated public func offset(xStart: CoreFoundation.CGFloat = 0, xEnd: CoreFoundation.CGFloat = 0, y: CoreFoundation.CGFloat = 0) -> some Charts.ChartContent
  
  nonisolated public func offset(xStart: CoreFoundation.CGFloat = 0, xEnd: CoreFoundation.CGFloat = 0, yStart: CoreFoundation.CGFloat = 0, yEnd: CoreFoundation.CGFloat = 0) -> some Charts.ChartContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func cornerRadius(_ radius: CoreFoundation.CGFloat, style: SwiftUICore.RoundedCornerStyle = .continuous) -> some Charts.ChartContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  nonisolated public func interpolationMethod(_ method: Charts.InterpolationMethod) -> some Charts.ChartContent
  
}
@available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
extension Charts.ChartContent {
  nonisolated public func blur(radius: CoreFoundation.CGFloat) -> some Charts.ChartContent
  
  nonisolated public func shadow(color: SwiftUICore.Color = Color(.sRGBLinear, white: 0, opacity: 0.33), radius: CoreFoundation.CGFloat, x: CoreFoundation.CGFloat = 0, y: CoreFoundation.CGFloat = 0) -> some Charts.ChartContent
  
}
@available(iOS 17, macOS 14, tvOS 17, watchOS 10, *)
extension Charts.ChartContent {
  nonisolated public func zIndex(_ value: Swift.Double) -> some Charts.ChartContent
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_functionBuilder public struct ChartContentBuilder {
  @_alwaysEmitIntoClient public static func buildBlock() -> some Charts.ChartContent {
        BuilderEmpty()
    }
  
  @available(iOS, introduced: 16.0, obsoleted: 18.0)
  @available(macOS, introduced: 13.0, obsoleted: 15.0)
  @available(tvOS, introduced: 16.0, obsoleted: 18.0)
  @available(watchOS, introduced: 9.0, obsoleted: 11.0)
  @available(visionOS, introduced: 1.0, obsoleted: 2.0)
  @_alwaysEmitIntoClient public static func buildPartialBlock<T>(first content: T) -> T where T : Charts.ChartContent {
        return content
    }
  @available(iOS, introduced: 16.0, obsoleted: 18.0)
  @available(macOS, introduced: 13.0, obsoleted: 15.0)
  @available(tvOS, introduced: 16.0, obsoleted: 18.0)
  @available(watchOS, introduced: 9.0, obsoleted: 11.0)
  @available(visionOS, introduced: 1.0, obsoleted: 2.0)
  @_alwaysEmitIntoClient public static func buildPartialBlock(accumulated: some ChartContent, next: some ChartContent) -> some Charts.ChartContent {
        return BuilderPair(accumulated, next)
    }
  
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient public static func buildBlock<C>(_ content: C) -> C where C : Charts.ChartContent {
        return content
    }
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_disfavoredOverload public static func buildBlock<each C>(_ content: repeat each C) -> some Charts.ChartContent where repeat each C : Charts.ChartContent {
        return BuilderTuple(elements: (repeat each content))
    }
  
  @_alwaysEmitIntoClient public static func buildIf<T>(_ content: T?) -> T? where T : Charts.ChartContent {
        return content
    }
  @_alwaysEmitIntoClient public static func buildEither<T1, T2>(first: T1) -> Charts.BuilderConditional<T1, T2> where T1 : Charts.ChartContent, T2 : Charts.ChartContent {
        return .init(storage: .trueContent(first))
    }
  @_alwaysEmitIntoClient public static func buildEither<T1, T2>(second: T2) -> Charts.BuilderConditional<T1, T2> where T1 : Charts.ChartContent, T2 : Charts.ChartContent {
        return .init(storage: .falseContent(second))
    }
  @_alwaysEmitIntoClient public static func buildLimitedAvailability(_ content: some ChartContent) -> Charts.AnyChartContent {
        AnyChartContent(content)
    }
  @_alwaysEmitIntoClient public static func buildExpression<Content>(_ content: Content) -> Content where Content : Charts.ChartContent {
        content
    }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Never : Charts.ChartContent {
  @_Concurrency.MainActor @preconcurrency public var body: Swift.Never {
    get
  }
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Swift.Never, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Swift.Never, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Optional : Charts.ChartContent where Wrapped : Charts.ChartContent {
  @_Concurrency.MainActor @preconcurrency public var body: Swift.Never {
    get
  }
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Swift.Optional<Wrapped>, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Swift.Optional<Wrapped>, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@usableFromInline
@frozen @_Concurrency.MainActor @preconcurrency internal struct BuilderEmpty : Charts.ChartContent {
  @inlinable @_Concurrency.MainActor @preconcurrency internal init() {}
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal var body: Swift.Never {
    get
  }
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal static func _layoutChartContent(_: Charts.BuilderEmpty, _: Charts._ChartContentLayoutInputs)
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal static func _renderChartContent(_: Charts.BuilderEmpty, _: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  @usableFromInline
  internal typealias Body = Swift.Never
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.BuilderEmpty {
  @_Concurrency.MainActor @preconcurrency public static func _makeChartContent(content: SwiftUICore._GraphValue<Charts.BuilderEmpty>, inputs: Charts._ChartContentInputs) -> Charts._ChartContentOutputs
  @_Concurrency.MainActor @preconcurrency public static func _chartContentCount(inputs: Charts._ChartContentInputs) -> Swift.Int?
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct BuilderConditional<TrueContent, FalseContent> {
  @usableFromInline
  @frozen internal enum Storage {
    case trueContent(TrueContent)
    case falseContent(FalseContent)
  }
  @usableFromInline
  internal let storage: Charts.BuilderConditional<TrueContent, FalseContent>.Storage
  @inlinable internal init(storage: Charts.BuilderConditional<TrueContent, FalseContent>.Storage) {
        self.storage = storage
    }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.BuilderConditional : Charts.ChartContent where TrueContent : Charts.ChartContent, FalseContent : Charts.ChartContent {
  @_Concurrency.MainActor @preconcurrency public var body: Swift.Never {
    get
  }
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Charts.BuilderConditional<TrueContent, FalseContent>, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Charts.BuilderConditional<TrueContent, FalseContent>, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @_Concurrency.MainActor @preconcurrency public static func _makeChartContent(content: SwiftUICore._GraphValue<Charts.BuilderConditional<TrueContent, FalseContent>>, inputs: Charts._ChartContentInputs) -> Charts._ChartContentOutputs
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @_Concurrency.MainActor @preconcurrency public static func _chartContentCount(inputs: Charts._ChartContentInputs) -> Swift.Int?
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@usableFromInline
@frozen internal struct BuilderPair<T0, T1> {
  @usableFromInline
  internal let first: T0
  @usableFromInline
  internal let firstConformance: Swift.UnsafeRawPointer
  @usableFromInline
  internal let second: T1
  @usableFromInline
  internal let secondConformance: Swift.UnsafeRawPointer
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.BuilderPair : Charts.ChartContent where T0 : Charts.ChartContent, T1 : Charts.ChartContent {
  @inlinable internal init(_ first: T0, _ second: T1) {
        self.first = first
        self.firstConformance = T0.conformanceToChartContent
        self.second = second
        self.secondConformance = T1.conformanceToChartContent
    }
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal var body: Swift.Never {
    get
  }
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal static func _layoutChartContent(_ content: Charts.BuilderPair<T0, T1>, _ inputs: Charts._ChartContentLayoutInputs)
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal static func _renderChartContent(_ content: Charts.BuilderPair<T0, T1>, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  @usableFromInline
  internal typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen @_Concurrency.MainActor @preconcurrency public struct AnyChartContent {
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal let storage: any Charts.ChartContent
  @inlinable nonisolated public init(_ content: any Charts.ChartContent) {
        self.storage = content
    }
  @inlinable nonisolated public init(erasing content: some ChartContent) {
        self.init(content)
    }
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Charts.AnyChartContent, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Charts.AnyChartContent, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct PlottableValue<Value> where Value : Charts.Plottable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.PlottableValue {
  public static func value(_ labelKey: SwiftUICore.LocalizedStringKey, _ value: Value) -> Charts.PlottableValue<Value>
  @_disfavoredOverload public static func value<S>(_ label: S, _ value: Value) -> Charts.PlottableValue<Value> where S : Swift.StringProtocol
  public static func value(_ label: SwiftUICore.Text, _ value: Value) -> Charts.PlottableValue<Value>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.PlottableValue {
  public static func value(_ labelKey: SwiftUICore.LocalizedStringKey, _ range: Swift.Range<Value>) -> Charts.PlottableValue<Value> where Value : Swift.Comparable
  @_disfavoredOverload public static func value<S>(_ label: S, _ range: Swift.Range<Value>) -> Charts.PlottableValue<Value> where Value : Swift.Comparable, S : Swift.StringProtocol
  public static func value(_ label: SwiftUICore.Text, _ range: Swift.Range<Value>) -> Charts.PlottableValue<Value> where Value : Swift.Comparable
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.PlottableValue {
  public static func value(_ labelKey: SwiftUICore.LocalizedStringKey, _ date: Foundation.Date, unit: Foundation.Calendar.Component, calendar: Foundation.Calendar? = nil) -> Charts.PlottableValue<Value> where Value == Foundation.Date
  @_disfavoredOverload public static func value<S>(_ label: S, _ date: Foundation.Date, unit: Foundation.Calendar.Component, calendar: Foundation.Calendar? = nil) -> Charts.PlottableValue<Value> where Value == Foundation.Date, S : Swift.StringProtocol
  public static func value(_ label: SwiftUICore.Text, _ date: Foundation.Date, unit: Foundation.Calendar.Component, calendar: Foundation.Calendar? = nil) -> Charts.PlottableValue<Value> where Value == Foundation.Date
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct PlottableProjection<DataElement, DataValue> where DataValue : Charts.Plottable {
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.PlottableProjection {
  public static func value(_ label: SwiftUICore.Text, _ value: Swift.KeyPath<DataElement, DataValue>) -> Charts.PlottableProjection<DataElement, DataValue>
  @_disfavoredOverload public static func value(_ label: some StringProtocol, _ value: Swift.KeyPath<DataElement, DataValue>) -> Charts.PlottableProjection<DataElement, DataValue>
  public static func value(_ labelKey: SwiftUICore.LocalizedStringKey, _ value: Swift.KeyPath<DataElement, DataValue>) -> Charts.PlottableProjection<DataElement, DataValue>
  public static func value(_ label: SwiftUICore.Text, _ start: Swift.KeyPath<DataElement, DataValue>, _ end: Swift.KeyPath<DataElement, DataValue>) -> Charts.PlottableProjection<DataElement, DataValue> where DataValue : Swift.Comparable
  @_disfavoredOverload public static func value(_ label: some StringProtocol, _ start: Swift.KeyPath<DataElement, DataValue>, _ end: Swift.KeyPath<DataElement, DataValue>) -> Charts.PlottableProjection<DataElement, DataValue> where DataValue : Swift.Comparable
  public static func value(_ labelKey: SwiftUICore.LocalizedStringKey, _ start: Swift.KeyPath<DataElement, DataValue>, _ end: Swift.KeyPath<DataElement, DataValue>) -> Charts.PlottableProjection<DataElement, DataValue> where DataValue : Swift.Comparable
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.PlottableProjection where DataValue.PrimitivePlottable == Foundation.Date {
  public static func value(_ label: SwiftUICore.Text, _ date: Swift.KeyPath<DataElement, DataValue>, unit: Foundation.Calendar.Component, calendar: Foundation.Calendar? = nil) -> Charts.PlottableProjection<DataElement, DataValue>
  @_disfavoredOverload public static func value(_ label: some StringProtocol, _ date: Swift.KeyPath<DataElement, DataValue>, unit: Foundation.Calendar.Component, calendar: Foundation.Calendar? = nil) -> Charts.PlottableProjection<DataElement, DataValue>
  public static func value(_ labelKey: SwiftUICore.LocalizedStringKey, _ date: Swift.KeyPath<DataElement, DataValue>, unit: Foundation.Calendar.Component, calendar: Foundation.Calendar? = nil) -> Charts.PlottableProjection<DataElement, DataValue>
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.PlottableProjection {
  public static func value(_ label: SwiftUICore.Text, _ value: DataValue) -> Charts.PlottableProjection<DataElement, DataValue>
  @_disfavoredOverload public static func value(_ label: some StringProtocol, _ value: DataValue) -> Charts.PlottableProjection<DataElement, DataValue>
  public static func value(_ labelKey: SwiftUICore.LocalizedStringKey, _ value: DataValue) -> Charts.PlottableProjection<DataElement, DataValue>
  public static func value(_ label: SwiftUICore.Text, _ start: DataValue, _ end: DataValue) -> Charts.PlottableProjection<DataElement, DataValue> where DataValue : Swift.Comparable
  @_disfavoredOverload public static func value(_ label: some StringProtocol, _ start: DataValue, _ end: DataValue) -> Charts.PlottableProjection<DataElement, DataValue> where DataValue : Swift.Comparable
  public static func value(_ labelKey: SwiftUICore.LocalizedStringKey, _ start: DataValue, _ end: DataValue) -> Charts.PlottableProjection<DataElement, DataValue> where DataValue : Swift.Comparable
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.PlottableProjection where DataValue == Foundation.Date {
  public static func value(_ label: SwiftUICore.Text, _ date: DataValue, unit: Foundation.Calendar.Component, calendar: Foundation.Calendar? = nil) -> Charts.PlottableProjection<DataElement, DataValue>
  @_disfavoredOverload public static func value(_ label: some StringProtocol, _ date: DataValue, unit: Foundation.Calendar.Component, calendar: Foundation.Calendar? = nil) -> Charts.PlottableProjection<DataElement, DataValue>
  public static func value(_ labelKey: SwiftUICore.LocalizedStringKey, _ date: DataValue, unit: Foundation.Calendar.Component, calendar: Foundation.Calendar? = nil) -> Charts.PlottableProjection<DataElement, DataValue>
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension SwiftUICore.View {
  nonisolated public func chartXSelection<P>(value: SwiftUICore.Binding<P?>) -> some SwiftUICore.View where P : Charts.Plottable
  
  nonisolated public func chartXSelection<P>(range: SwiftUICore.Binding<Swift.ClosedRange<P>?>) -> some SwiftUICore.View where P : Charts.Plottable, P : Swift.Comparable
  
  nonisolated public func chartYSelection<P>(value: SwiftUICore.Binding<P?>) -> some SwiftUICore.View where P : Charts.Plottable
  
  nonisolated public func chartYSelection<P>(range: SwiftUICore.Binding<Swift.ClosedRange<P>?>) -> some SwiftUICore.View where P : Charts.Plottable, P : Swift.Comparable
  
  nonisolated public func chartAngleSelection<P>(value: SwiftUICore.Binding<P?>) -> some SwiftUICore.View where P : Charts.Plottable
  
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension SwiftUICore.View {
  nonisolated public func chartGesture(_ gesture: @escaping (Charts.ChartProxy) -> some Gesture) -> some SwiftUICore.View
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct NumberBins<Value> where Value : Swift.Comparable, Value : Swift.Numeric {
  public var thresholds: [Value] {
    get
  }
  nonisolated public init(thresholds: [Value])
  nonisolated public init(size: Value, range: Swift.ClosedRange<Value>) where Value : Swift.BinaryFloatingPoint
  nonisolated public init(size: Value, range: Swift.ClosedRange<Value>) where Value : Swift.BinaryInteger
  nonisolated public init(range: Swift.ClosedRange<Value>, count: Swift.Int) where Value : Swift.BinaryFloatingPoint
  nonisolated public init(range: Swift.ClosedRange<Value>, count: Swift.Int) where Value : Swift.BinaryInteger
  nonisolated public init(range: Swift.ClosedRange<Value>, desiredCount: Swift.Int = 10, minimumStride: Value = 0) where Value : Swift.BinaryFloatingPoint
  nonisolated public init(range: Swift.ClosedRange<Value>, desiredCount: Swift.Int = 10, minimumStride: Value = 0) where Value : Swift.BinaryInteger
  nonisolated public init(data: [Value], desiredCount: Swift.Int? = nil, minimumStride: Value = 0) where Value : Swift.BinaryFloatingPoint
  nonisolated public init(data: [Value], desiredCount: Swift.Int? = nil, minimumStride: Value = 0) where Value : Swift.BinaryInteger
  public subscript(position: Swift.Int) -> Charts.ChartBinRange<Value> {
    get
  }
  public func index(for value: Value) -> Swift.Int
  public func index(after i: Swift.Int) -> Swift.Int
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public static func == (a: Charts.NumberBins<Value>, b: Charts.NumberBins<Value>) -> Swift.Bool
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Element = Charts.ChartBinRange<Value>
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Index = Swift.Int
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Indices = Swift.DefaultIndices<Charts.NumberBins<Value>>
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Iterator = Swift.IndexingIterator<Charts.NumberBins<Value>>
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias SubSequence = Swift.Slice<Charts.NumberBins<Value>>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_Concurrency.MainActor @preconcurrency public struct LineMark {
  nonisolated public init<X, Y>(x: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>) where X : Charts.Plottable, Y : Charts.Plottable
  nonisolated public init<X, Y, S>(x: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>, series: Charts.PlottableValue<S>) where X : Charts.Plottable, Y : Charts.Plottable, S : Charts.Plottable
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Charts.LineMark, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Charts.LineMark, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_Concurrency.MainActor @preconcurrency public struct ChartPlotContent : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Body = @_opaqueReturnTypeOf("$s6Charts16ChartPlotContentV4bodyQrvp", 0) __
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUICore.View {
  nonisolated public func chartPlotStyle<Content>(@SwiftUICore.ViewBuilder content: @escaping (Charts.ChartPlotContent) -> Content) -> some SwiftUICore.View where Content : SwiftUICore.View
  
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct PointPlot<Content> {
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.PointPlot : Charts.ChartContent where Content : Charts.ChartContent {
  @_Concurrency.MainActor @preconcurrency public var body: some Charts.ChartContent {
    get
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Body = @_opaqueReturnTypeOf("$s6Charts9PointPlotVA2A12ChartContentRzlE4bodyQrvp", 0) __<Content>
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.PointPlot : Charts.VectorizedChartContent where Content : Charts.VectorizedChartContent {
  public typealias DataElement = Content.DataElement
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.PointPlot {
  nonisolated public init<Data>(_ data: Data, x: Charts.PlottableProjection<Charts.PointPlot<Content>.DataElement, some Plottable>, y: Charts.PlottableProjection<Charts.PointPlot<Content>.DataElement, some Plottable>) where Content == Charts.VectorizedPointPlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data>(_ data: Data, x: Charts.PlottableProjection<Charts.PointPlot<Content>.DataElement, some Plottable>, y: CoreFoundation.CGFloat? = nil) where Content == Charts.VectorizedPointPlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data>(_ data: Data, x: Charts.PlottableProjection<Charts.PointPlot<Content>.DataElement, some Plottable>, y: Swift.KeyPath<Charts.PointPlot<Content>.DataElement, CoreFoundation.CGFloat>) where Content == Charts.VectorizedPointPlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data>(_ data: Data, x: CoreFoundation.CGFloat? = nil, y: Charts.PlottableProjection<Charts.PointPlot<Content>.DataElement, some Plottable>) where Content == Charts.VectorizedPointPlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data>(_ data: Data, x: Swift.KeyPath<Data.Element, CoreFoundation.CGFloat>, y: Charts.PlottableProjection<Charts.PointPlot<Content>.DataElement, some Plottable>) where Content == Charts.VectorizedPointPlotContent<Data>, Data : Swift.RandomAccessCollection
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@_Concurrency.MainActor @preconcurrency public struct VectorizedPointPlotContent<Data> : Charts.VectorizedChartContent where Data : Swift.RandomAccessCollection {
  public typealias DataElement = Data.Element
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Charts.VectorizedPointPlotContent<Data>, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Charts.VectorizedPointPlotContent<Data>, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_Concurrency.MainActor @preconcurrency public struct BarMark {
  nonisolated public init<X, Y>(x: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>, width: Charts.MarkDimension = .automatic, height: Charts.MarkDimension = .automatic, stacking: Charts.MarkStackingMethod = .standard) where X : Charts.Plottable, Y : Charts.Plottable
  nonisolated public init<X>(x: Charts.PlottableValue<X>, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil, width: Charts.MarkDimension = .automatic, stacking: Charts.MarkStackingMethod = .standard) where X : Charts.Plottable
  nonisolated public init<Y>(xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, y: Charts.PlottableValue<Y>, height: Charts.MarkDimension = .automatic, stacking: Charts.MarkStackingMethod = .standard) where Y : Charts.Plottable
  nonisolated public init<X, Y>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>, height: Charts.MarkDimension = .automatic) where X : Charts.Plottable, Y : Charts.Plottable
  nonisolated public init<X>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil) where X : Charts.Plottable
  nonisolated public init<X, Y>(x: Charts.PlottableValue<X>, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>, width: Charts.MarkDimension = .automatic) where X : Charts.Plottable, Y : Charts.Plottable
  nonisolated public init<Y>(xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>) where Y : Charts.Plottable
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Charts.BarMark, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Charts.BarMark, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct RulePlot<Content> {
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.RulePlot : Charts.ChartContent where Content : Charts.ChartContent {
  @_Concurrency.MainActor @preconcurrency public var body: some Charts.ChartContent {
    get
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Body = @_opaqueReturnTypeOf("$s6Charts8RulePlotVA2A12ChartContentRzlE4bodyQrvp", 0) __<Content>
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.RulePlot : Charts.VectorizedChartContent where Content : Charts.VectorizedChartContent {
  public typealias DataElement = Content.DataElement
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.RulePlot {
  nonisolated public init<Data, X>(_ data: Data, xStart: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, X>, xEnd: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, X>, y: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, some Plottable>) where Content == Charts.VectorizedRulePlotContent<Data>, Data : Swift.RandomAccessCollection, X : Charts.Plottable
  nonisolated public init<Data, Y>(_ data: Data, x: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, some Plottable>, yStart: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, Y>, yEnd: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, Y>) where Content == Charts.VectorizedRulePlotContent<Data>, Data : Swift.RandomAccessCollection, Y : Charts.Plottable
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.RulePlot {
  nonisolated public init<Data>(_ data: Data, xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, y: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, some Plottable>) where Content == Charts.VectorizedRulePlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data, X>(_ data: Data, xStart: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, X>, xEnd: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, X>, y: CoreFoundation.CGFloat? = nil) where Content == Charts.VectorizedRulePlotContent<Data>, Data : Swift.RandomAccessCollection, X : Charts.Plottable
  nonisolated public init<Data>(_ data: Data, x: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, some Plottable>, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil) where Content == Charts.VectorizedRulePlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data, Y>(_ data: Data, x: CoreFoundation.CGFloat? = nil, yStart: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, Y>, yEnd: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, Y>) where Content == Charts.VectorizedRulePlotContent<Data>, Data : Swift.RandomAccessCollection, Y : Charts.Plottable
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.RulePlot {
  nonisolated public init<Data>(_ data: Data, xStart: Swift.KeyPath<Charts.RulePlot<Content>.DataElement, CoreFoundation.CGFloat>, xEnd: Swift.KeyPath<Charts.RulePlot<Content>.DataElement, CoreFoundation.CGFloat>, y: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, some Plottable>) where Content == Charts.VectorizedRulePlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data, X>(_ data: Data, xStart: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, X>, xEnd: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, X>, y: Swift.KeyPath<Charts.RulePlot<Content>.DataElement, CoreFoundation.CGFloat>) where Content == Charts.VectorizedRulePlotContent<Data>, Data : Swift.RandomAccessCollection, X : Charts.Plottable
  nonisolated public init<Data>(_ data: Data, x: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, some Plottable>, yStart: Swift.KeyPath<Charts.RulePlot<Content>.DataElement, CoreFoundation.CGFloat>, yEnd: Swift.KeyPath<Charts.RulePlot<Content>.DataElement, CoreFoundation.CGFloat>) where Content == Charts.VectorizedRulePlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data, Y>(_ data: Data, x: Swift.KeyPath<Charts.RulePlot<Content>.DataElement, CoreFoundation.CGFloat>, yStart: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, Y>, yEnd: Charts.PlottableProjection<Charts.RulePlot<Content>.DataElement, Y>) where Content == Charts.VectorizedRulePlotContent<Data>, Data : Swift.RandomAccessCollection, Y : Charts.Plottable
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@_Concurrency.MainActor @preconcurrency public struct VectorizedRulePlotContent<Data> : Charts.VectorizedChartContent where Data : Swift.RandomAccessCollection {
  public typealias DataElement = Data.Element
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Charts.VectorizedRulePlotContent<Data>, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Charts.VectorizedRulePlotContent<Data>, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.ChartContent {
  @_Concurrency.MainActor @preconcurrency public static func _makeChartContent(content: SwiftUICore._GraphValue<Self>, inputs: Charts._ChartContentInputs) -> Charts._ChartContentOutputs
  @_Concurrency.MainActor @preconcurrency public static func _chartContentCount(inputs: Charts._ChartContentInputs) -> Swift.Int?
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_Concurrency.MainActor @preconcurrency public struct RectangleMark {
  nonisolated public init<X, Y>(x: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>, width: Charts.MarkDimension = .automatic, height: Charts.MarkDimension = .automatic) where X : Charts.Plottable, Y : Charts.Plottable
  nonisolated public init<X>(x: Charts.PlottableValue<X>, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil, width: Charts.MarkDimension = .automatic) where X : Charts.Plottable
  nonisolated public init<Y>(xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, y: Charts.PlottableValue<Y>, height: Charts.MarkDimension = .automatic) where Y : Charts.Plottable
  nonisolated public init<X, Y>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>, height: Charts.MarkDimension = .automatic) where X : Charts.Plottable, Y : Charts.Plottable
  nonisolated public init<X>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil) where X : Charts.Plottable
  nonisolated public init<X, Y>(x: Charts.PlottableValue<X>, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>, width: Charts.MarkDimension = .automatic) where X : Charts.Plottable, Y : Charts.Plottable
  nonisolated public init<Y>(xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>) where Y : Charts.Plottable
  nonisolated public init<X, Y>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>) where X : Charts.Plottable, Y : Charts.Plottable
  nonisolated public init(xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil)
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Charts.RectangleMark, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Charts.RectangleMark, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUICore.ForEach : Charts.ChartContent where Content : Charts.ChartContent {
  @_Concurrency.MainActor @preconcurrency public var body: Swift.Never {
    get
  }
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: SwiftUICore.ForEach<Data, ID, Content>, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: SwiftUICore.ForEach<Data, ID, Content>, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUICore.ForEach where ID == Data.Element.ID, Content : Charts.ChartContent, Data.Element : Swift.Identifiable {
  nonisolated public init(_ data: Data, @Charts.ChartContentBuilder content: @escaping (Data.Element) -> Content)
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUICore.ForEach where Content : Charts.ChartContent {
  nonisolated public init(_ data: Data, id: Swift.KeyPath<Data.Element, ID>, @Charts.ChartContentBuilder content: @escaping (Data.Element) -> Content)
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_functionBuilder public struct AxisMarkBuilder {
  @_alwaysEmitIntoClient public static func buildBlock() -> some Charts.AxisMark {
        BuilderEmpty()
    }
  
  @available(iOS, introduced: 16.0, obsoleted: 18.0)
  @available(macOS, introduced: 13.0, obsoleted: 15.0)
  @available(tvOS, introduced: 16.0, obsoleted: 18.0)
  @available(watchOS, introduced: 9.0, obsoleted: 11.0)
  @available(visionOS, introduced: 1.0, obsoleted: 2.0)
  @_alwaysEmitIntoClient public static func buildPartialBlock<T>(first content: T) -> T where T : Charts.AxisMark {
        return content
    }
  @available(iOS, introduced: 16.0, obsoleted: 18.0)
  @available(macOS, introduced: 13.0, obsoleted: 15.0)
  @available(tvOS, introduced: 16.0, obsoleted: 18.0)
  @available(watchOS, introduced: 9.0, obsoleted: 11.0)
  @available(visionOS, introduced: 1.0, obsoleted: 2.0)
  @_alwaysEmitIntoClient public static func buildPartialBlock(accumulated: some AxisMark, next: some AxisMark) -> some Charts.AxisMark {
        BuilderPair(accumulated, next)
    }
  
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient public static func buildBlock<T>(_ content: T) -> T where T : Charts.AxisMark {
        content
    }
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_disfavoredOverload public static func buildBlock<each T>(_ content: repeat each T) -> some Charts.AxisMark where repeat each T : Charts.AxisMark {
        BuilderTuple(elements: (repeat each content))
    }
  
  @_alwaysEmitIntoClient public static func buildIf<T>(_ content: T?) -> T? where T : Charts.AxisMark {
        return content
    }
  @_alwaysEmitIntoClient public static func buildEither<T1, T2>(first: T1) -> Charts.BuilderConditional<T1, T2> where T1 : Charts.AxisMark, T2 : Charts.AxisMark {
        return .init(storage: .trueContent(first))
    }
  @_alwaysEmitIntoClient public static func buildEither<T1, T2>(second: T2) -> Charts.BuilderConditional<T1, T2> where T1 : Charts.AxisMark, T2 : Charts.AxisMark {
        return .init(storage: .falseContent(second))
    }
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<Content>(_ content: Content) -> Charts.AnyAxisMark where Content : Charts.AxisMark {
        return AnyAxisMark(content)
    }
  @_alwaysEmitIntoClient public static func buildExpression<Content>(_ content: Content) -> Content where Content : Charts.AxisMark {
        content
    }
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.BuilderTuple : Charts.AxisMark where repeat each T : Charts.AxisMark {
  @usableFromInline
  internal static func _layoutAxisMark(_ content: Charts.BuilderTuple<repeat each T>, _ inputs: Charts._AxisMarkLayoutInputs)
  @usableFromInline
  internal static func _renderAxisMark(_ content: Charts.BuilderTuple<repeat each T>, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.BuilderPair : Charts.AxisContent where T0 : Charts.AxisContent, T1 : Charts.AxisContent {
  @inlinable internal init(_ first: T0, _ second: T1) {
        self.first = first
        self.firstConformance = T0.conformanceToAxisContent
        self.second = second
        self.secondConformance = T1.conformanceToAxisContent
    }
  @usableFromInline
  internal static func _makeAxisContent(_ content: Charts.BuilderPair<T0, T1>, _ inputs: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension SwiftUICore.View {
  nonisolated public func chartScrollableAxes(_ axes: SwiftUICore.Axis.Set) -> some SwiftUICore.View
  
  nonisolated public func chartXVisibleDomain<P>(length: P) -> some SwiftUICore.View where P : Charts.Plottable, P : Swift.Numeric
  
  nonisolated public func chartYVisibleDomain<P>(length: P) -> some SwiftUICore.View where P : Charts.Plottable, P : Swift.Numeric
  
  nonisolated public func chartScrollTargetBehavior(_ behavior: some ChartScrollTargetBehavior) -> some SwiftUICore.View
  
  nonisolated public func chartScrollPosition(initialX: some Plottable) -> some SwiftUICore.View
  
  nonisolated public func chartScrollPosition(x: SwiftUICore.Binding<some Plottable>) -> some SwiftUICore.View
  
  nonisolated public func chartScrollPosition(initialY: some Plottable) -> some SwiftUICore.View
  
  nonisolated public func chartScrollPosition(y: SwiftUICore.Binding<some Plottable>) -> some SwiftUICore.View
  
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
@dynamicMemberLookup public struct ChartScrollTargetBehaviorContext {
  public var chartProxy: Charts.ChartProxy {
    get
  }
  public subscript<T>(dynamicMember keyPath: Swift.KeyPath<SwiftUI.ScrollTargetBehaviorContext, T>) -> T {
    get
  }
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public protocol ChartScrollTargetBehavior : SwiftUI.ScrollTargetBehavior {
  func updateTarget(_ target: inout SwiftUICore.ScrollTarget, context: Charts.ChartScrollTargetBehaviorContext)
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Charts.ChartScrollTargetBehavior {
  public func updateTarget(_ target: inout SwiftUICore.ScrollTarget, context: SwiftUI.ScrollTargetBehaviorContext)
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Charts.ChartScrollTargetBehavior {
  public static func valueAligned<P>(unit: P, majorAlignment: Charts.MajorValueAlignment<P>? = nil, limitBehavior: Charts.ValueAlignedLimitBehavior = .automatic) -> Charts.ValueAlignedChartScrollTargetBehavior where Self == Charts.ValueAlignedChartScrollTargetBehavior, P : Charts.Plottable, P : Swift.Numeric
  public static func valueAligned(matching components: Foundation.DateComponents, majorAlignment: Charts.MajorValueAlignment<Foundation.Date>? = nil, limitBehavior: Charts.ValueAlignedLimitBehavior = .automatic) -> Charts.ValueAlignedChartScrollTargetBehavior where Self == Charts.ValueAlignedChartScrollTargetBehavior
  public static func valueAligned<X, Y>(xUnit: X, yUnit: Y, xMajorAlignment: Charts.MajorValueAlignment<X>? = nil, yMajorAlignment: Charts.MajorValueAlignment<Y>? = nil, limitBehavior: Charts.ValueAlignedLimitBehavior = .automatic) -> Charts.ValueAlignedChartScrollTargetBehavior where Self == Charts.ValueAlignedChartScrollTargetBehavior, X : Charts.Plottable, X : Swift.Numeric, Y : Charts.Plottable, Y : Swift.Numeric
  public static func valueAligned(xMatching xComponents: Foundation.DateComponents, yMatching yComponents: Foundation.DateComponents, xMajorAlignment: Charts.MajorValueAlignment<Foundation.Date>? = nil, yMajorAlignment: Charts.MajorValueAlignment<Foundation.Date>? = nil, limitBehavior: Charts.ValueAlignedLimitBehavior = .automatic) -> Charts.ValueAlignedChartScrollTargetBehavior where Self == Charts.ValueAlignedChartScrollTargetBehavior
  public static func valueAligned<Y>(xMatching xComponents: Foundation.DateComponents, yUnit: Y, xMajorAlignment: Charts.MajorValueAlignment<Foundation.Date>? = nil, yMajorAlignment: Charts.MajorValueAlignment<Y>? = nil, limitBehavior: Charts.ValueAlignedLimitBehavior = .automatic) -> Charts.ValueAlignedChartScrollTargetBehavior where Self == Charts.ValueAlignedChartScrollTargetBehavior, Y : Charts.Plottable, Y : Swift.Numeric
  public static func valueAligned<X>(xUnit: X, yMatching yComponents: Foundation.DateComponents, xMajorAlignment: Charts.MajorValueAlignment<X>? = nil, yMajorAlignment: Charts.MajorValueAlignment<Foundation.Date>? = nil, limitBehavior: Charts.ValueAlignedLimitBehavior = .automatic) -> Charts.ValueAlignedChartScrollTargetBehavior where Self == Charts.ValueAlignedChartScrollTargetBehavior, X : Charts.Plottable, X : Swift.Numeric
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct ValueAlignedLimitBehavior {
  public static var automatic: Charts.ValueAlignedLimitBehavior {
    get
  }
  public static var always: Charts.ValueAlignedLimitBehavior {
    get
  }
  public static var never: Charts.ValueAlignedLimitBehavior {
    get
  }
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct MajorValueAlignment<Value> where Value : Charts.Plottable {
  public static func unit(_ unit: Value) -> Charts.MajorValueAlignment<Value> where Value : Swift.Numeric
  public static func matching(_ components: Foundation.DateComponents) -> Charts.MajorValueAlignment<Value> where Value == Foundation.Date
  public static var page: Charts.MajorValueAlignment<Value> {
    get
  }
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
public struct ValueAlignedChartScrollTargetBehavior : Charts.ChartScrollTargetBehavior {
  nonisolated public init<T>(unit: T, majorAlignment: Charts.MajorValueAlignment<T>? = nil, limitBehavior: Charts.ValueAlignedLimitBehavior = .automatic) where T : Charts.Plottable, T : Swift.Numeric
  nonisolated public init(matching components: Foundation.DateComponents, majorAlignment: Charts.MajorValueAlignment<Foundation.Date>? = nil, limitBehavior: Charts.ValueAlignedLimitBehavior = .automatic)
  nonisolated public init<X, Y>(xUnit: X, yUnit: Y, xMajorAlignment: Charts.MajorValueAlignment<X>? = nil, yMajorAlignment: Charts.MajorValueAlignment<Y>? = nil, limitBehavior: Charts.ValueAlignedLimitBehavior = .automatic) where X : Charts.Plottable, X : Swift.Numeric, Y : Charts.Plottable, Y : Swift.Numeric
  nonisolated public init(xMatching xComponents: Foundation.DateComponents, yMatching yComponents: Foundation.DateComponents, xMajorAlignment: Charts.MajorValueAlignment<Foundation.Date>? = nil, yMajorAlignment: Charts.MajorValueAlignment<Foundation.Date>? = nil, limitBehavior: Charts.ValueAlignedLimitBehavior = .automatic)
  nonisolated public init<Y>(xMatching xComponents: Foundation.DateComponents, yUnit: Y, xMajorAlignment: Charts.MajorValueAlignment<Foundation.Date>? = nil, yMajorAlignment: Charts.MajorValueAlignment<Y>? = nil, limitBehavior: Charts.ValueAlignedLimitBehavior = .automatic) where Y : Charts.Plottable, Y : Swift.Numeric
  nonisolated public init<X>(xUnit: X, yMatching yComponents: Foundation.DateComponents, xMajorAlignment: Charts.MajorValueAlignment<X>? = nil, yMajorAlignment: Charts.MajorValueAlignment<Foundation.Date>? = nil, limitBehavior: Charts.ValueAlignedLimitBehavior = .automatic) where X : Charts.Plottable, X : Swift.Numeric
  public func updateTarget(_ target: inout SwiftUICore.ScrollTarget, context: Charts.ChartScrollTargetBehaviorContext)
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension SwiftUI.PagingScrollTargetBehavior : Charts.ChartScrollTargetBehavior {
  public func updateTarget(_ target: inout SwiftUICore.ScrollTarget, context: Charts.ChartScrollTargetBehaviorContext)
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.BuilderPair : Charts.AxisMark where T0 : Charts.AxisMark, T1 : Charts.AxisMark {
  @inlinable internal init(_ first: T0, _ second: T1) {
        self.first = first
        self.firstConformance = T0.conformanceToAxisMark
        self.second = second
        self.secondConformance = T1.conformanceToAxisMark
    }
  @usableFromInline
  internal static func _layoutAxisMark(_ content: Charts.BuilderPair<T0, T1>, _ inputs: Charts._AxisMarkLayoutInputs)
  @usableFromInline
  internal static func _renderAxisMark(_ content: Charts.BuilderPair<T0, T1>, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct SectorPlot<Content> {
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.SectorPlot : Charts.ChartContent where Content : Charts.ChartContent {
  @_Concurrency.MainActor @preconcurrency public var body: some Charts.ChartContent {
    get
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Body = @_opaqueReturnTypeOf("$s6Charts10SectorPlotVA2A12ChartContentRzlE4bodyQrvp", 0) __<Content>
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.SectorPlot : Charts.VectorizedChartContent where Content : Charts.VectorizedChartContent {
  public typealias DataElement = Content.DataElement
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.SectorPlot {
  nonisolated public init<Data>(_ data: Data, angle: Charts.PlottableProjection<Charts.SectorPlot<Content>.DataElement, some Plottable>, innerRadius: Charts.MarkDimensions<Charts.SectorPlot<Content>.DataElement> = .automatic, outerRadius: Charts.MarkDimensions<Charts.SectorPlot<Content>.DataElement> = .automatic, angularInset: CoreFoundation.CGFloat? = nil) where Content == Charts.VectorizedSectorPlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data>(_ data: Data, angle: Charts.PlottableProjection<Charts.SectorPlot<Content>.DataElement, some Plottable>, innerRadius: Charts.MarkDimensions<Charts.SectorPlot<Content>.DataElement> = .automatic, outerRadius: Charts.MarkDimensions<Charts.SectorPlot<Content>.DataElement> = .automatic, angularInset: Swift.KeyPath<Charts.SectorPlot<Content>.DataElement, CoreFoundation.CGFloat>) where Content == Charts.VectorizedSectorPlotContent<Data>, Data : Swift.RandomAccessCollection
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@_Concurrency.MainActor @preconcurrency public struct VectorizedSectorPlotContent<Data> : Charts.VectorizedChartContent where Data : Swift.RandomAccessCollection {
  public typealias DataElement = Data.Element
  @_Concurrency.MainActor @preconcurrency public var body: some Charts.ChartContent {
    get
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Body = @_opaqueReturnTypeOf("$s6Charts27VectorizedSectorPlotContentV4bodyQrvp", 0) __<Data>
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct LinePlot<Content> {
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.LinePlot : Charts.ChartContent where Content : Charts.ChartContent {
  @_Concurrency.MainActor @preconcurrency public var body: some Charts.ChartContent {
    get
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Body = @_opaqueReturnTypeOf("$s6Charts8LinePlotVA2A12ChartContentRzlE4bodyQrvp", 0) __<Content>
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.LinePlot : Charts.VectorizedChartContent where Content : Charts.VectorizedChartContent {
  public typealias DataElement = Content.DataElement
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.LinePlot {
  nonisolated public init<Data>(_ data: Data, x: Charts.PlottableProjection<Charts.LinePlot<Content>.DataElement, some Plottable>, y: Charts.PlottableProjection<Charts.LinePlot<Content>.DataElement, some Plottable>) where Content == Charts.VectorizedLinePlotContent<Data>, Data : Swift.RandomAccessCollection
  nonisolated public init<Data>(_ data: Data, x: Charts.PlottableProjection<Charts.LinePlot<Content>.DataElement, some Plottable>, y: Charts.PlottableProjection<Charts.LinePlot<Content>.DataElement, some Plottable>, series: Charts.PlottableProjection<Charts.LinePlot<Content>.DataElement, some Plottable>) where Content == Charts.VectorizedLinePlotContent<Data>, Data : Swift.RandomAccessCollection
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.LinePlot where Content == Charts.FunctionLinePlotContent {
  nonisolated public init(x: SwiftUICore.Text, y: SwiftUICore.Text, domain: Swift.ClosedRange<Swift.Double>? = nil, function: @escaping @Sendable (Swift.Double) -> Swift.Double)
  nonisolated public init(x: SwiftUICore.LocalizedStringKey, y: SwiftUICore.LocalizedStringKey, domain: Swift.ClosedRange<Swift.Double>? = nil, function: @escaping @Sendable (Swift.Double) -> Swift.Double)
  @_disfavoredOverload nonisolated public init<S1, S2>(x: S1, y: S2, domain: Swift.ClosedRange<Swift.Double>? = nil, function: @escaping @Sendable (Swift.Double) -> Swift.Double) where S1 : Swift.StringProtocol, S2 : Swift.StringProtocol
  nonisolated public init(x: SwiftUICore.Text, y: SwiftUICore.Text, t: SwiftUICore.Text, domain: Swift.ClosedRange<Swift.Double>, function: @escaping @Sendable (Swift.Double) -> (x: Swift.Double, y: Swift.Double))
  nonisolated public init(x: SwiftUICore.LocalizedStringKey, y: SwiftUICore.LocalizedStringKey, t: SwiftUICore.LocalizedStringKey, domain: Swift.ClosedRange<Swift.Double>, function: @escaping @Sendable (Swift.Double) -> (x: Swift.Double, y: Swift.Double))
  @_disfavoredOverload nonisolated public init<S1, S2, S3>(x: S1, y: S2, t: S3, domain: Swift.ClosedRange<Swift.Double>, function: @escaping @Sendable (Swift.Double) -> (x: Swift.Double, y: Swift.Double)) where S1 : Swift.StringProtocol, S2 : Swift.StringProtocol, S3 : Swift.StringProtocol
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@_Concurrency.MainActor @preconcurrency public struct FunctionLinePlotContent {
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Charts.FunctionLinePlotContent, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Charts.FunctionLinePlotContent, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@_Concurrency.MainActor @preconcurrency public struct VectorizedLinePlotContent<Data> : Charts.VectorizedChartContent where Data : Swift.RandomAccessCollection {
  public typealias DataElement = Data.Element
  @_Concurrency.MainActor @preconcurrency public var body: some Charts.ChartContent {
    get
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Body = @_opaqueReturnTypeOf("$s6Charts25VectorizedLinePlotContentV4bodyQrvp", 0) __<Data>
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Charts.AxisContent {
  public func compositingLayer() -> some Charts.AxisContent
  
  public func compositingLayer<V>(@SwiftUICore.ViewBuilder style: (SwiftUICore.PlaceholderContentView<Self>) -> V) -> some Charts.AxisContent where V : SwiftUICore.View
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartContent {
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal static var conformanceToChartContent: Swift.UnsafeRawPointer {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.AxisContent {
  @usableFromInline
  internal static var conformanceToAxisContent: Swift.UnsafeRawPointer {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.AxisMark {
  @usableFromInline
  internal static var conformanceToAxisMark: Swift.UnsafeRawPointer {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public protocol ChartSymbolShape : SwiftUICore.Shape {
  var perceptualUnitRect: CoreFoundation.CGRect { get }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartSymbolShape where Self : SwiftUICore.InsettableShape {
  public func strokeBorder(lineWidth: CoreFoundation.CGFloat = 1) -> some Charts.ChartSymbolShape
  
  public func strokeBorder(style: SwiftUICore.StrokeStyle) -> some Charts.ChartSymbolShape
  
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct AnyChartSymbolShape : Charts.ChartSymbolShape {
  internal let storage: any Charts.ChartSymbolShape
  nonisolated public init(_ content: any Charts.ChartSymbolShape)
  nonisolated public func path(in rect: CoreFoundation.CGRect) -> SwiftUICore.Path
  public var perceptualUnitRect: CoreFoundation.CGRect {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias AnimatableData = SwiftUICore.EmptyAnimatableData
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Body = SwiftUICore._ShapeView<Charts.AnyChartSymbolShape, SwiftUICore.ForegroundStyle>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension SwiftUICore.Circle : Charts.ChartSymbolShape {
  public var perceptualUnitRect: CoreFoundation.CGRect {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct BasicChartSymbolShape : Charts.ChartSymbolShape {
  nonisolated public func path(in rect: CoreFoundation.CGRect) -> SwiftUICore.Path
  public var perceptualUnitRect: CoreFoundation.CGRect {
    get
  }
  public func strokeBorder(lineWidth: CoreFoundation.CGFloat = 1) -> some Charts.ChartSymbolShape
  
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias AnimatableData = SwiftUICore.EmptyAnimatableData
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Body = SwiftUICore._ShapeView<Charts.BasicChartSymbolShape, SwiftUICore.ForegroundStyle>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartSymbolShape where Self == Charts.BasicChartSymbolShape {
  public static var circle: Charts.BasicChartSymbolShape {
    get
  }
  public static var square: Charts.BasicChartSymbolShape {
    get
  }
  public static var triangle: Charts.BasicChartSymbolShape {
    get
  }
  public static var diamond: Charts.BasicChartSymbolShape {
    get
  }
  public static var pentagon: Charts.BasicChartSymbolShape {
    get
  }
  public static var plus: Charts.BasicChartSymbolShape {
    get
  }
  public static var cross: Charts.BasicChartSymbolShape {
    get
  }
  public static var asterisk: Charts.BasicChartSymbolShape {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_functionBuilder public struct AxisContentBuilder {
  @_alwaysEmitIntoClient public static func buildBlock() -> some Charts.AxisContent {
        BuilderEmpty()
    }
  
  @available(iOS, introduced: 16.0, obsoleted: 18.0)
  @available(macOS, introduced: 13.0, obsoleted: 15.0)
  @available(tvOS, introduced: 16.0, obsoleted: 18.0)
  @available(watchOS, introduced: 9.0, obsoleted: 11.0)
  @available(visionOS, introduced: 1.0, obsoleted: 2.0)
  @_alwaysEmitIntoClient public static func buildPartialBlock<T>(first content: T) -> T where T : Charts.AxisContent {
        content
    }
  @available(iOS, introduced: 16.0, obsoleted: 18.0)
  @available(macOS, introduced: 13.0, obsoleted: 15.0)
  @available(tvOS, introduced: 16.0, obsoleted: 18.0)
  @available(watchOS, introduced: 9.0, obsoleted: 11.0)
  @available(visionOS, introduced: 1.0, obsoleted: 2.0)
  @_alwaysEmitIntoClient public static func buildPartialBlock(accumulated: some AxisContent, next: some AxisContent) -> some Charts.AxisContent {
        BuilderPair(accumulated, next)
    }
  
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient public static func buildBlock<T>(_ content: T) -> T where T : Charts.AxisContent {
        content
    }
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_disfavoredOverload public static func buildBlock<each T>(_ content: repeat each T) -> some Charts.AxisContent where repeat each T : Charts.AxisContent {
        BuilderTuple(elements: (repeat each content))
    }
  
  @_alwaysEmitIntoClient public static func buildIf<T>(_ content: T?) -> T? where T : Charts.AxisContent {
        content
    }
  @_alwaysEmitIntoClient public static func buildEither<T1, T2>(first: T1) -> Charts.BuilderConditional<T1, T2> where T1 : Charts.AxisContent, T2 : Charts.AxisContent {
        .init(storage: .trueContent(first))
    }
  @_alwaysEmitIntoClient public static func buildEither<T1, T2>(second: T2) -> Charts.BuilderConditional<T1, T2> where T1 : Charts.AxisContent, T2 : Charts.AxisContent {
        .init(storage: .falseContent(second))
    }
  @_alwaysEmitIntoClient public static func buildLimitedAvailability<Content>(_ content: Content) -> Charts.AnyAxisContent where Content : Charts.AxisContent {
        AnyAxisContent(content)
    }
  @_alwaysEmitIntoClient public static func buildExpression<Content>(_ content: Content) -> Content where Content : Charts.AxisContent {
        content
    }
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.BuilderTuple : Charts.AxisContent where repeat each T : Charts.AxisContent {
  @usableFromInline
  internal static func _makeAxisContent(_ content: Charts.BuilderTuple<repeat each T>, _ inputs: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_Concurrency.MainActor @preconcurrency public struct PointMark {
  nonisolated public init<X, Y>(x: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>) where X : Charts.Plottable, Y : Charts.Plottable
  nonisolated public init<X>(x: Charts.PlottableValue<X>, y: CoreFoundation.CGFloat? = nil) where X : Charts.Plottable
  nonisolated public init<Y>(x: CoreFoundation.CGFloat? = nil, y: Charts.PlottableValue<Y>) where Y : Charts.Plottable
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Charts.PointMark, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Charts.PointMark, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.PointMark {
  @_Concurrency.MainActor @preconcurrency public static func _makeChartContent(content: SwiftUICore._GraphValue<Charts.PointMark>, inputs: Charts._ChartContentInputs) -> Charts._ChartContentOutputs
  @_Concurrency.MainActor @preconcurrency public static func _chartContentCount(inputs: Charts._ChartContentInputs) -> Swift.Int?
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_typeEraser(AnyAxisContent) public protocol AxisContent {
  static func _makeAxisContent(_ content: Self, _ inputs: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _AxisContentInputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _AxisContentOutputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Never : Charts.AxisContent {
  public static func _makeAxisContent(_ content: Swift.Never, _ inputs: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct AnyAxisContent : Charts.AxisContent {
  @usableFromInline
  internal let storage: any Charts.AxisContent
  @inlinable nonisolated public init(_ content: any Charts.AxisContent) {
        storage = content
    }
  @inlinable nonisolated public init(erasing content: some AxisContent) {
        self.init(content)
    }
  public static func _makeAxisContent(_ content: Charts.AnyAxisContent, _ inputs: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Optional : Charts.AxisContent where Wrapped : Charts.AxisContent {
  public static func _makeAxisContent(_ content: Wrapped?, _ inputs: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.BuilderConditional : Charts.AxisContent where TrueContent : Charts.AxisContent, FalseContent : Charts.AxisContent {
  public static func _makeAxisContent(_ content: Charts.BuilderConditional<TrueContent, FalseContent>, _ inputs: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.BuilderEmpty : Charts.AxisContent {
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal static func _makeAxisContent(_: Charts.BuilderEmpty, _: Charts._AxisContentInputs) -> Charts._AxisContentOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_Concurrency.MainActor @preconcurrency public struct Plot<Content> where Content : Charts.ChartContent {
  nonisolated public init(@Charts.ChartContentBuilder content: () -> Content)
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Charts.Plot<Content>, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Charts.Plot<Content>, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public protocol Plottable {
  associatedtype PrimitivePlottable : Charts.PrimitivePlottableProtocol
  var primitivePlottable: Self.PrimitivePlottable { get }
  init?(primitivePlottable: Self.PrimitivePlottable)
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public protocol PrimitivePlottableProtocol : Charts.Plottable where Self == Self.PrimitivePlottable {
  static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Self> { get }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.PrimitivePlottableProtocol {
  public var primitivePlottable: Self {
    get
  }
  nonisolated public init?(primitivePlottable: Self.PrimitivePlottable)
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _PrimitivePlottableKind<Value> where Value : Charts.PrimitivePlottableProtocol {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.Plottable where Self : Swift.RawRepresentable, Self.RawValue == Swift.String {
  public var primitivePlottable: Swift.String {
    get
  }
  nonisolated public init?(primitivePlottable: Self.RawValue)
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Never : Charts.PrimitivePlottableProtocol {
  public static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Swift.Never> {
    get
  }
  public var primitivePlottable: Swift.Never {
    get
  }
  nonisolated public init?(primitivePlottable: Swift.Never)
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Swift.Never
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Double : Charts.Plottable, Charts.PrimitivePlottableProtocol {
  public static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Swift.Double> {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Swift.Double
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.String : Charts.Plottable, Charts.PrimitivePlottableProtocol {
  public static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Swift.String> {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Swift.String
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Date : Charts.Plottable, Charts.PrimitivePlottableProtocol {
  public static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Foundation.Date> {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Foundation.Date
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Float16 : Charts.PrimitivePlottableProtocol {
  public static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Swift.Float16> {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Swift.Float16
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Float : Charts.PrimitivePlottableProtocol {
  public static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Swift.Float> {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Swift.Float
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Decimal : Charts.Plottable {
  public var primitivePlottable: Swift.Double {
    get
  }
  nonisolated public init?(primitivePlottable: Swift.Double)
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Swift.Double
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Int : Charts.PrimitivePlottableProtocol {
  public var primitivePlottable: Swift.Int {
    get
  }
  nonisolated public init?(primitivePlottable: Swift.Int)
  public static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Swift.Int> {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Swift.Int
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Int8 : Charts.PrimitivePlottableProtocol {
  public static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Swift.Int8> {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Swift.Int8
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Int16 : Charts.PrimitivePlottableProtocol {
  public var primitivePlottable: Swift.Int16 {
    get
  }
  nonisolated public init?(primitivePlottable: Swift.Int16)
  public static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Swift.Int16> {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Swift.Int16
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Int32 : Charts.PrimitivePlottableProtocol {
  public static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Swift.Int32> {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Swift.Int32
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Int64 : Charts.PrimitivePlottableProtocol {
  public var primitivePlottable: Swift.Int64 {
    get
  }
  nonisolated public init?(primitivePlottable: Swift.Int64)
  public static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Swift.Int64> {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Swift.Int64
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.UInt : Charts.PrimitivePlottableProtocol {
  public static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Swift.UInt> {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Swift.UInt
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.UInt8 : Charts.PrimitivePlottableProtocol {
  public var primitivePlottable: Swift.UInt8 {
    get
  }
  nonisolated public init?(primitivePlottable: Swift.UInt8)
  public static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Swift.UInt8> {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Swift.UInt8
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.UInt16 : Charts.PrimitivePlottableProtocol {
  public static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Swift.UInt16> {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Swift.UInt16
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.UInt32 : Charts.PrimitivePlottableProtocol {
  public static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Swift.UInt32> {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Swift.UInt32
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.UInt64 : Charts.PrimitivePlottableProtocol {
  public static var _primitivePlottableKind: Charts._PrimitivePlottableKind<Swift.UInt64> {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias PrimitivePlottable = Swift.UInt64
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_Concurrency.MainActor @preconcurrency public struct RuleMark {
  nonisolated public init<Y>(xStart: CoreFoundation.CGFloat? = nil, xEnd: CoreFoundation.CGFloat? = nil, y: Charts.PlottableValue<Y>) where Y : Charts.Plottable
  nonisolated public init<X, Y>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, y: Charts.PlottableValue<Y>) where X : Charts.Plottable, Y : Charts.Plottable
  nonisolated public init<X>(xStart: Charts.PlottableValue<X>, xEnd: Charts.PlottableValue<X>, y: CoreFoundation.CGFloat? = nil) where X : Charts.Plottable
  nonisolated public init<X>(x: Charts.PlottableValue<X>, yStart: CoreFoundation.CGFloat? = nil, yEnd: CoreFoundation.CGFloat? = nil) where X : Charts.Plottable
  nonisolated public init<X, Y>(x: Charts.PlottableValue<X>, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>) where X : Charts.Plottable, Y : Charts.Plottable
  nonisolated public init<Y>(x: CoreFoundation.CGFloat? = nil, yStart: Charts.PlottableValue<Y>, yEnd: Charts.PlottableValue<Y>) where Y : Charts.Plottable
  @_Concurrency.MainActor @preconcurrency public static func _layoutChartContent(_ content: Charts.RuleMark, _ inputs: Charts._ChartContentLayoutInputs)
  @_Concurrency.MainActor @preconcurrency public static func _renderChartContent(_ content: Charts.RuleMark, _ inputs: Charts._ChartContentRenderInputs) -> Charts._ChartContentRenderOutputs
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Body = Swift.Never
}
@available(iOS 18.0, macOS 15.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public protocol _ChartContentModifier {
  associatedtype Body : Charts._ChartContentModifier
  var body: Self.Body { get }
  static func _makeChartContent(modifier: SwiftUICore._GraphValue<Self>, inputs: Charts._ChartContentInputs, body: @escaping (Charts._ChartContentInputs) -> Charts._ChartContentOutputs) -> Charts._ChartContentOutputs
  static func _chartContentCount(inputs: Charts._ChartContentInputs, body: @escaping (Charts._ChartContentInputs) -> Swift.Int?) -> Swift.Int?
}
@available(iOS 18.0, macOS 15.0, watchOS 11.0, tvOS 18.0, *)
extension Charts._ChartContentModifier {
  public static func _makeChartContent(modifier: SwiftUICore._GraphValue<Self>, inputs: Charts._ChartContentInputs, body: @escaping (Charts._ChartContentInputs) -> Charts._ChartContentOutputs) -> Charts._ChartContentOutputs
  public static func _chartContentCount(inputs: Charts._ChartContentInputs, body: @escaping (Charts._ChartContentInputs) -> Swift.Int?) -> Swift.Int?
}
@available(iOS 18.0, macOS 15.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Never : Charts._ChartContentModifier {
}
@available(iOS 18.0, macOS 15.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Charts.ChartModifiedContent : Charts.ChartContent where Content : Charts.ChartContent, Modifier : Charts._ChartContentModifier {
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal var body: Swift.Never {
    get
  }
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal static func _makeChartContent(content: SwiftUICore._GraphValue<Charts.ChartModifiedContent<Content, Modifier>>, inputs: Charts._ChartContentInputs) -> Charts._ChartContentOutputs
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal static func _chartContentCount(inputs: Charts._ChartContentInputs) -> Swift.Int?
}
@available(iOS 18.0, macOS 15.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Charts.ChartContent {
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal func modifier<M>(_ modifier: M) -> Charts.ChartModifiedContent<Self, M> where M : Charts._ChartContentModifier
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@_typeEraser(AnyAxisMark) public protocol AxisMark {
  static func _layoutAxisMark(_ content: Self, _ inputs: Charts._AxisMarkLayoutInputs)
  static func _renderAxisMark(_ content: Self, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _AxisMarkLayoutInputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _AxisMarkRenderInputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct _AxisMarkRenderOutputs {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Never : Charts.AxisMark {
  public static func _layoutAxisMark(_ content: Swift.Never, _ inputs: Charts._AxisMarkLayoutInputs)
  public static func _renderAxisMark(_ content: Swift.Never, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public struct AnyAxisMark : Charts.AxisMark {
  @usableFromInline
  internal let storage: any Charts.AxisMark
  @inlinable nonisolated public init(_ content: any Charts.AxisMark) {
        storage = content
    }
  @inlinable nonisolated public init(erasing content: some AxisMark) {
        self.init(content)
    }
  public static func _layoutAxisMark(_ content: Charts.AnyAxisMark, _ inputs: Charts._AxisMarkLayoutInputs)
  public static func _renderAxisMark(_ content: Charts.AnyAxisMark, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Optional : Charts.AxisMark where Wrapped : Charts.AxisMark {
  public static func _layoutAxisMark(_ content: Wrapped?, _ inputs: Charts._AxisMarkLayoutInputs)
  public static func _renderAxisMark(_ content: Wrapped?, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.BuilderEmpty : Charts.AxisMark {
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal static func _layoutAxisMark(_: Charts.BuilderEmpty, _: Charts._AxisMarkLayoutInputs)
  @usableFromInline
  @_Concurrency.MainActor @preconcurrency internal static func _renderAxisMark(_: Charts.BuilderEmpty, _: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.BuilderConditional : Charts.AxisMark where TrueContent : Charts.AxisMark, FalseContent : Charts.AxisMark {
  public static func _layoutAxisMark(_ content: Charts.BuilderConditional<TrueContent, FalseContent>, _ inputs: Charts._AxisMarkLayoutInputs)
  public static func _renderAxisMark(_ content: Charts.BuilderConditional<TrueContent, FalseContent>, _ inputs: Charts._AxisMarkRenderInputs) -> Charts._AxisMarkRenderOutputs
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Charts.ChartAxisContent : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.Chart : Swift.Sendable {}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Charts.SectorMark : Charts.ChartContent {}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension Charts.SectorMark : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.MarkDimension : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.MarkDimension : Swift.BitwiseCopyable {}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.FunctionAreaPlotContent : Charts.ChartContent {}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.FunctionAreaPlotContent : Swift.Sendable {}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedAreaPlotContent : Swift.Sendable {}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedRectanglePlotContent : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.MarkStackingMethod : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.MarkStackingMethod : Swift.BitwiseCopyable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.MarkStackingMethod.Storage : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.MarkStackingMethod.Storage : Swift.BitwiseCopyable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.MarkDimension.Storage : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.MarkDimension.Storage : Swift.BitwiseCopyable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.InterpolationMethod : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.InterpolationMethod : Swift.BitwiseCopyable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.InterpolationMethod.Storage : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.InterpolationMethod.Storage : Swift.BitwiseCopyable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.PointMark : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.PointMark : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.AreaMark : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.AreaMark : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.DateBins : Swift.Collection {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.DateBins : Swift.Equatable {}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedBarPlotContent : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.BuilderEmpty : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.BuilderEmpty : Swift.BitwiseCopyable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.AnyChartContent : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.AnyChartContent : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.NumberBins : Swift.Collection {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.NumberBins : Swift.Equatable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.LineMark : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.LineMark : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.ChartPlotContent : Swift.Sendable {}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedPointPlotContent : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.BarMark : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.BarMark : Swift.Sendable {}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedRulePlotContent : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.RectangleMark : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.RectangleMark : Swift.Sendable {}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedSectorPlotContent : Swift.Sendable {}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.FunctionLinePlotContent : Charts.ChartContent {}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.FunctionLinePlotContent : Swift.Sendable {}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Charts.VectorizedLinePlotContent : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.Plot : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.Plot : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.RuleMark : Charts.ChartContent {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension Charts.RuleMark : Swift.Sendable {}
