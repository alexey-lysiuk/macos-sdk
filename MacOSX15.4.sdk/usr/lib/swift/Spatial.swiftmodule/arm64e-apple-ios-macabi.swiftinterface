// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1 effective-5.10 (swiftlang-6.1.0.110.5 clang-1700.0.13.3)
// swift-module-flags: -target arm64e-apple-ios18.4-macabi -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftSpatial -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 99 -module-name Spatial
// swift-module-flags-ignorable:  -interface-compiler-version 6.1
@_exported import Spatial
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
@available(*, deprecated, renamed: "Axis3D.x")
public let x: Spatial.Axis3D
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
@available(*, deprecated, renamed: "Axis3D.y")
public let y: Spatial.Axis3D
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
@available(*, deprecated, renamed: "Axis3D.z")
public let z: Spatial.Axis3D
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D {
  @available(*, deprecated, renamed: "Rotation3D.init(angle:axis:)")
  public init(axis: Spatial.RotationAxis3D, angle: Spatial.Angle2D)
  @available(*, deprecated, renamed: "Rotation3D.init()")
  public init(quaternion: simd.simd_quatf)
  @available(*, deprecated, renamed: "Rotation3D.init()")
  public init(quaternion: simd.simd_quatd)
  @available(*, deprecated, renamed: "Rotation3D.init(position:target:up:)")
  public init(eye: Spatial.Point3D, target: Spatial.Point3D, up: Spatial.Vector3D = Vector3D(x: 0, y: 1, z: 0))
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  @available(*, deprecated, renamed: "vector")
  @inlinable public var simd: simd.simd_double3 {
    get {
            return self.vector
        }
    set {
            self.vector = newValue
        }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @available(*, deprecated, renamed: "vector")
  @inlinable public var simd: simd.simd_double3 {
    get {
            return self.vector
        }
    set {
            self.vector = newValue
        }
  }
  @available(*, deprecated, message: "This property is deprecated")
  @inlinable public var origin: Spatial.Point3D {
    get {
        return self
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D {
  @available(*, deprecated, renamed: "vector")
  @inlinable public var simd: simd.simd_double3 {
    get {
            return self.vector
        }
    set {
            self.vector = newValue
        }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  @available(*, deprecated, renamed: "contains(anyOf:)")
  @inlinable public func containsAny(of points: [Spatial.Point3D]) -> Swift.Bool {
        return __SPSize3DContainsAnyPoint(self,
                                          points,
                                          Int32(points.count))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D {
  @available(*, deprecated, renamed: "contains(anyOf:)")
  @inlinable public func containsAny(of points: [Spatial.Point3D]) -> Swift.Bool {
        return __SPRect3DContainsAnyPoint(self,
                                          points,
                                          Int32(points.count))
    }
  @available(*, deprecated, message: "This function is deprecated")
  @inlinable public func distance(to other: Spatial.Rect3D) -> Swift.Double {
        return self.origin.distance(to: other.origin)
    }
  @available(*, deprecated, message: "This function is deprecated")
  @inlinable public func rotation(to other: Spatial.Rect3D) -> Spatial.Rotation3D {
        return self.origin.rotation(to: other.origin)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.Point3D {
        return self.translated(by: Vector3D(size))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.Rect3D {
        return self.translated(by: Vector3D(size))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.Ray3D {
        return self.translated(by: Vector3D(size))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.Pose3D {
        return self.translated(by: Vector3D(size))
    }
  @available(*, deprecated, renamed: "init(_:)")
  @inlinable public init?(matrix: simd.simd_double4x4) {
        
        self.init(matrix)
    }
  @available(*, deprecated, renamed: "init(_:)")
  @inlinable public init?(matrix: simd.simd_float4x4) {
        
        self.init(matrix)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D {
  @available(*, deprecated, message: "Use `AffineTransform3D.init(truncating:)` instead.")
  @inlinable public init?(projectiveTransform transform: Spatial.ProjectiveTransform3D) {
        
        let affine = __SPAffineTransform3DMakeWithProjective(transform)
        
        if __SPAffineTransform3DIsValid(affine) {
            self = affine
        } else {
            return nil
        }
    }
  @available(*, deprecated, message: "Use `AffineTransform3D.init(truncating:)` instead.")
  @inlinable public init?(_ matrix: simd.simd_double4x4) {

        let affine = __SPAffineTransform3DMakeWith4x4Matrix(matrix)

        if __SPAffineTransform3DIsValid(affine) {
            self = affine
        } else {
            return nil
        }
    }
  @available(*, deprecated, renamed: "init(offset:)", message: "Use `Vector3D` variant.")
  @inlinable public init(translation: Spatial.Size3D) {
        self.init(translation: Vector3D(translation))
    }
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.AffineTransform3D {
        return self.translated(by: Vector3D(size))
    }
  @available(*, deprecated, renamed: "translation")
  @inlinable public var offset: Spatial.Vector3D {
    get {
            return __SPAffineTransform3DGetTranslation(self)
        }
    set {
            __SPAffineTransform3DSetTranslation(&self, newValue)
        }
  }
  @available(*, deprecated, message: "Use `AffineTransform3D.getter:inverse` instead.")
  @inlinable public func inverted() -> Spatial.AffineTransform3D? {
        
        return inverse
    }
  @available(*, deprecated, renamed: "init(_:)")
  @inlinable public init(matrix: simd.simd_float4x3) {
        self.init(matrix)
    }
  @available(*, deprecated, renamed: "init(_:)")
  @inlinable public init?(matrix: simd.simd_float4x4) {
        self.init(matrix)
    }
  @available(*, deprecated, renamed: "init(_:)")
  @inlinable public init?(matrix: simd.simd_double4x4) {
        
        self.init(matrix)
    }
  @available(*, deprecated, message: "Use `AffineTransform3D.init(truncating:)` instead.")
  @inlinable public init?(_ matrix: simd.simd_float4x4) {

        let column0 = matrix.columns.0
        let column1 = matrix.columns.1
        let column2 = matrix.columns.2
        let column3 = matrix.columns.3
        
        let m = simd_double4x4([
            simd_double4(Double(column0.x), Double(column0.y),
                         Double(column0.z), Double(column0.w)),
            simd_double4(Double(column1.x), Double(column1.y),
                         Double(column1.z), Double(column1.w)),
            simd_double4(Double(column2.x), Double(column2.y),
                         Double(column2.z), Double(column2.w)),
            simd_double4(Double(column3.x), Double(column3.y),
                         Double(column3.z), Double(column3.w))
        ])
        
        let affine = __SPAffineTransform3DMakeWith4x4Matrix(m)

        if __SPAffineTransform3DIsValid(affine) {
            self = affine
        } else {
            return nil
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D {
  @available(*, deprecated, renamed: "init(offset:)", message: "Use `Vector3D` variant.")
  @inlinable public init(translation: Spatial.Size3D) {
        self.init(translation: Vector3D(translation))
    }
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.ProjectiveTransform3D {
        return self.translated(by: Vector3D(size))
    }
  @available(*, deprecated, renamed: "translation")
  @inlinable public var offset: Spatial.Vector3D {
    get {
            return __SPProjectiveTransform3DGetTranslation(self)
        }
    set {
            __SPProjectiveTransform3DSetTranslation(&self, newValue)
        }
  }
  @available(*, deprecated, message: "Use `ProjectiveTransform3D.getter:inverse` instead.")
  @inlinable public func inverted() -> Spatial.ProjectiveTransform3D? {
        
        return inverse
    }
  @available(*, deprecated, renamed: "init(_:)")
  @inlinable public init(matrix: simd.simd_float4x4) {
        self.init(matrix)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.SIMD3 where Scalar == Swift.Float {
  @available(*, deprecated, renamed: "SIMD3.init(_:)")
  @inlinable public init(rotationAxis: Spatial.RotationAxis3D) {
        self.init(rotationAxis)
    }
  @available(*, deprecated, renamed: "SIMD3.init(_:)")
  @inlinable public init(point: Spatial.Point3D) {
        self.init(x: Float(point.x),
                  y: Float(point.y),
                  z: Float(point.z))
    }
  @available(*, deprecated, renamed: "SIMD3.init(_:)")
  @inlinable public init(vector: Spatial.Vector3D) {
        self.init(x: Float(vector.x),
                  y: Float(vector.y),
                  z: Float(vector.z))
    }
  @available(*, deprecated, renamed: "SIMD3.init(_:)")
  @inlinable public init(size: Spatial.Size3D) {
        self.init(x: Float(size.width),
                  y: Float(size.height),
                  z: Float(size.depth))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension simd.simd_quatf {
  @available(*, deprecated, renamed: "simd_quatf.init(_:)")
  @inlinable public init(rotation: Spatial.Rotation3D) {
        
        self.init(vector: simd_float(rotation.quaternion.vector))
        
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension simd.simd_float4x3 {
  @available(*, deprecated, renamed: "simd_float4x3.init(_:)")
  @inlinable public init(affineTransform: Spatial.AffineTransform3D) {
        
        self.init(affineTransform)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension simd.simd_float4x4 {
  @available(*, deprecated, renamed: "simd_float4x4.init(_:)")
  @inlinable public init(projectiveTransform: Spatial.ProjectiveTransform3D) {
        
        self.init(projectiveTransform)
    }
  @available(*, deprecated, renamed: "simd_float4x4.init(_:)")
  @inlinable public init(affineTransform: Spatial.AffineTransform3D) {
        
        self.init(affineTransform)
    }
  @available(*, deprecated, renamed: "simd_float4x4.init(_:)")
  @inlinable public init(pose: Spatial.Pose3D) {
        
        self.init(pose)
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.EulerAngles {
  @available(*, deprecated, renamed: "init(x:y:z:order:)")
  public init(_ x: Spatial.Angle2D, _ y: Spatial.Angle2D, _ z: Spatial.Angle2D, order: Spatial.EulerAngles.Order)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Rect3D {
  @available(*, deprecated, message: "Use `Rect3D.min.x`.")
  public var minX: Swift.Double {
    get
  }
  @available(*, deprecated, message: "Use `Rect3D.min.y`.")
  public var minY: Swift.Double {
    get
  }
  @available(*, deprecated, message: "Use `Rect3D.min.z`.")
  public var minZ: Swift.Double {
    get
  }
  @available(*, deprecated, message: "Use `Rect3D.center.x`.")
  public var midX: Swift.Double {
    get
  }
  @available(*, deprecated, message: "Use `Rect3D.center.y`.")
  public var midY: Swift.Double {
    get
  }
  @available(*, deprecated, message: "Use `Rect3D.center.z`.")
  public var midZ: Swift.Double {
    get
  }
  @available(*, deprecated, message: "Use `Rect3D.max.x`.")
  public var maxX: Swift.Double {
    get
  }
  @available(*, deprecated, message: "Use `Rect3D.max.y`.")
  public var maxY: Swift.Double {
    get
  }
  @available(*, deprecated, message: "Use `Rect3D.max.z`.")
  public var maxZ: Swift.Double {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public init(x: Swift.Double = 0, y: Swift.Double = 0, z: Swift.Double = 0) {
        self = __SPPoint3DMake(x, y, z)
    }
  @inlinable public init(_ xyz: simd.simd_double3) {
        self = __SPPoint3DMakeWithVector(xyz)
    }
  @inlinable public init(_ xyz: Spatial.Vector3D) {
        self = __SPPoint3DMakeWithVector(xyz)
    }
  @inlinable public init(_ size: Spatial.Size3D) {
        self = __SPPoint3DMakeWithSize(size)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public mutating func clamp(to rect: Spatial.Rect3D) {
        self = self.clamped(to: rect)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Spatial.Primitive3D {
  public func applying(_ pose: Spatial.Pose3D) -> Spatial.Point3D
  public func unapplying(_ pose: Spatial.Pose3D) -> Spatial.Point3D
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Point3D {
  public func applying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Point3D
  public func unapplying(_ pose: Spatial.ScaledPose3D) -> Spatial.Point3D
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Spatial.Rotatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Spatial.Translatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Point3D, rhs: Spatial.Point3D) -> Swift.Bool {
        return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z
    }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Point3D {
  @inlinable public func isApproximatelyEqual(to other: Spatial.Point3D, tolerance: Swift.Double = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPPoint3DAlmostEqualToPoint(self, other, tolerance)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Point3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public static func + (lhs: Spatial.Point3D, rhs: Spatial.Size3D) -> Spatial.Point3D {
       
        return Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func += (lhs: inout Spatial.Point3D, rhs: Spatial.Size3D) {
       
        lhs = Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func + (lhs: Spatial.Size3D, rhs: Spatial.Point3D) -> Spatial.Point3D {
       
        return Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Point3D, rhs: Spatial.Size3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Point3D, rhs: Spatial.Size3D) {
        
        lhs = Point3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Size3D, rhs: Spatial.Point3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector - rhs.vector)
    }
  @inlinable prefix public static func - (point: Spatial.Point3D) -> Spatial.Point3D {
        
        return Point3D(-point.vector)
    }
  @inlinable public static func * (lhs: Swift.Double, rhs: Spatial.Point3D) -> Spatial.Point3D {
        return Point3D(lhs * rhs.vector)
    }
  @inlinable public static func *= (lhs: inout Spatial.Point3D, rhs: Swift.Double) {
        lhs = Point3D(rhs * lhs.vector)
    }
  @inlinable public static func * (lhs: Spatial.Point3D, rhs: Swift.Double) -> Spatial.Point3D {
        return Point3D(lhs.vector * rhs)
    }
  @inlinable public static func / (lhs: Spatial.Point3D, rhs: Swift.Double) -> Spatial.Point3D {
        return Point3D(lhs.vector / rhs)
    }
  @inlinable public static func /= (lhs: inout Spatial.Point3D, rhs: Swift.Double) {
        lhs = Point3D(lhs.vector / rhs)
    }
  @inlinable public static func * (lhs: Spatial.AffineTransform3D, rhs: Spatial.Point3D) -> Spatial.Point3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.Point3D) -> Spatial.Point3D {

        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.Pose3D, rhs: Spatial.Point3D) -> Spatial.Point3D {

        return rhs.applying(lhs)
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Size3D : Swift.AdditiveArithmetic {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  @inlinable prefix public static func - (size: Spatial.Size3D) -> Spatial.Size3D {
        return Size3D(-size.vector)
    }
  @inlinable public static func + (lhs: Spatial.Size3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        return Size3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func += (lhs: inout Spatial.Size3D, rhs: Spatial.Size3D) {
        lhs = Size3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Size3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        return Size3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Size3D, rhs: Spatial.Size3D) {
        lhs = Size3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func * (lhs: Swift.Double, rhs: Spatial.Size3D) -> Spatial.Size3D {
        return Size3D(lhs * rhs.vector)
    }
  @inlinable public static func * (lhs: Spatial.Size3D, rhs: Swift.Double) -> Spatial.Size3D {
        return Size3D(lhs.vector * rhs)
    }
  @inlinable public static func *= (lhs: inout Spatial.Size3D, rhs: Swift.Double) {
        lhs = Size3D(lhs.vector * rhs)
    }
  @inlinable public static func / (lhs: Spatial.Size3D, rhs: Swift.Double) -> Spatial.Size3D {
        return Size3D(lhs.vector / rhs)
    }
  @inlinable public static func /= (lhs: inout Spatial.Size3D, rhs: Swift.Double) {
        lhs = Size3D(lhs.vector / rhs)
    }
  @inlinable public static func * (lhs: Spatial.AffineTransform3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.Pose3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        
        return rhs.applying(lhs)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D {
  @inlinable public static func * (lhs: Spatial.AffineTransform3D, rhs: Spatial.Rect3D) -> Spatial.Rect3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.Rect3D) -> Spatial.Rect3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.Pose3D, rhs: Spatial.Rect3D) -> Spatial.Rect3D {
        
        return rhs.applying(lhs)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D {
  @inlinable public static func * (lhs: Spatial.AffineTransform3D, rhs: Spatial.AffineTransform3D) -> Spatial.AffineTransform3D {
        
        let result = lhs.concatenating(rhs)
        
        return result
    }
  @inlinable public static func *= (lhs: inout Spatial.AffineTransform3D, rhs: Spatial.AffineTransform3D) {
        
        lhs = lhs.concatenating(rhs)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D {
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.ProjectiveTransform3D) -> Spatial.ProjectiveTransform3D {
        
        let result = lhs.concatenating(rhs)
        
        return result
    }
  @inlinable public static func *= (lhs: inout Spatial.ProjectiveTransform3D, rhs: Spatial.ProjectiveTransform3D) {
        
        lhs = lhs.concatenating(rhs)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
@inlinable public func * <T>(lhs: Spatial.Rotation3D, rhs: T) -> T where T : Spatial.Rotatable3D {
    
    let result = rhs.rotated(by: lhs)
    
    return result
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public static func - (lhs: Spatial.Point3D, rhs: Spatial.Point3D) -> Spatial.Vector3D {
        
        return Vector3D(lhs.vector - rhs.vector)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D {
  @inlinable public static func + (lhs: Spatial.Point3D, rhs: Spatial.Vector3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func + (lhs: Spatial.Vector3D, rhs: Spatial.Point3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Point3D, rhs: Spatial.Vector3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Vector3D, rhs: Spatial.Point3D) -> Spatial.Point3D {
        
        return Point3D(lhs.vector - rhs.vector)
    }
  @inlinable prefix public static func - (vector: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return Vector3D(-vector.vector)
    }
  @inlinable public static func + (lhs: Spatial.Vector3D, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return Vector3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func += (lhs: inout Spatial.Vector3D, rhs: Spatial.Vector3D) {
        
        lhs = Vector3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Vector3D, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return Vector3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Vector3D, rhs: Spatial.Vector3D) {
        
        lhs = Vector3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func * (lhs: Swift.Double, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return Vector3D(lhs * rhs.vector)
    }
  @inlinable public static func * (lhs: Spatial.Vector3D, rhs: Swift.Double) -> Spatial.Vector3D {
        
        return Vector3D(lhs.vector * rhs)
    }
  @inlinable public static func *= (lhs: inout Spatial.Vector3D, rhs: Swift.Double) {
        
        lhs = Vector3D(lhs.vector * rhs)
    }
  @inlinable public static func / (lhs: Spatial.Vector3D, rhs: Swift.Double) -> Spatial.Vector3D {
        
        return Vector3D(lhs.vector / rhs)
    }
  @inlinable public static func /= (lhs: inout Spatial.Vector3D, rhs: Swift.Double) {
        
        lhs = Vector3D(lhs.vector / rhs)
    }
  @inlinable public static func * (lhs: Spatial.AffineTransform3D, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func * (lhs: Spatial.Pose3D, rhs: Spatial.Vector3D) -> Spatial.Vector3D {
        
        return rhs.applying(lhs)
    }
  @inlinable public static func + (lhs: Spatial.Size3D, rhs: Spatial.Vector3D) -> Spatial.Size3D {
        
        return Size3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func + (lhs: Spatial.Vector3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        
        return Size3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Size3D, rhs: Spatial.Vector3D) -> Spatial.Size3D {
        
        return Size3D(lhs.vector - rhs.vector)
    }
  @inlinable public static func - (lhs: Spatial.Vector3D, rhs: Spatial.Size3D) -> Spatial.Size3D {
        
        return Size3D(lhs.vector - rhs.vector)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D {
  @inlinable public static func * (lhs: Spatial.Pose3D, rhs: Spatial.Ray3D) -> Spatial.Ray3D {

        return rhs.applying(lhs)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public static func += (lhs: inout Spatial.Point3D, rhs: Spatial.Vector3D) {

        lhs = Point3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Point3D, rhs: Spatial.Vector3D) {

        lhs = Point3D(lhs.vector - rhs.vector)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  @inlinable public static func += (lhs: inout Spatial.Size3D, rhs: Spatial.Vector3D) {

        lhs = Size3D(lhs.vector + rhs.vector)
    }
  @inlinable public static func -= (lhs: inout Spatial.Size3D, rhs: Spatial.Vector3D) {

        lhs = Size3D(lhs.vector - rhs.vector)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D {
  @inlinable public static func * (lhs: Spatial.Pose3D, rhs: Spatial.Pose3D) -> Spatial.Pose3D {
        return __SPPose3DConcatenation(lhs, rhs)
    }
  @inlinable public static func *= (lhs: inout Spatial.Pose3D, rhs: Spatial.Pose3D) {
        
        lhs = lhs.concatenating(rhs)
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Rotation3D {
  @inlinable public static func * (lhs: Spatial.Rotation3D, rhs: Swift.Double) -> Spatial.Rotation3D {

            return Rotation3D.slerp(
                from: .identity,
                to: lhs,
                t: rhs,
                along: lhs.quaternion.real >= 0 ? .shortest : .longest)
    }
  @inlinable public static func * (lhs: Swift.Double, rhs: Spatial.Rotation3D) -> Spatial.Rotation3D {

        return rhs * lhs
    }
  @inlinable public static func * (lhs: Spatial.Rotation3D, rhs: Spatial.Rotation3D) -> Spatial.Rotation3D {

        return Rotation3D(lhs.quaternion * rhs.quaternion)
    }
  @inlinable public static func *= (lhs: inout Spatial.Rotation3D, rhs: Spatial.Rotation3D) {
        lhs = rhs.rotated(by: lhs)
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Angle2D : Swift.AdditiveArithmetic {
  @inlinable prefix public static func - (angle: Spatial.Angle2D) -> Spatial.Angle2D {
        return __SPAngleNegate(angle)
    }
  @inlinable prefix public static func + (angle: Spatial.Angle2D) -> Spatial.Angle2D {
        return angle
    }
  @inlinable public static func + (lhs: Spatial.Angle2D, rhs: Spatial.Angle2D) -> Spatial.Angle2D {
        return Angle2D(radians: lhs.radians + rhs.radians)
    }
  @inlinable public static func += (lhs: inout Spatial.Angle2D, rhs: Spatial.Angle2D) {
        lhs = lhs + rhs
    }
  @inlinable public static func - (lhs: Spatial.Angle2D, rhs: Spatial.Angle2D) -> Spatial.Angle2D {
        return Angle2D(radians: lhs.radians - rhs.radians)
    }
  @inlinable public static func -= (lhs: inout Spatial.Angle2D, rhs: Spatial.Angle2D) {
        lhs = lhs - rhs
    }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D {
  @inlinable public static func * (lhs: Spatial.ScaledPose3D, rhs: Spatial.Pose3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DConcatenation(lhs, rhs)
    }
  @inlinable public static func * (lhs: Spatial.ScaledPose3D, rhs: Spatial.ScaledPose3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DConcatenation(lhs, rhs)
    }
  @inlinable public static func * (lhs: Spatial.Pose3D, rhs: Spatial.ScaledPose3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DConcatenation(lhs, rhs)
    }
  @inlinable public static func *= (lhs: inout Spatial.ScaledPose3D, rhs: Spatial.ScaledPose3D) {
        
        lhs = lhs.concatenating(rhs)
    }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D {
  @inlinable public init(position: Spatial.Point3D = .zero, rotation: Spatial.Rotation3D, scale: Swift.Double = 1) {
        
        self = __SPScaledPose3DMake(position, rotation, scale)
    }
  @inlinable public init(position: simd.simd_double3 = .zero, rotation: simd.simd_quatd, scale: Swift.Double = 1) {
        
        self = __SPScaledPose3DMakeWithVector(position, rotation, scale)
    }
  @inlinable public init(position: simd.simd_float3 = .zero, rotation: simd.simd_quatf, scale: Swift.Float = 1) {
        
        let quaternion = simd_quatd(vector: simd_double(rotation.vector))
        
        self = __SPScaledPose3DMakeWithVector(simd_double(position),
                                              quaternion,
                                              Double(scale))
    }
  @inlinable public init(position: Spatial.Point3D = .zero, target: Spatial.Point3D, scale: Swift.Double = 1, up: Spatial.Vector3D = Vector3D(x: 0, y: 1, z: 0)) {
        
        self = __SPScaledPose3DMakeLookAt(position, target, scale, up)
    }
  @inlinable public init(forward: Spatial.Vector3D, scale: Swift.Double = 1, up: Spatial.Vector3D = Vector3D(x: 0, y: 1, z: 0)) {
        
        self = __SPScaledPose3DMakeLookAt(forward, scale, up)
    }
  @inlinable public init?(transform: Spatial.AffineTransform3D) {
        
        let p = __SPScaledPose3DMakeWithAffineTransform(transform)
        
        if __SPScaledPose3DIsValid(p) {
            self = p
        } else {
            return nil
        }
    }
  @inlinable public init?(transform: Spatial.ProjectiveTransform3D) {
        
        let t = __SPScaledPose3DMakeWithProjectiveTransform(transform)
        
        if __SPScaledPose3DIsValid(t) {
            self = t
        } else {
            return nil
        }
    }
  @inlinable public init?(_ matrix: simd.simd_double4x4) {
        
        let p = __SPScaledPose3DMakeWith4x4Matrix(matrix)
        
        if __SPScaledPose3DIsValid(p) {
            self = p
        } else {
            return nil
        }
    }
  @inlinable public init?(_ matrix: simd.simd_float4x4) {
        
        let m = simd_double4x4(simd_double(matrix.columns.0),
                               simd_double(matrix.columns.1),
                               simd_double(matrix.columns.2),
                               simd_double(matrix.columns.3))
        
        let p = __SPScaledPose3DMakeWith4x4Matrix(m)
        
        if __SPScaledPose3DIsValid(p) {
            self = p
        } else {
            return nil
        }
    }
  @inlinable public var matrix: simd.simd_double4x4 {
    get {
        return __SPScaledPose3DGet4x4Matrix(self)
    }
  }
  @inlinable public var inverse: Spatial.ScaledPose3D {
    get {
        return __SPScaledPose3DGetInverse(self)
    }
  }
  @inlinable public func concatenating(_ transform: Spatial.ScaledPose3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DConcatenation(self, transform)
    }
  @inlinable public func concatenating(_ transform: Spatial.Pose3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DConcatenation(self, transform)
    }
  @inlinable public static var identity: Spatial.ScaledPose3D {
    get {
        return __SPScaledPose3DIdentity
    }
  }
  @inlinable public func flipped(along axis: Spatial.Axis3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DFlip(self, axis)
    }
  public mutating func flip(along axis: Spatial.Axis3D)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D : Spatial.Translatable3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public func translated(by size: Spatial.Size3D) -> Spatial.ScaledPose3D {
        return self.translated(by: Vector3D(size))
    }
  @inlinable public func translated(by offset: Spatial.Vector3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DTranslate(self, offset)
    }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D : Spatial.Rotatable3D {
  @inlinable public func rotated(by rotation: Spatial.Rotation3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DRotate(self, rotation)
    }
  @inlinable public func rotated(by quaternion: simd.simd_quatd) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DRotateByQuaternion(self, quaternion)
    }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D : @unchecked Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.ScaledPose3D, rhs: Spatial.ScaledPose3D) -> Swift.Bool {
        return __SPScaledPose3DEqualToPose(lhs, rhs)
    }
  @inlinable public func isApproximatelyEqual(to other: Spatial.ScaledPose3D, tolerance: Swift.Double = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPScaledPose3DAlmostEqualToPose(self, other, tolerance)
    }
  @inlinable public var isIdentity: Swift.Bool {
    get {
        return __SPScaledPose3DIsIdentity(self)
    }
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ScaledPose3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Pose3D {
  @inlinable public func concatenating(_ transform: Spatial.ScaledPose3D) -> Spatial.ScaledPose3D {
        return __SPScaledPose3DConcatenation(self, transform)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D {
  @inlinable public init(position: Spatial.Point3D = .zero, rotation: Spatial.Rotation3D) {
        
        self = __SPPose3DMake(position, rotation)
    }
  @inlinable public init(position: simd.simd_double3 = .zero, rotation: simd.simd_quatd) {
        
        self = __SPPose3DMakeWithVector(position, rotation)
    }
  @inlinable public init(position: simd.simd_float3 = .zero, rotation: simd.simd_quatf) {
        
        let quaternion = simd_quatd(vector: simd_double(rotation.vector))
        
        self = __SPPose3DMakeWithVector(simd_double(position),
                                        quaternion)
    }
  @inlinable public init(position: Spatial.Point3D = .zero, target: Spatial.Point3D, up: Spatial.Vector3D = Vector3D(x: 0, y: 1, z: 0)) {
        
        self = __SPPose3DMakeLookAt(position, target, up)
    }
  @inlinable public init(forward: Spatial.Vector3D, up: Spatial.Vector3D = Vector3D(x: 0, y: 1, z: 0)) {
        
        self = __SPPose3DMakeLookAt(forward, up)
    }
  @inlinable public init?(transform: Spatial.AffineTransform3D) {
        
        let p = __SPPose3DMakeWithAffineTransform(transform)
        
        if __SPPose3DIsValid(p) {
            self = p
        } else {
            return nil
        }
    }
  @inlinable public init?(transform: Spatial.ProjectiveTransform3D) {
        
        let t = __SPPose3DMakeWithProjectiveTransform(transform)
        
        if __SPPose3DIsValid(t) {
            self = t
        } else {
            return nil
        }
    }
  @inlinable public init?(_ matrix: simd.simd_double4x4) {
        
        let p = __SPPose3DMakeWith4x4Matrix(matrix)
        
        if __SPPose3DIsValid(p) {
            self = p
        } else {
            return nil
        }
    }
  @inlinable public init?(_ matrix: simd.simd_float4x4) {
        
        let m = simd_double4x4(simd_double(matrix.columns.0),
                               simd_double(matrix.columns.1),
                               simd_double(matrix.columns.2),
                               simd_double(matrix.columns.3))
        
        let p = __SPPose3DMakeWith4x4Matrix(m)
        
        if __SPPose3DIsValid(p) {
            self = p
        } else {
            return nil
        }
    }
  @inlinable public var matrix: simd.simd_double4x4 {
    get {
        return __SPPose3DGet4x4Matrix(self)
    }
  }
  @inlinable public var inverse: Spatial.Pose3D {
    get {
        return __SPPose3DGetInverse(self)
    }
  }
  @inlinable public func concatenating(_ transform: Spatial.Pose3D) -> Spatial.Pose3D {
        return __SPPose3DConcatenation(self, transform)
    }
  @inlinable public static var identity: Spatial.Pose3D {
    get {
        return __SPPose3DIdentity
    }
  }
  @inlinable public func flipped(along axis: Spatial.Axis3D) -> Spatial.Pose3D {
        return __SPPose3DFlip(self, axis)
    }
  public mutating func flip(along axis: Spatial.Axis3D)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D : Spatial.Translatable3D {
  @inlinable public func translated(by offset: Spatial.Vector3D) -> Spatial.Pose3D {
        return __SPPose3DTranslate(self, offset)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D : Spatial.Rotatable3D {
  @inlinable public func rotated(by rotation: Spatial.Rotation3D) -> Spatial.Pose3D {
        return __SPPose3DRotate(self, rotation)
    }
  @inlinable public func rotated(by quaternion: simd.simd_quatd) -> Spatial.Pose3D {
        return __SPPose3DRotateByQuaternion(self, quaternion)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Pose3D, rhs: Spatial.Pose3D) -> Swift.Bool {
        return __SPPose3DEqualToPose(lhs, rhs)
    }
  @inlinable public func isApproximatelyEqual(to other: Spatial.Pose3D, tolerance: Swift.Double = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPPose3DAlmostEqualToPose(self, other, tolerance)
    }
  @inlinable public var isIdentity: Swift.Bool {
    get {
        return __SPPose3DIsIdentity(self)
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Pose3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Pose3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.SphericalCoordinates3D : @unchecked Swift.Sendable {
  public init(x: Swift.Double, y: Swift.Double, z: Swift.Double)
  public init(_ vector: simd.simd_double3)
  public init(_ point: Spatial.Point3D)
  public init(_ vector: Spatial.Vector3D)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Point3D {
  public init(_ coords: Spatial.SphericalCoordinates3D)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Vector3D {
  public init(_ coords: Spatial.SphericalCoordinates3D)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.SphericalCoordinates3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.SphericalCoordinates3D, rhs: Spatial.SphericalCoordinates3D) -> Swift.Bool {
        
        return lhs.radius == rhs.radius && lhs.inclination == rhs.inclination && lhs.azimuth == rhs.azimuth
    }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.SphericalCoordinates3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.SphericalCoordinates3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.SphericalCoordinates3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.SphericalCoordinates3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Angle2D {
  @inlinable public static func radians(_ radians: Swift.Double) -> Spatial.Angle2D {
        return Angle2D(radians: radians)
    }
  @inlinable public static func degrees(_ degrees: Swift.Double) -> Spatial.Angle2D {
        return Angle2D(degrees: degrees)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Angle2D, rhs: Spatial.Angle2D) -> Swift.Bool {
        return lhs.radians == rhs.radians
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Angle2D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Angle2D {
  @inlinable public var normalized: Spatial.Angle2D {
    get {
        return __SPAngleNormalize(self)
    }
  }
  @inlinable public static func acos(_ x: Swift.Double) -> Spatial.Angle2D {
        return __SPAngleAcos(x)
    }
  @inlinable public static func asin(_ x: Swift.Double) -> Spatial.Angle2D {
        return __SPAngleAsin(x)
    }
  @inlinable public static func atan(_ x: Swift.Double) -> Spatial.Angle2D {
        return __SPAngleAtan(x)
    }
  @inlinable public static func acosh(_ x: Swift.Double) -> Spatial.Angle2D {
        return __SPAngleAcosh(x)
    }
  @inlinable public static func asinh(_ x: Swift.Double) -> Spatial.Angle2D {
        return __SPAngleAsinh(x)
    }
  @inlinable public static func atanh(_ x: Swift.Double) -> Spatial.Angle2D {
        return __SPAngleAtanh(x)
    }
  @inlinable public static func atan2(y: Swift.Double, x: Swift.Double) -> Spatial.Angle2D {
        return __SPAngleAtan2(y, x)
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
@inlinable public func cos(_ angle: Spatial.Angle2D) -> Swift.Double {
    return __SPAngleCos(angle)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
@inlinable public func sin(_ angle: Spatial.Angle2D) -> Swift.Double {
    return __SPAngleSin(angle)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
@inlinable public func tan(_ angle: Spatial.Angle2D) -> Swift.Double {
    return __SPAngleTan(angle)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
@inlinable public func cosh(_ angle: Spatial.Angle2D) -> Swift.Double {
    return __SPAngleCosh(angle)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
@inlinable public func sinh(_ angle: Spatial.Angle2D) -> Swift.Double {
    return __SPAngleSinh(angle)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
@inlinable public func tanh(_ angle: Spatial.Angle2D) -> Swift.Double {
    return __SPAngleTanh(angle)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D {
  @inlinable public var translation: Spatial.Vector3D {
    get {
            return __SPProjectiveTransform3DGetTranslation(self)
        }
    set {
            __SPProjectiveTransform3DSetTranslation(&self, newValue)
        }
  }
  @inlinable public init() {
         self.init(scale: Size3D(width: 1, height: 1, depth: 1))
     }
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public init(scale: Spatial.Size3D = Size3D(width: 1.0, height: 1, depth: 1), rotation: Spatial.Rotation3D = .zero, translation: Spatial.Size3D) {
        
        self = __SPProjectiveTransform3DMake(scale,
                                             rotation,
                                             Vector3D(translation))
    }
  @inlinable public init(scale: Spatial.Size3D = Size3D(width: 1.0, height: 1, depth: 1), rotation: Spatial.Rotation3D = .zero, translation: Spatial.Vector3D = .zero) {
        
        
        self = __SPProjectiveTransform3DMake(scale,
                                             rotation,
                                             translation)
    }
  @inlinable public init(pose: Spatial.Pose3D) {
        
        self = __SPProjectiveTransform3DMakeWithPose(pose)
    }
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
  @inlinable public init(scaledPose: Spatial.ScaledPose3D) {
        
        self = __SPProjectiveTransform3DMakeWithScaledPose(scaledPose)
    }
  @inlinable public func isApproximatelyEqual(to other: Spatial.ProjectiveTransform3D, tolerance: Swift.Double = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPProjectiveTransform3DAlmostEqualToTransform(self, other, tolerance)
    }
  public func flipped(along axis: Spatial.Axis3D) -> Spatial.ProjectiveTransform3D
  public mutating func flip(along axis: Spatial.Axis3D)
  @inlinable public func scaledBy(x: Swift.Double, y: Swift.Double, z: Swift.Double) -> Spatial.ProjectiveTransform3D {
        return __SPProjectiveTransform3DScaleBy(self, x, y, z)
    }
  @inlinable public func isUniform(overDimensions: Spatial.Dimension3DSet) -> Swift.Bool {
        
        let axes = Axis3D(rawValue: UInt32(overDimensions.rawValue))
        
        return __SPProjectiveTransform3DIsUniformOverDimensions(self,
                                                                axes)
    }
  @inlinable public init(shear: Spatial.AxisWithFactors) {
        switch shear {
            case .xAxis(let yShearFactor, let zShearFactor):
                self = __SPProjectiveTransform3DMakeShear(.x, yShearFactor, zShearFactor)
            case .yAxis(let xShearFactor, let zShearFactor):
                self = __SPProjectiveTransform3DMakeShear(.y, xShearFactor, zShearFactor)
            case .zAxis(let xShearFactor, let yShearFactor):
                self = __SPProjectiveTransform3DMakeShear(.z, xShearFactor, yShearFactor)
            @unknown default:
                fatalError("Unsupported shear")
        }
    }
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.ProjectiveTransform3D {
        switch shear {
            case .xAxis(let yShearFactor, let zShearFactor):
                return __SPProjectiveTransform3DShear(self, .x, yShearFactor, zShearFactor)
            case .yAxis(let xShearFactor, let zShearFactor):
                return __SPProjectiveTransform3DShear(self, .y, xShearFactor, zShearFactor)
            case .zAxis(let xShearFactor, let yShearFactor):
                return __SPProjectiveTransform3DShear(self, .z, xShearFactor, yShearFactor)
            @unknown default:
                fatalError("Unsupported shear")
        }
    }
  @inlinable public var rotation: Spatial.Rotation3D? {
    get {
        
        let r = __SPProjectiveTransform3DGetRotation(self)
        
        if __SPRotation3DIsValid(r) {
            return r
        } else {
            return nil
        }
    }
  }
  @available(*, deprecated, renamed: "scaleComponent")
  @inlinable public var scale: Spatial.Size3D? {
    get {
        
        let s = __SPProjectiveTransform3DGetScale(self)
        
        if __SPSize3DIsValid(s) {
            return s
        } else {
            return nil
        }
    }
  }
  @inlinable public var inverse: Spatial.ProjectiveTransform3D? {
    get {
        
        let t = __SPProjectiveTransform3DInverted(self)
        
        if __SPProjectiveTransform3DIsValid(t) {
            return t
        } else {
            return nil
        }
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.ProjectiveTransform3D, rhs: Spatial.ProjectiveTransform3D) -> Swift.Bool {
        return lhs.matrix == rhs.matrix
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.ProjectiveTransform3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.ProjectiveTransform3D {
  @inlinable public var scaleComponent: Spatial.Size3D {
    get {
        
        return __SPProjectiveTransform3DGetScale(self)
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Primitive3D {
  @inlinable public func unapplying(_ transform: Spatial.AffineTransform3D) -> Spatial.Rect3D {
        
        let unapplied = __SPRect3DUnapplyAffineTransform(self, transform)
        
        if __SPRect3DIsNull(unapplied) {
            return self
        } else {
            return unapplied
        }
    }
  @inlinable public func unapplying(_ transform: Spatial.ProjectiveTransform3D) -> Spatial.Rect3D {
        
        let unapplied = __SPRect3DUnapplyProjectiveTransform(self, transform)
        
        if __SPRect3DIsNull(unapplied) {
            return self
        } else {
            return unapplied
        }
    }
  public func applying(_ pose: Spatial.Pose3D) -> Spatial.Rect3D
  public func unapplying(_ pose: Spatial.Pose3D) -> Spatial.Rect3D
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Rect3D {
  public func applying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Rect3D
  public func unapplying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Rect3D
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Translatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Scalable3D {
  @inlinable public func scaledBy(x: Swift.Double = 1, y: Swift.Double = 1, z: Swift.Double = 1) -> Spatial.Rect3D {
        
        return __SPRect3DScaleBy(self, x, y, z)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Rotatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Shearable3D {
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.Rect3D {
        
        return _shear(shearFunc: __SPRect3DShear,
                      shear: shear)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Spatial.Volumetric {
  @inlinable public func contains(anyOf points: [Spatial.Point3D]) -> Swift.Bool {
        return __SPRect3DContainsAnyPoint(self,
                                          points,
                                          Int32(points.count))
    }
  @inlinable public mutating func formInset(by dXYZ: Spatial.Size3D) {
        
        self = self.inset(by: dXYZ)
    }
  @inlinable public func intersection(_ other: Spatial.Rect3D) -> Spatial.Rect3D? {
        let intersection = __SPRect3DIntersection(self, other)
        
        if intersection.origin.isFinite {
            return intersection
        } else {
            return nil
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Rect3D, rhs: Spatial.Rect3D) -> Swift.Bool {
        return lhs.origin == rhs.origin && lhs.size == rhs.size
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D {
  public init(origin: simd.simd_double3 = .zero, size: simd.simd_double3)
  public init(origin: Spatial.Vector3D = .zero, size: Spatial.Vector3D)
  public init(center: simd.simd_double3 = .zero, size: simd.simd_double3)
  public init(center: Spatial.Vector3D = .zero, size: Spatial.Vector3D)
  public init(points: [Spatial.Point3D])
  public var cornerPoints: [Spatial.Point3D] {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Rect3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Angle2D {
  @inlinable public init<T>(radians: T) where T : Swift.BinaryFloatingPoint {
        self.init(radians: Double(radians))
    }
  @inlinable public init<T>(degrees: T) where T : Swift.BinaryFloatingPoint {
        self.init(degrees: Double(degrees))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D {
  @inlinable public init(_ xyz: simd.simd_float3) {
        self.init(simd_double3(Double(xyz.x),
                               Double(xyz.y),
                               Double(xyz.z)))
    }
  @inlinable public init<T>(x: T, y: T, z: T) where T : Swift.BinaryFloatingPoint {
        self.init(x: Double(x),
                  y: Double(y),
                  z: Double(z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.SIMD3 where Scalar == Swift.Float {
  @inlinable public init(_ rotationAxis: Spatial.RotationAxis3D) {
        self.init(x: Float(rotationAxis.x),
                  y: Float(rotationAxis.y),
                  z: Float(rotationAxis.z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D {
  @inlinable public init(_ quaternion: simd.simd_quatf) {
        
        let q = simd_quatd(vector: simd_double(quaternion.vector))
    
        self.init(q)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension simd.simd_quatf {
  @inlinable public init(_ rotation: Spatial.Rotation3D) {
        
        self.init(vector: simd_float(rotation.quaternion.vector))
        
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Point3D {
  @inlinable public init(_ xyz: simd.simd_float3) {
        self.init(simd_double3(Double(xyz.x),
                               Double(xyz.y),
                               Double(xyz.z)))
    }
  @inlinable public init<T>(x: T, y: T, z: T) where T : Swift.BinaryFloatingPoint {
        self.init(x: Double(x),
                  y: Double(y),
                  z: Double(z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.SIMD3 where Scalar == Swift.Float {
  @inlinable public init(_ point: Spatial.Point3D) {
        self.init(x: Float(point.x),
                  y: Float(point.y),
                  z: Float(point.z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D {
  @inlinable public init(_ xyz: simd.simd_float3) {
        self.init(simd_double3(Double(xyz.x),
                               Double(xyz.y),
                               Double(xyz.z)))
    }
  @inlinable public init<T>(x: T, y: T, z: T) where T : Swift.BinaryFloatingPoint {
        self.init(x: Double(x),
                  y: Double(y),
                  z: Double(z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.SIMD3 where Scalar == Swift.Float {
  @inlinable public init(_ vector: Spatial.Vector3D) {
        self.init(x: Float(vector.x),
                  y: Float(vector.y),
                  z: Float(vector.z))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  @inlinable public init(_ xyz: simd.simd_float3) {
        self.init(simd_double3(Double(xyz.x),
                               Double(xyz.y),
                               Double(xyz.z)))
    }
  @inlinable public init<T>(width: T, height: T, depth: T) where T : Swift.BinaryFloatingPoint {
        self.init(width: Double(width),
                  height: Double(height),
                  depth: Double(depth))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.SIMD3 where Scalar == Swift.Float {
  @inlinable public init(_ size: Spatial.Size3D) {
        self.init(x: Float(size.width),
                  y: Float(size.height),
                  z: Float(size.depth))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rect3D {
  @inlinable public init(origin: simd.simd_float3 = .zero, size: simd.simd_float3) {
        
        let o = simd_double3(Double(origin.x),
                             Double(origin.y),
                             Double(origin.z))
        
        let s = simd_double3(Double(size.x),
                             Double(size.y),
                             Double(size.z))
        
        self = __SPRect3DMakeAtOriginWithVector(o, s)
    }
  @inlinable public init(center: simd.simd_float3 = .zero, size: simd.simd_float3) {
        
        let c = simd_double3(Double(center.x),
                             Double(center.y),
                             Double(center.z))
        
        let s = simd_double3(Double(size.x),
                             Double(size.y),
                             Double(size.z))
        
        
        self = __SPRect3DMakeAtCenterWithVector(c, s)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D {
  @inlinable public init(_ matrix: simd.simd_float4x3) {
        
        let column0 = matrix.columns.0
        let column1 = matrix.columns.1
        let column2 = matrix.columns.2
        let column3 = matrix.columns.3
        
        let m = simd_double4x3([
            simd_double3(Double(column0.x), Double(column0.y), Double(column0.z)),
            simd_double3(Double(column1.x), Double(column1.y), Double(column1.z)),
            simd_double3(Double(column2.x), Double(column2.y), Double(column2.z)),
            simd_double3(Double(column3.x), Double(column3.y), Double(column3.z))
        ])
        
        self.init(m)
    }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.AffineTransform3D {
  @inlinable public init(truncating matrix: simd.simd_float4x4) {

        let m = simd_double4x4([
            simd_double(matrix.columns.0),
            simd_double(matrix.columns.1),
            simd_double(matrix.columns.2),
            simd_double(matrix.columns.3)])
        
        self = .init(truncating: m)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension simd.simd_float4x3 {
  @inlinable public init(_ affineTransform: Spatial.AffineTransform3D) {
        
        let column0 = affineTransform.matrix.columns.0
        let column1 = affineTransform.matrix.columns.1
        let column2 = affineTransform.matrix.columns.2
        let column3 = affineTransform.matrix.columns.3
        
        self.init([
            simd_float3(Float(column0.x), Float(column0.y), Float(column0.z)),
            simd_float3(Float(column1.x), Float(column1.y), Float(column1.z)),
            simd_float3(Float(column2.x), Float(column2.y), Float(column2.z)),
            simd_float3(Float(column3.x), Float(column3.y), Float(column3.z))
        ])
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D {
  @inlinable public init(_ matrix: simd.simd_float4x4) {
        
        let column0 = matrix.columns.0
        let column1 = matrix.columns.1
        let column2 = matrix.columns.2
        let column3 = matrix.columns.3
        
        let m = simd_double4x4([
            simd_double4(Double(column0.x), Double(column0.y),
                         Double(column0.z), Double(column0.w)),
            
            simd_double4(Double(column1.x), Double(column1.y),
                         Double(column1.z), Double(column1.w)),
            
            simd_double4(Double(column2.x), Double(column2.y),
                         Double(column2.z), Double(column2.w)),
            
            simd_double4(Double(column3.x), Double(column3.y),
                         Double(column3.z), Double(column3.w))
        ])
        
        self.init(m)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension simd.simd_float4x4 {
  @inlinable public init(_ projectiveTransform: Spatial.ProjectiveTransform3D) {
        
        self.init(simd_float(projectiveTransform.matrix.columns.0),
                  simd_float(projectiveTransform.matrix.columns.1),
                  simd_float(projectiveTransform.matrix.columns.2),
                  simd_float(projectiveTransform.matrix.columns.3))
    }
  @inlinable public init(_ affineTransform: Spatial.AffineTransform3D) {
        let m = affineTransform.matrix4x4
        self.init(simd_float(m.columns.0),
                  simd_float(m.columns.1),
                  simd_float(m.columns.2),
                  simd_float(m.columns.3))
    }
  @inlinable public init(_ pose: Spatial.Pose3D) {
        let m = pose.matrix
        self.init(simd_float(m.columns.0),
                  simd_float(m.columns.1),
                  simd_float(m.columns.2),
                  simd_float(m.columns.3))
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D {
  public init(origin: Spatial.Point3D = .zero, direction: Spatial.Vector3D)
  public init(origin: simd.simd_double3 = .zero, direction: simd.simd_double3)
  public init(origin: simd.simd_float3 = .zero, direction: simd.simd_float3)
  public func intersects(_ rect: Spatial.Rect3D) -> Swift.Bool
  public func applying(_ pose: Spatial.Pose3D) -> Spatial.Ray3D
  public mutating func apply(_ pose: Spatial.Pose3D)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Ray3D {
  public func unapplying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Ray3D
  public func applying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Ray3D
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Ray3D : Spatial.Primitive3D {
  public func applying(_ transform: Spatial.AffineTransform3D) -> Spatial.Ray3D
  public func unapplying(_ transform: Spatial.AffineTransform3D) -> Spatial.Ray3D
  public func applying(_ transform: Spatial.ProjectiveTransform3D) -> Spatial.Ray3D
  public func unapplying(_ transform: Spatial.ProjectiveTransform3D) -> Spatial.Ray3D
  public func unapplying(_ pose: Spatial.Pose3D) -> Spatial.Ray3D
  public func rotated(by rotation: Spatial.Rotation3D, around pivot: Spatial.Point3D) -> Spatial.Ray3D
  public func rotated(by quaternion: simd.simd_quatd, around pivot: Spatial.Point3D) -> Spatial.Ray3D
  public var isNaN: Swift.Bool {
    get
  }
  public var isFinite: Swift.Bool {
    get
  }
  public var isZero: Swift.Bool {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Spatial.Translatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Spatial.Rotatable3D {
  public func rotated(by rotation: Spatial.Rotation3D) -> Spatial.Ray3D
  public func rotated(by quaternion: simd.simd_quatd) -> Spatial.Ray3D
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Ray3D, rhs: Spatial.Ray3D) -> Swift.Bool {
        return lhs.origin == rhs.origin && lhs.direction == rhs.direction
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Ray3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Ray3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : @unchecked Swift.Sendable {
  public static let right: Spatial.Vector3D
  public static let up: Spatial.Vector3D
  public static let forward: Spatial.Vector3D
  @inlinable public init(x: Swift.Double = 0, y: Swift.Double = 0, z: Swift.Double = 0) {
        self = __SPVector3DMake(x, y, z)
    }
  @inlinable public init(_ xyz: simd.simd_double3) {
        self = __SPVector3DMakeWithVector(xyz)
    }
  @inlinable public init(_ size: Spatial.Size3D) {
        self = __SPVector3DMakeWithSize(size)
    }
  @inlinable public init(_ point: Spatial.Point3D) {
        self = __SPVector3DMakeWithPoint(point)
    }
  @inlinable public init(_ axis: Spatial.RotationAxis3D) {
        self = __SPVector3DMakeWithRotationAxis(axis)
    }
  @inlinable public func dot(_ other: Spatial.Vector3D) -> Swift.Double {
        return __SPVector3DDotProduct(self, other)
    }
  @inlinable public func cross(_ other: Spatial.Vector3D) -> Spatial.Vector3D {
        return __SPVector3DCrossProduct(self, other)
    }
  @inlinable public var normalized: Spatial.Vector3D {
    get {
        return __SPVector3DNormalize(self)
    }
  }
  @inlinable public mutating func normalize() {
        self = __SPVector3DNormalize(self)
    }
  @inlinable public func projected(_ other: Spatial.Vector3D) -> Spatial.Vector3D {
        return __SPVector3DProject(self, other)
    }
  @inlinable public func reflected(_ normal: Spatial.Vector3D) -> Spatial.Vector3D {
        return __SPVector3DReflect(self, normal)
    }
  @inlinable public var length: Swift.Double {
    get {
        return __SPVector3DLength(self)
    }
  }
  @inlinable public var lengthSquared: Swift.Double {
    get {
        return __SPVector3DLengthSquared(self)
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Spatial.Primitive3D {
  @inlinable public func applying(_ transform: Spatial.AffineTransform3D) -> Spatial.Vector3D {
        return __SPVector3DApplyAffineTransform(self, transform)
    }
  @inlinable public func applying(_ transform: Spatial.ProjectiveTransform3D) -> Spatial.Vector3D {
        return __SPVector3DApplyProjectiveTransform(self, transform)
    }
  @inlinable public func unapplying(_ transform: Spatial.AffineTransform3D) -> Spatial.Vector3D {
        return __SPVector3DUnapplyAffineTransform(self, transform)
    }
  @inlinable public func unapplying(_ transform: Spatial.ProjectiveTransform3D) -> Spatial.Vector3D {
        return __SPVector3DUnapplyProjectiveTransform(self, transform)
    }
  public func applying(_ pose: Spatial.Pose3D) -> Spatial.Vector3D
  public func unapplying(_ pose: Spatial.Pose3D) -> Spatial.Vector3D
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Vector3D {
  public func applying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Vector3D
  public func unapplying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Vector3D
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Spatial.Rotatable3D {
  @inlinable public func rotated(by rotation: Spatial.Rotation3D) -> Spatial.Vector3D {
        return __SPVector3DRotate(self, rotation)
    }
  @inlinable public func rotated(by quaternion: simd.simd_quatd) -> Spatial.Vector3D {
        return __SPVector3DRotateByQuaternion(self, quaternion)
    }
  @inlinable public func rotation(to other: Spatial.Vector3D) -> Spatial.Rotation3D {
        return __SPVector3DRotationToVector(self, other)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Spatial.Scalable3D {
  @inlinable public func scaledBy(x: Swift.Double = 1, y: Swift.Double = 1, z: Swift.Double = 1) -> Spatial.Vector3D {
        
        return __SPVector3DScaleBy(self, x, y, z)
    }
  @inlinable public func scaled(by size: Spatial.Size3D) -> Spatial.Vector3D {
        
        return __SPVector3DScaleBySize(self, size)
    }
  @inlinable public func uniformlyScaled(by scale: Swift.Double) -> Spatial.Vector3D {
        return __SPVector3DScaleUniform(self, scale)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Spatial.Shearable3D {
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.Vector3D {
        
        return _shear(shearFunc: __SPVector3DShear, shear: shear)
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Vector3D : Swift.AdditiveArithmetic {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Vector3D, rhs: Spatial.Vector3D) -> Swift.Bool {
        
        return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Vector3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Vector3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Primitive3D : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  static var zero: Self { get }
  static var infinity: Self { get }
  var isZero: Swift.Bool { get }
  var isFinite: Swift.Bool { get }
  var isNaN: Swift.Bool { get }
  func applying(_ transform: Spatial.AffineTransform3D) -> Self
  func applying(_ transform: Spatial.ProjectiveTransform3D) -> Self
  func applying(_ pose: Spatial.Pose3D) -> Self
  mutating func apply(_ transform: Spatial.AffineTransform3D)
  mutating func apply(_ transform: Spatial.ProjectiveTransform3D)
  mutating func apply(_ pose: Spatial.Pose3D)
  func unapplying(_ transform: Spatial.AffineTransform3D) -> Self
  mutating func unapply(_ transform: Spatial.AffineTransform3D)
  func unapplying(_ transform: Spatial.ProjectiveTransform3D) -> Self
  func unapplying(_ pose: Spatial.Pose3D) -> Self
  mutating func unapply(_ transform: Spatial.ProjectiveTransform3D)
  mutating func unapply(_ pose: Spatial.Pose3D)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Primitive3D {
  public mutating func apply(_ transform: Spatial.AffineTransform3D)
  public mutating func apply(_ transform: Spatial.ProjectiveTransform3D)
  public mutating func apply(_ pose: Spatial.Pose3D)
  public mutating func unapply(_ transform: Spatial.AffineTransform3D)
  public mutating func unapply(_ transform: Spatial.ProjectiveTransform3D)
  public mutating func unapply(_ pose: Spatial.Pose3D)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Translatable3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  func translated(by size: Spatial.Size3D) -> Self
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  mutating func translate(by size: Spatial.Size3D)
  func translated(by vector: Spatial.Vector3D) -> Self
  mutating func translate(by vector: Spatial.Vector3D)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Translatable3D {
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public mutating func translate(by size: Spatial.Size3D) {
        self = self.translated(by: size)
    }
  @inlinable public func translated(by vector: Spatial.Vector3D) -> Self {
        return self.translated(by: vector)
    }
  @inlinable public mutating func translate(by vector: Spatial.Vector3D) {
        self = self.translated(by: vector)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Scalable3D {
  func scaledBy(x: Swift.Double, y: Swift.Double, z: Swift.Double) -> Self
  mutating func scaleBy(x: Swift.Double, y: Swift.Double, z: Swift.Double)
  func scaled(by size: Spatial.Size3D) -> Self
  mutating func scale(by size: Spatial.Size3D)
  func uniformlyScaled(by scale: Swift.Double) -> Self
  mutating func uniformlyScale(by scale: Swift.Double)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Scalable3D {
  public mutating func scaleBy(x: Swift.Double = 1, y: Swift.Double = 1, z: Swift.Double = 1)
  public mutating func scale(by scale: Spatial.Size3D)
  public mutating func uniformlyScale(by scale: Swift.Double)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Rotatable3D {
  func rotated(by rotation: Spatial.Rotation3D) -> Self
  mutating func rotate(by rotation: Spatial.Rotation3D)
  func rotated(by quaternion: simd.simd_quatd) -> Self
  mutating func rotate(by quaternion: simd.simd_quatd)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotatable3D {
  public mutating func rotate(by rotation: Spatial.Rotation3D)
  public mutating func rotate(by rotation: simd.simd_quatd)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public enum AxisWithFactors {
  case xAxis(yShearFactor: Swift.Double, zShearFactor: Swift.Double)
  case yAxis(xShearFactor: Swift.Double, zShearFactor: Swift.Double)
  case zAxis(xShearFactor: Swift.Double, yShearFactor: Swift.Double)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Shearable3D {
  func sheared(_ shear: Spatial.AxisWithFactors) -> Self
  mutating func shear(_ shear: Spatial.AxisWithFactors)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Shearable3D {
  public mutating func shear(_ shear: Spatial.AxisWithFactors)
  @usableFromInline
  internal func _shear(shearFunc: (Self, Spatial.Axis3D, Swift.Double, Swift.Double) -> Self, shear: Spatial.AxisWithFactors) -> Self
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public protocol Volumetric {
  var size: Spatial.Size3D { get }
  func contains(_ other: Self) -> Swift.Bool
  func contains(point: Spatial.Point3D) -> Swift.Bool
  func union(_ other: Self) -> Self
  func intersection(_ other: Self) -> Self?
  mutating func formIntersection(_ other: Self)
  mutating func formUnion(_ other: Self)
  @available(*, deprecated, renamed: "contains(anyOf:)")
  func containsAny(of points: [Spatial.Point3D]) -> Swift.Bool
  func contains(anyOf points: [Spatial.Point3D]) -> Swift.Bool
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Volumetric {
  public mutating func formIntersection(_ other: Self)
  public mutating func formUnion(_ other: Self)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
public struct Dimension3DSet : Swift.OptionSet {
  public let rawValue: Swift.Int
  public static let x: Spatial.Dimension3DSet
  public static let y: Spatial.Dimension3DSet
  public static let z: Spatial.Dimension3DSet
  public static let all: Spatial.Dimension3DSet
  public init(rawValue: Swift.Int)
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias ArrayLiteralElement = Spatial.Dimension3DSet
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Element = Spatial.Dimension3DSet
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias RawValue = Swift.Int
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D {
  public static let one: Spatial.Size3D
  @inlinable public init(width: Swift.Double = 0, height: Swift.Double = 0, depth: Swift.Double = 0) {
        self = __SPSize3DMake(width, height, depth)
    }
  @inlinable public init(_ xyz: simd.simd_double3) {
        self = __SPSize3DMakeWithVector(xyz)
    }
  @inlinable public init(_ point: Spatial.Point3D) {
        self = __SPSize3DMakeWithPoint(point)
    }
  @inlinable public init(_ xyz: Spatial.Vector3D) {
        self = __SPSize3DMakeWithVector(xyz)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Spatial.Primitive3D {
  @inlinable public func unapplying(_ transform: Spatial.AffineTransform3D) -> Spatial.Size3D {
        
        let unapplied = __SPSize3DUnapplyAffineTransform(self, transform)
        
        if __SPSize3DIsValid(unapplied) {
            return unapplied
        } else {
            return self
        }
    }
  @inlinable public func unapplying(_ transform: Spatial.ProjectiveTransform3D) -> Spatial.Size3D {
        
        let unapplied = __SPSize3DUnapplyProjectiveTransform(self, transform)
        
        if __SPSize3DIsValid(unapplied) {
            return unapplied
        } else {
            return self
        }
    }
  public func applying(_ pose: Spatial.Pose3D) -> Spatial.Size3D
  public func unapplying(_ pose: Spatial.Pose3D) -> Spatial.Size3D
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Size3D {
  public func applying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Size3D
  public func unapplying(_ scaledPose: Spatial.ScaledPose3D) -> Spatial.Size3D
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Spatial.Scalable3D {
  @inlinable public func scaledBy(x: Swift.Double = 1, y: Swift.Double = 1, z: Swift.Double = 1) -> Spatial.Size3D {
        
        return __SPSize3DScaleBy(self, x, y, z)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Spatial.Rotatable3D {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Spatial.Shearable3D {
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.Size3D {
        
        return _shear(shearFunc: __SPSize3DShear, shear: shear)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Spatial.Volumetric {
  public var size: Spatial.Size3D {
    get
  }
  @inlinable public func contains(anyOf points: [Spatial.Point3D]) -> Swift.Bool {
        return __SPSize3DContainsAnyPoint(self,
                                          points,
                                          Int32(points.count))
    }
  @inlinable public func intersection(_ other: Spatial.Size3D) -> Spatial.Size3D? {
        let intersection = __SPSize3DIntersection(self, other)
        
        if intersection != Size3D.zero {
            return intersection
        } else {
            return nil
        }
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Size3D, rhs: Spatial.Size3D) -> Swift.Bool {
        return lhs.width == rhs.width && lhs.height == rhs.height && lhs.depth == rhs.depth
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Size3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Size3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D : @unchecked Swift.Sendable {
  public init(_ quaternion: simd.simd_quatd)
  public var angle: Spatial.Angle2D {
    get
    set
  }
  public var axis: Spatial.RotationAxis3D {
    get
    set
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D {
  public init(position: Spatial.Point3D = Point3D(x: 0, y: 0, z: 0), target: Spatial.Point3D, up: Spatial.Vector3D = Vector3D(x: 0, y: 1, z: 0))
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Rotation3D {
  public init(forward: Spatial.Vector3D)
}
extension Spatial.Rotation3D {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  @backDeployed(before: macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0)
  public init() {
        self = Rotation3D(simd_quaternion(simd_double4(x: 0, y: 0, z: 0, w: 1)))
    }
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Rotation3D : Spatial.Rotatable3D {
  public func rotated(by rotation: Spatial.Rotation3D) -> Spatial.Rotation3D
  public func rotated(by quaternion: simd.simd_quatd) -> Spatial.Rotation3D
  public enum SlerpPath {
    case shortest
    case longest
    case automatic
    public static func == (a: Spatial.Rotation3D.SlerpPath, b: Spatial.Rotation3D.SlerpPath) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func slerp(from: Spatial.Rotation3D, to: Spatial.Rotation3D, t: Swift.Double, along path: Spatial.Rotation3D.SlerpPath = .shortest) -> Spatial.Rotation3D
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Rotation3D.SlerpPath : @unchecked Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Rotation3D {
  public static func spline(leftEndpoint r0: Spatial.Rotation3D, from r1: Spatial.Rotation3D, to r2: Spatial.Rotation3D, rightEndpoint r3: Spatial.Rotation3D, t: Swift.Double) -> Spatial.Rotation3D
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.Rotation3D, rhs: Spatial.Rotation3D) -> Swift.Bool {
        __SPRotation3DEqualToRotation(lhs, rhs)
    }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Rotation3D {
  @inlinable public func isApproximatelyEqual(to other: Spatial.Rotation3D, tolerance: Swift.Double = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPRotation3DAlmostEqualToRotation(self, other, tolerance)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Rotation3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.Rotation3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.EulerAngles {
  public typealias Order = Spatial.__SPEulerAngleOrder
  public init(angles: simd.simd_float3, order: Spatial.EulerAngles.Order)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.EulerAngles {
  public init(x: Spatial.Angle2D, y: Spatial.Angle2D, z: Spatial.Angle2D, order: Spatial.EulerAngles.Order)
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Rotation3D {
  public func swingTwist(twistAxis: Spatial.RotationAxis3D) -> (swing: Spatial.Rotation3D, twist: Spatial.Rotation3D)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.__SPEulerAngleOrder {
  @available(*, deprecated, renamed: "EulerAngles.Order.xyz")
  public static let pitchYawRoll: Spatial.__SPEulerAngleOrder
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
  public static let xyz: Spatial.__SPEulerAngleOrder
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
  public static let zxy: Spatial.__SPEulerAngleOrder
}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.__SPEulerAngleOrder : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D {
  @inlinable public var translation: Spatial.Vector3D {
    get {
            return __SPAffineTransform3DGetTranslation(self)
        }
    set {
            __SPAffineTransform3DSetTranslation(&self, newValue)
        }
  }
  @inlinable public func isApproximatelyEqual(to other: Spatial.AffineTransform3D, tolerance: Swift.Double = sqrt(.ulpOfOne)) -> Swift.Bool {
        
        return __SPAffineTransform3DAlmostEqualToTransform(self, other, tolerance)
    }
  @inlinable public init() {
         self.init(scale: Size3D(width: 1, height: 1, depth: 1))
     }
  @available(*, deprecated, message: "Use `Vector3D` variant.")
  @inlinable public init(scale: Spatial.Size3D = Size3D(width: 1.0, height: 1, depth: 1), rotation: Spatial.Rotation3D = .zero, translation: Spatial.Size3D) {
        
        
        self = __SPAffineTransform3DMake(scale,
                                         rotation,
                                         Vector3D(translation))
    }
  @inlinable public init(scale: Spatial.Size3D = Size3D(width: 1.0, height: 1, depth: 1), rotation: Spatial.Rotation3D = .zero, translation: Spatial.Vector3D = .zero) {
        
        
        self = __SPAffineTransform3DMake(scale,
                                         rotation,
                                         translation)
    }
  @inlinable public init(shear: Spatial.AxisWithFactors) {
        switch shear {
            case .xAxis(let yShearFactor, let zShearFactor):
                self = __SPAffineTransform3DMakeShear(.x, yShearFactor, zShearFactor)
            case .yAxis(let xShearFactor, let zShearFactor):
                self = __SPAffineTransform3DMakeShear(.y, xShearFactor, zShearFactor)
            case .zAxis(let xShearFactor, let yShearFactor):
                self = __SPAffineTransform3DMakeShear(.z, xShearFactor, yShearFactor)
            @unknown default:
                fatalError("Unsupported shear")
        }
    }
  @inlinable public init(pose: Spatial.Pose3D) {
        
        self = __SPAffineTransform3DMakeWithPose(pose)
    }
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
  @inlinable public init(scaledPose: Spatial.ScaledPose3D) {
        
        self = __SPAffineTransform3DMakeWithScaledPose(scaledPose)
    }
  @inlinable public func sheared(_ shear: Spatial.AxisWithFactors) -> Spatial.AffineTransform3D {
        return _shear(shearFunc: __SPAffineTransform3DShear, shear: shear)
    }
  @inlinable public func scaledBy(x: Swift.Double = 1, y: Swift.Double = 1, z: Swift.Double = 1) -> Spatial.AffineTransform3D {
        return __SPAffineTransform3DScaleBy(self, x, y, z)
    }
  @inlinable public func isUniform(overDimensions: Spatial.Dimension3DSet) -> Swift.Bool {
        
        let axes = Axis3D(rawValue: UInt32(overDimensions.rawValue))
        
        return __SPAffineTransform3DIsUniformOverDimensions(self,
                                                            axes)
    }
  @inlinable public func flipped(along axis: Spatial.Axis3D) -> Spatial.AffineTransform3D {
        return __SPAffineTransform3DFlip(self, axis)
    }
  public mutating func flip(along axis: Spatial.Axis3D)
  @inlinable public var rotation: Spatial.Rotation3D? {
    get {
        
        let r = __SPAffineTransform3DGetRotation(self)
        
        if __SPRotation3DIsValid(r) {
            return r
        } else {
            return nil
        }
    }
  }
  @inlinable public var inverse: Spatial.AffineTransform3D? {
    get {
        
        let t = __SPAffineTransform3DInverted(self)
        
        if __SPAffineTransform3DIsValid(t) {
            return t
        } else {
            return nil
        }
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.AffineTransform3D, rhs: Spatial.AffineTransform3D) -> Swift.Bool {
        return lhs.matrix == rhs.matrix
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.AffineTransform3D {
  public func changeBasis(from: Spatial.AffineTransform3D = .identity, to: Spatial.AffineTransform3D) -> Spatial.AffineTransform3D?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.AffineTransform3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Axis3D : @unchecked Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.Axis3D {
  @inlinable public static var x: Spatial.Axis3D {
    get {
        return __SPAxisX
    }
  }
  @inlinable public static var y: Spatial.Axis3D {
    get {
        return __SPAxisY
    }
  }
  @inlinable public static var z: Spatial.Axis3D {
    get {
        return __SPAxisZ
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D {
  public static let x: Spatial.RotationAxis3D
  public static let y: Spatial.RotationAxis3D
  public static let z: Spatial.RotationAxis3D
  public static let xy: Spatial.RotationAxis3D
  public static let yz: Spatial.RotationAxis3D
  public static let xz: Spatial.RotationAxis3D
  public static let xyz: Spatial.RotationAxis3D
  @inlinable public init(x: Swift.Double = 0, y: Swift.Double = 0, z: Swift.Double = 0) {
        self = __SPRotationAxis3DMake(x, y, z)
    }
  @inlinable public var x: Swift.Double {
    get {
            return self.__x
        }
    set {
            self.__x = newValue
        }
  }
  @inlinable public var y: Swift.Double {
    get {
            return self.__y
        }
    set {
            self.__y = newValue
        }
  }
  @inlinable public var z: Swift.Double {
    get {
            return self.__z
        }
    set {
            self.__z = newValue
        }
  }
  @inlinable public init(_ xyz: simd.simd_double3) {
        self = __SPRotationAxis3DMakeWithVector(xyz)
    }
  @inlinable public init(_ xyz: Spatial.Vector3D) {
        self = __SPRotationAxis3DMakeWithVector(xyz)
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D : Swift.Equatable {
  @inlinable public static func == (lhs: Spatial.RotationAxis3D, rhs: Spatial.RotationAxis3D) -> Swift.Bool {
        return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z
    }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.RotationAxis3D : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Spatial.RotationAxis3D : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Spatial.Shearable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Spatial.Scalable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Spatial.Rotatable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.AffineTransform3D : Spatial.Translatable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Shearable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Scalable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Rotatable3D {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Spatial.ProjectiveTransform3D : Spatial.Translatable3D {}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Rotation3D.SlerpPath : Swift.Equatable {}
@available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
extension Spatial.Rotation3D.SlerpPath : Swift.Hashable {}
