// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1 effective-5.10 (swiftlang-6.1.0.110.5 clang-1700.0.13.3)
// swift-module-flags: -target arm64e-apple-ios15.0-macabi -enable-objc-interop -enable-library-evolution -module-link-name swiftSystem -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 64 -module-name System
// swift-module-flags-ignorable:  -interface-compiler-version 6.1
import Darwin
import Darwin.Mach
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
public protocol MachPortRight {
}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
@inlinable internal func _machPrecondition(file: Swift.StaticString = #file, line: Swift.UInt = #line, _ body: @autoclosure () -> Darwin.kern_return_t) {
  let kr = body()
  let expected = KERN_SUCCESS
  precondition(kr == expected, file: file, line: line)
}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
@frozen public enum Mach {
  @available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
  public struct Port<RightType> : ~Swift.Copyable where RightType : System.MachPortRight {
    @usableFromInline
    internal var _name: Darwin.mach_port_name_t
    @usableFromInline
    internal var _context: Darwin.mach_port_context_t
    public init(name: Darwin.mach_port_name_t)
    @inlinable public func withBorrowedName<ReturnType>(body: (Darwin.mach_port_name_t) -> ReturnType) -> ReturnType {
      return body(_name)
    }
    deinit
  }
  public enum PortRightError : Swift.Error {
    case deadName
    public static func == (a: System.Mach.PortRightError, b: System.Mach.PortRightError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @frozen public struct ReceiveRight : System.MachPortRight {
  }
  @frozen public struct SendRight : System.MachPortRight {
  }
  @frozen public struct SendOnceRight : System.MachPortRight {
  }
}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension System.Mach.Port where RightType == System.Mach.ReceiveRight {
  public init(name: Darwin.mach_port_name_t, context: Darwin.mach_port_context_t)
  @available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
  @inlinable public init() {
    var storage: mach_port_name_t = mach_port_name_t(MACH_PORT_NULL)
    _machPrecondition(
      mach_port_allocate(mach_task_self_, MACH_PORT_RIGHT_RECEIVE, &storage)
    )

     
    self.init(name: storage)
  }
  @available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
  @inlinable public consuming func relinquish() -> (name: Darwin.mach_port_name_t, context: Darwin.mach_port_context_t) {
    let destructured = (name: _name, context: _context)
    discard self
    return destructured
  }
  @available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
  @inlinable public consuming func unguardAndRelinquish() -> Darwin.mach_port_name_t {
    let (name, context) = self.relinquish()
    _machPrecondition(mach_port_unguard(mach_task_self_, name, context))
    return name
  }
  @available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
  @inlinable public func withBorrowedName<ReturnType>(body: (Darwin.mach_port_name_t, Darwin.mach_port_context_t) -> ReturnType) -> ReturnType {
    return body(_name, _context)
  }
  @available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
  @inlinable public func makeSendOnceRight() -> System.Mach.Port<System.Mach.SendOnceRight> {
     
    var newRight: mach_port_name_t = mach_port_name_t(MACH_PORT_NULL)
    var newRightType: mach_port_type_t = MACH_PORT_TYPE_NONE

    _machPrecondition(
      mach_port_extract_right(
        mach_task_self_,
        _name,
        mach_msg_type_name_t(MACH_MSG_TYPE_MAKE_SEND_ONCE),
        &newRight,
        &newRightType
      )
    )

     
    precondition(newRightType == MACH_MSG_TYPE_MOVE_SEND_ONCE)

    return Mach.Port(name: newRight)
  }
  @available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
  @inlinable public func makeSendRight() -> System.Mach.Port<System.Mach.SendRight> {
    let how = MACH_MSG_TYPE_MAKE_SEND

     
    _machPrecondition(
      mach_port_insert_right(
        mach_task_self_, _name, _name, mach_msg_type_name_t(how)
      )
    )

    return Mach.Port(name: _name)
  }
  @available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
  @inlinable public var makeSendCount: Darwin.mach_port_mscount_t {
    get {
      var status: mach_port_status = mach_port_status()
      var size = mach_msg_type_number_t(
        MemoryLayout<mach_port_status>.size / MemoryLayout<natural_t>.size
      )

      withUnsafeMutablePointer(to: &status) {
        [ _name = self._name ] in
        let status = UnsafeMutableBufferPointer(start: $0, count: 1)
        status.withMemoryRebound(to: integer_t.self) {
          let info = $0.baseAddress
          _machPrecondition(
            mach_port_get_attributes(
              mach_task_self_, _name, MACH_PORT_RECEIVE_STATUS, info, &size
            )
          )
        }
      }
      return status.mps_mscount
    }
    set {
      _machPrecondition(mach_port_set_mscount(mach_task_self_, _name, newValue))
    }
  }
}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension System.Mach.Port where RightType == System.Mach.SendRight {
  @inlinable public consuming func relinquish() -> Darwin.mach_port_name_t {
    let name = _name
    discard self
    return name
  }
  @available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
  @inlinable public func copySendRight() throws -> System.Mach.Port<System.Mach.SendRight> {
    let how = MACH_MSG_TYPE_COPY_SEND

     
    let kr = mach_port_insert_right(
      mach_task_self_, _name, _name, mach_msg_type_name_t(how)
    )
    if kr == KERN_INVALID_NAME || kr == KERN_INVALID_CAPABILITY {
      throw Mach.PortRightError.deadName
    }
    _machPrecondition(kr)

    return Mach.Port(name: _name)
  }
}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension System.Mach.Port where RightType == System.Mach.SendOnceRight {
  @available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
  @inlinable public consuming func relinquish() -> Darwin.mach_port_name_t {
    let name = _name
    discard self
    return name
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@frozen public struct FileDescriptor : Swift.RawRepresentable, Swift.Hashable, Swift.Codable {
  @_alwaysEmitIntoClient public let rawValue: Swift.CInt
  @_alwaysEmitIntoClient public init(rawValue: Swift.CInt) { self.rawValue = rawValue }
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias RawValue = Swift.CInt
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor {
  @_alwaysEmitIntoClient public static var standardInput: System.FileDescriptor {
    get { .init(rawValue: 0) }
  }
  @_alwaysEmitIntoClient public static var standardOutput: System.FileDescriptor {
    get { .init(rawValue: 1) }
  }
  @_alwaysEmitIntoClient public static var standardError: System.FileDescriptor {
    get { .init(rawValue: 2) }
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor {
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @frozen public struct AccessMode : Swift.RawRepresentable, Swift.Sendable, Swift.Hashable, Swift.Codable {
    @_alwaysEmitIntoClient public var rawValue: Swift.CInt
    @_alwaysEmitIntoClient public init(rawValue: Swift.CInt) { self.rawValue = rawValue }
    @_alwaysEmitIntoClient public static var readOnly: System.FileDescriptor.AccessMode {
      get { AccessMode(rawValue: _O_RDONLY) }
    }
    @available(*, unavailable, renamed: "readOnly")
    @_alwaysEmitIntoClient public static var O_RDONLY: System.FileDescriptor.AccessMode {
      get { readOnly }
    }
    @_alwaysEmitIntoClient public static var writeOnly: System.FileDescriptor.AccessMode {
      get { AccessMode(rawValue: _O_WRONLY) }
    }
    @available(*, unavailable, renamed: "writeOnly")
    @_alwaysEmitIntoClient public static var O_WRONLY: System.FileDescriptor.AccessMode {
      get { writeOnly }
    }
    @_alwaysEmitIntoClient public static var readWrite: System.FileDescriptor.AccessMode {
      get { AccessMode(rawValue: _O_RDWR) }
    }
    @available(*, unavailable, renamed: "readWrite")
    @_alwaysEmitIntoClient public static var O_RDWR: System.FileDescriptor.AccessMode {
      get { readWrite }
    }
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias RawValue = Swift.CInt
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @frozen public struct OpenOptions : Swift.OptionSet, Swift.Sendable, Swift.Hashable, Swift.Codable {
    @_alwaysEmitIntoClient public var rawValue: Swift.CInt
    @_alwaysEmitIntoClient public init(rawValue: Swift.CInt) { self.rawValue = rawValue }
    @_alwaysEmitIntoClient public static var nonBlocking: System.FileDescriptor.OpenOptions {
      get { .init(rawValue: _O_NONBLOCK) }
    }
    @available(*, unavailable, renamed: "nonBlocking")
    @_alwaysEmitIntoClient public static var O_NONBLOCK: System.FileDescriptor.OpenOptions {
      get { nonBlocking }
    }
    @_alwaysEmitIntoClient public static var append: System.FileDescriptor.OpenOptions {
      get { .init(rawValue: _O_APPEND) }
    }
    @available(*, unavailable, renamed: "append")
    @_alwaysEmitIntoClient public static var O_APPEND: System.FileDescriptor.OpenOptions {
      get { append }
    }
    @_alwaysEmitIntoClient public static var create: System.FileDescriptor.OpenOptions {
      get { .init(rawValue: _O_CREAT) }
    }
    @available(*, unavailable, renamed: "create")
    @_alwaysEmitIntoClient public static var O_CREAT: System.FileDescriptor.OpenOptions {
      get { create }
    }
    @_alwaysEmitIntoClient public static var truncate: System.FileDescriptor.OpenOptions {
      get { .init(rawValue: _O_TRUNC) }
    }
    @available(*, unavailable, renamed: "truncate")
    @_alwaysEmitIntoClient public static var O_TRUNC: System.FileDescriptor.OpenOptions {
      get { truncate }
    }
    @_alwaysEmitIntoClient public static var exclusiveCreate: System.FileDescriptor.OpenOptions {
      get { .init(rawValue: _O_EXCL) }
    }
    @available(*, unavailable, renamed: "exclusiveCreate")
    @_alwaysEmitIntoClient public static var O_EXCL: System.FileDescriptor.OpenOptions {
      get { exclusiveCreate }
    }
    @_alwaysEmitIntoClient public static var sharedLock: System.FileDescriptor.OpenOptions {
      get { .init(rawValue: _O_SHLOCK) }
    }
    @available(*, unavailable, renamed: "sharedLock")
    @_alwaysEmitIntoClient public static var O_SHLOCK: System.FileDescriptor.OpenOptions {
      get { sharedLock }
    }
    @_alwaysEmitIntoClient public static var exclusiveLock: System.FileDescriptor.OpenOptions {
      get { .init(rawValue: _O_EXLOCK) }
    }
    @available(*, unavailable, renamed: "exclusiveLock")
    @_alwaysEmitIntoClient public static var O_EXLOCK: System.FileDescriptor.OpenOptions {
      get { exclusiveLock }
    }
    @_alwaysEmitIntoClient public static var noFollow: System.FileDescriptor.OpenOptions {
      get { .init(rawValue: _O_NOFOLLOW) }
    }
    @available(*, unavailable, renamed: "noFollow")
    @_alwaysEmitIntoClient public static var O_NOFOLLOW: System.FileDescriptor.OpenOptions {
      get { noFollow }
    }
    @_alwaysEmitIntoClient public static var directory: System.FileDescriptor.OpenOptions {
      get { .init(rawValue: _O_DIRECTORY) }
    }
    @available(*, unavailable, renamed: "directory")
    @_alwaysEmitIntoClient public static var O_DIRECTORY: System.FileDescriptor.OpenOptions {
      get { directory }
    }
    @_alwaysEmitIntoClient public static var symlink: System.FileDescriptor.OpenOptions {
      get { .init(rawValue: _O_SYMLINK) }
    }
    @available(*, unavailable, renamed: "symlink")
    @_alwaysEmitIntoClient public static var O_SYMLINK: System.FileDescriptor.OpenOptions {
      get { symlink }
    }
    @_alwaysEmitIntoClient public static var eventOnly: System.FileDescriptor.OpenOptions {
      get { .init(rawValue: _O_EVTONLY) }
    }
    @available(*, unavailable, renamed: "eventOnly")
    @_alwaysEmitIntoClient public static var O_EVTONLY: System.FileDescriptor.OpenOptions {
      get { eventOnly }
    }
    @_alwaysEmitIntoClient public static var closeOnExec: System.FileDescriptor.OpenOptions {
      get { .init(rawValue: _O_CLOEXEC) }
    }
    @available(*, unavailable, renamed: "closeOnExec")
    @_alwaysEmitIntoClient public static var O_CLOEXEC: System.FileDescriptor.OpenOptions {
      get { closeOnExec }
    }
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias ArrayLiteralElement = System.FileDescriptor.OpenOptions
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias Element = System.FileDescriptor.OpenOptions
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias RawValue = Swift.CInt
  }
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @frozen public struct SeekOrigin : Swift.RawRepresentable, Swift.Sendable, Swift.Hashable, Swift.Codable {
    @_alwaysEmitIntoClient public var rawValue: Swift.CInt
    @_alwaysEmitIntoClient public init(rawValue: Swift.CInt) { self.rawValue = rawValue }
    @_alwaysEmitIntoClient public static var start: System.FileDescriptor.SeekOrigin {
      get { SeekOrigin(rawValue: _SEEK_SET) }
    }
    @available(*, unavailable, renamed: "start")
    @_alwaysEmitIntoClient public static var SEEK_SET: System.FileDescriptor.SeekOrigin {
      get { start }
    }
    @_alwaysEmitIntoClient public static var current: System.FileDescriptor.SeekOrigin {
      get { SeekOrigin(rawValue: _SEEK_CUR) }
    }
    @available(*, unavailable, renamed: "current")
    @_alwaysEmitIntoClient public static var SEEK_CUR: System.FileDescriptor.SeekOrigin {
      get { current }
    }
    @_alwaysEmitIntoClient public static var end: System.FileDescriptor.SeekOrigin {
      get { SeekOrigin(rawValue: _SEEK_END) }
    }
    @available(*, unavailable, renamed: "end")
    @_alwaysEmitIntoClient public static var SEEK_END: System.FileDescriptor.SeekOrigin {
      get { end }
    }
    @_alwaysEmitIntoClient public static var nextHole: System.FileDescriptor.SeekOrigin {
      get { SeekOrigin(rawValue: _SEEK_HOLE) }
    }
    @available(*, unavailable, renamed: "nextHole")
    @_alwaysEmitIntoClient public static var SEEK_HOLE: System.FileDescriptor.SeekOrigin {
      get { nextHole }
    }
    @_alwaysEmitIntoClient public static var nextData: System.FileDescriptor.SeekOrigin {
      get { SeekOrigin(rawValue: _SEEK_DATA) }
    }
    @available(*, unavailable, renamed: "nextData")
    @_alwaysEmitIntoClient public static var SEEK_DATA: System.FileDescriptor.SeekOrigin {
      get { nextData }
    }
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    public typealias RawValue = Swift.CInt
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor.AccessMode : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor.SeekOrigin : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor.OpenOptions : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public var isAbsolute: Swift.Bool {
    get
  }
  public var isRelative: Swift.Bool {
    get
  }
  public func starts(with other: System.FilePath) -> Swift.Bool
  public func ends(with other: System.FilePath) -> Swift.Bool
  public var isEmpty: Swift.Bool {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public var root: System.FilePath.Root? {
    get
    set
  }
  public __consuming func removingRoot() -> System.FilePath
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public var lastComponent: System.FilePath.Component? {
    get
  }
  public __consuming func removingLastComponent() -> System.FilePath
  @discardableResult
  public mutating func removeLastComponent() -> Swift.Bool
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component {
  public var `extension`: Swift.String? {
    get
  }
  public var stem: Swift.String {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public var `extension`: Swift.String? {
    get
    set
  }
  public var stem: Swift.String? {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public var isLexicallyNormal: Swift.Bool {
    get
  }
  public mutating func lexicallyNormalize()
  public __consuming func lexicallyNormalized() -> System.FilePath
  public __consuming func lexicallyResolving(_ subpath: __owned System.FilePath) -> System.FilePath?
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public mutating func removePrefix(_ prefix: System.FilePath) -> Swift.Bool
  public mutating func append(_ component: __owned System.FilePath.Component)
  public mutating func append<C>(_ components: __owned C) where C : Swift.Collection, C.Element == System.FilePath.Component
  public mutating func append(_ other: __owned Swift.String)
  public __consuming func appending(_ other: __owned System.FilePath.Component) -> System.FilePath
  public __consuming func appending<C>(_ components: __owned C) -> System.FilePath where C : Swift.Collection, C.Element == System.FilePath.Component
  public __consuming func appending(_ other: __owned Swift.String) -> System.FilePath
  public mutating func push(_ other: __owned System.FilePath)
  public __consuming func pushing(_ other: __owned System.FilePath) -> System.FilePath
  public mutating func removeAll(keepingCapacity: Swift.Bool = false)
  public mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  @available(*, unavailable, renamed: "removingLastComponent()")
  public var dirname: System.FilePath {
    get
  }
  @available(*, unavailable, renamed: "lastComponent")
  public var basename: System.FilePath.Component? {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.String {
  @_disfavoredOverload public init(platformString: Swift.UnsafePointer<System.CInterop.PlatformChar>)
  @inlinable @_alwaysEmitIntoClient public init(platformString: [System.CInterop.PlatformChar]) {
    guard let _ = platformString.firstIndex(of: 0) else {
      fatalError(
        "input of String.init(platformString:) must be null-terminated"
      )
    }
    self = platformString.withUnsafeBufferPointer {
      String(platformString: $0.baseAddress!)
    }
  }
  @available(*, deprecated, message: "Use String.init(_ scalar: Unicode.Scalar)")
  @inlinable @_alwaysEmitIntoClient public init(platformString: inout System.CInterop.PlatformChar) {
    guard platformString == 0 else {
      fatalError(
        "input of String.init(platformString:) must be null-terminated"
      )
    }
    self = ""
  }
  @available(*, deprecated, message: "Use a copy of the String argument")
  @inlinable @_alwaysEmitIntoClient public init(platformString: Swift.String) {
    if let nullLoc = platformString.firstIndex(of: "\0") {
      self = String(platformString[..<nullLoc])
    } else {
      self = platformString
    }
  }
  public init?(validatingPlatformString platformString: Swift.UnsafePointer<System.CInterop.PlatformChar>)
  @inlinable @_alwaysEmitIntoClient public init?(validatingPlatformString platformString: [System.CInterop.PlatformChar]) {
    guard let _ = platformString.firstIndex(of: 0) else {
      fatalError(
        "input of String.init(validatingPlatformString:) must be null-terminated"
      )
    }
    guard let string = platformString.withUnsafeBufferPointer({
      String(validatingPlatformString: $0.baseAddress!)
    }) else {
      return nil
    }
    self = string
  }
  @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
  @inlinable @_alwaysEmitIntoClient public init?(validatingPlatformString platformString: inout System.CInterop.PlatformChar) {
    guard platformString == 0 else {
      fatalError(
        "input of String.init(validatingPlatformString:) must be null-terminated"
      )
    }
    self = ""
  }
  @available(*, deprecated, message: "Use a copy of the String argument")
  @inlinable @_alwaysEmitIntoClient public init?(validatingPlatformString platformString: Swift.String) {
    if let nullLoc = platformString.firstIndex(of: "\0") {
      self = String(platformString[..<nullLoc])
    } else {
      self = platformString
    }
  }
  public func withPlatformString<Result>(_ body: (Swift.UnsafePointer<System.CInterop.PlatformChar>) throws -> Result) rethrows -> Result
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public struct Root : Swift.Sendable {
  }
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public struct Component : Swift.Sendable {
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @frozen public enum Kind : Swift.Sendable {
    case currentDirectory
    case parentDirectory
    case regular
    public static func == (a: System.FilePath.Component.Kind, b: System.FilePath.Component.Kind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var kind: System.FilePath.Component.Kind {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component {
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Root {
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public struct ComponentView : Swift.Sendable {
  }
  public var components: System.FilePath.ComponentView {
    __consuming get
    _modify
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.ComponentView : Swift.BidirectionalCollection {
  public typealias Element = System.FilePath.Component
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public struct Index : Swift.Sendable, Swift.Comparable, Swift.Hashable {
    public static func < (lhs: System.FilePath.ComponentView.Index, rhs: System.FilePath.ComponentView.Index) -> Swift.Bool
    public static func == (a: System.FilePath.ComponentView.Index, b: System.FilePath.ComponentView.Index) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var startIndex: System.FilePath.ComponentView.Index {
    get
  }
  public var endIndex: System.FilePath.ComponentView.Index {
    get
  }
  public func index(after i: System.FilePath.ComponentView.Index) -> System.FilePath.ComponentView.Index
  public func index(before i: System.FilePath.ComponentView.Index) -> System.FilePath.ComponentView.Index
  public subscript(position: System.FilePath.ComponentView.Index) -> System.FilePath.Component {
    get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Indices = Swift.DefaultIndices<System.FilePath.ComponentView>
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Iterator = Swift.IndexingIterator<System.FilePath.ComponentView>
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias SubSequence = Swift.Slice<System.FilePath.ComponentView>
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.ComponentView : Swift.RangeReplaceableCollection {
  public init()
  public mutating func replaceSubrange<C>(_ subrange: Swift.Range<System.FilePath.ComponentView.Index>, with newElements: C) where C : Swift.Collection, C.Element == System.FilePath.Component
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public init<C>(root: System.FilePath.Root?, _ components: C) where C : Swift.Collection, C.Element == System.FilePath.Component
  public init(root: System.FilePath.Root?, components: System.FilePath.Component...)
  public init(root: System.FilePath.Root?, _ components: System.FilePath.ComponentView.SubSequence)
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.ComponentView {
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@frozen public struct FilePermissions : Swift.OptionSet, Swift.Sendable, Swift.Hashable, Swift.Codable {
  @_alwaysEmitIntoClient public let rawValue: System.CModeT
  @_alwaysEmitIntoClient public init(rawValue: System.CModeT) { self.rawValue = rawValue }
  @_alwaysEmitIntoClient public static var otherRead: System.FilePermissions {
    get { .init(rawValue: 0o4) }
  }
  @_alwaysEmitIntoClient public static var otherWrite: System.FilePermissions {
    get { .init(rawValue: 0o2) }
  }
  @_alwaysEmitIntoClient public static var otherExecute: System.FilePermissions {
    get { .init(rawValue: 0o1) }
  }
  @_alwaysEmitIntoClient public static var otherReadWrite: System.FilePermissions {
    get { .init(rawValue: 0o6) }
  }
  @_alwaysEmitIntoClient public static var otherReadExecute: System.FilePermissions {
    get { .init(rawValue: 0o5) }
  }
  @_alwaysEmitIntoClient public static var otherWriteExecute: System.FilePermissions {
    get { .init(rawValue: 0o3) }
  }
  @_alwaysEmitIntoClient public static var otherReadWriteExecute: System.FilePermissions {
    get { .init(rawValue: 0o7) }
  }
  @_alwaysEmitIntoClient public static var groupRead: System.FilePermissions {
    get { .init(rawValue: 0o40) }
  }
  @_alwaysEmitIntoClient public static var groupWrite: System.FilePermissions {
    get { .init(rawValue: 0o20) }
  }
  @_alwaysEmitIntoClient public static var groupExecute: System.FilePermissions {
    get { .init(rawValue: 0o10) }
  }
  @_alwaysEmitIntoClient public static var groupReadWrite: System.FilePermissions {
    get { .init(rawValue: 0o60) }
  }
  @_alwaysEmitIntoClient public static var groupReadExecute: System.FilePermissions {
    get { .init(rawValue: 0o50) }
  }
  @_alwaysEmitIntoClient public static var groupWriteExecute: System.FilePermissions {
    get { .init(rawValue: 0o30) }
  }
  @_alwaysEmitIntoClient public static var groupReadWriteExecute: System.FilePermissions {
    get { .init(rawValue: 0o70) }
  }
  @_alwaysEmitIntoClient public static var ownerRead: System.FilePermissions {
    get { .init(rawValue: 0o400) }
  }
  @_alwaysEmitIntoClient public static var ownerWrite: System.FilePermissions {
    get { .init(rawValue: 0o200) }
  }
  @_alwaysEmitIntoClient public static var ownerExecute: System.FilePermissions {
    get { .init(rawValue: 0o100) }
  }
  @_alwaysEmitIntoClient public static var ownerReadWrite: System.FilePermissions {
    get { .init(rawValue: 0o600) }
  }
  @_alwaysEmitIntoClient public static var ownerReadExecute: System.FilePermissions {
    get { .init(rawValue: 0o500) }
  }
  @_alwaysEmitIntoClient public static var ownerWriteExecute: System.FilePermissions {
    get { .init(rawValue: 0o300) }
  }
  @_alwaysEmitIntoClient public static var ownerReadWriteExecute: System.FilePermissions {
    get { .init(rawValue: 0o700) }
  }
  @_alwaysEmitIntoClient public static var setUserID: System.FilePermissions {
    get { .init(rawValue: 0o4000) }
  }
  @_alwaysEmitIntoClient public static var setGroupID: System.FilePermissions {
    get { .init(rawValue: 0o2000) }
  }
  @_alwaysEmitIntoClient public static var saveText: System.FilePermissions {
    get { .init(rawValue: 0o1000) }
  }
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias ArrayLiteralElement = System.FilePermissions
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias Element = System.FilePermissions
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias RawValue = System.CModeT
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FilePermissions : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public typealias CModeT = sys_types.mode_t
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public enum CInterop {
  public typealias Mode = sys_types.mode_t
  public typealias Char = Swift.CChar
  public typealias PlatformChar = System.CInterop.Char
  public typealias PlatformUnicodeEncoding = Swift.UTF8
}
@_alwaysEmitIntoClient internal var _ERRNO_NOT_USED: Swift.CInt {
  get { 0 }
}
@_alwaysEmitIntoClient internal var _EPERM: Swift.CInt {
  get { EPERM }
}
@_alwaysEmitIntoClient internal var _ENOENT: Swift.CInt {
  get { ENOENT }
}
@_alwaysEmitIntoClient internal var _ESRCH: Swift.CInt {
  get { ESRCH }
}
@_alwaysEmitIntoClient internal var _EINTR: Swift.CInt {
  get { EINTR }
}
@_alwaysEmitIntoClient internal var _EIO: Swift.CInt {
  get { EIO }
}
@_alwaysEmitIntoClient internal var _ENXIO: Swift.CInt {
  get { ENXIO }
}
@_alwaysEmitIntoClient internal var _E2BIG: Swift.CInt {
  get { E2BIG }
}
@_alwaysEmitIntoClient internal var _ENOEXEC: Swift.CInt {
  get { ENOEXEC }
}
@_alwaysEmitIntoClient internal var _EBADF: Swift.CInt {
  get { EBADF }
}
@_alwaysEmitIntoClient internal var _ECHILD: Swift.CInt {
  get { ECHILD }
}
@_alwaysEmitIntoClient internal var _EDEADLK: Swift.CInt {
  get { EDEADLK }
}
@_alwaysEmitIntoClient internal var _ENOMEM: Swift.CInt {
  get { ENOMEM }
}
@_alwaysEmitIntoClient internal var _EACCES: Swift.CInt {
  get { EACCES }
}
@_alwaysEmitIntoClient internal var _EFAULT: Swift.CInt {
  get { EFAULT }
}
@_alwaysEmitIntoClient internal var _ENOTBLK: Swift.CInt {
  get { ENOTBLK }
}
@_alwaysEmitIntoClient internal var _EBUSY: Swift.CInt {
  get { EBUSY }
}
@_alwaysEmitIntoClient internal var _EEXIST: Swift.CInt {
  get { EEXIST }
}
@_alwaysEmitIntoClient internal var _EXDEV: Swift.CInt {
  get { EXDEV }
}
@_alwaysEmitIntoClient internal var _ENODEV: Swift.CInt {
  get { ENODEV }
}
@_alwaysEmitIntoClient internal var _ENOTDIR: Swift.CInt {
  get { ENOTDIR }
}
@_alwaysEmitIntoClient internal var _EISDIR: Swift.CInt {
  get { EISDIR }
}
@_alwaysEmitIntoClient internal var _EINVAL: Swift.CInt {
  get { EINVAL }
}
@_alwaysEmitIntoClient internal var _ENFILE: Swift.CInt {
  get { ENFILE }
}
@_alwaysEmitIntoClient internal var _EMFILE: Swift.CInt {
  get { EMFILE }
}
@_alwaysEmitIntoClient internal var _ENOTTY: Swift.CInt {
  get { ENOTTY }
}
@_alwaysEmitIntoClient internal var _ETXTBSY: Swift.CInt {
  get { ETXTBSY }
}
@_alwaysEmitIntoClient internal var _EFBIG: Swift.CInt {
  get { EFBIG }
}
@_alwaysEmitIntoClient internal var _ENOSPC: Swift.CInt {
  get { ENOSPC }
}
@_alwaysEmitIntoClient internal var _ESPIPE: Swift.CInt {
  get { ESPIPE }
}
@_alwaysEmitIntoClient internal var _EROFS: Swift.CInt {
  get { EROFS }
}
@_alwaysEmitIntoClient internal var _EMLINK: Swift.CInt {
  get { EMLINK }
}
@_alwaysEmitIntoClient internal var _EPIPE: Swift.CInt {
  get { EPIPE }
}
@_alwaysEmitIntoClient internal var _EDOM: Swift.CInt {
  get { EDOM }
}
@_alwaysEmitIntoClient internal var _ERANGE: Swift.CInt {
  get { ERANGE }
}
@_alwaysEmitIntoClient internal var _EAGAIN: Swift.CInt {
  get { EAGAIN }
}
@_alwaysEmitIntoClient internal var _EWOULDBLOCK: Swift.CInt {
  get {
  EWOULDBLOCK
}
}
@_alwaysEmitIntoClient internal var _EINPROGRESS: Swift.CInt {
  get { EINPROGRESS }
}
@_alwaysEmitIntoClient internal var _EALREADY: Swift.CInt {
  get { EALREADY }
}
@_alwaysEmitIntoClient internal var _ENOTSOCK: Swift.CInt {
  get { ENOTSOCK }
}
@_alwaysEmitIntoClient internal var _EDESTADDRREQ: Swift.CInt {
  get { EDESTADDRREQ }
}
@_alwaysEmitIntoClient internal var _EMSGSIZE: Swift.CInt {
  get { EMSGSIZE }
}
@_alwaysEmitIntoClient internal var _EPROTOTYPE: Swift.CInt {
  get { EPROTOTYPE }
}
@_alwaysEmitIntoClient internal var _ENOPROTOOPT: Swift.CInt {
  get { ENOPROTOOPT }
}
@_alwaysEmitIntoClient internal var _EPROTONOSUPPORT: Swift.CInt {
  get { EPROTONOSUPPORT }
}
@_alwaysEmitIntoClient internal var _ESOCKTNOSUPPORT: Swift.CInt {
  get {
  return ESOCKTNOSUPPORT
}
}
@_alwaysEmitIntoClient internal var _ENOTSUP: Swift.CInt {
  get {
  return ENOTSUP
}
}
@_alwaysEmitIntoClient internal var _EPFNOSUPPORT: Swift.CInt {
  get {
  return EPFNOSUPPORT
}
}
@_alwaysEmitIntoClient internal var _EAFNOSUPPORT: Swift.CInt {
  get { EAFNOSUPPORT }
}
@_alwaysEmitIntoClient internal var _EADDRINUSE: Swift.CInt {
  get { EADDRINUSE }
}
@_alwaysEmitIntoClient internal var _EADDRNOTAVAIL: Swift.CInt {
  get { EADDRNOTAVAIL }
}
@_alwaysEmitIntoClient internal var _ENETDOWN: Swift.CInt {
  get { ENETDOWN }
}
@_alwaysEmitIntoClient internal var _ENETUNREACH: Swift.CInt {
  get { ENETUNREACH }
}
@_alwaysEmitIntoClient internal var _ENETRESET: Swift.CInt {
  get { ENETRESET }
}
@_alwaysEmitIntoClient internal var _ECONNABORTED: Swift.CInt {
  get { ECONNABORTED }
}
@_alwaysEmitIntoClient internal var _ECONNRESET: Swift.CInt {
  get { ECONNRESET }
}
@_alwaysEmitIntoClient internal var _ENOBUFS: Swift.CInt {
  get { ENOBUFS }
}
@_alwaysEmitIntoClient internal var _EISCONN: Swift.CInt {
  get { EISCONN }
}
@_alwaysEmitIntoClient internal var _ENOTCONN: Swift.CInt {
  get { ENOTCONN }
}
@_alwaysEmitIntoClient internal var _ESHUTDOWN: Swift.CInt {
  get {
  return ESHUTDOWN
}
}
@_alwaysEmitIntoClient internal var _ETOOMANYREFS: Swift.CInt {
  get {
  return ETOOMANYREFS
}
}
@_alwaysEmitIntoClient internal var _ETIMEDOUT: Swift.CInt {
  get { ETIMEDOUT }
}
@_alwaysEmitIntoClient internal var _ECONNREFUSED: Swift.CInt {
  get { ECONNREFUSED }
}
@_alwaysEmitIntoClient internal var _ELOOP: Swift.CInt {
  get { ELOOP }
}
@_alwaysEmitIntoClient internal var _ENAMETOOLONG: Swift.CInt {
  get { ENAMETOOLONG }
}
@_alwaysEmitIntoClient internal var _EHOSTDOWN: Swift.CInt {
  get {
  return EHOSTDOWN
}
}
@_alwaysEmitIntoClient internal var _EHOSTUNREACH: Swift.CInt {
  get { EHOSTUNREACH }
}
@_alwaysEmitIntoClient internal var _ENOTEMPTY: Swift.CInt {
  get { ENOTEMPTY }
}
@_alwaysEmitIntoClient internal var _EPROCLIM: Swift.CInt {
  get { EPROCLIM }
}
@_alwaysEmitIntoClient internal var _EUSERS: Swift.CInt {
  get {
  return EUSERS
}
}
@_alwaysEmitIntoClient internal var _EDQUOT: Swift.CInt {
  get {
  return EDQUOT
}
}
@_alwaysEmitIntoClient internal var _ESTALE: Swift.CInt {
  get {
  return ESTALE
}
}
@_alwaysEmitIntoClient internal var _EREMOTE: Swift.CInt {
  get {
  return EREMOTE
}
}
@_alwaysEmitIntoClient internal var _EBADRPC: Swift.CInt {
  get { EBADRPC }
}
@_alwaysEmitIntoClient internal var _ERPCMISMATCH: Swift.CInt {
  get { ERPCMISMATCH }
}
@_alwaysEmitIntoClient internal var _EPROGUNAVAIL: Swift.CInt {
  get { EPROGUNAVAIL }
}
@_alwaysEmitIntoClient internal var _EPROGMISMATCH: Swift.CInt {
  get { EPROGMISMATCH }
}
@_alwaysEmitIntoClient internal var _EPROCUNAVAIL: Swift.CInt {
  get { EPROCUNAVAIL }
}
@_alwaysEmitIntoClient internal var _ENOLCK: Swift.CInt {
  get { ENOLCK }
}
@_alwaysEmitIntoClient internal var _ENOSYS: Swift.CInt {
  get { ENOSYS }
}
@_alwaysEmitIntoClient internal var _EFTYPE: Swift.CInt {
  get { EFTYPE }
}
@_alwaysEmitIntoClient internal var _EAUTH: Swift.CInt {
  get { EAUTH }
}
@_alwaysEmitIntoClient internal var _ENEEDAUTH: Swift.CInt {
  get { ENEEDAUTH }
}
@_alwaysEmitIntoClient internal var _EPWROFF: Swift.CInt {
  get { EPWROFF }
}
@_alwaysEmitIntoClient internal var _EDEVERR: Swift.CInt {
  get { EDEVERR }
}
@_alwaysEmitIntoClient internal var _EOVERFLOW: Swift.CInt {
  get { EOVERFLOW }
}
@_alwaysEmitIntoClient internal var _EBADEXEC: Swift.CInt {
  get { EBADEXEC }
}
@_alwaysEmitIntoClient internal var _EBADARCH: Swift.CInt {
  get { EBADARCH }
}
@_alwaysEmitIntoClient internal var _ESHLIBVERS: Swift.CInt {
  get { ESHLIBVERS }
}
@_alwaysEmitIntoClient internal var _EBADMACHO: Swift.CInt {
  get { EBADMACHO }
}
@_alwaysEmitIntoClient internal var _ECANCELED: Swift.CInt {
  get { ECANCELED }
}
@_alwaysEmitIntoClient internal var _EIDRM: Swift.CInt {
  get { EIDRM }
}
@_alwaysEmitIntoClient internal var _ENOMSG: Swift.CInt {
  get { ENOMSG }
}
@_alwaysEmitIntoClient internal var _EILSEQ: Swift.CInt {
  get { EILSEQ }
}
@_alwaysEmitIntoClient internal var _ENOATTR: Swift.CInt {
  get { ENOATTR }
}
@_alwaysEmitIntoClient internal var _EBADMSG: Swift.CInt {
  get { EBADMSG }
}
@_alwaysEmitIntoClient internal var _EMULTIHOP: Swift.CInt {
  get { EMULTIHOP }
}
@_alwaysEmitIntoClient internal var _ENODATA: Swift.CInt {
  get { ENODATA }
}
@_alwaysEmitIntoClient internal var _ENOLINK: Swift.CInt {
  get { ENOLINK }
}
@_alwaysEmitIntoClient internal var _ENOSR: Swift.CInt {
  get { ENOSR }
}
@_alwaysEmitIntoClient internal var _ENOSTR: Swift.CInt {
  get { ENOSTR }
}
@_alwaysEmitIntoClient internal var _EPROTO: Swift.CInt {
  get { EPROTO }
}
@_alwaysEmitIntoClient internal var _ETIME: Swift.CInt {
  get { ETIME }
}
@_alwaysEmitIntoClient internal var _EOPNOTSUPP: Swift.CInt {
  get {
  EOPNOTSUPP
}
}
@_alwaysEmitIntoClient internal var _ENOPOLICY: Swift.CInt {
  get { ENOPOLICY }
}
@_alwaysEmitIntoClient internal var _ENOTRECOVERABLE: Swift.CInt {
  get { ENOTRECOVERABLE }
}
@_alwaysEmitIntoClient internal var _EOWNERDEAD: Swift.CInt {
  get { EOWNERDEAD }
}
@_alwaysEmitIntoClient internal var _EQFULL: Swift.CInt {
  get { EQFULL }
}
@_alwaysEmitIntoClient internal var _ELAST: Swift.CInt {
  get { ELAST }
}
@_alwaysEmitIntoClient internal var _O_RDONLY: Swift.CInt {
  get { O_RDONLY }
}
@_alwaysEmitIntoClient internal var _O_WRONLY: Swift.CInt {
  get { O_WRONLY }
}
@_alwaysEmitIntoClient internal var _O_RDWR: Swift.CInt {
  get { O_RDWR }
}
@_alwaysEmitIntoClient internal var _O_ACCMODE: Swift.CInt {
  get {
  O_ACCMODE
}
}
@_alwaysEmitIntoClient internal var _O_NONBLOCK: Swift.CInt {
  get {
  O_NONBLOCK
}
}
@_alwaysEmitIntoClient internal var _O_APPEND: Swift.CInt {
  get {
  O_APPEND
}
}
@_alwaysEmitIntoClient internal var _O_SHLOCK: Swift.CInt {
  get { O_SHLOCK }
}
@_alwaysEmitIntoClient internal var _O_EXLOCK: Swift.CInt {
  get { O_EXLOCK }
}
@_alwaysEmitIntoClient internal var _O_ASYNC: Swift.CInt {
  get { O_ASYNC }
}
@_alwaysEmitIntoClient internal var _O_NOFOLLOW: Swift.CInt {
  get { O_NOFOLLOW }
}
@_alwaysEmitIntoClient internal var _O_CREAT: Swift.CInt {
  get {
  O_CREAT
}
}
@_alwaysEmitIntoClient internal var _O_TRUNC: Swift.CInt {
  get {
  O_TRUNC
}
}
@_alwaysEmitIntoClient internal var _O_EXCL: Swift.CInt {
  get {
  O_EXCL
}
}
@_alwaysEmitIntoClient internal var _O_EVTONLY: Swift.CInt {
  get { O_EVTONLY }
}
@_alwaysEmitIntoClient internal var _O_NOCTTY: Swift.CInt {
  get { O_NOCTTY }
}
@_alwaysEmitIntoClient internal var _O_DIRECTORY: Swift.CInt {
  get {
  O_DIRECTORY
}
}
@_alwaysEmitIntoClient internal var _O_SYMLINK: Swift.CInt {
  get { O_SYMLINK }
}
@_alwaysEmitIntoClient internal var _O_CLOEXEC: Swift.CInt {
  get { O_CLOEXEC }
}
@_alwaysEmitIntoClient internal var _SEEK_SET: Swift.CInt {
  get { SEEK_SET }
}
@_alwaysEmitIntoClient internal var _SEEK_CUR: Swift.CInt {
  get { SEEK_CUR }
}
@_alwaysEmitIntoClient internal var _SEEK_END: Swift.CInt {
  get { SEEK_END }
}
@_alwaysEmitIntoClient internal var _SEEK_HOLE: Swift.CInt {
  get { SEEK_HOLE }
}
@_alwaysEmitIntoClient internal var _SEEK_DATA: Swift.CInt {
  get { SEEK_DATA }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor {
  public func closeAfter<R>(_ body: () throws -> R) throws -> R
  @discardableResult
  @_alwaysEmitIntoClient public func writeAll<S>(_ sequence: S) throws -> Swift.Int where S : Swift.Sequence, S.Element == Swift.UInt8 {
    return try _writeAll(sequence).get()
  }
  @usableFromInline
  internal func _writeAll<S>(_ sequence: S) -> Swift.Result<Swift.Int, System.Errno> where S : Swift.Sequence, S.Element == Swift.UInt8
  @discardableResult
  @_alwaysEmitIntoClient public func writeAll<S>(toAbsoluteOffset offset: Swift.Int64, _ sequence: S) throws -> Swift.Int where S : Swift.Sequence, S.Element == Swift.UInt8 {
    try _writeAll(toAbsoluteOffset: offset, sequence).get()
  }
  @usableFromInline
  internal func _writeAll<S>(toAbsoluteOffset offset: Swift.Int64, _ sequence: S) -> Swift.Result<Swift.Int, System.Errno> where S : Swift.Sequence, S.Element == Swift.UInt8
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public init(platformString: Swift.UnsafePointer<System.CInterop.PlatformChar>)
  @inlinable @_alwaysEmitIntoClient public init(platformString: [System.CInterop.PlatformChar]) {
    guard let _ = platformString.firstIndex(of: 0) else {
      fatalError(
        "input of FilePath.init(platformString:) must be null-terminated"
      )
    }
    self = platformString.withUnsafeBufferPointer {
      FilePath(platformString: $0.baseAddress!)
    }
  }
  @available(*, deprecated, message: "Use FilePath.init(_ scalar: Unicode.Scalar)")
  @inlinable @_alwaysEmitIntoClient public init(platformString: inout System.CInterop.PlatformChar) {
    guard platformString == 0 else {
      fatalError(
        "input of FilePath.init(platformString:) must be null-terminated"
      )
    }
    self = FilePath()
  }
  @available(*, deprecated, message: "Use FilePath(_: String) to create a path from a String")
  @inlinable @_alwaysEmitIntoClient public init(platformString: Swift.String) {
    if let nullLoc = platformString.firstIndex(of: "\0") {
      self = FilePath(String(platformString[..<nullLoc]))
    } else {
      self = FilePath(platformString)
    }
  }
  @_alwaysEmitIntoClient public func withPlatformString<Result>(_ body: (Swift.UnsafePointer<System.CInterop.PlatformChar>) throws -> Result) rethrows -> Result {
    return try withCString(body)
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component {
  public init?(platformString: Swift.UnsafePointer<System.CInterop.PlatformChar>)
  @inlinable @_alwaysEmitIntoClient public init?(platformString: [System.CInterop.PlatformChar]) {
    guard let _ = platformString.firstIndex(of: 0) else {
      fatalError(
        "input of FilePath.Component.init?(platformString:) must be null-terminated"
      )
    }
    guard let component = platformString.withUnsafeBufferPointer({
      FilePath.Component(platformString: $0.baseAddress!)
    }) else {
      return nil
    }
    self = component
  }
  @available(*, deprecated, message: "Use FilePath.Component.init(_ scalar: Unicode.Scalar)")
  @inlinable @_alwaysEmitIntoClient public init?(platformString: inout System.CInterop.PlatformChar) {
    guard platformString == 0 else {
      fatalError(
        "input of FilePath.Component.init?(platformString:) must be null-terminated"
      )
    }
    return nil
  }
  @available(*, deprecated, message: "Use FilePath.Component.init(_: String)")
  @inlinable @_alwaysEmitIntoClient public init?(platformString: Swift.String) {
    let string: String
    if let nullLoc = platformString.firstIndex(of: "\0") {
      string = String(platformString[..<nullLoc])
    } else {
      string = platformString
    }
    guard let component = FilePath.Component(string) else { return nil }
    self = component
  }
  public func withPlatformString<Result>(_ body: (Swift.UnsafePointer<System.CInterop.PlatformChar>) throws -> Result) rethrows -> Result
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Root {
  public init?(platformString: Swift.UnsafePointer<System.CInterop.PlatformChar>)
  @inlinable @_alwaysEmitIntoClient public init?(platformString: [System.CInterop.PlatformChar]) {
    guard let _ = platformString.firstIndex(of: 0) else {
      fatalError(
        "input of FilePath.Root.init?(platformString:) must be null-terminated"
      )
    }
    guard let component = platformString.withUnsafeBufferPointer({
      FilePath.Root(platformString: $0.baseAddress!)
    }) else {
      return nil
    }
    self = component
  }
  @available(*, deprecated, message: "Use FilePath.Root.init(_ scalar: Unicode.Scalar)")
  @inlinable @_alwaysEmitIntoClient public init?(platformString: inout System.CInterop.PlatformChar) {
    guard platformString == 0 else {
      fatalError(
        "input of FilePath.Root.init?(platformString:) must be null-terminated"
      )
    }
    return nil
  }
  @available(*, deprecated, message: "Use FilePath.Root.init(_: String)")
  @inlinable @_alwaysEmitIntoClient public init?(platformString: Swift.String) {
    let string: String
    if let nullLoc = platformString.firstIndex(of: "\0") {
      string = String(platformString[..<nullLoc])
    } else {
      string = platformString
    }
    guard let root = FilePath.Root(string) else { return nil }
    self = root
  }
  public func withPlatformString<Result>(_ body: (Swift.UnsafePointer<System.CInterop.PlatformChar>) throws -> Result) rethrows -> Result
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FilePath : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral: Swift.String)
  public init(_ string: Swift.String)
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias StringLiteralType = Swift.String
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral: Swift.String)
  public init?(_ string: Swift.String)
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias StringLiteralType = Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Root : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral: Swift.String)
  public init?(_ string: Swift.String)
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias StringLiteralType = Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FilePath : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Root : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath {
  public var string: Swift.String {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component {
  public var string: Swift.String {
    get
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Root {
  public var string: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.String {
  public init(decoding path: System.FilePath)
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.String {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public init?(validating path: System.FilePath)
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.String {
  public init(decoding component: System.FilePath.Component)
  public init?(validating component: System.FilePath.Component)
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Swift.String {
  public init(decoding root: System.FilePath.Root)
  public init?(validating root: System.FilePath.Root)
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension Swift.String {
  @available(macOS, introduced: 11.0, deprecated: 12.0, renamed: "init(decoding:)")
  @available(iOS, introduced: 14.0, deprecated: 15.0, renamed: "init(decoding:)")
  @available(watchOS, introduced: 7.0, deprecated: 8.0, renamed: "init(decoding:)")
  @available(tvOS, introduced: 14.0, deprecated: 15.0, renamed: "init(decoding:)")
  @available(visionOS, unavailable, renamed: "init(decoding:)")
  @available(*, deprecated, renamed: "init(decoding:)")
  public init(_ path: System.FilePath)
  @available(macOS, introduced: 11.0, deprecated: 12.0, renamed: "init(validating:)")
  @available(iOS, introduced: 14.0, deprecated: 15.0, renamed: "init(validating:)")
  @available(watchOS, introduced: 7.0, deprecated: 8.0, renamed: "init(validating:)")
  @available(tvOS, introduced: 14.0, deprecated: 15.0, renamed: "init(validating:)")
  @available(visionOS, unavailable, renamed: "init(validating:)")
  @available(*, deprecated, renamed: "init(validating:)")
  public init?(validatingUTF8 path: System.FilePath)
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FilePath {
  @available(macOS, introduced: 11.0, deprecated: 12.0, renamed: "init(platformString:)")
  @available(iOS, introduced: 14.0, deprecated: 15.0, renamed: "init(platformString:)")
  @available(watchOS, introduced: 7.0, deprecated: 8.0, renamed: "init(platformString:)")
  @available(tvOS, introduced: 14.0, deprecated: 15.0, renamed: "init(platformString:)")
  @available(visionOS, unavailable, renamed: "init(platformString:)")
  @available(*, deprecated, renamed: "init(platformString:)")
  public init(cString: Swift.UnsafePointer<Swift.CChar>)
  @backDeployed(before: macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0)
  @available(*, deprecated, renamed: "init(platformString:)")
  @available(visionOS, unavailable, renamed: "init(platformString:)")
  public init(cString: [Swift.CChar]) {
    guard let _ = cString.firstIndex(of: 0) else {
      fatalError(
        "input of FilePath.init(platformString:) must be null-terminated"
      )
    }
    self = cString.withUnsafeBufferPointer {
      FilePath(cString: $0.baseAddress!)
    }
  }
  @backDeployed(before: macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0)
  @available(*, deprecated, renamed: "init(platformString:)")
  @available(visionOS, unavailable, renamed: "init(platformString:)")
  public init(cString: inout Swift.CChar) {
    guard cString == 0 else {
      fatalError(
        "input of FilePath.init(platformString:) must be null-terminated"
      )
    }
    self = FilePath()
  }
  @backDeployed(before: macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0)
  @available(*, deprecated, renamed: "init(platformString:)")
  @available(visionOS, unavailable, renamed: "init(platformString:)")
  public init(cString: Swift.String) {
    if let nullLoc = cString.firstIndex(of: "\0") {
      self = FilePath(String(cString.prefix(upTo: nullLoc)))
    } else {
      self = FilePath(cString)
    }
  }
  public func withCString<Result>(_ body: (Swift.UnsafePointer<Swift.CChar>) throws -> Result) rethrows -> Result
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
public struct FilePath : Swift.Sendable {
  public init()
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FilePath {
  public var length: Swift.Int {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FilePath : Swift.Hashable {
  public static func == (a: System.FilePath, b: System.FilePath) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FilePath : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor {
  @_alwaysEmitIntoClient public static func open(_ path: System.FilePath, _ mode: System.FileDescriptor.AccessMode, options: System.FileDescriptor.OpenOptions = FileDescriptor.OpenOptions(), permissions: System.FilePermissions? = nil, retryOnInterrupt: Swift.Bool = true) throws -> System.FileDescriptor {
    return try path.withCString {
      try FileDescriptor.open(
        $0, mode, options: options, permissions: permissions, retryOnInterrupt: retryOnInterrupt)
    }
  }
  @_alwaysEmitIntoClient public static func open(_ path: Swift.UnsafePointer<Swift.CChar>, _ mode: System.FileDescriptor.AccessMode, options: System.FileDescriptor.OpenOptions = FileDescriptor.OpenOptions(), permissions: System.FilePermissions? = nil, retryOnInterrupt: Swift.Bool = true) throws -> System.FileDescriptor {
    try FileDescriptor._open(
      path, mode, options: options, permissions: permissions, retryOnInterrupt: retryOnInterrupt
    ).get()
  }
  @usableFromInline
  internal static func _open(_ path: Swift.UnsafePointer<Swift.CChar>, _ mode: System.FileDescriptor.AccessMode, options: System.FileDescriptor.OpenOptions, permissions: System.FilePermissions?, retryOnInterrupt: Swift.Bool) -> Swift.Result<System.FileDescriptor, System.Errno>
  @_alwaysEmitIntoClient public func close() throws { try _close().get() }
  @usableFromInline
  internal func _close() -> Swift.Result<(), System.Errno>
  @discardableResult
  @_alwaysEmitIntoClient public func seek(offset: Swift.Int64, from whence: System.FileDescriptor.SeekOrigin) throws -> Swift.Int64 {
    try _seek(offset: offset, from: whence).get()
  }
  @usableFromInline
  internal func _seek(offset: Swift.Int64, from whence: System.FileDescriptor.SeekOrigin) -> Swift.Result<Swift.Int64, System.Errno>
  @available(*, unavailable, renamed: "seek")
  @_alwaysEmitIntoClient public func lseek(offset: Swift.Int64, from whence: System.FileDescriptor.SeekOrigin) throws -> Swift.Int64 {
    try seek(offset: offset, from: whence)
  }
  @_alwaysEmitIntoClient public func read(into buffer: Swift.UnsafeMutableRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try _read(into: buffer, retryOnInterrupt: retryOnInterrupt).get()
  }
  @usableFromInline
  internal func _read(into buffer: Swift.UnsafeMutableRawBufferPointer, retryOnInterrupt: Swift.Bool) throws -> Swift.Result<Swift.Int, System.Errno>
  @_alwaysEmitIntoClient public func read(fromAbsoluteOffset offset: Swift.Int64, into buffer: Swift.UnsafeMutableRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try _read(
      fromAbsoluteOffset: offset,
      into: buffer,
      retryOnInterrupt: retryOnInterrupt
    ).get()
  }
  @usableFromInline
  internal func _read(fromAbsoluteOffset offset: Swift.Int64, into buffer: Swift.UnsafeMutableRawBufferPointer, retryOnInterrupt: Swift.Bool) -> Swift.Result<Swift.Int, System.Errno>
  @available(*, unavailable, renamed: "read")
  @_alwaysEmitIntoClient public func pread(fromAbsoluteOffset offset: Swift.Int64, into buffer: Swift.UnsafeMutableRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try read(
      fromAbsoluteOffset: offset,
      into: buffer,
      retryOnInterrupt: retryOnInterrupt)
  }
  @_alwaysEmitIntoClient public func write(_ buffer: Swift.UnsafeRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try _write(buffer, retryOnInterrupt: retryOnInterrupt).get()
  }
  @usableFromInline
  internal func _write(_ buffer: Swift.UnsafeRawBufferPointer, retryOnInterrupt: Swift.Bool) -> Swift.Result<Swift.Int, System.Errno>
  @_alwaysEmitIntoClient public func write(toAbsoluteOffset offset: Swift.Int64, _ buffer: Swift.UnsafeRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try _write(toAbsoluteOffset: offset, buffer, retryOnInterrupt: retryOnInterrupt).get()
  }
  @usableFromInline
  internal func _write(toAbsoluteOffset offset: Swift.Int64, _ buffer: Swift.UnsafeRawBufferPointer, retryOnInterrupt: Swift.Bool) -> Swift.Result<Swift.Int, System.Errno>
  @available(*, unavailable, renamed: "write")
  @_alwaysEmitIntoClient public func pwrite(toAbsoluteOffset offset: Swift.Int64, into buffer: Swift.UnsafeRawBufferPointer, retryOnInterrupt: Swift.Bool = true) throws -> Swift.Int {
    try write(
      toAbsoluteOffset: offset,
      buffer,
      retryOnInterrupt: retryOnInterrupt)
  }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FileDescriptor {
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @_alwaysEmitIntoClient public func duplicate(as target: System.FileDescriptor? = nil, retryOnInterrupt: Swift.Bool = true) throws -> System.FileDescriptor {
    try _duplicate(as: target, retryOnInterrupt: retryOnInterrupt).get()
  }
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  @usableFromInline
  internal func _duplicate(as target: System.FileDescriptor?, retryOnInterrupt: Swift.Bool) throws -> Swift.Result<System.FileDescriptor, System.Errno>
  @available(*, unavailable, renamed: "duplicate")
  @_alwaysEmitIntoClient public func dup() throws -> System.FileDescriptor {
    fatalError("Not implemented")
  }
  @available(*, unavailable, renamed: "duplicate")
  @_alwaysEmitIntoClient public func dup2() throws -> System.FileDescriptor {
    fatalError("Not implemented")
  }
}
@available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
extension System.FileDescriptor {
  @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
  @_alwaysEmitIntoClient public static func pipe() throws -> (readEnd: System.FileDescriptor, writeEnd: System.FileDescriptor) {
    try _pipe().get()
  }
  @available(macOS 12.3, iOS 15.4, watchOS 8.5, tvOS 15.4, *)
  @usableFromInline
  internal static func _pipe() -> Swift.Result<(readEnd: System.FileDescriptor, writeEnd: System.FileDescriptor), System.Errno>
}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension System.FileDescriptor {
  @available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
  @_alwaysEmitIntoClient public func resize(to newSize: Swift.Int64, retryOnInterrupt: Swift.Bool = true) throws {
    try _resize(
      to: newSize,
      retryOnInterrupt: retryOnInterrupt
    ).get()
  }
  @available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
  @usableFromInline
  internal func _resize(to newSize: Swift.Int64, retryOnInterrupt: Swift.Bool) -> Swift.Result<(), System.Errno>
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@frozen public struct Errno : Swift.RawRepresentable, Swift.Error, Swift.Hashable, Swift.Codable {
  @_alwaysEmitIntoClient public let rawValue: Swift.CInt
  @_alwaysEmitIntoClient public init(rawValue: Swift.CInt) { self.rawValue = rawValue }
  @_alwaysEmitIntoClient public static var notUsed: System.Errno {
    get { .init(rawValue: _ERRNO_NOT_USED) }
  }
  @available(*, unavailable, renamed: "notUsed")
  @_alwaysEmitIntoClient public static var ERRNO_NOT_USED: System.Errno {
    get { notUsed }
  }
  @_alwaysEmitIntoClient public static var notPermitted: System.Errno {
    get { .init(rawValue: _EPERM) }
  }
  @available(*, unavailable, renamed: "notPermitted")
  @_alwaysEmitIntoClient public static var EPERM: System.Errno {
    get { notPermitted }
  }
  @_alwaysEmitIntoClient public static var noSuchFileOrDirectory: System.Errno {
    get { .init(rawValue: _ENOENT) }
  }
  @available(*, unavailable, renamed: "noSuchFileOrDirectory")
  @_alwaysEmitIntoClient public static var ENOENT: System.Errno {
    get { noSuchFileOrDirectory }
  }
  @_alwaysEmitIntoClient public static var noSuchProcess: System.Errno {
    get { .init(rawValue: _ESRCH) }
  }
  @available(*, unavailable, renamed: "noSuchProcess")
  @_alwaysEmitIntoClient public static var ESRCH: System.Errno {
    get { noSuchProcess }
  }
  @_alwaysEmitIntoClient public static var interrupted: System.Errno {
    get { .init(rawValue: _EINTR) }
  }
  @available(*, unavailable, renamed: "interrupted")
  @_alwaysEmitIntoClient public static var EINTR: System.Errno {
    get { interrupted }
  }
  @_alwaysEmitIntoClient public static var ioError: System.Errno {
    get { .init(rawValue: _EIO) }
  }
  @available(*, unavailable, renamed: "ioError")
  @_alwaysEmitIntoClient public static var EIO: System.Errno {
    get { ioError }
  }
  @_alwaysEmitIntoClient public static var noSuchAddressOrDevice: System.Errno {
    get { .init(rawValue: _ENXIO) }
  }
  @available(*, unavailable, renamed: "noSuchAddressOrDevice")
  @_alwaysEmitIntoClient public static var ENXIO: System.Errno {
    get { noSuchAddressOrDevice }
  }
  @_alwaysEmitIntoClient public static var argListTooLong: System.Errno {
    get { .init(rawValue: _E2BIG) }
  }
  @available(*, unavailable, renamed: "argListTooLong")
  @_alwaysEmitIntoClient public static var E2BIG: System.Errno {
    get { argListTooLong }
  }
  @_alwaysEmitIntoClient public static var execFormatError: System.Errno {
    get { .init(rawValue: _ENOEXEC) }
  }
  @available(*, unavailable, renamed: "execFormatError")
  @_alwaysEmitIntoClient public static var ENOEXEC: System.Errno {
    get { execFormatError }
  }
  @_alwaysEmitIntoClient public static var badFileDescriptor: System.Errno {
    get { .init(rawValue: _EBADF) }
  }
  @available(*, unavailable, renamed: "badFileDescriptor")
  @_alwaysEmitIntoClient public static var EBADF: System.Errno {
    get { badFileDescriptor }
  }
  @_alwaysEmitIntoClient public static var noChildProcess: System.Errno {
    get { .init(rawValue: _ECHILD) }
  }
  @available(*, unavailable, renamed: "noChildProcess")
  @_alwaysEmitIntoClient public static var ECHILD: System.Errno {
    get { noChildProcess }
  }
  @_alwaysEmitIntoClient public static var deadlock: System.Errno {
    get { .init(rawValue: _EDEADLK) }
  }
  @available(*, unavailable, renamed: "deadlock")
  @_alwaysEmitIntoClient public static var EDEADLK: System.Errno {
    get { deadlock }
  }
  @_alwaysEmitIntoClient public static var noMemory: System.Errno {
    get { .init(rawValue: _ENOMEM) }
  }
  @available(*, unavailable, renamed: "noMemory")
  @_alwaysEmitIntoClient public static var ENOMEM: System.Errno {
    get { noMemory }
  }
  @_alwaysEmitIntoClient public static var permissionDenied: System.Errno {
    get { .init(rawValue: _EACCES) }
  }
  @available(*, unavailable, renamed: "permissionDenied")
  @_alwaysEmitIntoClient public static var EACCES: System.Errno {
    get { permissionDenied }
  }
  @_alwaysEmitIntoClient public static var badAddress: System.Errno {
    get { .init(rawValue: _EFAULT) }
  }
  @available(*, unavailable, renamed: "badAddress")
  @_alwaysEmitIntoClient public static var EFAULT: System.Errno {
    get { badAddress }
  }
  @_alwaysEmitIntoClient public static var notBlockDevice: System.Errno {
    get { .init(rawValue: _ENOTBLK) }
  }
  @available(*, unavailable, renamed: "notBlockDevice")
  @_alwaysEmitIntoClient public static var ENOTBLK: System.Errno {
    get { notBlockDevice }
  }
  @_alwaysEmitIntoClient public static var resourceBusy: System.Errno {
    get { .init(rawValue: _EBUSY) }
  }
  @available(*, unavailable, renamed: "resourceBusy")
  @_alwaysEmitIntoClient public static var EBUSY: System.Errno {
    get { resourceBusy }
  }
  @_alwaysEmitIntoClient public static var fileExists: System.Errno {
    get { .init(rawValue: _EEXIST) }
  }
  @available(*, unavailable, renamed: "fileExists")
  @_alwaysEmitIntoClient public static var EEXIST: System.Errno {
    get { fileExists }
  }
  @_alwaysEmitIntoClient public static var improperLink: System.Errno {
    get { .init(rawValue: _EXDEV) }
  }
  @available(*, unavailable, renamed: "improperLink")
  @_alwaysEmitIntoClient public static var EXDEV: System.Errno {
    get { improperLink }
  }
  @_alwaysEmitIntoClient public static var operationNotSupportedByDevice: System.Errno {
    get { .init(rawValue: _ENODEV) }
  }
  @available(*, unavailable, renamed: "operationNotSupportedByDevice")
  @_alwaysEmitIntoClient public static var ENODEV: System.Errno {
    get { operationNotSupportedByDevice }
  }
  @_alwaysEmitIntoClient public static var notDirectory: System.Errno {
    get { .init(rawValue: _ENOTDIR) }
  }
  @available(*, unavailable, renamed: "notDirectory")
  @_alwaysEmitIntoClient public static var ENOTDIR: System.Errno {
    get { notDirectory }
  }
  @_alwaysEmitIntoClient public static var isDirectory: System.Errno {
    get { .init(rawValue: _EISDIR) }
  }
  @available(*, unavailable, renamed: "isDirectory")
  @_alwaysEmitIntoClient public static var EISDIR: System.Errno {
    get { isDirectory }
  }
  @_alwaysEmitIntoClient public static var invalidArgument: System.Errno {
    get { .init(rawValue: _EINVAL) }
  }
  @available(*, unavailable, renamed: "invalidArgument")
  @_alwaysEmitIntoClient public static var EINVAL: System.Errno {
    get { invalidArgument }
  }
  @_alwaysEmitIntoClient public static var tooManyOpenFilesInSystem: System.Errno {
    get { .init(rawValue: _ENFILE) }
  }
  @available(*, unavailable, renamed: "tooManyOpenFilesInSystem")
  @_alwaysEmitIntoClient public static var ENFILE: System.Errno {
    get { tooManyOpenFilesInSystem }
  }
  @_alwaysEmitIntoClient public static var tooManyOpenFiles: System.Errno {
    get { .init(rawValue: _EMFILE) }
  }
  @available(*, unavailable, renamed: "tooManyOpenFiles")
  @_alwaysEmitIntoClient public static var EMFILE: System.Errno {
    get { tooManyOpenFiles }
  }
  @_alwaysEmitIntoClient public static var inappropriateIOCTLForDevice: System.Errno {
    get { .init(rawValue: _ENOTTY) }
  }
  @available(*, unavailable, renamed: "inappropriateIOCTLForDevice")
  @_alwaysEmitIntoClient public static var ENOTTY: System.Errno {
    get { inappropriateIOCTLForDevice }
  }
  @_alwaysEmitIntoClient public static var textFileBusy: System.Errno {
    get { .init(rawValue: _ETXTBSY) }
  }
  @available(*, unavailable, renamed: "textFileBusy")
  @_alwaysEmitIntoClient public static var ETXTBSY: System.Errno {
    get { textFileBusy }
  }
  @_alwaysEmitIntoClient public static var fileTooLarge: System.Errno {
    get { .init(rawValue: _EFBIG) }
  }
  @available(*, unavailable, renamed: "fileTooLarge")
  @_alwaysEmitIntoClient public static var EFBIG: System.Errno {
    get { fileTooLarge }
  }
  @_alwaysEmitIntoClient public static var noSpace: System.Errno {
    get { .init(rawValue: _ENOSPC) }
  }
  @available(*, unavailable, renamed: "noSpace")
  @_alwaysEmitIntoClient public static var ENOSPC: System.Errno {
    get { noSpace }
  }
  @_alwaysEmitIntoClient public static var illegalSeek: System.Errno {
    get { .init(rawValue: _ESPIPE) }
  }
  @available(*, unavailable, renamed: "illegalSeek")
  @_alwaysEmitIntoClient public static var ESPIPE: System.Errno {
    get { illegalSeek }
  }
  @_alwaysEmitIntoClient public static var readOnlyFileSystem: System.Errno {
    get { .init(rawValue: _EROFS) }
  }
  @available(*, unavailable, renamed: "readOnlyFileSystem")
  @_alwaysEmitIntoClient public static var EROFS: System.Errno {
    get { readOnlyFileSystem }
  }
  @_alwaysEmitIntoClient public static var tooManyLinks: System.Errno {
    get { .init(rawValue: _EMLINK) }
  }
  @available(*, unavailable, renamed: "tooManyLinks")
  @_alwaysEmitIntoClient public static var EMLINK: System.Errno {
    get { tooManyLinks }
  }
  @_alwaysEmitIntoClient public static var brokenPipe: System.Errno {
    get { .init(rawValue: _EPIPE) }
  }
  @available(*, unavailable, renamed: "brokenPipe")
  @_alwaysEmitIntoClient public static var EPIPE: System.Errno {
    get { brokenPipe }
  }
  @_alwaysEmitIntoClient public static var outOfDomain: System.Errno {
    get { .init(rawValue: _EDOM) }
  }
  @available(*, unavailable, renamed: "outOfDomain")
  @_alwaysEmitIntoClient public static var EDOM: System.Errno {
    get { outOfDomain }
  }
  @_alwaysEmitIntoClient public static var outOfRange: System.Errno {
    get { .init(rawValue: _ERANGE) }
  }
  @available(*, unavailable, renamed: "outOfRange")
  @_alwaysEmitIntoClient public static var ERANGE: System.Errno {
    get { outOfRange }
  }
  @_alwaysEmitIntoClient public static var resourceTemporarilyUnavailable: System.Errno {
    get { .init(rawValue: _EAGAIN) }
  }
  @available(*, unavailable, renamed: "resourceTemporarilyUnavailable")
  @_alwaysEmitIntoClient public static var EAGAIN: System.Errno {
    get { resourceTemporarilyUnavailable }
  }
  @_alwaysEmitIntoClient public static var nowInProgress: System.Errno {
    get { .init(rawValue: _EINPROGRESS) }
  }
  @available(*, unavailable, renamed: "nowInProgress")
  @_alwaysEmitIntoClient public static var EINPROGRESS: System.Errno {
    get { nowInProgress }
  }
  @_alwaysEmitIntoClient public static var alreadyInProcess: System.Errno {
    get { .init(rawValue: _EALREADY) }
  }
  @available(*, unavailable, renamed: "alreadyInProcess")
  @_alwaysEmitIntoClient public static var EALREADY: System.Errno {
    get { alreadyInProcess }
  }
  @_alwaysEmitIntoClient public static var notSocket: System.Errno {
    get { .init(rawValue: _ENOTSOCK) }
  }
  @available(*, unavailable, renamed: "notSocket")
  @_alwaysEmitIntoClient public static var ENOTSOCK: System.Errno {
    get { notSocket }
  }
  @_alwaysEmitIntoClient public static var addressRequired: System.Errno {
    get { .init(rawValue: _EDESTADDRREQ) }
  }
  @available(*, unavailable, renamed: "addressRequired")
  @_alwaysEmitIntoClient public static var EDESTADDRREQ: System.Errno {
    get { addressRequired }
  }
  @_alwaysEmitIntoClient public static var messageTooLong: System.Errno {
    get { .init(rawValue: _EMSGSIZE) }
  }
  @available(*, unavailable, renamed: "messageTooLong")
  @_alwaysEmitIntoClient public static var EMSGSIZE: System.Errno {
    get { messageTooLong }
  }
  @_alwaysEmitIntoClient public static var protocolWrongTypeForSocket: System.Errno {
    get { .init(rawValue: _EPROTOTYPE) }
  }
  @available(*, unavailable, renamed: "protocolWrongTypeForSocket")
  @_alwaysEmitIntoClient public static var EPROTOTYPE: System.Errno {
    get { protocolWrongTypeForSocket }
  }
  @_alwaysEmitIntoClient public static var protocolNotAvailable: System.Errno {
    get { .init(rawValue: _ENOPROTOOPT) }
  }
  @available(*, unavailable, renamed: "protocolNotAvailable")
  @_alwaysEmitIntoClient public static var ENOPROTOOPT: System.Errno {
    get { protocolNotAvailable }
  }
  @_alwaysEmitIntoClient public static var protocolNotSupported: System.Errno {
    get { .init(rawValue: _EPROTONOSUPPORT) }
  }
  @available(*, unavailable, renamed: "protocolNotSupported")
  @_alwaysEmitIntoClient public static var EPROTONOSUPPORT: System.Errno {
    get { protocolNotSupported }
  }
  @_alwaysEmitIntoClient public static var socketTypeNotSupported: System.Errno {
    get { .init(rawValue: _ESOCKTNOSUPPORT) }
  }
  @available(*, unavailable, renamed: "socketTypeNotSupported")
  @_alwaysEmitIntoClient public static var ESOCKTNOSUPPORT: System.Errno {
    get { socketTypeNotSupported }
  }
  @_alwaysEmitIntoClient public static var notSupported: System.Errno {
    get { .init(rawValue: _ENOTSUP) }
  }
  @available(*, unavailable, renamed: "notSupported")
  @_alwaysEmitIntoClient public static var ENOTSUP: System.Errno {
    get { notSupported }
  }
  @_alwaysEmitIntoClient public static var protocolFamilyNotSupported: System.Errno {
    get { .init(rawValue: _EPFNOSUPPORT) }
  }
  @available(*, unavailable, renamed: "protocolFamilyNotSupported")
  @_alwaysEmitIntoClient public static var EPFNOSUPPORT: System.Errno {
    get { protocolFamilyNotSupported }
  }
  @_alwaysEmitIntoClient public static var addressFamilyNotSupported: System.Errno {
    get { .init(rawValue: _EAFNOSUPPORT) }
  }
  @available(*, unavailable, renamed: "addressFamilyNotSupported")
  @_alwaysEmitIntoClient public static var EAFNOSUPPORT: System.Errno {
    get { addressFamilyNotSupported }
  }
  @_alwaysEmitIntoClient public static var addressInUse: System.Errno {
    get { .init(rawValue: _EADDRINUSE) }
  }
  @available(*, unavailable, renamed: "addressInUse")
  @_alwaysEmitIntoClient public static var EADDRINUSE: System.Errno {
    get { addressInUse }
  }
  @_alwaysEmitIntoClient public static var addressNotAvailable: System.Errno {
    get { .init(rawValue: _EADDRNOTAVAIL) }
  }
  @available(*, unavailable, renamed: "addressNotAvailable")
  @_alwaysEmitIntoClient public static var EADDRNOTAVAIL: System.Errno {
    get { addressNotAvailable }
  }
  @_alwaysEmitIntoClient public static var networkDown: System.Errno {
    get { .init(rawValue: _ENETDOWN) }
  }
  @available(*, unavailable, renamed: "networkDown")
  @_alwaysEmitIntoClient public static var ENETDOWN: System.Errno {
    get { networkDown }
  }
  @_alwaysEmitIntoClient public static var networkUnreachable: System.Errno {
    get { .init(rawValue: _ENETUNREACH) }
  }
  @available(*, unavailable, renamed: "networkUnreachable")
  @_alwaysEmitIntoClient public static var ENETUNREACH: System.Errno {
    get { networkUnreachable }
  }
  @_alwaysEmitIntoClient public static var networkReset: System.Errno {
    get { .init(rawValue: _ENETRESET) }
  }
  @available(*, unavailable, renamed: "networkReset")
  @_alwaysEmitIntoClient public static var ENETRESET: System.Errno {
    get { networkReset }
  }
  @_alwaysEmitIntoClient public static var connectionAbort: System.Errno {
    get { .init(rawValue: _ECONNABORTED) }
  }
  @available(*, unavailable, renamed: "connectionAbort")
  @_alwaysEmitIntoClient public static var ECONNABORTED: System.Errno {
    get { connectionAbort }
  }
  @_alwaysEmitIntoClient public static var connectionReset: System.Errno {
    get { .init(rawValue: _ECONNRESET) }
  }
  @available(*, unavailable, renamed: "connectionReset")
  @_alwaysEmitIntoClient public static var ECONNRESET: System.Errno {
    get { connectionReset }
  }
  @_alwaysEmitIntoClient public static var noBufferSpace: System.Errno {
    get { .init(rawValue: _ENOBUFS) }
  }
  @available(*, unavailable, renamed: "noBufferSpace")
  @_alwaysEmitIntoClient public static var ENOBUFS: System.Errno {
    get { noBufferSpace }
  }
  @_alwaysEmitIntoClient public static var socketIsConnected: System.Errno {
    get { .init(rawValue: _EISCONN) }
  }
  @available(*, unavailable, renamed: "socketIsConnected")
  @_alwaysEmitIntoClient public static var EISCONN: System.Errno {
    get { socketIsConnected }
  }
  @_alwaysEmitIntoClient public static var socketNotConnected: System.Errno {
    get { .init(rawValue: _ENOTCONN) }
  }
  @available(*, unavailable, renamed: "socketNotConnected")
  @_alwaysEmitIntoClient public static var ENOTCONN: System.Errno {
    get { socketNotConnected }
  }
  @_alwaysEmitIntoClient public static var socketShutdown: System.Errno {
    get { .init(rawValue: _ESHUTDOWN) }
  }
  @available(*, unavailable, renamed: "socketShutdown")
  @_alwaysEmitIntoClient public static var ESHUTDOWN: System.Errno {
    get { socketShutdown }
  }
  @_alwaysEmitIntoClient public static var timedOut: System.Errno {
    get { .init(rawValue: _ETIMEDOUT) }
  }
  @available(*, unavailable, renamed: "timedOut")
  @_alwaysEmitIntoClient public static var ETIMEDOUT: System.Errno {
    get { timedOut }
  }
  @_alwaysEmitIntoClient public static var connectionRefused: System.Errno {
    get { .init(rawValue: _ECONNREFUSED) }
  }
  @available(*, unavailable, renamed: "connectionRefused")
  @_alwaysEmitIntoClient public static var ECONNREFUSED: System.Errno {
    get { connectionRefused }
  }
  @_alwaysEmitIntoClient public static var tooManySymbolicLinkLevels: System.Errno {
    get { .init(rawValue: _ELOOP) }
  }
  @available(*, unavailable, renamed: "tooManySymbolicLinkLevels")
  @_alwaysEmitIntoClient public static var ELOOP: System.Errno {
    get { tooManySymbolicLinkLevels }
  }
  @_alwaysEmitIntoClient public static var fileNameTooLong: System.Errno {
    get { .init(rawValue: _ENAMETOOLONG) }
  }
  @available(*, unavailable, renamed: "fileNameTooLong")
  @_alwaysEmitIntoClient public static var ENAMETOOLONG: System.Errno {
    get { fileNameTooLong }
  }
  @_alwaysEmitIntoClient public static var hostIsDown: System.Errno {
    get { .init(rawValue: _EHOSTDOWN) }
  }
  @available(*, unavailable, renamed: "hostIsDown")
  @_alwaysEmitIntoClient public static var EHOSTDOWN: System.Errno {
    get { hostIsDown }
  }
  @_alwaysEmitIntoClient public static var noRouteToHost: System.Errno {
    get { .init(rawValue: _EHOSTUNREACH) }
  }
  @available(*, unavailable, renamed: "noRouteToHost")
  @_alwaysEmitIntoClient public static var EHOSTUNREACH: System.Errno {
    get { noRouteToHost }
  }
  @_alwaysEmitIntoClient public static var directoryNotEmpty: System.Errno {
    get { .init(rawValue: _ENOTEMPTY) }
  }
  @available(*, unavailable, renamed: "directoryNotEmpty")
  @_alwaysEmitIntoClient public static var ENOTEMPTY: System.Errno {
    get { directoryNotEmpty }
  }
  @_alwaysEmitIntoClient public static var tooManyProcesses: System.Errno {
    get { .init(rawValue: _EPROCLIM) }
  }
  @available(*, unavailable, renamed: "tooManyProcesses")
  @_alwaysEmitIntoClient public static var EPROCLIM: System.Errno {
    get { tooManyProcesses }
  }
  @_alwaysEmitIntoClient public static var tooManyUsers: System.Errno {
    get { .init(rawValue: _EUSERS) }
  }
  @available(*, unavailable, renamed: "tooManyUsers")
  @_alwaysEmitIntoClient public static var EUSERS: System.Errno {
    get { tooManyUsers }
  }
  @_alwaysEmitIntoClient public static var diskQuotaExceeded: System.Errno {
    get { .init(rawValue: _EDQUOT) }
  }
  @available(*, unavailable, renamed: "diskQuotaExceeded")
  @_alwaysEmitIntoClient public static var EDQUOT: System.Errno {
    get { diskQuotaExceeded }
  }
  @_alwaysEmitIntoClient public static var staleNFSFileHandle: System.Errno {
    get { .init(rawValue: _ESTALE) }
  }
  @available(*, unavailable, renamed: "staleNFSFileHandle")
  @_alwaysEmitIntoClient public static var ESTALE: System.Errno {
    get { staleNFSFileHandle }
  }
  @_alwaysEmitIntoClient public static var rpcUnsuccessful: System.Errno {
    get { .init(rawValue: _EBADRPC) }
  }
  @available(*, unavailable, renamed: "rpcUnsuccessful")
  @_alwaysEmitIntoClient public static var EBADRPC: System.Errno {
    get { rpcUnsuccessful }
  }
  @_alwaysEmitIntoClient public static var rpcVersionMismatch: System.Errno {
    get { .init(rawValue: _ERPCMISMATCH) }
  }
  @available(*, unavailable, renamed: "rpcVersionMismatch")
  @_alwaysEmitIntoClient public static var ERPCMISMATCH: System.Errno {
    get { rpcVersionMismatch }
  }
  @_alwaysEmitIntoClient public static var rpcProgramUnavailable: System.Errno {
    get { .init(rawValue: _EPROGUNAVAIL) }
  }
  @available(*, unavailable, renamed: "rpcProgramUnavailable")
  @_alwaysEmitIntoClient public static var EPROGUNAVAIL: System.Errno {
    get { rpcProgramUnavailable }
  }
  @_alwaysEmitIntoClient public static var rpcProgramVersionMismatch: System.Errno {
    get { .init(rawValue: _EPROGMISMATCH) }
  }
  @available(*, unavailable, renamed: "rpcProgramVersionMismatch")
  @_alwaysEmitIntoClient public static var EPROGMISMATCH: System.Errno {
    get { rpcProgramVersionMismatch }
  }
  @_alwaysEmitIntoClient public static var rpcProcedureUnavailable: System.Errno {
    get { .init(rawValue: _EPROCUNAVAIL) }
  }
  @available(*, unavailable, renamed: "rpcProcedureUnavailable")
  @_alwaysEmitIntoClient public static var EPROCUNAVAIL: System.Errno {
    get { rpcProcedureUnavailable }
  }
  @_alwaysEmitIntoClient public static var noLocks: System.Errno {
    get { .init(rawValue: _ENOLCK) }
  }
  @available(*, unavailable, renamed: "noLocks")
  @_alwaysEmitIntoClient public static var ENOLCK: System.Errno {
    get { noLocks }
  }
  @_alwaysEmitIntoClient public static var noFunction: System.Errno {
    get { .init(rawValue: _ENOSYS) }
  }
  @available(*, unavailable, renamed: "noFunction")
  @_alwaysEmitIntoClient public static var ENOSYS: System.Errno {
    get { noFunction }
  }
  @_alwaysEmitIntoClient public static var badFileTypeOrFormat: System.Errno {
    get { .init(rawValue: _EFTYPE) }
  }
  @available(*, unavailable, renamed: "badFileTypeOrFormat")
  @_alwaysEmitIntoClient public static var EFTYPE: System.Errno {
    get { badFileTypeOrFormat }
  }
  @_alwaysEmitIntoClient public static var authenticationError: System.Errno {
    get { .init(rawValue: _EAUTH) }
  }
  @available(*, unavailable, renamed: "authenticationError")
  @_alwaysEmitIntoClient public static var EAUTH: System.Errno {
    get { authenticationError }
  }
  @_alwaysEmitIntoClient public static var needAuthenticator: System.Errno {
    get { .init(rawValue: _ENEEDAUTH) }
  }
  @available(*, unavailable, renamed: "needAuthenticator")
  @_alwaysEmitIntoClient public static var ENEEDAUTH: System.Errno {
    get { needAuthenticator }
  }
  @_alwaysEmitIntoClient public static var devicePowerIsOff: System.Errno {
    get { .init(rawValue: _EPWROFF) }
  }
  @available(*, unavailable, renamed: "devicePowerIsOff")
  @_alwaysEmitIntoClient public static var EPWROFF: System.Errno {
    get { devicePowerIsOff }
  }
  @_alwaysEmitIntoClient public static var deviceError: System.Errno {
    get { .init(rawValue: _EDEVERR) }
  }
  @available(*, unavailable, renamed: "deviceError")
  @_alwaysEmitIntoClient public static var EDEVERR: System.Errno {
    get { deviceError }
  }
  @_alwaysEmitIntoClient public static var overflow: System.Errno {
    get { .init(rawValue: _EOVERFLOW) }
  }
  @available(*, unavailable, renamed: "overflow")
  @_alwaysEmitIntoClient public static var EOVERFLOW: System.Errno {
    get { overflow }
  }
  @_alwaysEmitIntoClient public static var badExecutable: System.Errno {
    get { .init(rawValue: _EBADEXEC) }
  }
  @available(*, unavailable, renamed: "badExecutable")
  @_alwaysEmitIntoClient public static var EBADEXEC: System.Errno {
    get { badExecutable }
  }
  @_alwaysEmitIntoClient public static var badCPUType: System.Errno {
    get { .init(rawValue: _EBADARCH) }
  }
  @available(*, unavailable, renamed: "badCPUType")
  @_alwaysEmitIntoClient public static var EBADARCH: System.Errno {
    get { badCPUType }
  }
  @_alwaysEmitIntoClient public static var sharedLibraryVersionMismatch: System.Errno {
    get { .init(rawValue: _ESHLIBVERS) }
  }
  @available(*, unavailable, renamed: "sharedLibraryVersionMismatch")
  @_alwaysEmitIntoClient public static var ESHLIBVERS: System.Errno {
    get { sharedLibraryVersionMismatch }
  }
  @_alwaysEmitIntoClient public static var malformedMachO: System.Errno {
    get { .init(rawValue: _EBADMACHO) }
  }
  @available(*, unavailable, renamed: "malformedMachO")
  @_alwaysEmitIntoClient public static var EBADMACHO: System.Errno {
    get { malformedMachO }
  }
  @_alwaysEmitIntoClient public static var canceled: System.Errno {
    get { .init(rawValue: _ECANCELED) }
  }
  @available(*, unavailable, renamed: "canceled")
  @_alwaysEmitIntoClient public static var ECANCELED: System.Errno {
    get { canceled }
  }
  @_alwaysEmitIntoClient public static var identifierRemoved: System.Errno {
    get { .init(rawValue: _EIDRM) }
  }
  @available(*, unavailable, renamed: "identifierRemoved")
  @_alwaysEmitIntoClient public static var EIDRM: System.Errno {
    get { identifierRemoved }
  }
  @_alwaysEmitIntoClient public static var noMessage: System.Errno {
    get { .init(rawValue: _ENOMSG) }
  }
  @available(*, unavailable, renamed: "noMessage")
  @_alwaysEmitIntoClient public static var ENOMSG: System.Errno {
    get { noMessage }
  }
  @_alwaysEmitIntoClient public static var illegalByteSequence: System.Errno {
    get { .init(rawValue: _EILSEQ) }
  }
  @available(*, unavailable, renamed: "illegalByteSequence")
  @_alwaysEmitIntoClient public static var EILSEQ: System.Errno {
    get { illegalByteSequence }
  }
  @_alwaysEmitIntoClient public static var attributeNotFound: System.Errno {
    get { .init(rawValue: _ENOATTR) }
  }
  @available(*, unavailable, renamed: "attributeNotFound")
  @_alwaysEmitIntoClient public static var ENOATTR: System.Errno {
    get { attributeNotFound }
  }
  @_alwaysEmitIntoClient public static var badMessage: System.Errno {
    get { .init(rawValue: _EBADMSG) }
  }
  @available(*, unavailable, renamed: "badMessage")
  @_alwaysEmitIntoClient public static var EBADMSG: System.Errno {
    get { badMessage }
  }
  @_alwaysEmitIntoClient public static var multiHop: System.Errno {
    get { .init(rawValue: _EMULTIHOP) }
  }
  @available(*, unavailable, renamed: "multiHop")
  @_alwaysEmitIntoClient public static var EMULTIHOP: System.Errno {
    get { multiHop }
  }
  @_alwaysEmitIntoClient public static var noData: System.Errno {
    get { .init(rawValue: _ENODATA) }
  }
  @available(*, unavailable, renamed: "noData")
  @_alwaysEmitIntoClient public static var ENODATA: System.Errno {
    get { noData }
  }
  @_alwaysEmitIntoClient public static var noLink: System.Errno {
    get { .init(rawValue: _ENOLINK) }
  }
  @available(*, unavailable, renamed: "noLink")
  @_alwaysEmitIntoClient public static var ENOLINK: System.Errno {
    get { noLink }
  }
  @_alwaysEmitIntoClient public static var noStreamResources: System.Errno {
    get { .init(rawValue: _ENOSR) }
  }
  @available(*, unavailable, renamed: "noStreamResources")
  @_alwaysEmitIntoClient public static var ENOSR: System.Errno {
    get { noStreamResources }
  }
  @_alwaysEmitIntoClient public static var notStream: System.Errno {
    get { .init(rawValue: _ENOSTR) }
  }
  @available(*, unavailable, renamed: "notStream")
  @_alwaysEmitIntoClient public static var ENOSTR: System.Errno {
    get { notStream }
  }
  @_alwaysEmitIntoClient public static var protocolError: System.Errno {
    get { .init(rawValue: _EPROTO) }
  }
  @available(*, unavailable, renamed: "protocolError")
  @_alwaysEmitIntoClient public static var EPROTO: System.Errno {
    get { protocolError }
  }
  @_alwaysEmitIntoClient public static var timeout: System.Errno {
    get { .init(rawValue: _ETIME) }
  }
  @available(*, unavailable, renamed: "timeout")
  @_alwaysEmitIntoClient public static var ETIME: System.Errno {
    get { timeout }
  }
  @_alwaysEmitIntoClient public static var notSupportedOnSocket: System.Errno {
    get { .init(rawValue: _EOPNOTSUPP) }
  }
  @available(*, unavailable, renamed: "notSupportedOnSocket")
  @_alwaysEmitIntoClient public static var EOPNOTSUPP: System.Errno {
    get { notSupportedOnSocket }
  }
  @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
  public typealias RawValue = Swift.CInt
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.Errno {
  @_alwaysEmitIntoClient public static var wouldBlock: System.Errno {
    get { .init(rawValue: _EWOULDBLOCK) }
  }
  @available(*, unavailable, renamed: "wouldBlock")
  @_alwaysEmitIntoClient public static var EWOULDBLOCK: System.Errno {
    get { wouldBlock }
  }
  @_alwaysEmitIntoClient public static var tooManyReferences: System.Errno {
    get { .init(rawValue: _ETOOMANYREFS) }
  }
  @available(*, unavailable, renamed: "tooManyReferences")
  @_alwaysEmitIntoClient public static var ETOOMANYREFS: System.Errno {
    get { tooManyReferences }
  }
  @_alwaysEmitIntoClient public static var tooManyRemoteLevels: System.Errno {
    get { .init(rawValue: _EREMOTE) }
  }
  @available(*, unavailable, renamed: "tooManyRemoteLevels")
  @_alwaysEmitIntoClient public static var EREMOTE: System.Errno {
    get { tooManyRemoteLevels }
  }
  @_alwaysEmitIntoClient public static var noSuchPolicy: System.Errno {
    get { .init(rawValue: _ENOPOLICY) }
  }
  @available(*, unavailable, renamed: "noSuchPolicy")
  @_alwaysEmitIntoClient public static var ENOPOLICY: System.Errno {
    get { noSuchPolicy }
  }
  @_alwaysEmitIntoClient public static var notRecoverable: System.Errno {
    get { .init(rawValue: _ENOTRECOVERABLE) }
  }
  @available(*, unavailable, renamed: "notRecoverable")
  @_alwaysEmitIntoClient public static var ENOTRECOVERABLE: System.Errno {
    get { notRecoverable }
  }
  @_alwaysEmitIntoClient public static var previousOwnerDied: System.Errno {
    get { .init(rawValue: _EOWNERDEAD) }
  }
  @available(*, unavailable, renamed: "previousOwnerDied")
  @_alwaysEmitIntoClient public static var EOWNERDEAD: System.Errno {
    get { previousOwnerDied }
  }
  @_alwaysEmitIntoClient public static var outputQueueFull: System.Errno {
    get { .init(rawValue: _EQFULL) }
  }
  @available(*, unavailable, renamed: "outputQueueFull")
  @_alwaysEmitIntoClient public static var EQFULL: System.Errno {
    get { outputQueueFull }
  }
  @_alwaysEmitIntoClient public static var lastErrnoValue: System.Errno {
    get { .init(rawValue: _ELAST) }
  }
  @available(*, unavailable, renamed: "lastErrnoValue")
  @_alwaysEmitIntoClient public static var ELAST: System.Errno {
    get { lastErrnoValue }
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.Errno {
  public var _code: Swift.Int {
    get
  }
  public var _domain: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.Errno : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @inline(never) public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.Errno {
  @_alwaysEmitIntoClient public static func ~= (lhs: System.Errno, rhs: any Swift.Error) -> Swift.Bool {
    guard let value = rhs as? Errno else { return false }
    return lhs == value
  }
}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension System.Mach : Swift.Sendable {}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension System.Mach : Swift.BitwiseCopyable {}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension System.Mach.PortRightError : Swift.Equatable {}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension System.Mach.PortRightError : Swift.Hashable {}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension System.Mach.ReceiveRight : Swift.Sendable {}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension System.Mach.ReceiveRight : Swift.BitwiseCopyable {}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension System.Mach.SendRight : Swift.Sendable {}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension System.Mach.SendRight : Swift.BitwiseCopyable {}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension System.Mach.SendOnceRight : Swift.Sendable {}
@available(macOS 14.4, iOS 17.4, watchOS 10.4, tvOS 17.4, *)
extension System.Mach.SendOnceRight : Swift.BitwiseCopyable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor : Swift.Sendable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor : Swift.BitwiseCopyable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor.AccessMode : Swift.BitwiseCopyable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor.OpenOptions : Swift.BitwiseCopyable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FileDescriptor.SeekOrigin : Swift.BitwiseCopyable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component : Swift.Encodable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component : Swift.Decodable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Root : Swift.Encodable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Root : Swift.Decodable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Root : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component.Kind : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component.Kind : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.Component.Kind : Swift.BitwiseCopyable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.ComponentView : Swift.Encodable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.ComponentView : Swift.Decodable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension System.FilePath.ComponentView : Swift.Hashable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.FilePermissions : Swift.BitwiseCopyable {}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension System.Errno : Swift.BitwiseCopyable {}
