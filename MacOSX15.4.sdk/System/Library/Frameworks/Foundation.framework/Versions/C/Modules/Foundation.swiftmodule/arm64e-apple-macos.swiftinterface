// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1 effective-5.10 (swiftlang-6.1.0.110.5 clang-1700.0.13.3)
// swift-module-flags: -target arm64e-apple-macos15.4 -target-variant arm64e-apple-ios18.4-macabi -enable-objc-interop -autolink-force-load -enable-library-evolution -module-link-name swiftFoundation -swift-version 5 -enforce-exclusivity=unchecked -O -library-level api -enable-experimental-feature DebugDescriptionMacro -enable-upcoming-feature InferSendableFromCaptures -enable-bare-slash-regex -user-module-version 3423 -module-name Foundation -package-name "\"FoundationPreview\""
// swift-module-flags-ignorable:  -interface-compiler-version 6.1
import Combine
import CoreFoundation
import Darwin
import Dispatch
@_exported import Foundation
import ObjectiveC
@_exported import Observation
import Swift
import System
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import Darwin.sysdir
import Darwin.uuid
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol _KeyValueCodingAndObservingPublishing {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension ObjectiveC.NSObject : Foundation._KeyValueCodingAndObservingPublishing {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation._KeyValueCodingAndObservingPublishing where Self : ObjectiveC.NSObject {
  public func publisher<Value>(for keyPath: Swift.KeyPath<Self, Value>, options: Foundation.NSKeyValueObservingOptions = [.initial, .new]) -> ObjectiveC.NSObject.KeyValueObservingPublisher<Self, Value>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension ObjectiveC.NSObject.KeyValueObservingPublisher {
  public func didChange() -> Combine.Publishers.Map<ObjectiveC.NSObject.KeyValueObservingPublisher<Subject, Value>, Swift.Void>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension ObjectiveC.NSObject {
  public struct KeyValueObservingPublisher<Subject, Value> : Swift.Equatable where Subject : ObjectiveC.NSObject {
    public let object: Subject
    public let keyPath: Swift.KeyPath<Subject, Value>
    public let options: Foundation.NSKeyValueObservingOptions
    public init(object: Subject, keyPath: Swift.KeyPath<Subject, Value>, options: Foundation.NSKeyValueObservingOptions)
    public static func == (lhs: ObjectiveC.NSObject.KeyValueObservingPublisher<Subject, Value>, rhs: ObjectiveC.NSObject.KeyValueObservingPublisher<Subject, Value>) -> Swift.Bool
  }
}
@available(macOS, unavailable, introduced: 10.15)
@available(iOS, unavailable, introduced: 13.0)
@available(tvOS, unavailable, introduced: 13.0)
@available(watchOS, unavailable, introduced: 6.0)
@available(*, unavailable)
extension ObjectiveC.NSObject.KeyValueObservingPublisher : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension ObjectiveC.NSObject.KeyValueObservingPublisher : Combine.Publisher {
  public typealias Output = Value
  public typealias Failure = Swift.Never
  public func receive<S>(subscriber: S) where Value == S.Input, S : Combine.Subscriber, S.Failure == Swift.Never
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@_originallyDefinedIn(module: "_System_Foundation", macOS 15)
@_originallyDefinedIn(module: "_System_Foundation", iOS 18)
@_originallyDefinedIn(module: "_System_Foundation", tvOS 18)
@_originallyDefinedIn(module: "_System_Foundation", watchOS 11)
extension Foundation.URL {
  @available(macOS, introduced: 11.0, deprecated: 13.0, renamed: "init(filePath:)")
  @available(iOS, introduced: 14.0, deprecated: 16.0, renamed: "init(filePath:)")
  @available(watchOS, introduced: 7.0, deprecated: 9.0, renamed: "init(filePath:)")
  @available(tvOS, introduced: 14.0, deprecated: 16.0, renamed: "init(filePath:)")
  @available(visionOS, unavailable, renamed: "init(filePath:)")
  public init?(_ path: System.FilePath)
  @available(macOS, introduced: 11.0, deprecated: 13.0, message: "Use init?(filePath:directoryHint:) instead")
  @available(iOS, introduced: 14.0, deprecated: 16.0, message: "Use init?(filePath:directoryHint:) instead")
  @available(watchOS, introduced: 7.0, deprecated: 9.0, message: "Use init?(filePath:directoryHint:) instead")
  @available(tvOS, introduced: 14.0, deprecated: 16.0, message: "Use init?(filePath:directoryHint:) instead")
  @available(visionOS, unavailable, message: "Use init?(filePath:directoryHint:) instead")
  public init?(_ path: System.FilePath, isDirectory: Swift.Bool)
}
extension Foundation.URL {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient public init?(filePath path: System.FilePath, directoryHint: Foundation.URL.DirectoryHint = .inferFromPath) {
        guard let p = String(validating: path) else {
            return nil
        }
        self.init(filePath: p, directoryHint: directoryHint, relativeTo: nil)
    }
}
@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
@_originallyDefinedIn(module: "_System_Foundation", macOS 15)
@_originallyDefinedIn(module: "_System_Foundation", iOS 18)
@_originallyDefinedIn(module: "_System_Foundation", tvOS 18)
@_originallyDefinedIn(module: "_System_Foundation", watchOS 11)
extension System.FilePath {
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  public init?(_ url: Foundation.URL)
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public struct TermOfAddress : Swift.Sendable, Swift.Equatable, Swift.Hashable {
  public var language: Foundation.Locale.Language? {
    get
  }
  public var pronouns: [Foundation.Morphology.Pronoun] {
    get
  }
  public static let neutral: Foundation.TermOfAddress
  public static let feminine: Foundation.TermOfAddress
  public static let masculine: Foundation.TermOfAddress
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
  public static let currentUser: Foundation.TermOfAddress
  public static func localized(language: Foundation.Locale.Language, pronouns: [Foundation.Morphology.Pronoun]) -> Foundation.TermOfAddress
  public static func == (lhs: Foundation.TermOfAddress, rhs: Foundation.TermOfAddress) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.TermOfAddress : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.TermOfAddress : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.__NSTermOfAddress
  public static func _forceBridgeFromObjectiveC(_ termOfAddress: Foundation.__NSTermOfAddress, result: inout Foundation.TermOfAddress?)
  public static func _conditionallyBridgeFromObjectiveC(_ termOfAddress: Foundation.__NSTermOfAddress, result: inout Foundation.TermOfAddress?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ termOfAddress: Foundation.__NSTermOfAddress?) -> Foundation.TermOfAddress
  @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
  public typealias _ObjectiveCType = Foundation.__NSTermOfAddress
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Calendar {
  public var eraSymbols: [Swift.String] {
    get
  }
  public var longEraSymbols: [Swift.String] {
    get
  }
  public var monthSymbols: [Swift.String] {
    get
  }
  public var shortMonthSymbols: [Swift.String] {
    get
  }
  public var veryShortMonthSymbols: [Swift.String] {
    get
  }
  public var standaloneMonthSymbols: [Swift.String] {
    get
  }
  public var shortStandaloneMonthSymbols: [Swift.String] {
    get
  }
  public var veryShortStandaloneMonthSymbols: [Swift.String] {
    get
  }
  public var weekdaySymbols: [Swift.String] {
    get
  }
  public var shortWeekdaySymbols: [Swift.String] {
    get
  }
  public var veryShortWeekdaySymbols: [Swift.String] {
    get
  }
  public var standaloneWeekdaySymbols: [Swift.String] {
    get
  }
  public var shortStandaloneWeekdaySymbols: [Swift.String] {
    get
  }
  public var veryShortStandaloneWeekdaySymbols: [Swift.String] {
    get
  }
  public var quarterSymbols: [Swift.String] {
    get
  }
  public var shortQuarterSymbols: [Swift.String] {
    get
  }
  public var standaloneQuarterSymbols: [Swift.String] {
    get
  }
  public var shortStandaloneQuarterSymbols: [Swift.String] {
    get
  }
  public var amSymbol: Swift.String {
    get
  }
  public var pmSymbol: Swift.String {
    get
  }
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date {
  public struct AnchoredRelativeFormatStyle : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public typealias Presentation = Foundation.Date.RelativeFormatStyle.Presentation
    public typealias UnitsStyle = Foundation.Date.RelativeFormatStyle.UnitsStyle
    public typealias Field = Foundation.Date.RelativeFormatStyle.Field
    public var anchor: Foundation.Date
    public var presentation: Foundation.Date.AnchoredRelativeFormatStyle.Presentation {
      get
      set
    }
    public var unitsStyle: Foundation.Date.AnchoredRelativeFormatStyle.UnitsStyle {
      get
      set
    }
    public var capitalizationContext: Foundation.FormatStyleCapitalizationContext {
      get
      set
    }
    public var locale: Foundation.Locale {
      get
      set
    }
    public var calendar: Foundation.Calendar {
      get
      set
    }
    public var allowedFields: Swift.Set<Foundation.Date.AnchoredRelativeFormatStyle.Field> {
      get
      set
    }
    public init(anchor: Foundation.Date, presentation: Foundation.Date.AnchoredRelativeFormatStyle.Presentation = .numeric, unitsStyle: Foundation.Date.AnchoredRelativeFormatStyle.UnitsStyle = .wide, locale: Foundation.Locale = .autoupdatingCurrent, calendar: Foundation.Calendar = .autoupdatingCurrent, capitalizationContext: Foundation.FormatStyleCapitalizationContext = .unknown)
    public init(anchor: Foundation.Date, allowedFields: Swift.Set<Foundation.Date.AnchoredRelativeFormatStyle.Field>, presentation: Foundation.Date.AnchoredRelativeFormatStyle.Presentation = .numeric, unitsStyle: Foundation.Date.AnchoredRelativeFormatStyle.UnitsStyle = .wide, locale: Foundation.Locale = .autoupdatingCurrent, calendar: Foundation.Calendar = .autoupdatingCurrent, capitalizationContext: Foundation.FormatStyleCapitalizationContext = .unknown)
    public func format(_ input: Foundation.Date) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.AnchoredRelativeFormatStyle
    public static func == (a: Foundation.Date.AnchoredRelativeFormatStyle, b: Foundation.Date.AnchoredRelativeFormatStyle) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.AnchoredRelativeFormatStyle : Foundation.DiscreteFormatStyle {
  public func discreteInput(before input: Foundation.Date) -> Foundation.Date?
  public func discreteInput(after input: Foundation.Date) -> Foundation.Date?
  public func input(before input: Foundation.Date) -> Foundation.Date?
  public func input(after input: Foundation.Date) -> Foundation.Date?
  @available(iOS 18, tvOS 18, watchOS 11, macOS 15, *)
  public typealias FormatInput = Foundation.Date
  @available(iOS 18, tvOS 18, watchOS 11, macOS 15, *)
  public typealias FormatOutput = Swift.String
}
extension Foundation.Date {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct IntervalFormatStyle : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public typealias DateStyle = Foundation.Date.FormatStyle.DateStyle
    public typealias TimeStyle = Foundation.Date.FormatStyle.TimeStyle
    public var locale: Foundation.Locale
    public var timeZone: Foundation.TimeZone
    public var calendar: Foundation.Calendar
    public init(date: Foundation.Date.IntervalFormatStyle.DateStyle? = nil, time: Foundation.Date.IntervalFormatStyle.TimeStyle? = nil, locale: Foundation.Locale = .autoupdatingCurrent, calendar: Foundation.Calendar = .autoupdatingCurrent, timeZone: Foundation.TimeZone = .autoupdatingCurrent)
    public func format(_ v: Swift.Range<Foundation.Date>) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.IntervalFormatStyle
    public static func == (a: Foundation.Date.IntervalFormatStyle, b: Foundation.Date.IntervalFormatStyle) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.IntervalFormatStyle : Foundation.FormatStyle {
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Swift.Range<Foundation.Date>
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.IntervalFormatStyle {
  public typealias Symbol = Foundation.Date.FormatStyle.Symbol
  public func year() -> Foundation.Date.IntervalFormatStyle
  public func month(_ format: Foundation.Date.IntervalFormatStyle.Symbol.Month = .abbreviated) -> Foundation.Date.IntervalFormatStyle
  public func day() -> Foundation.Date.IntervalFormatStyle
  public func weekday(_ format: Foundation.Date.IntervalFormatStyle.Symbol.Weekday = .abbreviated) -> Foundation.Date.IntervalFormatStyle
  public func hour(_ format: Foundation.Date.IntervalFormatStyle.Symbol.Hour = .defaultDigits(amPM: .abbreviated)) -> Foundation.Date.IntervalFormatStyle
  public func minute() -> Foundation.Date.IntervalFormatStyle
  public func second() -> Foundation.Date.IntervalFormatStyle
  public func timeZone(_ format: Foundation.Date.IntervalFormatStyle.Symbol.TimeZone = .genericName(.short)) -> Foundation.Date.IntervalFormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.IntervalFormatStyle {
  public static var interval: Foundation.Date.IntervalFormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Range where Bound == Foundation.Date {
  public func formatted() -> Swift.String
  public func formatted(date: Foundation.Date.IntervalFormatStyle.DateStyle, time: Foundation.Date.IntervalFormatStyle.TimeStyle) -> Swift.String
  public func formatted<S>(_ style: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput == Swift.Range<Foundation.Date>
}
extension Foundation.Date {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct RelativeFormatStyle : Swift.Codable, Swift.Hashable, Swift.Sendable {
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public typealias Field = Foundation.Date.ComponentsFormatStyle.Field
    public struct UnitsStyle : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public static var wide: Foundation.Date.RelativeFormatStyle.UnitsStyle {
        get
      }
      public static var spellOut: Foundation.Date.RelativeFormatStyle.UnitsStyle {
        get
      }
      public static var abbreviated: Foundation.Date.RelativeFormatStyle.UnitsStyle {
        get
      }
      public static var narrow: Foundation.Date.RelativeFormatStyle.UnitsStyle {
        get
      }
      public static func == (a: Foundation.Date.RelativeFormatStyle.UnitsStyle, b: Foundation.Date.RelativeFormatStyle.UnitsStyle) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct Presentation : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public static var numeric: Foundation.Date.RelativeFormatStyle.Presentation {
        get
      }
      public static var named: Foundation.Date.RelativeFormatStyle.Presentation {
        get
      }
      public static func == (a: Foundation.Date.RelativeFormatStyle.Presentation, b: Foundation.Date.RelativeFormatStyle.Presentation) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public var presentation: Foundation.Date.RelativeFormatStyle.Presentation
    public var unitsStyle: Foundation.Date.RelativeFormatStyle.UnitsStyle
    public var capitalizationContext: Foundation.FormatStyleCapitalizationContext
    public var locale: Foundation.Locale
    public var calendar: Foundation.Calendar
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public var allowedFields: Swift.Set<Foundation.Date.RelativeFormatStyle.Field> {
      get
      set
    }
    public init(presentation: Foundation.Date.RelativeFormatStyle.Presentation = .numeric, unitsStyle: Foundation.Date.RelativeFormatStyle.UnitsStyle = .wide, locale: Foundation.Locale = .autoupdatingCurrent, calendar: Foundation.Calendar = .autoupdatingCurrent, capitalizationContext: Foundation.FormatStyleCapitalizationContext = .unknown)
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public init(allowedFields: Swift.Set<Foundation.Date.RelativeFormatStyle.Field>, presentation: Foundation.Date.RelativeFormatStyle.Presentation = .numeric, unitsStyle: Foundation.Date.RelativeFormatStyle.UnitsStyle = .wide, locale: Foundation.Locale = .autoupdatingCurrent, calendar: Foundation.Calendar = .autoupdatingCurrent, capitalizationContext: Foundation.FormatStyleCapitalizationContext = .unknown)
    public func format(_ destDate: Foundation.Date) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.RelativeFormatStyle
    public static func == (a: Foundation.Date.RelativeFormatStyle, b: Foundation.Date.RelativeFormatStyle) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.RelativeFormatStyle : Foundation.FormatStyle {
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Foundation.Date
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.RelativeFormatStyle {
  public static func relative(presentation: Foundation.Date.RelativeFormatStyle.Presentation, unitsStyle: Foundation.Date.RelativeFormatStyle.UnitsStyle = .wide) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public struct VerbatimFormatStyle : Swift.Sendable {
    public var timeZone: Foundation.TimeZone
    public var calendar: Foundation.Calendar
    public var locale: Foundation.Locale?
    public init(format: Foundation.Date.FormatString, locale: Foundation.Locale? = nil, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar)
    @available(macOS, introduced: 12, deprecated: 15, message: "Use attributedStyle instead")
    @available(iOS, introduced: 15, deprecated: 18, message: "Use attributedStyle instead")
    @available(tvOS, introduced: 15, deprecated: 18, message: "Use attributedStyle instead")
    @available(watchOS, introduced: 8, deprecated: 11, message: "Use attributedStyle instead")
    public var attributed: Foundation.Date.AttributedStyle {
      get
    }
    public func format(_ value: Foundation.Date) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.VerbatimFormatStyle
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.VerbatimFormatStyle : Foundation.FormatStyle {
  public static func == (a: Foundation.Date.VerbatimFormatStyle, b: Foundation.Date.VerbatimFormatStyle) -> Swift.Bool
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Foundation.Date
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.VerbatimFormatStyle {
  public static func verbatim(_ format: Foundation.Date.FormatString, locale: Foundation.Locale? = nil, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar) -> Foundation.Date.VerbatimFormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.VerbatimFormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Date.ParseStrategy {
    get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Strategy = Foundation.Date.ParseStrategy
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.VerbatimFormatStyle {
  @dynamicMemberLookup public struct Attributed : Foundation.FormatStyle, Swift.Sendable {
    public subscript<T>(dynamicMember key: Swift.KeyPath<Foundation.Date.VerbatimFormatStyle, T>) -> T {
      get
    }
    public subscript<T>(dynamicMember key: Swift.WritableKeyPath<Foundation.Date.VerbatimFormatStyle, T>) -> T {
      get
      set
    }
    public func format(_ value: Foundation.Date) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.VerbatimFormatStyle.Attributed
    public static func == (a: Foundation.Date.VerbatimFormatStyle.Attributed, b: Foundation.Date.VerbatimFormatStyle.Attributed) -> Swift.Bool
    @available(iOS 18, tvOS 18, watchOS 11, macOS 15, *)
    public typealias FormatInput = Foundation.Date
    @available(iOS 18, tvOS 18, watchOS 11, macOS 15, *)
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public var attributedStyle: Foundation.Date.VerbatimFormatStyle.Attributed {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Date.VerbatimFormatStyle : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Foundation.Date
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Foundation.Date)?
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.VerbatimFormatStyle : Foundation.DiscreteFormatStyle {
  public func discreteInput(before input: Foundation.Date) -> Foundation.Date?
  public func discreteInput(after input: Foundation.Date) -> Foundation.Date?
  public func input(before input: Foundation.Date) -> Foundation.Date?
  public func input(after input: Foundation.Date) -> Foundation.Date?
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.VerbatimFormatStyle.Attributed : Foundation.DiscreteFormatStyle {
  public func discreteInput(before input: Foundation.Date) -> Foundation.Date?
  public func discreteInput(after input: Foundation.Date) -> Foundation.Date?
  public func input(before input: Foundation.Date) -> Foundation.Date?
  public func input(after input: Foundation.Date) -> Foundation.Date?
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle {
  public struct Symbol : Swift.Hashable, Swift.Sendable {
    public struct Era : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Era, b: Foundation.Date.FormatStyle.Symbol.Era) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Year : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Year, b: Foundation.Date.FormatStyle.Symbol.Year) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct YearForWeekOfYear : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear, b: Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct CyclicYear : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.CyclicYear, b: Foundation.Date.FormatStyle.Symbol.CyclicYear) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Quarter : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Quarter, b: Foundation.Date.FormatStyle.Symbol.Quarter) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Month : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Month, b: Foundation.Date.FormatStyle.Symbol.Month) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Week : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Week, b: Foundation.Date.FormatStyle.Symbol.Week) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Day : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Day, b: Foundation.Date.FormatStyle.Symbol.Day) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct DayOfYear : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.DayOfYear, b: Foundation.Date.FormatStyle.Symbol.DayOfYear) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Weekday : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Weekday, b: Foundation.Date.FormatStyle.Symbol.Weekday) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct DayPeriod : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.DayPeriod, b: Foundation.Date.FormatStyle.Symbol.DayPeriod) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Hour : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Hour, b: Foundation.Date.FormatStyle.Symbol.Hour) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Minute : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Minute, b: Foundation.Date.FormatStyle.Symbol.Minute) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Second : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.Second, b: Foundation.Date.FormatStyle.Symbol.Second) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct SecondFraction : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.SecondFraction, b: Foundation.Date.FormatStyle.Symbol.SecondFraction) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct TimeZone : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.TimeZone, b: Foundation.Date.FormatStyle.Symbol.TimeZone) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct StandaloneQuarter : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter, b: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct StandaloneMonth : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.StandaloneMonth, b: Foundation.Date.FormatStyle.Symbol.StandaloneMonth) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct StandaloneWeekday : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday, b: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct VerbatimHour : Swift.Hashable, Swift.Sendable {
      public static func == (a: Foundation.Date.FormatStyle.Symbol.VerbatimHour, b: Foundation.Date.FormatStyle.Symbol.VerbatimHour) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public static func == (a: Foundation.Date.FormatStyle.Symbol, b: Foundation.Date.FormatStyle.Symbol) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Era {
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.Era {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.Era {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.Era {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Year {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Year {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Year {
    get
  }
  public static func padded(_ length: Swift.Int) -> Foundation.Date.FormatStyle.Symbol.Year
  public static func relatedGregorian(minimumLength: Swift.Int = 1) -> Foundation.Date.FormatStyle.Symbol.Year
  public static func extended(minimumLength: Swift.Int = 1) -> Foundation.Date.FormatStyle.Symbol.Year
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear {
    get
  }
  public static func padded(_ length: Swift.Int) -> Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.CyclicYear {
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.CyclicYear {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.CyclicYear {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.CyclicYear {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Quarter {
  public static var oneDigit: Foundation.Date.FormatStyle.Symbol.Quarter {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Quarter {
    get
  }
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.Quarter {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.Quarter {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.Quarter {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
  public static var oneDigit: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
    get
  }
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Month {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Month {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Month {
    get
  }
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.Month {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.Month {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.Month {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
    get
  }
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.StandaloneMonth {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Week {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Week {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Week {
    get
  }
  public static var weekOfMonth: Foundation.Date.FormatStyle.Symbol.Week {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Day {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Day {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Day {
    get
  }
  public static var ordinalOfDayInMonth: Foundation.Date.FormatStyle.Symbol.Day {
    get
  }
  public static func julianModified(minimumLength: Swift.Int = 1) -> Foundation.Date.FormatStyle.Symbol.Day
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.DayOfYear {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.DayOfYear {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.DayOfYear {
    get
  }
  public static var threeDigits: Foundation.Date.FormatStyle.Symbol.DayOfYear {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Weekday {
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
  public static var short: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
  public static var oneDigit: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Weekday {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
  public static var oneDigit: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
    get
  }
  public static var abbreviated: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
    get
  }
  public static var wide: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
    get
  }
  public static var narrow: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
    get
  }
  public static var short: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.DayPeriod {
  public enum Width : Swift.Sendable {
    case abbreviated
    case wide
    case narrow
    public static func == (a: Foundation.Date.FormatStyle.Symbol.DayPeriod.Width, b: Foundation.Date.FormatStyle.Symbol.DayPeriod.Width) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func standard(_ width: Foundation.Date.FormatStyle.Symbol.DayPeriod.Width) -> Foundation.Date.FormatStyle.Symbol.DayPeriod
  public static func with12s(_ width: Foundation.Date.FormatStyle.Symbol.DayPeriod.Width) -> Foundation.Date.FormatStyle.Symbol.DayPeriod
  public static func conversational(_ width: Foundation.Date.FormatStyle.Symbol.DayPeriod.Width) -> Foundation.Date.FormatStyle.Symbol.DayPeriod
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Hour {
  public struct AMPMStyle : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static let omitted: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle
    public static let narrow: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle
    public static let abbreviated: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle
    public static let wide: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle
    public static func == (a: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle, b: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public static func defaultDigits(amPM: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Foundation.Date.FormatStyle.Symbol.Hour
  public static func twoDigits(amPM: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Foundation.Date.FormatStyle.Symbol.Hour
  public static func conversationalDefaultDigits(amPM: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Foundation.Date.FormatStyle.Symbol.Hour
  public static func conversationalTwoDigits(amPM: Foundation.Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Foundation.Date.FormatStyle.Symbol.Hour
  @available(*, deprecated, renamed: "defaultDigits(amPM:)")
  public static var defaultDigitsNoAMPM: Foundation.Date.FormatStyle.Symbol.Hour {
    get
  }
  @available(*, deprecated, renamed: "twoDigits(amPM:)")
  public static var twoDigitsNoAMPM: Foundation.Date.FormatStyle.Symbol.Hour {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.VerbatimHour {
  public struct HourCycle : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static let zeroBased: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle
    public static let oneBased: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle
    public static func == (a: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle, b: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Clock : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static let twelveHour: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock
    public static let twentyFourHour: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock
    public static func == (a: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock, b: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public static func defaultDigits(clock: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock, hourCycle: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle) -> Foundation.Date.FormatStyle.Symbol.VerbatimHour
  public static func twoDigits(clock: Foundation.Date.FormatStyle.Symbol.VerbatimHour.Clock, hourCycle: Foundation.Date.FormatStyle.Symbol.VerbatimHour.HourCycle) -> Foundation.Date.FormatStyle.Symbol.VerbatimHour
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Minute {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Minute {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Minute {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.Second {
  public static var defaultDigits: Foundation.Date.FormatStyle.Symbol.Second {
    get
  }
  public static var twoDigits: Foundation.Date.FormatStyle.Symbol.Second {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.SecondFraction {
  public static func fractional(_ val: Swift.Int) -> Foundation.Date.FormatStyle.Symbol.SecondFraction
  public static func milliseconds(_ val: Swift.Int) -> Foundation.Date.FormatStyle.Symbol.SecondFraction
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.TimeZone {
  public enum Width : Swift.Sendable {
    case short
    case long
    public static func == (a: Foundation.Date.FormatStyle.Symbol.TimeZone.Width, b: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func specificName(_ width: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Foundation.Date.FormatStyle.Symbol.TimeZone
  public static func genericName(_ width: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Foundation.Date.FormatStyle.Symbol.TimeZone
  public static func iso8601(_ width: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Foundation.Date.FormatStyle.Symbol.TimeZone
  public static func localizedGMT(_ width: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Foundation.Date.FormatStyle.Symbol.TimeZone
  public static func identifier(_ width: Foundation.Date.FormatStyle.Symbol.TimeZone.Width) -> Foundation.Date.FormatStyle.Symbol.TimeZone
  public static var exemplarLocation: Foundation.Date.FormatStyle.Symbol.TimeZone {
    get
  }
  public static var genericLocation: Foundation.Date.FormatStyle.Symbol.TimeZone {
    get
  }
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Symbol.Era {
  public static let omitted: Foundation.Date.FormatStyle.Symbol.Era
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Symbol.Year {
  public static let omitted: Foundation.Date.FormatStyle.Symbol.Year
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear {
  public static let omitted: Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Symbol.CyclicYear {
  public static let omitted: Foundation.Date.FormatStyle.Symbol.CyclicYear
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Symbol.Quarter {
  public static let omitted: Foundation.Date.FormatStyle.Symbol.Quarter
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Symbol.Month {
  public static let omitted: Foundation.Date.FormatStyle.Symbol.Month
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Symbol.Week {
  public static let omitted: Foundation.Date.FormatStyle.Symbol.Week
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Symbol.Day {
  public static let omitted: Foundation.Date.FormatStyle.Symbol.Day
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Symbol.DayOfYear {
  public static let omitted: Foundation.Date.FormatStyle.Symbol.DayOfYear
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Symbol.Weekday {
  public static let omitted: Foundation.Date.FormatStyle.Symbol.Weekday
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Symbol.DayPeriod {
  public static let omitted: Foundation.Date.FormatStyle.Symbol.DayPeriod
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Symbol.Hour {
  public static let omitted: Foundation.Date.FormatStyle.Symbol.Hour
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Symbol.Minute {
  public static let omitted: Foundation.Date.FormatStyle.Symbol.Minute
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Symbol.Second {
  public static let omitted: Foundation.Date.FormatStyle.Symbol.Second
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Symbol.SecondFraction {
  public static let omitted: Foundation.Date.FormatStyle.Symbol.SecondFraction
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Symbol.TimeZone {
  public static let omitted: Foundation.Date.FormatStyle.Symbol.TimeZone
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public struct FormatString : Swift.Hashable, Swift.Sendable {
    public static func == (a: Foundation.Date.FormatString, b: Foundation.Date.FormatString) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatString : Swift.ExpressibleByStringInterpolation {
  public init(stringInterpolation: Foundation.Date.FormatString.StringInterpolation)
  public init(stringLiteral value: Swift.String)
  public struct StringInterpolation : Swift.StringInterpolationProtocol, Swift.Sendable {
    public typealias StringLiteralType = Swift.String
    public init(literalCapacity: Swift.Int, interpolationCount: Swift.Int)
    public mutating func appendLiteral(_ literal: Swift.String)
    public mutating func appendInterpolation(era: Foundation.Date.FormatStyle.Symbol.Era)
    public mutating func appendInterpolation(year: Foundation.Date.FormatStyle.Symbol.Year)
    public mutating func appendInterpolation(yearForWeekOfYear: Foundation.Date.FormatStyle.Symbol.YearForWeekOfYear)
    public mutating func appendInterpolation(cyclicYear: Foundation.Date.FormatStyle.Symbol.CyclicYear)
    public mutating func appendInterpolation(quarter: Foundation.Date.FormatStyle.Symbol.Quarter)
    public mutating func appendInterpolation(standaloneQuarter: Foundation.Date.FormatStyle.Symbol.StandaloneQuarter)
    public mutating func appendInterpolation(month: Foundation.Date.FormatStyle.Symbol.Month)
    public mutating func appendInterpolation(standaloneMonth: Foundation.Date.FormatStyle.Symbol.StandaloneMonth)
    public mutating func appendInterpolation(week: Foundation.Date.FormatStyle.Symbol.Week)
    public mutating func appendInterpolation(day: Foundation.Date.FormatStyle.Symbol.Day)
    public mutating func appendInterpolation(dayOfYear: Foundation.Date.FormatStyle.Symbol.DayOfYear)
    public mutating func appendInterpolation(weekday: Foundation.Date.FormatStyle.Symbol.Weekday)
    public mutating func appendInterpolation(standaloneWeekday: Foundation.Date.FormatStyle.Symbol.StandaloneWeekday)
    public mutating func appendInterpolation(dayPeriod: Foundation.Date.FormatStyle.Symbol.DayPeriod)
    public mutating func appendInterpolation(hour: Foundation.Date.FormatStyle.Symbol.VerbatimHour)
    public mutating func appendInterpolation(minute: Foundation.Date.FormatStyle.Symbol.Minute)
    public mutating func appendInterpolation(second: Foundation.Date.FormatStyle.Symbol.Second)
    public mutating func appendInterpolation(secondFraction: Foundation.Date.FormatStyle.Symbol.SecondFraction)
    public mutating func appendInterpolation(timeZone: Foundation.Date.FormatStyle.Symbol.TimeZone)
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias StringLiteralType = Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public func formatted(date: Foundation.Date.FormatStyle.DateStyle, time: Foundation.Date.FormatStyle.TimeStyle) -> Swift.String
  public func formatted() -> Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public struct FormatStyle : Swift.Sendable {
    public var locale: Foundation.Locale
    public var timeZone: Foundation.TimeZone
    public var calendar: Foundation.Calendar
    public var capitalizationContext: Foundation.FormatStyleCapitalizationContext
    @available(macOS, introduced: 12, deprecated: 15, message: "Use attributedStyle instead")
    @available(iOS, introduced: 15, deprecated: 18, message: "Use attributedStyle instead")
    @available(tvOS, introduced: 15, deprecated: 18, message: "Use attributedStyle instead")
    @available(watchOS, introduced: 8, deprecated: 11, message: "Use attributedStyle instead")
    public var attributed: Foundation.Date.AttributedStyle {
      get
    }
    public init(date: Foundation.Date.FormatStyle.DateStyle? = nil, time: Foundation.Date.FormatStyle.TimeStyle? = nil, locale: Foundation.Locale = .autoupdatingCurrent, calendar: Foundation.Calendar = .autoupdatingCurrent, timeZone: Foundation.TimeZone = .autoupdatingCurrent, capitalizationContext: Foundation.FormatStyleCapitalizationContext = .unknown)
  }
  @available(macOS, introduced: 12, deprecated: 15, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
  @available(iOS, introduced: 15, deprecated: 18, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
  @available(tvOS, introduced: 15, deprecated: 18, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
  @available(watchOS, introduced: 8, deprecated: 11, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
  public struct AttributedStyle : Swift.Sendable {
    public func format(_ value: Foundation.Date) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.AttributedStyle
  }
}
@available(macOS, introduced: 12, deprecated: 15, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
@available(iOS, introduced: 15, deprecated: 18, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
@available(tvOS, introduced: 15, deprecated: 18, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
@available(watchOS, introduced: 8, deprecated: 11, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
extension Foundation.Date.AttributedStyle : Foundation.FormatStyle {
  public static func == (a: Foundation.Date.AttributedStyle, b: Foundation.Date.AttributedStyle) -> Swift.Bool
  @available(iOS, introduced: 15, deprecated: 18, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
  @available(tvOS, introduced: 15, deprecated: 18, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
  @available(watchOS, introduced: 8, deprecated: 11, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
  @available(macOS, introduced: 12, deprecated: 15, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
  public typealias FormatInput = Foundation.Date
  @available(iOS, introduced: 15, deprecated: 18, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
  @available(tvOS, introduced: 15, deprecated: 18, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
  @available(watchOS, introduced: 8, deprecated: 11, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
  @available(macOS, introduced: 12, deprecated: 15, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
  public typealias FormatOutput = Foundation.AttributedString
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle {
  @dynamicMemberLookup public struct Attributed : Foundation.FormatStyle, Swift.Sendable {
    public subscript<T>(dynamicMember key: Swift.KeyPath<Foundation.Date.FormatStyle, T>) -> T {
      get
    }
    public subscript<T>(dynamicMember key: Swift.WritableKeyPath<Foundation.Date.FormatStyle, T>) -> T {
      get
      set
    }
    public func format(_ value: Foundation.Date) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.FormatStyle.Attributed
    public static func == (a: Foundation.Date.FormatStyle.Attributed, b: Foundation.Date.FormatStyle.Attributed) -> Swift.Bool
    @available(iOS 18, tvOS 18, watchOS 11, macOS 15, *)
    public typealias FormatInput = Foundation.Date
    @available(iOS 18, tvOS 18, watchOS 11, macOS 15, *)
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public var attributedStyle: Foundation.Date.FormatStyle.Attributed {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle {
  public func era(_ format: Foundation.Date.FormatStyle.Symbol.Era = .abbreviated) -> Foundation.Date.FormatStyle
  public func year(_ format: Foundation.Date.FormatStyle.Symbol.Year = .defaultDigits) -> Foundation.Date.FormatStyle
  public func quarter(_ format: Foundation.Date.FormatStyle.Symbol.Quarter = .abbreviated) -> Foundation.Date.FormatStyle
  public func month(_ format: Foundation.Date.FormatStyle.Symbol.Month = .abbreviated) -> Foundation.Date.FormatStyle
  public func week(_ format: Foundation.Date.FormatStyle.Symbol.Week = .defaultDigits) -> Foundation.Date.FormatStyle
  public func day(_ format: Foundation.Date.FormatStyle.Symbol.Day = .defaultDigits) -> Foundation.Date.FormatStyle
  public func dayOfYear(_ format: Foundation.Date.FormatStyle.Symbol.DayOfYear = .defaultDigits) -> Foundation.Date.FormatStyle
  public func weekday(_ format: Foundation.Date.FormatStyle.Symbol.Weekday = .abbreviated) -> Foundation.Date.FormatStyle
  public func hour(_ format: Foundation.Date.FormatStyle.Symbol.Hour = .defaultDigits(amPM: .abbreviated)) -> Foundation.Date.FormatStyle
  public func minute(_ format: Foundation.Date.FormatStyle.Symbol.Minute = .defaultDigits) -> Foundation.Date.FormatStyle
  public func second(_ format: Foundation.Date.FormatStyle.Symbol.Second = .defaultDigits) -> Foundation.Date.FormatStyle
  public func secondFraction(_ format: Foundation.Date.FormatStyle.Symbol.SecondFraction) -> Foundation.Date.FormatStyle
  public func timeZone(_ format: Foundation.Date.FormatStyle.Symbol.TimeZone = .specificName(.short)) -> Foundation.Date.FormatStyle
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Attributed {
  public func era(_ format: Foundation.Date.FormatStyle.Symbol.Era = .abbreviated) -> Foundation.Date.FormatStyle.Attributed
  public func year(_ format: Foundation.Date.FormatStyle.Symbol.Year = .defaultDigits) -> Foundation.Date.FormatStyle.Attributed
  public func quarter(_ format: Foundation.Date.FormatStyle.Symbol.Quarter = .abbreviated) -> Foundation.Date.FormatStyle.Attributed
  public func month(_ format: Foundation.Date.FormatStyle.Symbol.Month = .abbreviated) -> Foundation.Date.FormatStyle.Attributed
  public func week(_ format: Foundation.Date.FormatStyle.Symbol.Week = .defaultDigits) -> Foundation.Date.FormatStyle.Attributed
  public func day(_ format: Foundation.Date.FormatStyle.Symbol.Day = .defaultDigits) -> Foundation.Date.FormatStyle.Attributed
  public func dayOfYear(_ format: Foundation.Date.FormatStyle.Symbol.DayOfYear = .defaultDigits) -> Foundation.Date.FormatStyle.Attributed
  public func weekday(_ format: Foundation.Date.FormatStyle.Symbol.Weekday = .abbreviated) -> Foundation.Date.FormatStyle.Attributed
  public func hour(_ format: Foundation.Date.FormatStyle.Symbol.Hour = .defaultDigits(amPM: .abbreviated)) -> Foundation.Date.FormatStyle.Attributed
  public func minute(_ format: Foundation.Date.FormatStyle.Symbol.Minute = .defaultDigits) -> Foundation.Date.FormatStyle.Attributed
  public func second(_ format: Foundation.Date.FormatStyle.Symbol.Second = .defaultDigits) -> Foundation.Date.FormatStyle.Attributed
  public func secondFraction(_ format: Foundation.Date.FormatStyle.Symbol.SecondFraction) -> Foundation.Date.FormatStyle.Attributed
  public func timeZone(_ format: Foundation.Date.FormatStyle.Symbol.TimeZone = .specificName(.short)) -> Foundation.Date.FormatStyle.Attributed
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle : Foundation.FormatStyle {
  public func format(_ value: Foundation.Date) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.Date.FormatStyle
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Foundation.Date
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle : Foundation.ParseStrategy {
  public func parse(_ value: Swift.String) throws -> Foundation.Date
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias ParseInput = Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias ParseOutput = Foundation.Date
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle : Swift.Codable, Swift.Hashable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: Foundation.Date.FormatStyle, b: Foundation.Date.FormatStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle {
  public struct DateStyle : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static let omitted: Foundation.Date.FormatStyle.DateStyle
    public static let numeric: Foundation.Date.FormatStyle.DateStyle
    public static let abbreviated: Foundation.Date.FormatStyle.DateStyle
    public static let long: Foundation.Date.FormatStyle.DateStyle
    public static let complete: Foundation.Date.FormatStyle.DateStyle
    public static func == (a: Foundation.Date.FormatStyle.DateStyle, b: Foundation.Date.FormatStyle.DateStyle) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct TimeStyle : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static let omitted: Foundation.Date.FormatStyle.TimeStyle
    public static let shortened: Foundation.Date.FormatStyle.TimeStyle
    public static let standard: Foundation.Date.FormatStyle.TimeStyle
    public static let complete: Foundation.Date.FormatStyle.TimeStyle
    public static func == (a: Foundation.Date.FormatStyle.TimeStyle, b: Foundation.Date.FormatStyle.TimeStyle) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Date.FormatStyle {
    get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Strategy = Foundation.Date.FormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.FormatStyle {
  public static var dateTime: Foundation.Date.FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.Date.FormatStyle {
  public static var dateTime: Foundation.Date.FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseStrategy where Self == Foundation.Date.FormatStyle {
  @_disfavoredOverload public static var dateTime: Foundation.Date.FormatStyle {
    get
  }
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle : Foundation.DiscreteFormatStyle {
  public func discreteInput(before input: Foundation.Date) -> Foundation.Date?
  public func discreteInput(after input: Foundation.Date) -> Foundation.Date?
  public func input(before input: Foundation.Date) -> Foundation.Date?
  public func input(after input: Foundation.Date) -> Foundation.Date?
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.FormatStyle.Attributed : Foundation.DiscreteFormatStyle {
  public func discreteInput(before input: Foundation.Date) -> Foundation.Date?
  public func discreteInput(after input: Foundation.Date) -> Foundation.Date?
  public func input(before input: Foundation.Date) -> Foundation.Date?
  public func input(after input: Foundation.Date) -> Foundation.Date?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Date.FormatStyle : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Foundation.Date
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Foundation.Date)?
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public struct ParseStrategy : Swift.Hashable, Swift.Sendable {
    public var isLenient: Swift.Bool
    public var twoDigitStartDate: Foundation.Date
    public var locale: Foundation.Locale?
    public var timeZone: Foundation.TimeZone
    public var calendar: Foundation.Calendar
    public var format: Swift.String {
      get
    }
    public init(format: Foundation.Date.FormatString, locale: Foundation.Locale? = nil, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar = Calendar(identifier: .gregorian), isLenient: Swift.Bool = true, twoDigitStartDate: Foundation.Date = Date(timeIntervalSince1970: 0))
    public static func == (a: Foundation.Date.ParseStrategy, b: Foundation.Date.ParseStrategy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ParseStrategy : Foundation.ParseStrategy {
  public func parse(_ value: Swift.String) throws -> Foundation.Date
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias ParseInput = Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias ParseOutput = Foundation.Date
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseStrategy {
  public static func fixed(format: Foundation.Date.FormatString, timeZone: Foundation.TimeZone, locale: Foundation.Locale? = nil) -> Self where Self == Foundation.Date.ParseStrategy
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Date.ParseStrategy : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Foundation.Date
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Foundation.Date)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.Date.ParseStrategy {
  public typealias DateStyle = Foundation.Date.FormatStyle.DateStyle
  public typealias TimeStyle = Foundation.Date.FormatStyle.TimeStyle
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static func date(format: Foundation.Date.FormatString, locale: Foundation.Locale, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar? = nil, twoDigitStartDate: Foundation.Date = Date(timeIntervalSince1970: 0)) -> Self
  public static func dateTime(date: Foundation.Date.FormatStyle.DateStyle, time: Foundation.Date.FormatStyle.TimeStyle, locale: Foundation.Locale, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar? = nil) -> Foundation.Date.ParseStrategy
  public static func date(_ style: Foundation.Date.FormatStyle.DateStyle, locale: Foundation.Locale, timeZone: Foundation.TimeZone, calendar: Foundation.Calendar? = nil) -> Foundation.Date.ParseStrategy
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.BinaryFloatingPoint {
  public func formatted() -> Swift.String
  public func formatted<S>(_ format: S) -> S.FormatOutput where Self == S.FormatInput, S : Foundation.FormatStyle
  public func formatted<S>(_ format: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput : Swift.BinaryFloatingPoint
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.BinaryFloatingPoint {
  public init<S>(_ value: S.ParseInput, strategy: S) throws where S : Foundation.ParseStrategy, S.ParseOutput : Swift.BinaryFloatingPoint
  public init<S>(_ value: S.ParseInput, strategy: S) throws where Self == S.ParseOutput, S : Foundation.ParseStrategy
  public init(_ value: Swift.String, format: Foundation.FloatingPointFormatStyle<Self>, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.FloatingPointFormatStyle<Self>.Percent, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.FloatingPointFormatStyle<Self>.Currency, lenient: Swift.Bool = true) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.BinaryInteger {
  public func formatted() -> Swift.String
  public func formatted<S>(_ format: S) -> S.FormatOutput where Self == S.FormatInput, S : Foundation.FormatStyle
  public func formatted<S>(_ format: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput : Swift.BinaryInteger
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.BinaryInteger {
  public init<S>(_ value: S.ParseInput, strategy: S) throws where S : Foundation.ParseStrategy, S.ParseOutput : Swift.BinaryInteger
  public init<S>(_ value: S.ParseInput, strategy: S) throws where Self == S.ParseOutput, S : Foundation.ParseStrategy
  public init(_ value: Swift.String, format: Foundation.IntegerFormatStyle<Self>, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.IntegerFormatStyle<Self>.Percent, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.IntegerFormatStyle<Self>.Currency, lenient: Swift.Bool = true) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal {
  public struct FormatStyle : Swift.Sendable {
    public var locale: Foundation.Locale
    public init(locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.Decimal.FormatStyle.Attributed {
      get
    }
    public typealias Configuration = Foundation.NumberFormatStyleConfiguration
    public func grouping(_ group: Foundation.Decimal.FormatStyle.Configuration.Grouping) -> Foundation.Decimal.FormatStyle
    public func precision(_ p: Foundation.Decimal.FormatStyle.Configuration.Precision) -> Foundation.Decimal.FormatStyle
    public func sign(strategy: Foundation.Decimal.FormatStyle.Configuration.SignDisplayStrategy) -> Foundation.Decimal.FormatStyle
    public func decimalSeparator(strategy: Foundation.Decimal.FormatStyle.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.Decimal.FormatStyle
    public func rounded(rule: Foundation.Decimal.FormatStyle.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.Decimal.FormatStyle
    public func scale(_ multiplicand: Swift.Double) -> Foundation.Decimal.FormatStyle
    public func notation(_ notation: Foundation.Decimal.FormatStyle.Configuration.Notation) -> Foundation.Decimal.FormatStyle
    public func format(_ value: Foundation.Decimal) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Decimal.FormatStyle
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.FormatStyle : Foundation.FormatStyle {
  public static func == (a: Foundation.Decimal.FormatStyle, b: Foundation.Decimal.FormatStyle) -> Swift.Bool
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Foundation.Decimal
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.FormatStyle {
  public struct Percent : Swift.Sendable {
    public typealias Configuration = Foundation.NumberFormatStyleConfiguration
    public var locale: Foundation.Locale
    public init(locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.Decimal.FormatStyle.Attributed {
      get
    }
    public func grouping(_ group: Foundation.Decimal.FormatStyle.Percent.Configuration.Grouping) -> Foundation.Decimal.FormatStyle.Percent
    public func precision(_ p: Foundation.Decimal.FormatStyle.Percent.Configuration.Precision) -> Foundation.Decimal.FormatStyle.Percent
    public func sign(strategy: Foundation.Decimal.FormatStyle.Percent.Configuration.SignDisplayStrategy) -> Foundation.Decimal.FormatStyle.Percent
    public func decimalSeparator(strategy: Foundation.Decimal.FormatStyle.Percent.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.Decimal.FormatStyle.Percent
    public func rounded(rule: Foundation.Decimal.FormatStyle.Percent.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.Decimal.FormatStyle.Percent
    public func scale(_ multiplicand: Swift.Double) -> Foundation.Decimal.FormatStyle.Percent
    public func notation(_ notation: Foundation.Decimal.FormatStyle.Percent.Configuration.Notation) -> Foundation.Decimal.FormatStyle.Percent
    public func format(_ value: Foundation.Decimal) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Decimal.FormatStyle.Percent
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct Currency : Swift.Sendable {
    public typealias Configuration = Foundation.CurrencyFormatStyleConfiguration
    public var locale: Foundation.Locale
    public var currencyCode: Swift.String
    public init(code: Swift.String, locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.Decimal.FormatStyle.Attributed {
      get
    }
    public func grouping(_ group: Foundation.Decimal.FormatStyle.Currency.Configuration.Grouping) -> Foundation.Decimal.FormatStyle.Currency
    public func precision(_ p: Foundation.Decimal.FormatStyle.Currency.Configuration.Precision) -> Foundation.Decimal.FormatStyle.Currency
    public func sign(strategy: Foundation.Decimal.FormatStyle.Currency.Configuration.SignDisplayStrategy) -> Foundation.Decimal.FormatStyle.Currency
    public func decimalSeparator(strategy: Foundation.Decimal.FormatStyle.Currency.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.Decimal.FormatStyle.Currency
    public func rounded(rule: Foundation.Decimal.FormatStyle.Currency.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.Decimal.FormatStyle.Currency
    public func scale(_ multiplicand: Swift.Double) -> Foundation.Decimal.FormatStyle.Currency
    public func presentation(_ p: Foundation.Decimal.FormatStyle.Currency.Configuration.Presentation) -> Foundation.Decimal.FormatStyle.Currency
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public func notation(_ notation: Foundation.Decimal.FormatStyle.Currency.Configuration.Notation) -> Foundation.Decimal.FormatStyle.Currency
    public func format(_ value: Foundation.Decimal) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Decimal.FormatStyle.Currency
  }
  public struct Attributed : Swift.Sendable {
    public func format(_ value: Foundation.Decimal) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.Decimal.FormatStyle.Attributed
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.FormatStyle.Percent : Foundation.FormatStyle {
  public static func == (a: Foundation.Decimal.FormatStyle.Percent, b: Foundation.Decimal.FormatStyle.Percent) -> Swift.Bool
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Foundation.Decimal
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.FormatStyle.Currency : Foundation.FormatStyle {
  public static func == (a: Foundation.Decimal.FormatStyle.Currency, b: Foundation.Decimal.FormatStyle.Currency) -> Swift.Bool
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Foundation.Decimal
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.FormatStyle.Attributed : Foundation.FormatStyle {
  public static func == (a: Foundation.Decimal.FormatStyle.Attributed, b: Foundation.Decimal.FormatStyle.Attributed) -> Swift.Bool
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Foundation.Decimal
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Foundation.AttributedString
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.FormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle> {
    get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Strategy = Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.FormatStyle.Currency : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle.Currency> {
    get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Strategy = Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle.Currency>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.FormatStyle.Percent : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle.Percent> {
    get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Strategy = Foundation.Decimal.ParseStrategy<Foundation.Decimal.FormatStyle.Percent>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Decimal.FormatStyle {
  public static var number: Foundation.Decimal.FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Decimal.FormatStyle.Percent {
  public static var percent: Foundation.Decimal.FormatStyle.Percent {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Decimal.FormatStyle.Currency {
  public static func currency(code: Swift.String) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.Decimal.FormatStyle {
  public static var number: Foundation.Decimal.FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.Decimal.FormatStyle.Percent {
  public static var percent: Foundation.Decimal.FormatStyle.Percent {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.Decimal.FormatStyle.Currency {
  public static func currency(code: Swift.String) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal {
  public func formatted() -> Swift.String
  public func formatted<S>(_ format: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput == Foundation.Decimal
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Decimal.FormatStyle : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Foundation.Decimal
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Foundation.Decimal)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Decimal.FormatStyle.Percent : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Foundation.Decimal
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Foundation.Decimal)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Decimal.FormatStyle.Currency : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Foundation.Decimal
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Foundation.Decimal)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.Decimal.FormatStyle {
  public static func localizedDecimal(locale: Foundation.Locale) -> Self
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.Decimal.FormatStyle.Currency {
  public static func localizedCurrency(code: Foundation.Locale.Currency, locale: Foundation.Locale) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal {
  public struct ParseStrategy<Format> : Foundation.ParseStrategy, Swift.Codable, Swift.Hashable where Format : Foundation.FormatStyle, Format.FormatInput == Foundation.Decimal {
    public var formatStyle: Format
    public var lenient: Swift.Bool
    public static func == (a: Foundation.Decimal.ParseStrategy<Format>, b: Foundation.Decimal.ParseStrategy<Format>) -> Swift.Bool
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ParseInput = Swift.String
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ParseOutput = Foundation.Decimal
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.ParseStrategy {
  public func parse(_ value: Swift.String) throws -> Format.FormatInput
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.ParseStrategy : Swift.Sendable where Format : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal {
  public init<S>(_ value: S.ParseInput, strategy: S) throws where S : Foundation.ParseStrategy, S.ParseOutput == Foundation.Decimal
  public init(_ value: Swift.String, format: Foundation.Decimal.FormatStyle, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.Decimal.FormatStyle.Percent, lenient: Swift.Bool = true) throws
  public init(_ value: Swift.String, format: Foundation.Decimal.FormatStyle.Currency, lenient: Swift.Bool = true) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.ParseStrategy where Format == Foundation.Decimal.FormatStyle {
  public init(format: Format, lenient: Swift.Bool = true)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.ParseStrategy where Format == Foundation.Decimal.FormatStyle.Percent {
  public init(format: Format, lenient: Swift.Bool = true)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Decimal.ParseStrategy where Format == Foundation.Decimal.FormatStyle.Currency {
  public init(format: Format, lenient: Swift.Bool = true)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct FloatingPointFormatStyle<Value> : Swift.Codable, Swift.Hashable, Swift.Sendable where Value : Swift.BinaryFloatingPoint {
  public var locale: Foundation.Locale
  public init(locale: Foundation.Locale = .autoupdatingCurrent)
  public var attributed: Foundation.FloatingPointFormatStyle<Value>.Attributed {
    get
  }
  public typealias Configuration = Foundation.NumberFormatStyleConfiguration
  public func grouping(_ group: Foundation.FloatingPointFormatStyle<Value>.Configuration.Grouping) -> Foundation.FloatingPointFormatStyle<Value>
  public func precision(_ p: Foundation.FloatingPointFormatStyle<Value>.Configuration.Precision) -> Foundation.FloatingPointFormatStyle<Value>
  public func sign(strategy: Foundation.FloatingPointFormatStyle<Value>.Configuration.SignDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>
  public func decimalSeparator(strategy: Foundation.FloatingPointFormatStyle<Value>.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>
  public func rounded(rule: Foundation.FloatingPointFormatStyle<Value>.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Double? = nil) -> Foundation.FloatingPointFormatStyle<Value>
  public func scale(_ multiplicand: Swift.Double) -> Foundation.FloatingPointFormatStyle<Value>
  public func notation(_ notation: Foundation.FloatingPointFormatStyle<Value>.Configuration.Notation) -> Foundation.FloatingPointFormatStyle<Value>
  public static func == (a: Foundation.FloatingPointFormatStyle<Value>, b: Foundation.FloatingPointFormatStyle<Value>) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle {
  public struct Percent : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var locale: Foundation.Locale
    public init(locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.FloatingPointFormatStyle<Value>.Attributed {
      get
    }
    public typealias Configuration = Foundation.NumberFormatStyleConfiguration
    public func grouping(_ group: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.Grouping) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func precision(_ p: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.Precision) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func sign(strategy: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.SignDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func decimalSeparator(strategy: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func rounded(rule: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Double? = nil) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func scale(_ multiplicand: Swift.Double) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public func notation(_ notation: Foundation.FloatingPointFormatStyle<Value>.Percent.Configuration.Notation) -> Foundation.FloatingPointFormatStyle<Value>.Percent
    public static func == (a: Foundation.FloatingPointFormatStyle<Value>.Percent, b: Foundation.FloatingPointFormatStyle<Value>.Percent) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct Currency : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var locale: Foundation.Locale
    public let currencyCode: Swift.String
    public typealias Configuration = Foundation.CurrencyFormatStyleConfiguration
    public init(code: Swift.String, locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.FloatingPointFormatStyle<Value>.Attributed {
      get
    }
    public func grouping(_ group: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.Grouping) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func precision(_ p: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.Precision) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func sign(strategy: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.SignDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func decimalSeparator(strategy: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func rounded(rule: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Double? = nil) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func scale(_ multiplicand: Swift.Double) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public func presentation(_ p: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.Presentation) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public func notation(_ notation: Foundation.FloatingPointFormatStyle<Value>.Currency.Configuration.Notation) -> Foundation.FloatingPointFormatStyle<Value>.Currency
    public static func == (a: Foundation.FloatingPointFormatStyle<Value>.Currency, b: Foundation.FloatingPointFormatStyle<Value>.Currency) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle : Foundation.FormatStyle {
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.FloatingPointFormatStyle<Value>
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Value
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle.Percent : Foundation.FormatStyle {
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.FloatingPointFormatStyle<Value>.Percent
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Value
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle.Currency : Foundation.FormatStyle {
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.FloatingPointFormatStyle<Value>.Currency
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Value
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>> {
    get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Strategy = Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle.Currency : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>.Currency> {
    get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Strategy = Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>.Currency>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle.Percent : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>.Percent> {
    get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Strategy = Foundation.FloatingPointParseStrategy<Foundation.FloatingPointFormatStyle<Value>.Percent>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.FloatingPointFormatStyle<Swift.Double> {
  @_alwaysEmitIntoClient public static var number: Foundation.FloatingPointFormatStyle<Swift.Double> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.FloatingPointFormatStyle<Swift.Float> {
  @_alwaysEmitIntoClient public static var number: Foundation.FloatingPointFormatStyle<Swift.Float> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.FloatingPointFormatStyle<Swift.Double>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.FloatingPointFormatStyle<Swift.Double>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.FloatingPointFormatStyle<Swift.Float>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.FloatingPointFormatStyle<Swift.Float>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  @_alwaysEmitIntoClient public static func currency<Value>(code: Swift.String) -> Self where Self == Foundation.FloatingPointFormatStyle<Value>.Currency, Value : Swift.BinaryFloatingPoint {
        return Self(code: code)
    }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.FloatingPointFormatStyle<Swift.Float16> {
  @_alwaysEmitIntoClient public static var number: Foundation.FloatingPointFormatStyle<Swift.Float16> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.FloatingPointFormatStyle<Swift.Float16>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.FloatingPointFormatStyle<Swift.Float16>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointFormatStyle {
  public struct Attributed : Swift.Codable, Swift.Hashable, Foundation.FormatStyle, Swift.Sendable {
    public func format(_ value: Value) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.FloatingPointFormatStyle<Value>.Attributed
    public static func == (a: Foundation.FloatingPointFormatStyle<Value>.Attributed, b: Foundation.FloatingPointFormatStyle<Value>.Attributed) -> Swift.Bool
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Value
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.FloatingPointFormatStyle : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Value
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Value)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.FloatingPointFormatStyle.Percent : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Value
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Value)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.FloatingPointFormatStyle.Currency : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Value
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Value)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.FloatingPointFormatStyle<Swift.Double> {
  public static func localizedDouble(locale: Foundation.Locale) -> Self
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.FloatingPointFormatStyle<Swift.Double>.Percent {
  public static func localizedDoublePercentage(locale: Foundation.Locale) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct FloatingPointParseStrategy<Format> : Swift.Codable, Swift.Hashable where Format : Foundation.FormatStyle, Format.FormatInput : Swift.BinaryFloatingPoint {
  public var formatStyle: Format
  public var lenient: Swift.Bool
  public static func == (a: Foundation.FloatingPointParseStrategy<Format>, b: Foundation.FloatingPointParseStrategy<Format>) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointParseStrategy : Swift.Sendable where Format : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointParseStrategy : Foundation.ParseStrategy {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public func parse(_ value: Swift.String) throws -> Format.FormatInput
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias ParseInput = Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias ParseOutput = Format.FormatInput
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.FloatingPointFormatStyle<Value>, Value : Swift.BinaryFloatingPoint
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.FloatingPointFormatStyle<Value>.Currency, Value : Swift.BinaryFloatingPoint
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FloatingPointParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.FloatingPointFormatStyle<Value>.Percent, Value : Swift.BinaryFloatingPoint
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct IntegerFormatStyle<Value> : Swift.Codable, Swift.Hashable, Swift.Sendable where Value : Swift.BinaryInteger {
  public typealias Configuration = Foundation.NumberFormatStyleConfiguration
  public var locale: Foundation.Locale
  public init(locale: Foundation.Locale = .autoupdatingCurrent)
  public var attributed: Foundation.IntegerFormatStyle<Value>.Attributed {
    get
  }
  public func grouping(_ group: Foundation.IntegerFormatStyle<Value>.Configuration.Grouping) -> Foundation.IntegerFormatStyle<Value>
  public func precision(_ p: Foundation.IntegerFormatStyle<Value>.Configuration.Precision) -> Foundation.IntegerFormatStyle<Value>
  public func sign(strategy: Foundation.IntegerFormatStyle<Value>.Configuration.SignDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>
  public func decimalSeparator(strategy: Foundation.IntegerFormatStyle<Value>.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>
  public func rounded(rule: Foundation.IntegerFormatStyle<Value>.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.IntegerFormatStyle<Value>
  public func scale(_ multiplicand: Swift.Double) -> Foundation.IntegerFormatStyle<Value>
  public func notation(_ notation: Foundation.IntegerFormatStyle<Value>.Configuration.Notation) -> Foundation.IntegerFormatStyle<Value>
  public static func == (a: Foundation.IntegerFormatStyle<Value>, b: Foundation.IntegerFormatStyle<Value>) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle {
  public struct Percent : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public typealias Configuration = Foundation.NumberFormatStyleConfiguration
    public var locale: Foundation.Locale
    public init(locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.IntegerFormatStyle<Value>.Attributed {
      get
    }
    public func grouping(_ group: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.Grouping) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func precision(_ p: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.Precision) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func sign(strategy: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.SignDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func decimalSeparator(strategy: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func rounded(rule: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func scale(_ multiplicand: Swift.Double) -> Foundation.IntegerFormatStyle<Value>.Percent
    public func notation(_ notation: Foundation.IntegerFormatStyle<Value>.Percent.Configuration.Notation) -> Foundation.IntegerFormatStyle<Value>.Percent
    public static func == (a: Foundation.IntegerFormatStyle<Value>.Percent, b: Foundation.IntegerFormatStyle<Value>.Percent) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct Currency : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public typealias Configuration = Foundation.CurrencyFormatStyleConfiguration
    public var locale: Foundation.Locale
    public let currencyCode: Swift.String
    public init(code: Swift.String, locale: Foundation.Locale = .autoupdatingCurrent)
    public var attributed: Foundation.IntegerFormatStyle<Value>.Attributed {
      get
    }
    public func grouping(_ group: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.Grouping) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func precision(_ p: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.Precision) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func sign(strategy: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.SignDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func decimalSeparator(strategy: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.DecimalSeparatorDisplayStrategy) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func rounded(rule: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.RoundingRule = .toNearestOrEven, increment: Swift.Int? = nil) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func scale(_ multiplicand: Swift.Double) -> Foundation.IntegerFormatStyle<Value>.Currency
    public func presentation(_ p: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.Presentation) -> Foundation.IntegerFormatStyle<Value>.Currency
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public func notation(_ notation: Foundation.IntegerFormatStyle<Value>.Currency.Configuration.Notation) -> Foundation.IntegerFormatStyle<Value>.Currency
    public static func == (a: Foundation.IntegerFormatStyle<Value>.Currency, b: Foundation.IntegerFormatStyle<Value>.Currency) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle : Foundation.FormatStyle {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.IntegerFormatStyle<Value>
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Value
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle.Percent : Foundation.FormatStyle {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.IntegerFormatStyle<Value>.Percent
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Value
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle.Currency : Foundation.FormatStyle {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public func format(_ value: Value) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.IntegerFormatStyle<Value>.Currency
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Value
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>> {
    get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Strategy = Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle.Currency : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>.Currency> {
    get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Strategy = Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>.Currency>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle.Percent : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>.Percent> {
    get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Strategy = Foundation.IntegerParseStrategy<Foundation.IntegerFormatStyle<Value>.Percent>
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.Int> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int16> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.Int16> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int32> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.Int32> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int64> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.Int64> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int8> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.Int8> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.UInt> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt16> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.UInt16> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt32> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.UInt32> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt64> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.UInt64> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt8> {
  @_alwaysEmitIntoClient public static var number: Foundation.IntegerFormatStyle<Swift.UInt8> {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.Int>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int16>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.Int16>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int32>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.Int32>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int64>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.Int64>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.Int8>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.Int8>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.UInt>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt16>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.UInt16>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt32>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.UInt32>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt64>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.UInt64>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.IntegerFormatStyle<Swift.UInt8>.Percent {
  @_alwaysEmitIntoClient public static var percent: Foundation.IntegerFormatStyle<Swift.UInt8>.Percent {
    get { Self() }
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  public static func currency<V>(code: Swift.String) -> Self where Self == Foundation.IntegerFormatStyle<V>.Currency, V : Swift.BinaryInteger
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerFormatStyle {
  public struct Attributed : Swift.Codable, Swift.Hashable, Foundation.FormatStyle, Swift.Sendable {
    public func format(_ value: Value) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.IntegerFormatStyle<Value>.Attributed
    public static func == (a: Foundation.IntegerFormatStyle<Value>.Attributed, b: Foundation.IntegerFormatStyle<Value>.Attributed) -> Swift.Bool
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Value
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.IntegerFormatStyle : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Value
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Value)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.IntegerFormatStyle.Percent : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Value
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Value)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.IntegerFormatStyle.Currency : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Value
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Value)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.IntegerFormatStyle<Swift.Int> {
  public static func localizedInteger(locale: Foundation.Locale) -> Self
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.IntegerFormatStyle<Swift.Int>.Percent {
  public static func localizedIntegerPercentage(locale: Foundation.Locale) -> Self
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.IntegerFormatStyle<Swift.Int>.Currency {
  public static func localizedIntegerCurrency(code: Foundation.Locale.Currency, locale: Foundation.Locale) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct IntegerParseStrategy<Format> : Swift.Codable, Swift.Hashable where Format : Foundation.FormatStyle, Format.FormatInput : Swift.BinaryInteger {
  public var formatStyle: Format
  public var lenient: Swift.Bool
  public static func == (a: Foundation.IntegerParseStrategy<Format>, b: Foundation.IntegerParseStrategy<Format>) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerParseStrategy : Swift.Sendable where Format : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerParseStrategy : Foundation.ParseStrategy {
  public func parse(_ value: Swift.String) throws -> Format.FormatInput
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias ParseInput = Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias ParseOutput = Format.FormatInput
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.IntegerFormatStyle<Value>, Value : Swift.BinaryInteger
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.IntegerFormatStyle<Value>.Percent, Value : Swift.BinaryInteger
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.IntegerParseStrategy {
  public init<Value>(format: Format, lenient: Swift.Bool = true) where Format == Foundation.IntegerFormatStyle<Value>.Currency, Value : Swift.BinaryInteger
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct FormatStyleCapitalizationContext : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public static var unknown: Foundation.FormatStyleCapitalizationContext {
    get
  }
  public static var standalone: Foundation.FormatStyleCapitalizationContext {
    get
  }
  public static var listItem: Foundation.FormatStyleCapitalizationContext {
    get
  }
  public static var beginningOfSentence: Foundation.FormatStyleCapitalizationContext {
    get
  }
  public static var middleOfSentence: Foundation.FormatStyleCapitalizationContext {
    get
  }
  public static func == (a: Foundation.FormatStyleCapitalizationContext, b: Foundation.FormatStyleCapitalizationContext) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public enum NumberFormatStyleConfiguration {
  public typealias RoundingRule = Swift.FloatingPointRoundingRule
  public struct Grouping : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible, Swift.Sendable {
    public static var automatic: Foundation.NumberFormatStyleConfiguration.Grouping {
      get
    }
    public static var never: Foundation.NumberFormatStyleConfiguration.Grouping {
      get
    }
    public var description: Swift.String {
      get
    }
    public static func == (a: Foundation.NumberFormatStyleConfiguration.Grouping, b: Foundation.NumberFormatStyleConfiguration.Grouping) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Precision : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static func significantDigits<R>(_ limits: R) -> Foundation.NumberFormatStyleConfiguration.Precision where R : Swift.RangeExpression, R.Bound == Swift.Int
    public static func significantDigits(_ digits: Swift.Int) -> Foundation.NumberFormatStyleConfiguration.Precision
    public static func integerAndFractionLength<R1, R2>(integerLimits: R1, fractionLimits: R2) -> Foundation.NumberFormatStyleConfiguration.Precision where R1 : Swift.RangeExpression, R2 : Swift.RangeExpression, R1.Bound == Swift.Int, R2.Bound == Swift.Int
    public static func integerAndFractionLength(integer: Swift.Int, fraction: Swift.Int) -> Foundation.NumberFormatStyleConfiguration.Precision
    public static func integerLength<R>(_ limits: R) -> Foundation.NumberFormatStyleConfiguration.Precision where R : Swift.RangeExpression
    public static func integerLength(_ length: Swift.Int) -> Foundation.NumberFormatStyleConfiguration.Precision
    public static func fractionLength<R>(_ limits: R) -> Foundation.NumberFormatStyleConfiguration.Precision where R : Swift.RangeExpression, R.Bound == Swift.Int
    public static func fractionLength(_ length: Swift.Int) -> Foundation.NumberFormatStyleConfiguration.Precision
    public static func == (a: Foundation.NumberFormatStyleConfiguration.Precision, b: Foundation.NumberFormatStyleConfiguration.Precision) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct DecimalSeparatorDisplayStrategy : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible, Swift.Sendable {
    public static var automatic: Foundation.NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy {
      get
    }
    public static var always: Foundation.NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy {
      get
    }
    public var description: Swift.String {
      get
    }
    public static func == (a: Foundation.NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy, b: Foundation.NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct SignDisplayStrategy : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible, Swift.Sendable {
    public static var automatic: Foundation.NumberFormatStyleConfiguration.SignDisplayStrategy {
      get
    }
    public static var never: Foundation.NumberFormatStyleConfiguration.SignDisplayStrategy {
      get
    }
    public static func always(includingZero: Swift.Bool = true) -> Foundation.NumberFormatStyleConfiguration.SignDisplayStrategy
    public var description: Swift.String {
      get
    }
    public static func == (a: Foundation.NumberFormatStyleConfiguration.SignDisplayStrategy, b: Foundation.NumberFormatStyleConfiguration.SignDisplayStrategy) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Notation : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible, Swift.Sendable {
    public static var scientific: Foundation.NumberFormatStyleConfiguration.Notation {
      get
    }
    public static var automatic: Foundation.NumberFormatStyleConfiguration.Notation {
      get
    }
    public static var compactName: Foundation.NumberFormatStyleConfiguration.Notation {
      get
    }
    public var description: Swift.String {
      get
    }
    public static func == (a: Foundation.NumberFormatStyleConfiguration.Notation, b: Foundation.NumberFormatStyleConfiguration.Notation) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.NumberFormatStyleConfiguration : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public enum CurrencyFormatStyleConfiguration {
  public typealias Grouping = Foundation.NumberFormatStyleConfiguration.Grouping
  public typealias Precision = Foundation.NumberFormatStyleConfiguration.Precision
  public typealias DecimalSeparatorDisplayStrategy = Foundation.NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy
  public typealias RoundingRule = Foundation.NumberFormatStyleConfiguration.RoundingRule
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
  public typealias Notation = Foundation.NumberFormatStyleConfiguration.Notation
  public struct SignDisplayStrategy : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static var automatic: Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy {
      get
    }
    public static var never: Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy {
      get
    }
    public static func always(showZero: Swift.Bool = true) -> Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy
    public static var accounting: Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy {
      get
    }
    public static func accountingAlways(showZero: Swift.Bool = false) -> Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy
    public static func == (a: Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy, b: Foundation.CurrencyFormatStyleConfiguration.SignDisplayStrategy) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Presentation : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static var narrow: Foundation.CurrencyFormatStyleConfiguration.Presentation {
      get
    }
    public static var standard: Foundation.CurrencyFormatStyleConfiguration.Presentation {
      get
    }
    public static var isoCode: Foundation.CurrencyFormatStyleConfiguration.Presentation {
      get
    }
    public static var fullName: Foundation.CurrencyFormatStyleConfiguration.Presentation {
      get
    }
    public static func == (a: Foundation.CurrencyFormatStyleConfiguration.Presentation, b: Foundation.CurrencyFormatStyleConfiguration.Presentation) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.CurrencyFormatStyleConfiguration : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public enum DescriptiveNumberFormatConfiguration {
  public typealias CapitalizationContext = Foundation.FormatStyleCapitalizationContext
  public struct Presentation : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public static var spellOut: Foundation.DescriptiveNumberFormatConfiguration.Presentation {
      get
    }
    public static var ordinal: Foundation.DescriptiveNumberFormatConfiguration.Presentation {
      get
    }
    public static func == (a: Foundation.DescriptiveNumberFormatConfiguration.Presentation, b: Foundation.DescriptiveNumberFormatConfiguration.Presentation) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.DescriptiveNumberFormatConfiguration : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.FloatingPointRoundingRule {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.FloatingPointRoundingRule : Swift.Codable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct ByteCountFormatStyle : Foundation.FormatStyle, Swift.Sendable {
  public var style: Foundation.ByteCountFormatStyle.Style {
    get
    set
  }
  public var allowedUnits: Foundation.ByteCountFormatStyle.Units {
    get
    set
  }
  public var spellsOutZero: Swift.Bool {
    get
    set
  }
  public var includesActualByteCount: Swift.Bool {
    get
    set
  }
  public var locale: Foundation.Locale {
    get
    set
  }
  public var attributed: Foundation.ByteCountFormatStyle.Attributed
  public func format(_ value: Swift.Int64) -> Swift.String
  public func locale(_ locale: Foundation.Locale) -> Foundation.ByteCountFormatStyle
  public init(style: Foundation.ByteCountFormatStyle.Style = .file, allowedUnits: Foundation.ByteCountFormatStyle.Units = .all, spellsOutZero: Swift.Bool = true, includesActualByteCount: Swift.Bool = false, locale: Foundation.Locale = .autoupdatingCurrent)
  public enum Style : Swift.Int, Swift.Codable, Swift.Hashable, Swift.Sendable {
    case file, memory, decimal, binary
    public init?(rawValue: Swift.Int)
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public struct Units : Swift.OptionSet, Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static var bytes: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var kb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var mb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var gb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var tb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var pb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var eb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var zb: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var ybOrHigher: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var all: Foundation.ByteCountFormatStyle.Units {
      get
    }
    public static var `default`: Foundation.ByteCountFormatStyle.Units {
      get
    }
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ArrayLiteralElement = Foundation.ByteCountFormatStyle.Units
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Element = Foundation.ByteCountFormatStyle.Units
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias RawValue = Swift.UInt
  }
  public struct Attributed : Foundation.FormatStyle, Swift.Sendable {
    public var style: Foundation.ByteCountFormatStyle.Style
    public var allowedUnits: Foundation.ByteCountFormatStyle.Units
    public var spellsOutZero: Swift.Bool
    public var includesActualByteCount: Swift.Bool
    public var locale: Foundation.Locale
    public func locale(_ locale: Foundation.Locale) -> Foundation.ByteCountFormatStyle.Attributed
    public func format(_ value: Swift.Int64) -> Foundation.AttributedString
    public static func == (a: Foundation.ByteCountFormatStyle.Attributed, b: Foundation.ByteCountFormatStyle.Attributed) -> Swift.Bool
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Swift.Int64
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public static func == (a: Foundation.ByteCountFormatStyle, b: Foundation.ByteCountFormatStyle) -> Swift.Bool
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Swift.Int64
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.ByteCountFormatStyle {
  public static func byteCount(style: Foundation.ByteCountFormatStyle.Style, allowedUnits: Foundation.ByteCountFormatStyle.Units = .all, spellsOutZero: Swift.Bool = true, includesActualByteCount: Swift.Bool = false) -> Self
}
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Swift.Duration {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func formatted<S>(_ v: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput == Swift.Duration
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public func formatted() -> Swift.String
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Duration {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  public struct TimeFormatStyle : Foundation.FormatStyle, Swift.Sendable {
    public struct Pattern : Swift.Hashable, Swift.Codable, Swift.Sendable {
      public static var hourMinute: Swift.Duration.TimeFormatStyle.Pattern {
        get
      }
      public static func hourMinute(padHourToLength: Swift.Int, roundSeconds: Swift.FloatingPointRoundingRule = .toNearestOrEven) -> Swift.Duration.TimeFormatStyle.Pattern
      public static var hourMinuteSecond: Swift.Duration.TimeFormatStyle.Pattern {
        get
      }
      public static func hourMinuteSecond(padHourToLength: Swift.Int, fractionalSecondsLength: Swift.Int = 0, roundFractionalSeconds: Swift.FloatingPointRoundingRule = .toNearestOrEven) -> Swift.Duration.TimeFormatStyle.Pattern
      public static var minuteSecond: Swift.Duration.TimeFormatStyle.Pattern {
        get
      }
      public static func minuteSecond(padMinuteToLength: Swift.Int, fractionalSecondsLength: Swift.Int = 0, roundFractionalSeconds: Swift.FloatingPointRoundingRule = .toNearestOrEven) -> Swift.Duration.TimeFormatStyle.Pattern
      public static func == (a: Swift.Duration.TimeFormatStyle.Pattern, b: Swift.Duration.TimeFormatStyle.Pattern) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public var locale: Foundation.Locale {
      get
      set
    }
    public var pattern: Swift.Duration.TimeFormatStyle.Pattern {
      get
      set
    }
    public var attributed: Swift.Duration.TimeFormatStyle.Attributed {
      get
    }
    public init(pattern: Swift.Duration.TimeFormatStyle.Pattern, locale: Foundation.Locale = .autoupdatingCurrent)
    public func format(_ value: Swift.Duration) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Swift.Duration.TimeFormatStyle
    public static func == (a: Swift.Duration.TimeFormatStyle, b: Swift.Duration.TimeFormatStyle) -> Swift.Bool
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias FormatInput = Swift.Duration
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.FormatStyle where Self == Swift.Duration.TimeFormatStyle {
  public static func time(pattern: Swift.Duration.TimeFormatStyle.Pattern) -> Self
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Duration.TimeFormatStyle {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  @dynamicMemberLookup public struct Attributed : Foundation.FormatStyle, Swift.Sendable {
    public func locale(_ locale: Foundation.Locale) -> Swift.Duration.TimeFormatStyle.Attributed
    public func format(_ value: Swift.Duration) -> Foundation.AttributedString
    public static func == (a: Swift.Duration.TimeFormatStyle.Attributed, b: Swift.Duration.TimeFormatStyle.Attributed) -> Swift.Bool
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias FormatInput = Swift.Duration
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Swift.Duration.TimeFormatStyle {
  public func grouping(_ grouping: Foundation.NumberFormatStyleConfiguration.Grouping) -> Swift.Duration.TimeFormatStyle
  public var grouping: Foundation.NumberFormatStyleConfiguration.Grouping {
    get
    set
  }
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Swift.Duration.TimeFormatStyle.Attributed {
  public func grouping(_ grouping: Foundation.NumberFormatStyleConfiguration.Grouping) -> Swift.Duration.TimeFormatStyle.Attributed
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Swift.Duration.TimeFormatStyle.Attributed {
  public subscript<T>(dynamicMember key: Swift.KeyPath<Swift.Duration.TimeFormatStyle, T>) -> T {
    get
  }
  public subscript<T>(dynamicMember key: Swift.WritableKeyPath<Swift.Duration.TimeFormatStyle, T>) -> T {
    get
    set
  }
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Swift.Duration.TimeFormatStyle.Attributed : Foundation.DiscreteFormatStyle {
  public func discreteInput(before input: Swift.Duration) -> Swift.Duration?
  public func discreteInput(after input: Swift.Duration) -> Swift.Duration?
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Swift.Duration.TimeFormatStyle : Foundation.DiscreteFormatStyle {
  public func discreteInput(before input: Swift.Duration) -> Swift.Duration?
  public func discreteInput(after input: Swift.Duration) -> Swift.Duration?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Duration {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public struct UnitsFormatStyle : Foundation.FormatStyle, Swift.Sendable {
    public struct UnitWidth : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public static var wide: Swift.Duration.UnitsFormatStyle.UnitWidth {
        get
      }
      public static var abbreviated: Swift.Duration.UnitsFormatStyle.UnitWidth {
        get
      }
      public static var condensedAbbreviated: Swift.Duration.UnitsFormatStyle.UnitWidth {
        get
      }
      public static var narrow: Swift.Duration.UnitsFormatStyle.UnitWidth {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Swift.Duration.UnitsFormatStyle.UnitWidth, b: Swift.Duration.UnitsFormatStyle.UnitWidth) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct Unit : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public static var weeks: Swift.Duration.UnitsFormatStyle.Unit {
        get
      }
      public static var days: Swift.Duration.UnitsFormatStyle.Unit {
        get
      }
      public static var hours: Swift.Duration.UnitsFormatStyle.Unit {
        get
      }
      public static var minutes: Swift.Duration.UnitsFormatStyle.Unit {
        get
      }
      public static var seconds: Swift.Duration.UnitsFormatStyle.Unit {
        get
      }
      public static var milliseconds: Swift.Duration.UnitsFormatStyle.Unit {
        get
      }
      public static var microseconds: Swift.Duration.UnitsFormatStyle.Unit {
        get
      }
      public static var nanoseconds: Swift.Duration.UnitsFormatStyle.Unit {
        get
      }
      public static func == (a: Swift.Duration.UnitsFormatStyle.Unit, b: Swift.Duration.UnitsFormatStyle.Unit) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct ZeroValueUnitsDisplayStrategy : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public static var hide: Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy {
        get
      }
      public static func show(length: Swift.Int) -> Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy
      public static func == (a: Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy, b: Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct FractionalPartDisplayStrategy : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public var minimumLength: Swift.Int
      public var maximumLength: Swift.Int
      public var roundingRule: Swift.FloatingPointRoundingRule
      public var roundingIncrement: Swift.Double?
      public init<Range>(lengthLimits: Range, roundingRule: Swift.FloatingPointRoundingRule = .toNearestOrEven, roundingIncrement: Swift.Double? = nil) where Range : Swift.RangeExpression, Range.Bound == Swift.Int
      public static func show(length: Swift.Int, rounded rule: Swift.FloatingPointRoundingRule = .toNearestOrEven, increment: Swift.Double? = nil) -> Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy
      public static var hide: Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy {
        get
      }
      public static func hide(rounded: Swift.FloatingPointRoundingRule = .toNearestOrEven) -> Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy
      public static func == (a: Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy, b: Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public var locale: Foundation.Locale
    public var allowedUnits: Swift.Set<Swift.Duration.UnitsFormatStyle.Unit>
    public var unitWidth: Swift.Duration.UnitsFormatStyle.UnitWidth
    public var maximumUnitCount: Swift.Int?
    public var zeroValueUnitsDisplay: Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy
    public var fractionalPartDisplay: Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy
    public var valueLengthLimits: Swift.Range<Swift.Int>?
    public init(allowedUnits: Swift.Set<Swift.Duration.UnitsFormatStyle.Unit>, width: Swift.Duration.UnitsFormatStyle.UnitWidth, maximumUnitCount: Swift.Int? = nil, zeroValueUnits: Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy = .hide, valueLength: Swift.Int? = nil, fractionalPart: Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy = .hide)
    public init<ValueRange>(allowedUnits: Swift.Set<Swift.Duration.UnitsFormatStyle.Unit>, width: Swift.Duration.UnitsFormatStyle.UnitWidth, maximumUnitCount: Swift.Int? = nil, zeroValueUnits: Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy = .hide, valueLengthLimits: ValueRange, fractionalPart: Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy = .hide) where ValueRange : Swift.RangeExpression, ValueRange.Bound == Swift.Int
    public func format(_ duration: Swift.Duration) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Swift.Duration.UnitsFormatStyle
    public var attributed: Swift.Duration.UnitsFormatStyle.Attributed {
      get
    }
    public static func == (a: Swift.Duration.UnitsFormatStyle, b: Swift.Duration.UnitsFormatStyle) -> Swift.Bool
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias FormatInput = Swift.Duration
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.FormatStyle where Self == Swift.Duration.UnitsFormatStyle {
  public static func units(allowed units: Swift.Set<Swift.Duration.UnitsFormatStyle.Unit> = [.hours, .minutes, .seconds], width: Swift.Duration.UnitsFormatStyle.UnitWidth = .abbreviated, maximumUnitCount: Swift.Int? = nil, zeroValueUnits: Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy = .hide, valueLength: Swift.Int? = nil, fractionalPart: Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy = .hide) -> Self
  public static func units<ValueRange>(allowed units: Swift.Set<Swift.Duration.UnitsFormatStyle.Unit> = [.hours, .minutes, .seconds], width: Swift.Duration.UnitsFormatStyle.UnitWidth = .abbreviated, maximumUnitCount: Swift.Int? = nil, zeroValueUnits: Swift.Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy = .hide, valueLengthLimits: ValueRange, fractionalPart: Swift.Duration.UnitsFormatStyle.FractionalPartDisplayStrategy = .hide) -> Self where ValueRange : Swift.RangeExpression, ValueRange.Bound == Swift.Int
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Swift.Duration.UnitsFormatStyle {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  @dynamicMemberLookup public struct Attributed : Foundation.FormatStyle, Swift.Sendable {
    public func format(_ duration: Swift.Duration) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Swift.Duration.UnitsFormatStyle.Attributed
    public static func == (a: Swift.Duration.UnitsFormatStyle.Attributed, b: Swift.Duration.UnitsFormatStyle.Attributed) -> Swift.Bool
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias FormatInput = Swift.Duration
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Swift.Duration.UnitsFormatStyle.Attributed {
  public subscript<T>(dynamicMember key: Swift.KeyPath<Swift.Duration.UnitsFormatStyle, T>) -> T {
    get
  }
  public subscript<T>(dynamicMember key: Swift.WritableKeyPath<Swift.Duration.UnitsFormatStyle, T>) -> T {
    get
    set
  }
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Swift.Duration.UnitsFormatStyle.Attributed : Foundation.DiscreteFormatStyle {
  public func discreteInput(before input: Swift.Duration) -> Swift.Duration?
  public func discreteInput(after input: Swift.Duration) -> Swift.Duration?
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Swift.Duration.UnitsFormatStyle : Foundation.DiscreteFormatStyle {
  public func discreteInput(before input: Swift.Duration) -> Swift.Duration?
  public func discreteInput(after input: Swift.Duration) -> Swift.Duration?
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct ListFormatStyle<Style, Base> : Foundation.FormatStyle where Style : Foundation.FormatStyle, Base : Swift.Sequence, Style.FormatInput == Base.Element, Style.FormatOutput == Swift.String {
  public var width: Foundation.ListFormatStyle<Style, Base>.Width
  public var listType: Foundation.ListFormatStyle<Style, Base>.ListType
  public var locale: Foundation.Locale
  public init(memberStyle: Style)
  public func format(_ value: Base) -> Swift.String
  public enum Width : Swift.Int, Swift.Codable, Swift.Sendable {
    case standard
    case short
    case narrow
    public init?(rawValue: Swift.Int)
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum ListType : Swift.Int, Swift.Codable, Swift.Sendable {
    case and
    case or
    public init?(rawValue: Swift.Int)
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public func locale(_ locale: Foundation.Locale) -> Foundation.ListFormatStyle<Style, Base>
  public static func == (a: Foundation.ListFormatStyle<Style, Base>, b: Foundation.ListFormatStyle<Style, Base>) -> Swift.Bool
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Base
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle : Swift.Sendable where Style : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct StringStyle : Foundation.FormatStyle, Swift.Sendable {
  public func format(_ value: Swift.String) -> Swift.String
  public static func == (a: Foundation.StringStyle, b: Foundation.StringStyle) -> Swift.Bool
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Sequence {
  public func formatted<S>(_ style: S) -> S.FormatOutput where Self == S.FormatInput, S : Foundation.FormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Sequence where Self.Element == Swift.String {
  public func formatted() -> Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  public static func list<MemberStyle, Base>(memberStyle: MemberStyle, type: Foundation.ListFormatStyle<MemberStyle, Base>.ListType, width: Foundation.ListFormatStyle<MemberStyle, Base>.Width = .standard) -> Self where Self == Foundation.ListFormatStyle<MemberStyle, Base>, MemberStyle : Foundation.FormatStyle, Base : Swift.Sequence, MemberStyle.FormatInput == Base.Element, MemberStyle.FormatOutput == Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  public static func list<Base>(type: Foundation.ListFormatStyle<Foundation.StringStyle, Base>.ListType, width: Foundation.ListFormatStyle<Foundation.StringStyle, Base>.Width = .standard) -> Self where Self == Foundation.ListFormatStyle<Foundation.StringStyle, Base>, Base : Swift.Sequence, Base.Element == Swift.String
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Locale {
  public static func identifier(fromWindowsLocaleCode code: Swift.Int) -> Swift.String?
  public static func windowsLocaleCode(fromIdentifier identifier: Swift.String) -> Swift.Int?
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public static func identifier(_ type: Foundation.Locale.IdentifierType, from string: Swift.String) -> Swift.String
  public static var availableIdentifiers: [Swift.String] {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public static var commonISOCurrencyCodes: [Swift.String] {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Locale : Foundation.ReferenceConvertible {
  public typealias ReferenceType = Foundation.NSLocale
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Locale : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSLocale
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSLocale, result: inout Foundation.Locale?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSLocale, result: inout Foundation.Locale?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSLocale?) -> Foundation.Locale
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSLocale
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSLocale : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Locale {
  @available(macOS, deprecated: 13, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
  @available(iOS, deprecated: 16, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
  @available(tvOS, deprecated: 16, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
  @available(watchOS, deprecated: 9, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
  public static var isoLanguageCodes: [Swift.String] {
    get
  }
  @available(macOS, deprecated: 13, message: "Use `Locale.Components(identifier:)` to access components")
  @available(iOS, deprecated: 16, message: "Use `Locale.Components(identifier:)` to access components")
  @available(tvOS, deprecated: 16, message: "Use `Locale.Components(identifier:)` to access components")
  @available(watchOS, deprecated: 9, message: "Use `Locale.Components(identifier:)` to access components")
  public static func components(fromIdentifier string: Swift.String) -> [Swift.String : Swift.String]
  @available(macOS, deprecated: 13, message: "Use `Locale.Region.isoRegions` instead")
  @available(iOS, deprecated: 16, message: "Use `Locale.Region.isoRegions` instead")
  @available(tvOS, deprecated: 16, message: "Use `Locale.Region.isoRegions` instead")
  @available(watchOS, deprecated: 9, message: "Use `Locale.Region.isoRegions` instead")
  public static var isoRegionCodes: [Swift.String] {
    get
  }
  @available(macOS, deprecated: 13, message: "Use `Locale.Currency.isoCurrencies` instead")
  @available(iOS, deprecated: 16, message: "Use `Locale.Currency.isoCurrencies` instead")
  @available(tvOS, deprecated: 16, message: "Use `Locale.Currency.isoCurrencies` instead")
  @available(watchOS, deprecated: 9, message: "Use `Locale.Currency.isoCurrencies` instead")
  public static var isoCurrencyCodes: [Swift.String] {
    get
  }
  @available(macOS, deprecated: 13, message: "Use `Locale.Language(identifier:).characterDirection`")
  @available(iOS, deprecated: 16, message: "Use `Locale.Language(identifier:).characterDirection`")
  @available(tvOS, deprecated: 16, message: "Use `Locale.Language(identifier:).characterDirection`")
  @available(watchOS, deprecated: 9, message: "Use `Locale.Language(identifier:).characterDirection`")
  public static func characterDirection(forLanguage isoLangCode: Swift.String) -> Foundation.Locale.LanguageDirection
  @available(macOS, deprecated: 13, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
  @available(iOS, deprecated: 16, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
  @available(tvOS, deprecated: 16, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
  @available(watchOS, deprecated: 9, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
  public static func lineDirection(forLanguage isoLangCode: Swift.String) -> Foundation.Locale.LanguageDirection
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.Components {
  public init(identifier: Swift.String)
  public init(locale: Foundation.Locale)
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.LanguageCode {
  public func identifier(_ type: Foundation.Locale.LanguageCode.IdentifierType) -> Swift.String?
  public var isISOLanguage: Swift.Bool {
    get
  }
  public static var isoLanguageCodes: [Foundation.Locale.LanguageCode] {
    get
  }
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.Script {
  public var isISOScript: Swift.Bool {
    get
  }
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.Region {
  public var isISORegion: Swift.Bool {
    get
  }
  public var subRegions: [Foundation.Locale.Region] {
    get
  }
  public var containingRegion: Foundation.Locale.Region? {
    get
  }
  public var continent: Foundation.Locale.Region? {
    get
  }
  public static var isoRegions: [Foundation.Locale.Region] {
    get
  }
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.Collation {
  public static var availableCollations: [Foundation.Locale.Collation] {
    get
  }
  public static func availableCollations(for language: Foundation.Locale.Language) -> [Foundation.Locale.Collation]
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.Currency {
  public var isISOCurrency: Swift.Bool {
    get
  }
  public static let unknown: Foundation.Locale.Currency
  public static var isoCurrencies: [Foundation.Locale.Currency] {
    get
  }
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.NumberingSystem {
  public static var availableNumberingSystems: [Foundation.Locale.NumberingSystem] {
    get
  }
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.Language {
  public var lineLayoutDirection: Foundation.Locale.LanguageDirection {
    get
  }
  public var characterDirection: Foundation.Locale.LanguageDirection {
    get
  }
  public var parent: Foundation.Locale.Language? {
    get
  }
  public func hasCommonParent(with language: Foundation.Locale.Language) -> Swift.Bool
  public func isEquivalent(to language: Foundation.Locale.Language) -> Swift.Bool
  public init(identifier: Swift.String)
  public var minimalIdentifier: Swift.String {
    get
  }
  public var maximalIdentifier: Swift.String {
    get
  }
  public var languageCode: Foundation.Locale.LanguageCode? {
    get
  }
  public var script: Foundation.Locale.Script? {
    get
  }
  public var region: Foundation.Locale.Region? {
    get
  }
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.Language.Components {
  public init(identifier: Swift.String)
  public init(language: Foundation.Locale.Language)
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct StringLocalizedStandardContains<Root, Other> : Foundation.PredicateExpression where Root : Foundation.PredicateExpression, Other : Foundation.PredicateExpression, Root.Output : Swift.StringProtocol, Other.Output : Swift.StringProtocol {
    public typealias Output = Swift.Bool
    public let root: Root
    public let other: Other
    public init(root: Root, other: Other)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.StringLocalizedStandardContains<Root, Other>.Output
  }
  public static func build_localizedStandardContains<Root, Other>(_ root: Root, _ other: Other) -> Foundation.PredicateExpressions.StringLocalizedStandardContains<Root, Other> where Root : Foundation.PredicateExpression, Other : Foundation.PredicateExpression, Root.Output : Swift.StringProtocol, Other.Output : Swift.StringProtocol
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.StringLocalizedStandardContains : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.StringLocalizedStandardContains : Foundation.StandardPredicateExpression where Root : Foundation.StandardPredicateExpression, Other : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.StringLocalizedStandardContains : Swift.Codable where Root : Swift.Decodable, Root : Swift.Encodable, Other : Swift.Decodable, Other : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.StringLocalizedStandardContains : Swift.Sendable where Root : Swift.Sendable, Other : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct StringLocalizedCompare<Root, Other> : Foundation.PredicateExpression where Root : Foundation.PredicateExpression, Other : Foundation.PredicateExpression, Root.Output : Swift.StringProtocol, Other.Output : Swift.StringProtocol {
    public typealias Output = Foundation.ComparisonResult
    public let root: Root
    public let other: Other
    public init(root: Root, other: Other)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.StringLocalizedCompare<Root, Other>.Output
  }
  public static func build_localizedCompare<Root, Other>(_ root: Root, _ other: Other) -> Foundation.PredicateExpressions.StringLocalizedCompare<Root, Other> where Root : Foundation.PredicateExpression, Other : Foundation.PredicateExpression, Root.Output : Swift.StringProtocol, Other.Output : Swift.StringProtocol
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.StringLocalizedCompare : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.StringLocalizedCompare : Foundation.StandardPredicateExpression where Root : Foundation.StandardPredicateExpression, Other : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.StringLocalizedCompare : Swift.Codable where Root : Swift.Decodable, Root : Swift.Encodable, Other : Swift.Decodable, Other : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.StringLocalizedCompare : Swift.Sendable where Root : Swift.Sendable, Other : Swift.Sendable {
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct KeyPathComparator<Compared> : Foundation.SortComparator {
  @preconcurrency public let keyPath: any Swift.PartialKeyPath<Compared> & Swift.Sendable
  public var order: Foundation.SortOrder {
    get
    set
  }
  @_alwaysEmitIntoClient public init<Value>(_ keyPath: any Swift.KeyPath<Compared, Value> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Value : Swift.Comparable {
        self.init(keyPath as KeyPath<Compared, Value>, order: order)
    }
  @_alwaysEmitIntoClient public init<Value>(_ keyPath: any Swift.KeyPath<Compared, Value?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Value : Swift.Comparable {
        self.init(keyPath as KeyPath<Compared, Value?>, order: order)
    }
  @_alwaysEmitIntoClient public init<Value, Comparator>(_ keyPath: any Swift.KeyPath<Compared, Value> & Swift.Sendable, comparator: Comparator) where Value == Comparator.Compared, Comparator : Foundation.SortComparator {
        self.init(keyPath as KeyPath<Compared, Value>, comparator: comparator)
    }
  @_alwaysEmitIntoClient public init<Value, Comparator>(_ keyPath: any Swift.KeyPath<Compared, Value?> & Swift.Sendable, comparator: Comparator) where Value == Comparator.Compared, Comparator : Foundation.SortComparator {
        self.init(keyPath as KeyPath<Compared, Value?>, comparator: comparator)
    }
  @_alwaysEmitIntoClient public init<Value, Comparator>(_ keyPath: any Swift.KeyPath<Compared, Value> & Swift.Sendable, comparator: Comparator, order: Foundation.SortOrder) where Value == Comparator.Compared, Comparator : Foundation.SortComparator {
        self.init(keyPath as KeyPath<Compared, Value>, comparator: comparator, order: order)
    }
  @_alwaysEmitIntoClient public init<Value, Comparator>(_ keyPath: any Swift.KeyPath<Compared, Value?> & Swift.Sendable, comparator: Comparator, order: Foundation.SortOrder) where Value == Comparator.Compared, Comparator : Foundation.SortComparator {
        self.init(keyPath as KeyPath<Compared, Value?>, comparator: comparator, order: order)
    }
  @usableFromInline
  internal init<Value>(_ keyPath: Swift.KeyPath<Compared, Value>, order: Foundation.SortOrder = .forward) where Value : Swift.Comparable
  @usableFromInline
  internal init<Value>(_ keyPath: Swift.KeyPath<Compared, Value?>, order: Foundation.SortOrder = .forward) where Value : Swift.Comparable
  @usableFromInline
  internal init<Value, Comparator>(_ keyPath: Swift.KeyPath<Compared, Value>, comparator: Comparator) where Value == Comparator.Compared, Comparator : Foundation.SortComparator
  @usableFromInline
  internal init<Value, Comparator>(_ keyPath: Swift.KeyPath<Compared, Value?>, comparator: Comparator) where Value == Comparator.Compared, Comparator : Foundation.SortComparator
  @usableFromInline
  internal init<Value, Comparator>(_ keyPath: Swift.KeyPath<Compared, Value>, comparator: Comparator, order: Foundation.SortOrder) where Value == Comparator.Compared, Comparator : Foundation.SortComparator
  @usableFromInline
  internal init<Value, Comparator>(_ keyPath: Swift.KeyPath<Compared, Value?>, comparator: Comparator, order: Foundation.SortOrder) where Value == Comparator.Compared, Comparator : Foundation.SortComparator
  public func compare(_ lhs: Compared, _ rhs: Compared) -> Foundation.ComparisonResult
  public static func == (lhs: Foundation.KeyPathComparator<Compared>, rhs: Foundation.KeyPathComparator<Compared>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct SortDescriptor<Compared> : Foundation.SortComparator, Swift.Codable, Swift.Sendable {
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public var keyPath: Swift.PartialKeyPath<Compared>? {
    get
  }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public var stringComparator: Swift.String.StandardComparator? {
    get
  }
  public var order: Foundation.SortOrder
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @_alwaysEmitIntoClient public init<Value>(_ keyPath: any Swift.KeyPath<Compared, Value> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Value : Swift.Comparable {
        self.init(keyPath as KeyPath<Compared, Value>, order: order)
    }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @_alwaysEmitIntoClient public init<Value>(_ keyPath: any Swift.KeyPath<Compared, Value?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Value : Swift.Comparable {
        self.init(keyPath as KeyPath<Compared, Value?>, order: order)
    }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.String> & Swift.Sendable, comparator: Swift.String.StandardComparator = .localizedStandard) {
        self.init(keyPath as KeyPath<Compared, String>, comparator: comparator)
    }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.String?> & Swift.Sendable, comparator: Swift.String.StandardComparator = .localizedStandard) {
        self.init(keyPath as KeyPath<Compared, String?>, comparator: comparator)
    }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.String> & Swift.Sendable, comparator: Swift.String.StandardComparator = .localizedStandard, order: Foundation.SortOrder) {
        self.init(keyPath as KeyPath<Compared, String>, comparator: comparator, order: order)
    }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.String?> & Swift.Sendable, comparator: Swift.String.StandardComparator = .localizedStandard, order: Foundation.SortOrder) {
        self.init(keyPath as KeyPath<Compared, String?>, comparator: comparator, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.Bool> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Bool>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.Bool?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Bool?>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.Double> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Double>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.Double?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Double?>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.Float> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Float>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.Float?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Float?>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.Int8> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Int8>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.Int8?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Int8?>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.Int16> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Int16>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.Int16?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Int16?>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.Int32> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Int32>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.Int32?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Int32?>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.Int64> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Int64>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.Int64?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Int64?>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.Int> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Int>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.Int?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Int?>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.UInt8> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, UInt8>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.UInt8?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, UInt8?>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.UInt16> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, UInt16>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.UInt16?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, UInt16?>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.UInt32> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, UInt32>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.UInt32?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, UInt32?>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.UInt64> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, UInt64>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.UInt64?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, UInt64?>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.UInt> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, UInt>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.UInt?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, UInt?>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Foundation.Date> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Date>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Foundation.Date?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, Date?>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Foundation.UUID> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, UUID>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Foundation.UUID?> & Swift.Sendable, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, UUID?>, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.String> & Swift.Sendable, comparator: Swift.String.StandardComparator = .localizedStandard) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, String>, comparator: comparator)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.String?> & Swift.Sendable, comparator: Swift.String.StandardComparator = .localizedStandard) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, String?>, comparator: comparator)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.String> & Swift.Sendable, comparator: Swift.String.StandardComparator = .localizedStandard, order: Foundation.SortOrder) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, String>, comparator: comparator, order: order)
    }
  @_alwaysEmitIntoClient public init(_ keyPath: any Swift.KeyPath<Compared, Swift.String?> & Swift.Sendable, comparator: Swift.String.StandardComparator = .localizedStandard, order: Foundation.SortOrder) where Compared : ObjectiveC.NSObject {
        self.init(keyPath as KeyPath<Compared, String?>, comparator: comparator, order: order)
    }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @usableFromInline
  internal init<Value>(_ keyPath: Swift.KeyPath<Compared, Value>, order: Foundation.SortOrder = .forward) where Value : Swift.Comparable
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @usableFromInline
  internal init<Value>(_ keyPath: Swift.KeyPath<Compared, Value?>, order: Foundation.SortOrder = .forward) where Value : Swift.Comparable
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.String>, comparator: Swift.String.StandardComparator = .localizedStandard)
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.String?>, comparator: Swift.String.StandardComparator = .localizedStandard)
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.String>, comparator: Swift.String.StandardComparator = .localizedStandard, order: Foundation.SortOrder)
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.String?>, comparator: Swift.String.StandardComparator = .localizedStandard, order: Foundation.SortOrder)
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.Bool>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.Bool?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.Double>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.Double?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.Float>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.Float?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.Int8>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.Int8?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.Int16>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.Int16?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.Int32>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.Int32?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.Int64>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.Int64?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.Int>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.Int?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt8>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt8?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt16>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt16?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt32>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt32?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt64>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt64?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.UInt?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Foundation.Date>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Foundation.Date?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Foundation.UUID>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Foundation.UUID?>, order: Foundation.SortOrder = .forward) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.String>, comparator: Swift.String.StandardComparator = .localizedStandard) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.String?>, comparator: Swift.String.StandardComparator = .localizedStandard) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.String>, comparator: Swift.String.StandardComparator = .localizedStandard, order: Foundation.SortOrder) where Compared : ObjectiveC.NSObject
  @usableFromInline
  internal init(_ keyPath: Swift.KeyPath<Compared, Swift.String?>, comparator: Swift.String.StandardComparator = .localizedStandard, order: Foundation.SortOrder) where Compared : ObjectiveC.NSObject
  public init?(_ descriptor: Foundation.NSSortDescriptor, comparing comparedType: Compared.Type) where Compared : ObjectiveC.NSObject
  public func compare(_ lhs: Compared, _ rhs: Compared) -> Foundation.ComparisonResult
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Foundation.SortDescriptor<Compared>, b: Foundation.SortDescriptor<Compared>) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.NSSortDescriptor {
  @backDeployed(before: iOS 17, macOS 14, tvOS 17, watchOS 10)
  convenience public init<Compared>(_ sortDescriptor: Foundation.SortDescriptor<Compared>) where Compared : ObjectiveC.NSObject {
        self.init(_sortDescriptor: sortDescriptor)
    }
  @_alwaysEmitIntoClient convenience public init<Compared>(_sortDescriptor: Foundation.SortDescriptor<Compared>) {
        self.init(_sortDescriptor)
    }
  @available(macOS, deprecated: 14, message: "Use `init(_:) where Compared: NSObject` instead. Attempt to convert SortDescriptor with Compared being non-NSObject will result in a fatalError at runtime.")
  @available(iOS, deprecated: 17, message: "Use `init(_:) where Compared: NSObject` instead. Attempt to convert SortDescriptor with Compared being non-NSObject will result in a fatalError at runtime.")
  @available(tvOS, deprecated: 17, message: "Use `init(_:) where Compared: NSObject` instead. Attempt to convert SortDescriptor with Compared being non-NSObject will result in a fatalError at runtime.")
  @available(watchOS, deprecated: 10, message: "Use `init(_:) where Compared: NSObject` instead. Attempt to convert SortDescriptor with Compared being non-NSObject will result in a fatalError at runtime.")
  @_disfavoredOverload convenience public init<Compared>(_ sortDescriptor: Foundation.SortDescriptor<Compared>)
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.String {
  public struct StandardComparator : Foundation.SortComparator, Swift.Codable, Swift.Sendable {
    public typealias Compared = Swift.String
    public static let localizedStandard: Swift.String.StandardComparator
    public static let localized: Swift.String.StandardComparator
    public static let lexical: Swift.String.StandardComparator
    public var order: Foundation.SortOrder
    public init(_ base: Swift.String.StandardComparator, order: Foundation.SortOrder = .forward)
    public init(from decoder: any Swift.Decoder) throws
    public func compare(_ lhs: Swift.String, _ rhs: Swift.String) -> Foundation.ComparisonResult
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: any Swift.Encoder) throws
    public static func == (a: Swift.String.StandardComparator, b: Swift.String.StandardComparator) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Comparator : Foundation.SortComparator, Swift.Codable, Swift.Sendable {
    public let options: Swift.String.CompareOptions
    public let locale: Foundation.Locale?
    public var order: Foundation.SortOrder
    public init(options: Swift.String.CompareOptions, locale: Foundation.Locale? = Locale.current, order: Foundation.SortOrder = .forward)
    public init(_ standardComparison: Swift.String.StandardComparator)
    public init(from decoder: any Swift.Decoder) throws
    public func compare(_ lhs: Swift.String, _ rhs: Swift.String) -> Foundation.ComparisonResult
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: any Swift.Encoder) throws
    public static func == (a: Swift.String.Comparator, b: Swift.String.Comparator) -> Swift.Bool
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Compared = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.SortComparator where Self == Swift.String.Comparator {
  public static var localizedStandard: Swift.String.Comparator {
    get
  }
  public static var localized: Swift.String.Comparator {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.StringProtocol {
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public var localizedCapitalized: Swift.String {
    get
  }
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public func capitalized(with locale: Foundation.Locale?) -> Swift.String
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public var localizedLowercase: Swift.String {
    get
  }
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public func lowercased(with locale: Foundation.Locale?) -> Swift.String
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public var localizedUppercase: Swift.String {
    get
  }
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public func uppercased(with locale: Foundation.Locale?) -> Swift.String
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.TimeZone {
  public static var knownTimeZoneIdentifiers: [Swift.String] {
    get
  }
  public static var timeZoneDataVersion: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.NSAttributedString {
  convenience public init(contentsOf url: Foundation.URL, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
  convenience public init(markdown: Foundation.Data, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
  convenience public init(markdown: Swift.String, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol _KeyValueCodingAndObserving {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension ObjectiveC.NSObject : Foundation._KeyValueCodingAndObserving {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct NSKeyValueObservedChange<Value> {
  public typealias Kind = Foundation.NSKeyValueChange
  public let kind: Foundation.NSKeyValueObservedChange<Value>.Kind
  public let newValue: Value?
  public let oldValue: Value?
  public let indexes: Foundation.IndexSet?
  public let isPrior: Swift.Bool
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSKeyValueObservedChange : Swift.Sendable where Value : Swift.Sendable {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol NSKeyValueObservingCustomization : ObjectiveC.NSObjectProtocol {
  static func keyPathsAffectingValue(for key: Swift.AnyKeyPath) -> Swift.Set<Swift.AnyKeyPath>
  static func automaticallyNotifiesObservers(for key: Swift.AnyKeyPath) -> Swift.Bool
}
@_hasMissingDesignatedInitializers @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@objc(_NSKeyValueObservation) public class NSKeyValueObservation : ObjectiveC.NSObject {
  @objc public func invalidate()
  @objc deinit
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.NSKeyValueObservation : @unchecked Swift.Sendable {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._KeyValueCodingAndObserving {
  @preconcurrency public func observe<Value>(_ keyPath: Swift.KeyPath<Self, Value>, options: Foundation.NSKeyValueObservingOptions = [], changeHandler: @escaping @Sendable (Self, Foundation.NSKeyValueObservedChange<Value>) -> Swift.Void) -> Foundation.NSKeyValueObservation
  @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.") public func willChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>)
  @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.") public func willChange<Value>(_ changeKind: Foundation.NSKeyValueChange, valuesAt indexes: Foundation.IndexSet, for keyPath: __owned Swift.KeyPath<Self, Value>)
  @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.") public func willChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>, withSetMutation mutation: Foundation.NSKeyValueSetMutationKind, using set: Swift.Set<Value>) where Value : Swift.Hashable
  @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.") public func didChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>)
  @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.") public func didChange<Value>(_ changeKind: Foundation.NSKeyValueChange, valuesAt indexes: Foundation.IndexSet, for keyPath: __owned Swift.KeyPath<Self, Value>)
  @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.") public func didChangeValue<Value>(for keyPath: __owned Swift.KeyPath<Self, Value>, withSetMutation mutation: Foundation.NSKeyValueSetMutationKind, using set: Swift.Set<Value>) where Value : Swift.Hashable
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public typealias Published = Combine.Published
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public typealias ObservableObject = Combine.ObservableObject
extension Foundation.Dimension {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  convenience public init(forLocale: Foundation.Locale)
}
extension Foundation.UnitTemperature {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_disfavoredOverload convenience public init(forLocale: Foundation.Locale, usage: Foundation.MeasurementFormatUnitUsage<Foundation.UnitTemperature> = .general)
}
extension Foundation.UnitLength {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_disfavoredOverload convenience public init(forLocale: Foundation.Locale, usage: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> = .general)
}
extension Foundation.UnitEnergy {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_disfavoredOverload convenience public init(forLocale: Foundation.Locale, usage: Foundation.MeasurementFormatUnitUsage<Foundation.UnitEnergy> = .general)
}
extension Foundation.UnitMass {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_disfavoredOverload convenience public init(forLocale: Foundation.Locale, usage: Foundation.MeasurementFormatUnitUsage<Foundation.UnitMass> = .general)
}
extension Foundation.UnitPressure {
  @available(macOS 14, iOS 16, tvOS 17, watchOS 9, *)
  @_disfavoredOverload convenience public init(forLocale: Foundation.Locale, usage: Foundation.MeasurementFormatUnitUsage<Foundation.UnitPressure> = .general)
}
extension Foundation.UnitSpeed {
  @available(macOS 14, iOS 16, tvOS 17, watchOS 9, *)
  @_disfavoredOverload convenience public init(forLocale: Foundation.Locale, usage: Foundation.MeasurementFormatUnitUsage<Foundation.UnitSpeed> = .general)
}
extension Foundation.UnitVolume {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_disfavoredOverload convenience public init(forLocale: Foundation.Locale, usage: Foundation.MeasurementFormatUnitUsage<Foundation.UnitVolume> = .general)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._NSRange : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout Foundation.NSRange?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout Foundation.NSRange?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> Foundation.NSRange
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSValue
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CoreFoundation.CGRect : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGRect?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGRect?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreFoundation.CGRect
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSValue
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CoreFoundation.CGPoint : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGPoint?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGPoint?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreFoundation.CGPoint
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSValue
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CoreFoundation.CGVector : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGVector?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGVector?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreFoundation.CGVector
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSValue
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CoreFoundation.CGSize : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGSize?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGSize?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreFoundation.CGSize
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSValue
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CoreFoundation.CGAffineTransform : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.NSValue
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGAffineTransform?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue, result: inout CoreFoundation.CGAffineTransform?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSValue?) -> CoreFoundation.CGAffineTransform
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSValue
}
extension Foundation.NSValue {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func value<StoredType>(of type: StoredType.Type) -> StoredType?
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.RunLoop : Combine.Scheduler {
  public struct SchedulerTimeType : Swift.Strideable, Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var date: Foundation.Date
    public init(_ date: Foundation.Date)
    public func distance(to other: Foundation.RunLoop.SchedulerTimeType) -> Foundation.RunLoop.SchedulerTimeType.Stride
    public func advanced(by n: Foundation.RunLoop.SchedulerTimeType.Stride) -> Foundation.RunLoop.SchedulerTimeType
    public struct Stride : Swift.ExpressibleByFloatLiteral, Swift.Comparable, Swift.SignedNumeric, Swift.Codable, Combine.SchedulerTimeIntervalConvertible, Swift.Sendable {
      public typealias FloatLiteralType = Foundation.TimeInterval
      public typealias IntegerLiteralType = Foundation.TimeInterval
      public typealias Magnitude = Foundation.TimeInterval
      public var magnitude: Foundation.TimeInterval
      public var timeInterval: Foundation.TimeInterval {
        get
      }
      public init(integerLiteral value: Foundation.TimeInterval)
      public init(floatLiteral value: Foundation.TimeInterval)
      public init(_ timeInterval: Foundation.TimeInterval)
      public init?<T>(exactly source: T) where T : Swift.BinaryInteger
      public static func < (lhs: Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride) -> Swift.Bool
      public static func * (lhs: Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func + (lhs: Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func - (lhs: Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func *= (lhs: inout Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride)
      public static func += (lhs: inout Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride)
      public static func -= (lhs: inout Foundation.RunLoop.SchedulerTimeType.Stride, rhs: Foundation.RunLoop.SchedulerTimeType.Stride)
      public static func seconds(_ s: Swift.Int) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func seconds(_ s: Swift.Double) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func milliseconds(_ ms: Swift.Int) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func microseconds(_ us: Swift.Int) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func nanoseconds(_ ns: Swift.Int) -> Foundation.RunLoop.SchedulerTimeType.Stride
      public static func == (a: Foundation.RunLoop.SchedulerTimeType.Stride, b: Foundation.RunLoop.SchedulerTimeType.Stride) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
    }
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct SchedulerOptions : Swift.Sendable {
  }
  public func schedule(options: Foundation.RunLoop.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Foundation.RunLoop.SchedulerTimeType, tolerance: Foundation.RunLoop.SchedulerTimeType.Stride, options: Foundation.RunLoop.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Foundation.RunLoop.SchedulerTimeType, interval: Foundation.RunLoop.SchedulerTimeType.Stride, tolerance: Foundation.RunLoop.SchedulerTimeType.Stride, options: Foundation.RunLoop.SchedulerOptions?, _ action: @escaping () -> Swift.Void) -> any Combine.Cancellable
  public var now: Foundation.RunLoop.SchedulerTimeType {
    get
  }
  public var minimumTolerance: Foundation.RunLoop.SchedulerTimeType.Stride {
    get
  }
}
extension Foundation.URL {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public struct ParseStrategy : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public init(scheme: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .required, user: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional, password: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional, host: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .required, port: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.Int> = .optional, path: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional, query: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional, fragment: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional)
    public static func == (a: Foundation.URL.ParseStrategy, b: Foundation.URL.ParseStrategy) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.ParseStrategy {
  public enum ComponentParseStrategy<Component> : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible, Swift.Sendable where Component : Swift.Decodable, Component : Swift.Encodable, Component : Swift.Hashable, Component : Swift.Sendable {
    case required
    case optional
    case defaultValue(Component)
    public var description: Swift.String {
      get
    }
    public static func == (a: Foundation.URL.ParseStrategy.ComponentParseStrategy<Component>, b: Foundation.URL.ParseStrategy.ComponentParseStrategy<Component>) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.ParseStrategy {
  public func scheme(_ strategy: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .required) -> Foundation.URL.ParseStrategy
  public func user(_ strategy: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional) -> Foundation.URL.ParseStrategy
  public func password(_ strategy: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional) -> Foundation.URL.ParseStrategy
  public func host(_ strategy: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .required) -> Foundation.URL.ParseStrategy
  public func port(_ strategy: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.Int> = .optional) -> Foundation.URL.ParseStrategy
  public func path(_ strategy: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional) -> Foundation.URL.ParseStrategy
  public func query(_ strategy: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional) -> Foundation.URL.ParseStrategy
  public func fragment(_ strategy: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional) -> Foundation.URL.ParseStrategy
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.ParseStrategy : Foundation.ParseStrategy {
  public func parse(_ value: Swift.String) throws -> Foundation.URL
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias ParseInput = Swift.String
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias ParseOutput = Foundation.URL
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.ParseStrategy where Self == Foundation.URL.ParseStrategy {
  public static var url: Foundation.URL.ParseStrategy {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL {
  public init<T>(_ value: T.ParseInput, strategy: T) throws where T : Foundation.ParseStrategy, T.ParseOutput == Foundation.URL
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.ParseStrategy : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Foundation.URL
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Foundation.URL)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.URL.ParseStrategy {
  public static func url(scheme: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .required, user: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional, password: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional, host: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .required, port: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.Int> = .optional, path: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional, query: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional, fragment: Foundation.URL.ParseStrategy.ComponentParseStrategy<Swift.String> = .optional) -> Self
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.FileManager {
  @available(*, deprecated, renamed: "replaceItemAt(_:withItemAt:backupItemName:options:)")
  public func replaceItemAtURL(originalItemURL: Foundation.NSURL, withItemAtURL newItemURL: Foundation.NSURL, backupItemName: Swift.String? = nil, options: Foundation.FileManager.ItemReplacementOptions = []) throws -> Foundation.NSURL?
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  @available(swift, obsoleted: 4)
  public func replaceItemAt(_ originalItemURL: Foundation.URL, withItemAt newItemURL: Foundation.URL, backupItemName: Swift.String? = nil, options: Foundation.FileManager.ItemReplacementOptions = []) throws -> Foundation.NSURL?
  @available(swift 4)
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public func replaceItemAt(_ originalItemURL: Foundation.URL, withItemAt newItemURL: Foundation.URL, backupItemName: Swift.String? = nil, options: Foundation.FileManager.ItemReplacementOptions = []) throws -> Foundation.URL?
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  @nonobjc public func enumerator(at url: Foundation.URL, includingPropertiesForKeys keys: [Foundation.URLResourceKey]?, options mask: Foundation.FileManager.DirectoryEnumerationOptions = [], errorHandler handler: ((Foundation.URL, any Swift.Error) -> Swift.Bool)? = nil) -> Foundation.FileManager.DirectoryEnumerator?
}
extension Foundation.FileHandle {
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  public func readToEnd() throws -> Foundation.Data?
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  public func read(upToCount count: Swift.Int) throws -> Foundation.Data?
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  public func offset() throws -> Swift.UInt64
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  @discardableResult
  public func seekToEnd() throws -> Swift.UInt64
  @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
  @_specialize(exported: false, kind: full, where T == Foundation.Data)
  @_specialize(exported: false, kind: full, where T == Dispatch.DispatchData)
  public func write<T>(contentsOf data: T) throws where T : Foundation.DataProtocol
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct CharacterSet : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable, Swift.SetAlgebra {
  public typealias ReferenceType = Foundation.NSCharacterSet
  public init()
  public init(charactersIn range: Swift.Range<Swift.Unicode.Scalar>)
  public init(charactersIn range: Swift.ClosedRange<Swift.Unicode.Scalar>)
  public init(charactersIn string: __shared Swift.String)
  public init(bitmapRepresentation data: __shared Foundation.Data)
  public init?(contentsOfFile file: __shared Swift.String)
  public static var controlCharacters: Foundation.CharacterSet {
    get
  }
  public static var whitespaces: Foundation.CharacterSet {
    get
  }
  public static var whitespacesAndNewlines: Foundation.CharacterSet {
    get
  }
  public static var decimalDigits: Foundation.CharacterSet {
    get
  }
  public static var letters: Foundation.CharacterSet {
    get
  }
  public static var lowercaseLetters: Foundation.CharacterSet {
    get
  }
  public static var uppercaseLetters: Foundation.CharacterSet {
    get
  }
  public static var nonBaseCharacters: Foundation.CharacterSet {
    get
  }
  public static var alphanumerics: Foundation.CharacterSet {
    get
  }
  public static var decomposables: Foundation.CharacterSet {
    get
  }
  public static var illegalCharacters: Foundation.CharacterSet {
    get
  }
  public static var punctuationCharacters: Foundation.CharacterSet {
    get
  }
  public static var capitalizedLetters: Foundation.CharacterSet {
    get
  }
  public static var symbols: Foundation.CharacterSet {
    get
  }
  public static var newlines: Foundation.CharacterSet {
    get
  }
  public static var urlUserAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlPasswordAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlHostAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlPathAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlQueryAllowed: Foundation.CharacterSet {
    get
  }
  public static var urlFragmentAllowed: Foundation.CharacterSet {
    get
  }
  @nonobjc public var bitmapRepresentation: Foundation.Data {
    get
  }
  @nonobjc public var inverted: Foundation.CharacterSet {
    get
  }
  public func hasMember(inPlane plane: Swift.UInt8) -> Swift.Bool
  public mutating func insert(charactersIn range: Swift.Range<Swift.Unicode.Scalar>)
  public mutating func insert(charactersIn range: Swift.ClosedRange<Swift.Unicode.Scalar>)
  public mutating func remove(charactersIn range: Swift.Range<Swift.Unicode.Scalar>)
  public mutating func remove(charactersIn range: Swift.ClosedRange<Swift.Unicode.Scalar>)
  public mutating func insert(charactersIn string: Swift.String)
  public mutating func remove(charactersIn string: Swift.String)
  public mutating func invert()
  @discardableResult
  public mutating func insert(_ character: Swift.Unicode.Scalar) -> (inserted: Swift.Bool, memberAfterInsert: Swift.Unicode.Scalar)
  @discardableResult
  public mutating func update(with character: Swift.Unicode.Scalar) -> Swift.Unicode.Scalar?
  @discardableResult
  public mutating func remove(_ character: Swift.Unicode.Scalar) -> Swift.Unicode.Scalar?
  public func contains(_ member: Swift.Unicode.Scalar) -> Swift.Bool
  public func union(_ other: Foundation.CharacterSet) -> Foundation.CharacterSet
  public mutating func formUnion(_ other: Foundation.CharacterSet)
  public func intersection(_ other: Foundation.CharacterSet) -> Foundation.CharacterSet
  public mutating func formIntersection(_ other: Foundation.CharacterSet)
  public func subtracting(_ other: Foundation.CharacterSet) -> Foundation.CharacterSet
  public mutating func subtract(_ other: Foundation.CharacterSet)
  public func symmetricDifference(_ other: Foundation.CharacterSet) -> Foundation.CharacterSet
  public mutating func formSymmetricDifference(_ other: Foundation.CharacterSet)
  public func isSuperset(of other: Foundation.CharacterSet) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.CharacterSet, rhs: Foundation.CharacterSet) -> Swift.Bool
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias ArrayLiteralElement = Swift.Unicode.Scalar
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Element = Swift.Unicode.Scalar
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.CharacterSet : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSCharacterSet
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSCharacterSet, result: inout Foundation.CharacterSet?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSCharacterSet, result: inout Foundation.CharacterSet?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSCharacterSet?) -> Foundation.CharacterSet
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSCharacterSet
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.CharacterSet : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSCharacterSet : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.CharacterSet : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.CharacterSet : Swift.Sendable {
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
public struct Measurement<UnitType> : Foundation.ReferenceConvertible, Swift.Comparable, Swift.Equatable where UnitType : Foundation.Unit {
  public typealias ReferenceType = Foundation.NSMeasurement
  public let unit: UnitType
  public var value: Swift.Double
  public init(value: Swift.Double, unit: UnitType)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.Measurement : Swift.Sendable {
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.Measurement : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.Measurement where UnitType : Foundation.Dimension {
  public func converted(to otherUnit: UnitType) -> Foundation.Measurement<UnitType>
  public mutating func convert(to otherUnit: UnitType)
  public static func + (lhs: Foundation.Measurement<UnitType>, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func - (lhs: Foundation.Measurement<UnitType>, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.Measurement {
  public static func + (lhs: Foundation.Measurement<UnitType>, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func - (lhs: Foundation.Measurement<UnitType>, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func * (lhs: Foundation.Measurement<UnitType>, rhs: Swift.Double) -> Foundation.Measurement<UnitType>
  public static func * (lhs: Swift.Double, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func / (lhs: Foundation.Measurement<UnitType>, rhs: Swift.Double) -> Foundation.Measurement<UnitType>
  public static func / (lhs: Swift.Double, rhs: Foundation.Measurement<UnitType>) -> Foundation.Measurement<UnitType>
  public static func == <LeftHandSideType, RightHandSideType>(lhs: Foundation.Measurement<LeftHandSideType>, rhs: Foundation.Measurement<RightHandSideType>) -> Swift.Bool where LeftHandSideType : Foundation.Unit, RightHandSideType : Foundation.Unit
  public static func < <LeftHandSideType, RightHandSideType>(lhs: Foundation.Measurement<LeftHandSideType>, rhs: Foundation.Measurement<RightHandSideType>) -> Swift.Bool where LeftHandSideType : Foundation.Unit, RightHandSideType : Foundation.Unit
}
@usableFromInline
internal typealias MeasurementBridgeType = Swift._ObjectiveCBridgeable
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.Measurement : Foundation.MeasurementBridgeType {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSMeasurement
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSMeasurement, result: inout Foundation.Measurement<UnitType>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSMeasurement, result: inout Foundation.Measurement<UnitType>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSMeasurement?) -> Foundation.Measurement<UnitType>
  @available(iOS 10.0, tvOS 10.0, watchOS 3.0, macOS 10.12, *)
  public typealias _ObjectiveCType = Foundation.NSMeasurement
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.NSMeasurement : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.Measurement : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSCoder {
  public func decodeObject<DecodedObjectType>(of cls: DecodedObjectType.Type, forKey key: Swift.String) -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @nonobjc public func decodeObject(of classes: [Swift.AnyClass]?, forKey key: Swift.String) -> Any?
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @nonobjc public func decodeTopLevelObject() throws -> Any?
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  @available(swift, obsoleted: 4)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @nonobjc public func decodeTopLevelObject(forKey key: Swift.String) throws -> Swift.AnyObject?
  @available(swift 4)
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
  @nonobjc public func decodeTopLevelObject(forKey key: Swift.String) throws -> Any?
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public func decodeTopLevelObject<DecodedObjectType>(of cls: DecodedObjectType.Type, forKey key: Swift.String) throws -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  @nonobjc public func decodeTopLevelObject(of classes: [Swift.AnyClass]?, forKey key: Swift.String) throws -> Any?
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public func decodeArrayOfObjects<DecodedObject>(ofClass cls: DecodedObject.Type, forKey key: Swift.String) -> [DecodedObject]? where DecodedObject : ObjectiveC.NSObject, DecodedObject : Foundation.NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public func decodeArrayOfObjects(ofClasses classes: [Swift.AnyClass], forKey key: Swift.String) -> [Any]?
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public func decodeDictionary<DecodedKey, DecodedObject>(withKeyClass keyClass: DecodedKey.Type, objectClass: DecodedObject.Type, forKey key: Swift.String) -> [DecodedKey : DecodedObject]? where DecodedKey : ObjectiveC.NSObject, DecodedKey : Foundation.NSCopying, DecodedKey : Foundation.NSSecureCoding, DecodedObject : ObjectiveC.NSObject, DecodedObject : Foundation.NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public func decodeDictionary(withKeysOfClasses keyClasses: [Swift.AnyClass], objectsOfClasses classes: [Swift.AnyClass], forKey key: Swift.String) -> [Swift.AnyHashable : Any]?
}
extension Foundation.NSKeyedArchiver {
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  @nonobjc public func encodeEncodable<T>(_ value: T, forKey key: Swift.String) throws where T : Swift.Encodable
}
extension Foundation.NSKeyedUnarchiver {
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  @available(swift, obsoleted: 4)
  @available(macOS, introduced: 10.11, deprecated: 10.14, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(iOS, introduced: 9.0, deprecated: 12.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 12.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 5.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @nonobjc public class func unarchiveTopLevelObjectWithData(_ data: Foundation.NSData) throws -> Swift.AnyObject?
  @available(swift 4)
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  @available(macOS, introduced: 10.11, deprecated: 10.14, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(iOS, introduced: 9.0, deprecated: 12.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 12.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 5.0, message: "Use unarchivedObject(ofClass:from:) instead")
  @nonobjc public class func unarchiveTopLevelObjectWithData(_ data: Foundation.Data) throws -> Any?
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  @nonobjc public static func unarchivedObject<DecodedObjectType>(ofClass cls: DecodedObjectType.Type, from data: Foundation.Data) throws -> DecodedObjectType? where DecodedObjectType : ObjectiveC.NSObject, DecodedObjectType : Foundation.NSCoding
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  @nonobjc public static func unarchivedObject(ofClasses classes: [Swift.AnyClass], from data: Foundation.Data) throws -> Any?
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  @nonobjc public func decodeDecodable<T>(_ type: T.Type, forKey key: Swift.String) -> T? where T : Swift.Decodable
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  @nonobjc public func decodeTopLevelDecodable<T>(_ type: T.Type, forKey key: Swift.String) throws -> T? where T : Swift.Decodable
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public static func unarchivedArrayOfObjects<DecodedObject>(ofClass cls: DecodedObject.Type, from data: Foundation.Data) throws -> [DecodedObject]? where DecodedObject : ObjectiveC.NSObject, DecodedObject : Foundation.NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public static func unarchivedArrayOfObjects(ofClasses classes: [Swift.AnyClass], from data: Foundation.Data) throws -> [Any]?
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public static func unarchivedDictionary<DecodedKey, DecodedObject>(ofKeyClass keyClass: DecodedKey.Type, objectClass: DecodedObject.Type, from data: Foundation.Data) throws -> [DecodedKey : DecodedObject]? where DecodedKey : ObjectiveC.NSObject, DecodedKey : Foundation.NSCopying, DecodedKey : Foundation.NSSecureCoding, DecodedObject : ObjectiveC.NSObject, DecodedObject : Foundation.NSSecureCoding
  @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
  @nonobjc public static func unarchivedDictionary(keysOfClasses keyClasses: [Swift.AnyClass], objectsOfClasses objectClasses: [Swift.AnyClass], from data: Foundation.Data) throws -> [Swift.AnyHashable : Any]?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSSortDescriptor {
  convenience public init<Root, Value>(keyPath: Swift.KeyPath<Root, Value>, ascending: Swift.Bool)
  convenience public init<Root, Value>(keyPath: Swift.KeyPath<Root, Value>, ascending: Swift.Bool, comparator cmptr: @escaping Foundation.Comparator)
  public var keyPath: Swift.AnyKeyPath? {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct MachError : Foundation._BridgedStoredNSError {
  public let _nsError: Foundation.NSError
  public init(_nsError error: Foundation.NSError)
  public static var errorDomain: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public typealias Code = Darwin.MachErrorCode
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Darwin.MachErrorCode : Foundation._ErrorCodeProtocol {
  public typealias _ErrorType = Foundation.MachError
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.MachError {
  public static var success: Foundation.MachError.Code {
    get
  }
  public static var invalidAddress: Foundation.MachError.Code {
    get
  }
  public static var protectionFailure: Foundation.MachError.Code {
    get
  }
  public static var noSpace: Foundation.MachError.Code {
    get
  }
  public static var invalidArgument: Foundation.MachError.Code {
    get
  }
  public static var failure: Foundation.MachError.Code {
    get
  }
  public static var resourceShortage: Foundation.MachError.Code {
    get
  }
  public static var notReceiver: Foundation.MachError.Code {
    get
  }
  public static var noAccess: Foundation.MachError.Code {
    get
  }
  public static var memoryFailure: Foundation.MachError.Code {
    get
  }
  public static var memoryError: Foundation.MachError.Code {
    get
  }
  public static var alreadyInSet: Foundation.MachError.Code {
    get
  }
  public static var notInSet: Foundation.MachError.Code {
    get
  }
  public static var nameExists: Foundation.MachError.Code {
    get
  }
  public static var aborted: Foundation.MachError.Code {
    get
  }
  public static var invalidName: Foundation.MachError.Code {
    get
  }
  public static var invalidTask: Foundation.MachError.Code {
    get
  }
  public static var invalidRight: Foundation.MachError.Code {
    get
  }
  public static var invalidValue: Foundation.MachError.Code {
    get
  }
  public static var userReferencesOverflow: Foundation.MachError.Code {
    get
  }
  public static var invalidCapability: Foundation.MachError.Code {
    get
  }
  public static var rightExists: Foundation.MachError.Code {
    get
  }
  public static var invalidHost: Foundation.MachError.Code {
    get
  }
  public static var memoryPresent: Foundation.MachError.Code {
    get
  }
  public static var memoryDataMoved: Foundation.MachError.Code {
    get
  }
  public static var memoryRestartCopy: Foundation.MachError.Code {
    get
  }
  public static var invalidProcessorSet: Foundation.MachError.Code {
    get
  }
  public static var policyLimit: Foundation.MachError.Code {
    get
  }
  public static var invalidPolicy: Foundation.MachError.Code {
    get
  }
  public static var invalidObject: Foundation.MachError.Code {
    get
  }
  public static var alreadyWaiting: Foundation.MachError.Code {
    get
  }
  public static var defaultSet: Foundation.MachError.Code {
    get
  }
  public static var exceptionProtected: Foundation.MachError.Code {
    get
  }
  public static var invalidLedger: Foundation.MachError.Code {
    get
  }
  public static var invalidMemoryControl: Foundation.MachError.Code {
    get
  }
  public static var invalidSecurity: Foundation.MachError.Code {
    get
  }
  public static var notDepressed: Foundation.MachError.Code {
    get
  }
  public static var terminated: Foundation.MachError.Code {
    get
  }
  public static var lockSetDestroyed: Foundation.MachError.Code {
    get
  }
  public static var lockUnstable: Foundation.MachError.Code {
    get
  }
  public static var lockOwned: Foundation.MachError.Code {
    get
  }
  public static var lockOwnedSelf: Foundation.MachError.Code {
    get
  }
  public static var semaphoreDestroyed: Foundation.MachError.Code {
    get
  }
  public static var rpcServerTerminated: Foundation.MachError.Code {
    get
  }
  public static var rpcTerminateOrphan: Foundation.MachError.Code {
    get
  }
  public static var rpcContinueOrphan: Foundation.MachError.Code {
    get
  }
  public static var notSupported: Foundation.MachError.Code {
    get
  }
  public static var nodeDown: Foundation.MachError.Code {
    get
  }
  public static var notWaiting: Foundation.MachError.Code {
    get
  }
  public static var operationTimedOut: Foundation.MachError.Code {
    get
  }
  public static var codesignError: Foundation.MachError.Code {
    get
  }
  public static var policyStatic: Foundation.MachError.Code {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct AsyncLineSequence<Base> : _Concurrency.AsyncSequence where Base : _Concurrency.AsyncSequence, Base.Element == Swift.UInt8 {
  public typealias Element = Swift.String
  public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    public typealias Element = Swift.String
    @_specialize(exported: false, kind: full, where Base == Foundation.URL.AsyncBytes)
    @_specialize(exported: false, kind: full, where Base == Foundation.FileHandle.AsyncBytes)
    @_specialize(exported: false, kind: full, where Base == Foundation.URLSession.AsyncBytes)
    public mutating func next() async rethrows -> Swift.String?
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Base.Failure
  }
  public func makeAsyncIterator() -> Foundation.AsyncLineSequence<Base>.AsyncIterator
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Base.Failure
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.AsyncLineSequence : Swift.Sendable where Base : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.AsyncLineSequence.AsyncIterator : Swift.Sendable where Base.AsyncIterator : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension _Concurrency.AsyncSequence where Self.Element == Swift.UInt8 {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var lines: Foundation.AsyncLineSequence<Self> {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.URLSession {
  public func dataTaskPublisher(for url: Foundation.URL) -> Foundation.URLSession.DataTaskPublisher
  public func dataTaskPublisher(for request: Foundation.URLRequest) -> Foundation.URLSession.DataTaskPublisher
  public struct DataTaskPublisher : Combine.Publisher, Swift.Sendable {
    public typealias Output = (data: Foundation.Data, response: Foundation.URLResponse)
    public typealias Failure = Foundation.URLError
    public let request: Foundation.URLRequest
    public let session: Foundation.URLSession
    public init(request: Foundation.URLRequest, session: Foundation.URLSession)
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Foundation.URLError, S.Input == (data: Foundation.Data, response: Foundation.URLResponse)
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSArray : Swift.ExpressibleByArrayLiteral {
  required convenience public init(arrayLiteral elements: Any...)
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias ArrayLiteralElement = Any
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Array : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSArray
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSArray, result: inout Swift.Array<Element>?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSArray, result: inout Swift.Array<Element>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSArray?) -> Swift.Array<Element>
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSArray
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSArray : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSArray : Swift.Sequence {
  final public func makeIterator() -> Foundation.NSFastEnumerationIterator
  @_alwaysEmitIntoClient @nonobjc public var underestimatedCount: Swift.Int {
    get { count }
  }
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Element = Any
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSArray {
  convenience public init(objects elements: Any...)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSArray {
  @nonobjc convenience public init(array anArray: __shared Foundation.NSArray)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSArray : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Array : Swift.CVarArg {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSSet : Swift.Sequence {
  public func makeIterator() -> Foundation.NSFastEnumerationIterator
  @_alwaysEmitIntoClient @nonobjc public var underestimatedCount: Swift.Int {
    get { count }
  }
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Element = Any
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSOrderedSet : Swift.Sequence {
  public func makeIterator() -> Foundation.NSFastEnumerationIterator
  @_alwaysEmitIntoClient @nonobjc public var underestimatedCount: Swift.Int {
    get { count }
  }
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Element = Any
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Set : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSSet
  public static func _forceBridgeFromObjectiveC(_ s: Foundation.NSSet, result: inout Swift.Set<Element>?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSSet, result: inout Swift.Set<Element>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ s: Foundation.NSSet?) -> Swift.Set<Element>
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSSet
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSSet : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSOrderedSet {
  convenience public init(objects elements: Any...)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSSet {
  convenience public init(objects elements: Any...)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSSet : Swift.ExpressibleByArrayLiteral {
  required convenience public init(arrayLiteral elements: Any...)
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias ArrayLiteralElement = Any
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSOrderedSet : Swift.ExpressibleByArrayLiteral {
  required convenience public init(arrayLiteral elements: Any...)
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias ArrayLiteralElement = Any
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSSet {
  @nonobjc convenience public init(set anSet: __shared Foundation.NSSet)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSSet : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Set : Swift.CVarArg {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSData : Foundation.DataProtocol {
  @nonobjc public var startIndex: Swift.Int {
    get
  }
  @nonobjc public var endIndex: Swift.Int {
    get
  }
  @nonobjc public func lastRange<D, R>(of data: D, in r: R) -> Swift.Range<Swift.Int>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, R.Bound == Swift.Int
  @nonobjc public func firstRange<D, R>(of data: D, in r: R) -> Swift.Range<Swift.Int>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, R.Bound == Swift.Int
  @nonobjc public var regions: [Foundation.Data] {
    get
  }
  @nonobjc public subscript(position: Swift.Int) -> Swift.UInt8 {
    get
  }
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Element = Swift.UInt8
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Index = Swift.Int
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Indices = Swift.Range<Swift.Int>
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Iterator = Swift.IndexingIterator<Foundation.NSData>
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Regions = [Foundation.Data]
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias SubSequence = Swift.Slice<Foundation.NSData>
}
@available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
public struct PersonNameComponents : Foundation.ReferenceConvertible, Swift.Hashable, Swift.Equatable, Swift.Sendable {
  public typealias ReferenceType = Foundation.NSPersonNameComponents
  public init()
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public init(namePrefix: Swift.String? = nil, givenName: Swift.String? = nil, middleName: Swift.String? = nil, familyName: Swift.String? = nil, nameSuffix: Swift.String? = nil, nickname: Swift.String? = nil, phoneticRepresentation: Foundation.PersonNameComponents? = nil)
  public var namePrefix: Swift.String? {
    get
    set
  }
  public var givenName: Swift.String? {
    get
    set
  }
  public var middleName: Swift.String? {
    get
    set
  }
  public var familyName: Swift.String? {
    get
    set
  }
  public var nameSuffix: Swift.String? {
    get
    set
  }
  public var nickname: Swift.String? {
    get
    set
  }
  public var phoneticRepresentation: Foundation.PersonNameComponents? {
    get
    set
  }
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public static func == (lhs: Foundation.PersonNameComponents, rhs: Foundation.PersonNameComponents) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.PersonNameComponents : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.PersonNameComponents : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSPersonNameComponents
  public static func _forceBridgeFromObjectiveC(_ personNameComponents: Foundation.NSPersonNameComponents, result: inout Foundation.PersonNameComponents?)
  public static func _conditionallyBridgeFromObjectiveC(_ personNameComponents: Foundation.NSPersonNameComponents, result: inout Foundation.PersonNameComponents?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSPersonNameComponents?) -> Foundation.PersonNameComponents
  @available(iOS 9.0, tvOS 9.0, watchOS 2.0, macOS 10.11, *)
  public typealias _ObjectiveCType = Foundation.NSPersonNameComponents
}
@available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSPersonNameComponents : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.PersonNameComponents : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Measurement where UnitType : Foundation.Dimension {
  @dynamicMemberLookup public struct AttributedStyle : Foundation.FormatStyle, Swift.Sendable {
    public func format(_ measurement: Foundation.Measurement<UnitType>) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.Measurement<UnitType>.AttributedStyle
    public static func == (a: Foundation.Measurement<UnitType>.AttributedStyle, b: Foundation.Measurement<UnitType>.AttributedStyle) -> Swift.Bool
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Foundation.Measurement<UnitType>
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Measurement.AttributedStyle where UnitType == Foundation.UnitInformationStorage {
  public struct ByteCount : Foundation.FormatStyle, Swift.Sendable {
    public typealias Style = Foundation.ByteCountFormatStyle.Style
    public typealias Units = Foundation.ByteCountFormatStyle.Units
    public var style: Foundation.Measurement<Foundation.UnitInformationStorage>.AttributedStyle.ByteCount.Style {
      get
      set
    }
    public var allowedUnits: Foundation.Measurement<Foundation.UnitInformationStorage>.AttributedStyle.ByteCount.Units {
      get
      set
    }
    public var spellsOutZero: Swift.Bool {
      get
      set
    }
    public var includesActualByteCount: Swift.Bool {
      get
      set
    }
    public var locale: Foundation.Locale {
      get
      set
    }
    public init(style: Foundation.Measurement<UnitType>.AttributedStyle.ByteCount.Style, allowedUnits: Foundation.Measurement<UnitType>.AttributedStyle.ByteCount.Units, spellsOutZero: Swift.Bool, includesActualByteCount: Swift.Bool, locale: Foundation.Locale)
    public func format(_ value: Foundation.Measurement<Foundation.UnitInformationStorage>) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.Measurement<UnitType>.AttributedStyle.ByteCount
    public static func == (a: Foundation.Measurement<UnitType>.AttributedStyle.ByteCount, b: Foundation.Measurement<UnitType>.AttributedStyle.ByteCount) -> Swift.Bool
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias FormatInput = Foundation.Measurement<Foundation.UnitInformationStorage>
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Measurement.AttributedStyle {
  public subscript<T>(dynamicMember key: Swift.KeyPath<Foundation.Measurement<UnitType>.FormatStyle, T>) -> T {
    get
  }
  public subscript<T>(dynamicMember key: Swift.WritableKeyPath<Foundation.Measurement<UnitType>.FormatStyle, T>) -> T {
    get
    set
  }
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.MeasurementFormatter {
  public func string<UnitType>(from measurement: Foundation.Measurement<UnitType>) -> Swift.String where UnitType : Foundation.Unit
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public struct Morphology : Swift.Sendable {
  public init()
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public enum GrammaticalGender : Swift.Int, Swift.Hashable, Swift.Sendable {
    case feminine
    case masculine
    case neuter
    public init?(rawValue: Swift.Int)
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var grammaticalGender: Foundation.Morphology.GrammaticalGender?
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public enum PartOfSpeech : Swift.Int, Swift.Hashable, Swift.Sendable {
    case determiner
    case pronoun
    case letter
    case adverb
    case particle
    case adjective
    case adposition
    case verb
    case noun
    case conjunction
    case numeral
    case interjection
    case preposition
    case abbreviation
    public init?(rawValue: Swift.Int)
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var partOfSpeech: Foundation.Morphology.PartOfSpeech?
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public enum GrammaticalNumber : Swift.Int, Swift.Hashable, Swift.Sendable {
    case singular
    case zero
    case plural
    case pluralTwo
    case pluralFew
    case pluralMany
    public init?(rawValue: Swift.Int)
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var number: Foundation.Morphology.GrammaticalNumber?
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public enum GrammaticalCase : Swift.Int, Swift.Hashable, Swift.Sendable {
    case nominative, accusative, dative, genitive, prepositional, ablative, adessive, allative, elative, illative, essive, inessive, locative, translative
    public init?(rawValue: Swift.Int)
    @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public var grammaticalCase: Foundation.Morphology.GrammaticalCase?
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public enum GrammaticalPerson : Swift.Int, Swift.Hashable, Swift.Sendable {
    case first, second, third
    public init?(rawValue: Swift.Int)
    @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public var grammaticalPerson: Foundation.Morphology.GrammaticalPerson?
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public enum PronounType : Swift.Int, Swift.Hashable, Swift.Sendable {
    case personal, reflexive, possessive
    public init?(rawValue: Swift.Int)
    @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public var pronounType: Foundation.Morphology.PronounType?
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public enum Determination : Swift.Int, Swift.Hashable, Swift.Sendable {
    case independent, dependent
    public init?(rawValue: Swift.Int)
    @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public var determination: Foundation.Morphology.Determination?
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public enum Definiteness : Swift.Int, Swift.Hashable, Swift.Sendable {
    case indefinite, definite
    public init?(rawValue: Swift.Int)
    @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public var definiteness: Foundation.Morphology.Definiteness?
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public enum InflectionRule : Swift.Sendable {
  case automatic
  case explicit(Foundation.Morphology)
  public init(morphology: Foundation.Morphology)
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology : Swift.Hashable {
  public static func == (a: Foundation.Morphology, b: Foundation.Morphology) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.InflectionRule : Swift.Hashable {
  public static func == (a: Foundation.InflectionRule, b: Foundation.InflectionRule) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology.GrammaticalGender : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology.GrammaticalNumber : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology.PartOfSpeech : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Morphology.GrammaticalCase : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Morphology.Determination : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Morphology.Definiteness : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Morphology.GrammaticalPerson : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Morphology.PronounType : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.InflectionRule : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.InflectionRule {
  public static func canInflect(language: Swift.String) -> Swift.Bool
  public static var canInflectPreferredLocalization: Swift.Bool {
    get
  }
}
@available(macOS, introduced: 12.0, deprecated: 14.0, message: "Use TermOfAddress instead")
@available(iOS, introduced: 15.0, deprecated: 17.0, message: "Use TermOfAddress instead")
@available(tvOS, introduced: 15.0, deprecated: 17.0, message: "Use TermOfAddress instead")
@available(watchOS, introduced: 8.0, deprecated: 10.0, message: "Use TermOfAddress instead")
extension Foundation.Morphology {
  public func customPronoun(forLanguage language: Swift.String) -> Foundation.Morphology.CustomPronoun?
  public mutating func setCustomPronoun(_ pronoun: Foundation.Morphology.CustomPronoun?, forLanguage language: Swift.String) throws
  @available(macOS, introduced: 12.0, deprecated: 14.0, message: "Use TermOfAddress instead")
  @available(iOS, introduced: 15.0, deprecated: 17.0, message: "Use TermOfAddress instead")
  @available(tvOS, introduced: 15.0, deprecated: 17.0, message: "Use TermOfAddress instead")
  @available(watchOS, introduced: 8.0, deprecated: 10.0, message: "Use TermOfAddress instead")
  public struct CustomPronoun : Swift.Sendable, Swift.Codable, Swift.Hashable, Swift.Equatable {
    public init()
    public static func isSupported(forLanguage language: Swift.String) -> Swift.Bool
    public static func requiredKeys(forLanguage language: Swift.String) -> [Swift.PartialKeyPath<Foundation.Morphology.CustomPronoun>]
    public var subjectForm: Swift.String? {
      get
      set
    }
    public var objectForm: Swift.String? {
      get
      set
    }
    public var possessiveForm: Swift.String? {
      get
      set
    }
    public var possessiveAdjectiveForm: Swift.String? {
      get
      set
    }
    public var reflexiveForm: Swift.String? {
      get
      set
    }
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Foundation.Morphology.CustomPronoun, b: Foundation.Morphology.CustomPronoun) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Morphology {
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public struct Pronoun : Swift.Sendable, Swift.Equatable, Swift.Hashable, Swift.Codable {
    public var pronoun: Swift.String
    public var morphology: Foundation.Morphology
    public var dependentMorphology: Foundation.Morphology?
    public init(pronoun: Swift.String, morphology: Foundation.Morphology, dependentMorphology: Foundation.Morphology? = nil)
    public static func == (a: Foundation.Morphology.Pronoun, b: Foundation.Morphology.Pronoun) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology {
  public var isUnspecified: Swift.Bool {
    get
  }
  public static let user: Foundation.Morphology
}
@available(macOS, introduced: 12.0, deprecated: 14.0, message: "Use TermOfAddress instead")
@available(iOS, introduced: 15.0, deprecated: 17.0, message: "Use TermOfAddress instead")
@available(tvOS, introduced: 15.0, deprecated: 17.0, message: "Use TermOfAddress instead")
@available(watchOS, introduced: 8.0, deprecated: 10.0, message: "Use TermOfAddress instead")
extension Foundation.Morphology.CustomPronoun : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.__NSMorphologyCustomPronoun
  public static func _forceBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphologyCustomPronoun, result: inout Foundation.Morphology.CustomPronoun?)
  public static func _conditionallyBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphologyCustomPronoun, result: inout Foundation.Morphology.CustomPronoun?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphologyCustomPronoun?) -> Foundation.Morphology.CustomPronoun
  @available(iOS, introduced: 15.0, deprecated: 17.0, message: "Use TermOfAddress instead")
  @available(tvOS, introduced: 15.0, deprecated: 17.0, message: "Use TermOfAddress instead")
  @available(watchOS, introduced: 8.0, deprecated: 10.0, message: "Use TermOfAddress instead")
  @available(macOS, introduced: 12.0, deprecated: 14.0, message: "Use TermOfAddress instead")
  public typealias _ObjectiveCType = Foundation.__NSMorphologyCustomPronoun
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Morphology.Pronoun : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.__NSMorphologyPronoun
  public static func _forceBridgeFromObjectiveC(_ pronoun: Foundation.__NSMorphologyPronoun, result: inout Foundation.Morphology.Pronoun?)
  public static func _conditionallyBridgeFromObjectiveC(_ pronoun: Foundation.__NSMorphologyPronoun, result: inout Foundation.Morphology.Pronoun?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ pronoun: Foundation.__NSMorphologyPronoun?) -> Foundation.Morphology.Pronoun
  @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
  public typealias _ObjectiveCType = Foundation.__NSMorphologyPronoun
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.InflectionRule : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.__NSInflectionRule
  public static func _forceBridgeFromObjectiveC(_ rule: Foundation.__NSInflectionRule, result: inout Foundation.InflectionRule?)
  public static func _conditionallyBridgeFromObjectiveC(_ rule: Foundation.__NSInflectionRule, result: inout Foundation.InflectionRule?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ rule: Foundation.__NSInflectionRule?) -> Foundation.InflectionRule
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _ObjectiveCType = Foundation.__NSInflectionRule
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.Morphology : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.__NSMorphology
  public static func _forceBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphology, result: inout Foundation.Morphology?)
  public static func _conditionallyBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphology, result: inout Foundation.Morphology?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ morphology: Foundation.__NSMorphology?) -> Foundation.Morphology
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _ObjectiveCType = Foundation.__NSMorphology
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSPredicate {
  convenience public init(format predicateFormat: __shared Swift.String, _ args: any Swift.CVarArg...)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.IndexSet.Index {
  public static func == (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
  public static func < (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
  public static func <= (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
  public static func > (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
  public static func >= (lhs: Foundation.IndexSet.Index, rhs: Foundation.IndexSet.Index) -> Swift.Bool
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.IndexSet.RangeView {
  public static func == (lhs: Foundation.IndexSet.RangeView, rhs: Foundation.IndexSet.RangeView) -> Swift.Bool
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct IndexSet : Foundation.ReferenceConvertible, Swift.Equatable, Swift.BidirectionalCollection, Swift.SetAlgebra {
  public struct RangeView : Swift.Equatable, Swift.BidirectionalCollection {
    public typealias Index = Swift.Int
    public let startIndex: Foundation.IndexSet.RangeView.Index
    public let endIndex: Foundation.IndexSet.RangeView.Index
    public func makeIterator() -> Swift.IndexingIterator<Foundation.IndexSet.RangeView>
    public subscript(index: Foundation.IndexSet.RangeView.Index) -> Swift.Range<Foundation.IndexSet.Element> {
      get
    }
    public subscript(bounds: Swift.Range<Foundation.IndexSet.RangeView.Index>) -> Swift.Slice<Foundation.IndexSet.RangeView> {
      get
    }
    public func index(after i: Foundation.IndexSet.RangeView.Index) -> Foundation.IndexSet.RangeView.Index
    public func index(before i: Foundation.IndexSet.RangeView.Index) -> Foundation.IndexSet.RangeView.Index
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Element = Swift.Range<Foundation.IndexSet.Element>
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Indices = Swift.DefaultIndices<Foundation.IndexSet.RangeView>
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Iterator = Swift.IndexingIterator<Foundation.IndexSet.RangeView>
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias SubSequence = Swift.Slice<Foundation.IndexSet.RangeView>
  }
  public struct Index : Swift.CustomStringConvertible, Swift.Comparable, Swift.Sendable {
    public var description: Swift.String {
      get
    }
  }
  public typealias ReferenceType = Foundation.NSIndexSet
  public typealias Element = Swift.Int
  public init(integersIn range: Swift.Range<Foundation.IndexSet.Element>)
  public init<R>(integersIn range: R) where R : Swift.RangeExpression, R.Bound == Swift.Int
  public init(integer: Foundation.IndexSet.Element)
  public init()
  public func hash(into hasher: inout Swift.Hasher)
  public var count: Swift.Int {
    get
  }
  public func makeIterator() -> Swift.IndexingIterator<Foundation.IndexSet>
  public var rangeView: Foundation.IndexSet.RangeView {
    get
  }
  public func rangeView(of range: Swift.Range<Foundation.IndexSet.Element>) -> Foundation.IndexSet.RangeView
  public func rangeView<R>(of range: R) -> Foundation.IndexSet.RangeView where R : Swift.RangeExpression, R.Bound == Swift.Int
  public var startIndex: Foundation.IndexSet.Index {
    get
  }
  public var endIndex: Foundation.IndexSet.Index {
    get
  }
  public subscript(index: Foundation.IndexSet.Index) -> Foundation.IndexSet.Element {
    get
  }
  public subscript(bounds: Swift.Range<Foundation.IndexSet.Index>) -> Swift.Slice<Foundation.IndexSet> {
    get
  }
  public var first: Foundation.IndexSet.Element? {
    get
  }
  public var last: Foundation.IndexSet.Element? {
    get
  }
  public func integerGreaterThan(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public func integerLessThan(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public func integerGreaterThanOrEqualTo(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public func integerLessThanOrEqualTo(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public func indexRange(in range: Swift.Range<Foundation.IndexSet.Element>) -> Swift.Range<Foundation.IndexSet.Index>
  public func indexRange<R>(in range: R) -> Swift.Range<Foundation.IndexSet.Index> where R : Swift.RangeExpression, R.Bound == Swift.Int
  public func count(in range: Swift.Range<Foundation.IndexSet.Element>) -> Swift.Int
  public func count<R>(in range: R) -> Swift.Int where R : Swift.RangeExpression, R.Bound == Swift.Int
  public func contains(_ integer: Foundation.IndexSet.Element) -> Swift.Bool
  public func contains(integersIn range: Swift.Range<Foundation.IndexSet.Element>) -> Swift.Bool
  public func contains<R>(integersIn range: R) -> Swift.Bool where R : Swift.RangeExpression, R.Bound == Swift.Int
  public func contains(integersIn indexSet: Foundation.IndexSet) -> Swift.Bool
  public func intersects(integersIn range: Swift.Range<Foundation.IndexSet.Element>) -> Swift.Bool
  public func intersects<R>(integersIn range: R) -> Swift.Bool where R : Swift.RangeExpression, R.Bound == Swift.Int
  public func index(after i: Foundation.IndexSet.Index) -> Foundation.IndexSet.Index
  public func formIndex(after i: inout Foundation.IndexSet.Index)
  public func index(before i: Foundation.IndexSet.Index) -> Foundation.IndexSet.Index
  public func formIndex(before i: inout Foundation.IndexSet.Index)
  public mutating func formUnion(_ other: Foundation.IndexSet)
  public func union(_ other: Foundation.IndexSet) -> Foundation.IndexSet
  public func symmetricDifference(_ other: Foundation.IndexSet) -> Foundation.IndexSet
  public mutating func formSymmetricDifference(_ other: Foundation.IndexSet)
  public func intersection(_ other: Foundation.IndexSet) -> Foundation.IndexSet
  public mutating func formIntersection(_ other: Foundation.IndexSet)
  @discardableResult
  public mutating func insert(_ integer: Foundation.IndexSet.Element) -> (inserted: Swift.Bool, memberAfterInsert: Foundation.IndexSet.Element)
  @discardableResult
  public mutating func update(with integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  @discardableResult
  public mutating func remove(_ integer: Foundation.IndexSet.Element) -> Foundation.IndexSet.Element?
  public mutating func removeAll()
  public mutating func insert(integersIn range: Swift.Range<Foundation.IndexSet.Element>)
  public mutating func insert<R>(integersIn range: R) where R : Swift.RangeExpression, R.Bound == Swift.Int
  public mutating func remove(integersIn range: Swift.Range<Foundation.IndexSet.Element>)
  public mutating func remove(integersIn range: Swift.ClosedRange<Foundation.IndexSet.Element>)
  public var isEmpty: Swift.Bool {
    get
  }
  public func filteredIndexSet(in range: Swift.Range<Foundation.IndexSet.Element>, includeInteger: (Foundation.IndexSet.Element) throws -> Swift.Bool) rethrows -> Foundation.IndexSet
  public func filteredIndexSet(in range: Swift.ClosedRange<Foundation.IndexSet.Element>, includeInteger: (Foundation.IndexSet.Element) throws -> Swift.Bool) rethrows -> Foundation.IndexSet
  public func filteredIndexSet(includeInteger: (Foundation.IndexSet.Element) throws -> Swift.Bool) rethrows -> Foundation.IndexSet
  public mutating func shift(startingAt integer: Foundation.IndexSet.Element, by delta: Swift.Int)
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias ArrayLiteralElement = Foundation.IndexSet.Element
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Indices = Swift.DefaultIndices<Foundation.IndexSet>
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Iterator = Swift.IndexingIterator<Foundation.IndexSet>
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias SubSequence = Swift.Slice<Foundation.IndexSet>
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.IndexSet : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.IndexSet {
  public static func == (lhs: Foundation.IndexSet, rhs: Foundation.IndexSet) -> Swift.Bool
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.IndexSet : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSIndexSet
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSIndexSet, result: inout Foundation.IndexSet?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSIndexSet, result: inout Foundation.IndexSet?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSIndexSet?) -> Foundation.IndexSet
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSIndexSet
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSIndexSet : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.IndexSet : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.IndexSet : Swift.Sendable {
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.IndexSet.RangeView : Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Foundation.IndexSet {
  public init?(integersIn indices: Swift.RangeSet<Swift.Int>)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension Swift.RangeSet where Bound == Swift.Int {
  public init(_ indices: Foundation.IndexSet)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.String {
  public init(_ cocoaString: Foundation.NSString)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.String : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSString
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSString, result: inout Swift.String?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSString, result: inout Swift.String?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSString?) -> Swift.String
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSString
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Substring : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSString
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSString, result: inout Swift.Substring?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSString, result: inout Swift.Substring?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSString?) -> Swift.Substring
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSString
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.String : Swift.CVarArg {
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Swift.CollectionDifference.Change : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSOrderedCollectionChange
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSOrderedCollectionChange, result: inout Swift.CollectionDifference<ChangeElement>.Change?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSOrderedCollectionChange, result: inout Swift.CollectionDifference<ChangeElement>.Change?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ s: Foundation.NSOrderedCollectionChange?) -> Swift.CollectionDifference<ChangeElement>.Change
  @available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
  public typealias _ObjectiveCType = Foundation.NSOrderedCollectionChange
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Swift.CollectionDifference : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSOrderedCollectionDifference
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSOrderedCollectionDifference, result: inout Swift.CollectionDifference<ChangeElement>?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSOrderedCollectionDifference, result: inout Swift.CollectionDifference<ChangeElement>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ s: Foundation.NSOrderedCollectionDifference?) -> Swift.CollectionDifference<ChangeElement>
  @available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
  public typealias _ObjectiveCType = Foundation.NSOrderedCollectionDifference
}
extension Foundation.URLCache {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  convenience public init(memoryCapacity: Swift.Int, diskCapacity: Swift.Int, directory: Foundation.URL? = nil)
}
extension Foundation.URL {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public struct FormatStyle : Swift.Codable, Swift.Hashable, Swift.Sendable {
    public init(scheme: Foundation.URL.FormatStyle.ComponentDisplayOption = .always, user: Foundation.URL.FormatStyle.ComponentDisplayOption = .never, password: Foundation.URL.FormatStyle.ComponentDisplayOption = .never, host: Foundation.URL.FormatStyle.HostDisplayOption = .always, port: Foundation.URL.FormatStyle.ComponentDisplayOption = .omitIfHTTPFamily, path: Foundation.URL.FormatStyle.ComponentDisplayOption = .always, query: Foundation.URL.FormatStyle.ComponentDisplayOption = .never, fragment: Foundation.URL.FormatStyle.ComponentDisplayOption = .never)
    public static func == (a: Foundation.URL.FormatStyle, b: Foundation.URL.FormatStyle) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.FormatStyle {
  public enum Component : Swift.Int, Swift.Codable, Swift.Hashable, Swift.Sendable, Swift.CustomStringConvertible {
    case scheme
    case user
    case password
    case host
    case port
    case path
    case query
    case fragment
    public var description: Swift.String {
      get
    }
    public init?(rawValue: Swift.Int)
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.FormatStyle {
  public struct ComponentDisplayOption : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible, Swift.Sendable {
    public var description: Swift.String {
      get
    }
    public static var always: Foundation.URL.FormatStyle.ComponentDisplayOption {
      get
    }
    public static var never: Foundation.URL.FormatStyle.ComponentDisplayOption {
      get
    }
    public static func displayWhen(_ component: Foundation.URL.FormatStyle.Component, matches requirements: Swift.Set<Swift.String>) -> Foundation.URL.FormatStyle.ComponentDisplayOption
    public static func omitWhen(_ component: Foundation.URL.FormatStyle.Component, matches requirements: Swift.Set<Swift.String>) -> Foundation.URL.FormatStyle.ComponentDisplayOption
    public static var omitIfHTTPFamily: Foundation.URL.FormatStyle.ComponentDisplayOption {
      get
    }
    public static func == (a: Foundation.URL.FormatStyle.ComponentDisplayOption, b: Foundation.URL.FormatStyle.ComponentDisplayOption) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct HostDisplayOption : Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible, Swift.Sendable {
    public var description: Swift.String {
      get
    }
    public static var always: Foundation.URL.FormatStyle.HostDisplayOption {
      get
    }
    public static var never: Foundation.URL.FormatStyle.HostDisplayOption {
      get
    }
    public static func displayWhen(_ component: Foundation.URL.FormatStyle.Component, matches requirements: Swift.Set<Swift.String>) -> Foundation.URL.FormatStyle.HostDisplayOption
    public static func omitWhen(_ component: Foundation.URL.FormatStyle.Component, matches requirements: Swift.Set<Swift.String>) -> Foundation.URL.FormatStyle.HostDisplayOption
    public static var omitIfHTTPFamily: Foundation.URL.FormatStyle.HostDisplayOption {
      get
    }
    public static func omitSpecificSubdomains(_ subdomainsToOmit: Swift.Set<Swift.String> = Set(), includeMultiLevelSubdomains omitMultiLevelSubdomains: Swift.Bool = false) -> Foundation.URL.FormatStyle.HostDisplayOption
    public static func omitSpecificSubdomains(_ subdomainsToOmit: Swift.Set<Swift.String> = Set(), includeMultiLevelSubdomains omitMultiLevelSubdomains: Swift.Bool = false, when component: Foundation.URL.FormatStyle.Component, matches requirements: Swift.Set<Swift.String>) -> Foundation.URL.FormatStyle.HostDisplayOption
    public static func == (a: Foundation.URL.FormatStyle.HostDisplayOption, b: Foundation.URL.FormatStyle.HostDisplayOption) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.FormatStyle {
  public func scheme(_ strategy: Foundation.URL.FormatStyle.ComponentDisplayOption = .always) -> Foundation.URL.FormatStyle
  public func user(_ strategy: Foundation.URL.FormatStyle.ComponentDisplayOption = .never) -> Foundation.URL.FormatStyle
  public func password(_ strategy: Foundation.URL.FormatStyle.ComponentDisplayOption = .never) -> Foundation.URL.FormatStyle
  public func host(_ strategy: Foundation.URL.FormatStyle.HostDisplayOption = .always) -> Foundation.URL.FormatStyle
  public func port(_ strategy: Foundation.URL.FormatStyle.ComponentDisplayOption = .omitIfHTTPFamily) -> Foundation.URL.FormatStyle
  public func path(_ strategy: Foundation.URL.FormatStyle.ComponentDisplayOption = .always) -> Foundation.URL.FormatStyle
  public func query(_ strategy: Foundation.URL.FormatStyle.ComponentDisplayOption = .never) -> Foundation.URL.FormatStyle
  public func fragment(_ strategy: Foundation.URL.FormatStyle.ComponentDisplayOption = .never) -> Foundation.URL.FormatStyle
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.FormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.URL.ParseStrategy {
    get
  }
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Strategy = Foundation.URL.ParseStrategy
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.FormatStyle : Foundation.FormatStyle {
  public func format(_ value: Foundation.URL) -> Swift.String
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias FormatInput = Foundation.URL
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias FormatOutput = Swift.String
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL {
  public func formatted<F>(_ format: F) -> F.FormatOutput where F : Foundation.FormatStyle, F.FormatInput == Foundation.URL
  public func formatted() -> Swift.String
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.FormatStyle where Self == Foundation.URL.FormatStyle {
  public static var url: Foundation.URL.FormatStyle {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.URL.FormatStyle {
  public static var url: Foundation.URL.FormatStyle {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol ReferenceConvertible : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.Hashable, Swift._ObjectiveCBridgeable {
  associatedtype ReferenceType : ObjectiveC.NSObject, Foundation.NSCopying
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSTextCheckingResult.CheckingType {
  public static var allSystemTypes: Foundation.NSTextCheckingResult.CheckingType {
    get
  }
  public static var allCustomTypes: Foundation.NSTextCheckingResult.CheckingType {
    get
  }
  public static var allTypes: Foundation.NSTextCheckingResult.CheckingType {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSRectEdge {
  @inlinable public init(rectEdge: CoreFoundation.CGRectEdge) {
        self = NSRectEdge(rawValue: UInt(rectEdge.rawValue))!
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CoreFoundation.CGRectEdge {
  @inlinable public init(rectEdge: Foundation.NSRectEdge) {
        self = CGRectEdge(rawValue: UInt32(rectEdge.rawValue))!
    }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.OperationQueue : Combine.Scheduler {
  public struct SchedulerTimeType : Swift.Strideable, Swift.Codable, Swift.Hashable, Swift.Sendable {
    public var date: Foundation.Date
    public init(_ date: Foundation.Date)
    public func distance(to other: Foundation.OperationQueue.SchedulerTimeType) -> Foundation.OperationQueue.SchedulerTimeType.Stride
    public func advanced(by n: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Foundation.OperationQueue.SchedulerTimeType
    public struct Stride : Swift.ExpressibleByFloatLiteral, Swift.Comparable, Swift.SignedNumeric, Swift.Codable, Combine.SchedulerTimeIntervalConvertible, Swift.Sendable {
      public typealias FloatLiteralType = Foundation.TimeInterval
      public typealias IntegerLiteralType = Foundation.TimeInterval
      public typealias Magnitude = Foundation.TimeInterval
      public var magnitude: Foundation.TimeInterval
      public var timeInterval: Foundation.TimeInterval {
        get
      }
      public init(integerLiteral value: Foundation.TimeInterval)
      public init(floatLiteral value: Foundation.TimeInterval)
      public init(_ timeInterval: Foundation.TimeInterval)
      public init?<T>(exactly source: T) where T : Swift.BinaryInteger
      public static func < (lhs: Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Swift.Bool
      public static func * (lhs: Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func + (lhs: Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func - (lhs: Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func *= (lhs: inout Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride)
      public static func += (lhs: inout Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride)
      public static func -= (lhs: inout Foundation.OperationQueue.SchedulerTimeType.Stride, rhs: Foundation.OperationQueue.SchedulerTimeType.Stride)
      public static func seconds(_ s: Swift.Int) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func seconds(_ s: Swift.Double) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func milliseconds(_ ms: Swift.Int) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func microseconds(_ us: Swift.Int) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func nanoseconds(_ ns: Swift.Int) -> Foundation.OperationQueue.SchedulerTimeType.Stride
      public static func == (a: Foundation.OperationQueue.SchedulerTimeType.Stride, b: Foundation.OperationQueue.SchedulerTimeType.Stride) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
    }
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct SchedulerOptions : Swift.Sendable {
  }
  public func schedule(options: Foundation.OperationQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Foundation.OperationQueue.SchedulerTimeType, tolerance: Foundation.OperationQueue.SchedulerTimeType.Stride, options: Foundation.OperationQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void)
  public func schedule(after date: Foundation.OperationQueue.SchedulerTimeType, interval: Foundation.OperationQueue.SchedulerTimeType.Stride, tolerance: Foundation.OperationQueue.SchedulerTimeType.Stride, options: Foundation.OperationQueue.SchedulerOptions?, _ action: @escaping () -> Swift.Void) -> any Combine.Cancellable
  public var now: Foundation.OperationQueue.SchedulerTimeType {
    get
  }
  public var minimumTolerance: Foundation.OperationQueue.SchedulerTimeType.Stride {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Measurement where UnitType : Foundation.Dimension {
  public struct FormatStyle : Foundation.FormatStyle, Swift.Sendable {
    public struct UnitWidth : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public static var wide: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth {
        get
      }
      public static var abbreviated: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth {
        get
      }
      public static var narrow: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth {
        get
      }
      public static func == (a: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth, b: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public var width: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth
    public var locale: Foundation.Locale
    public var numberFormatStyle: Foundation.FloatingPointFormatStyle<Swift.Double>?
    public var usage: Foundation.MeasurementFormatUnitUsage<UnitType>?
    public var attributed: Foundation.Measurement<UnitType>.AttributedStyle {
      get
    }
    public init(width: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth, locale: Foundation.Locale = .autoupdatingCurrent, usage: Foundation.MeasurementFormatUnitUsage<UnitType> = .general, numberFormatStyle: Foundation.FloatingPointFormatStyle<Swift.Double>? = nil)
    public func locale(_ locale: Foundation.Locale) -> Foundation.Measurement<UnitType>.FormatStyle
    public func format(_ measurement: Foundation.Measurement<UnitType>) -> Swift.String
    public static func == (a: Foundation.Measurement<UnitType>.FormatStyle, b: Foundation.Measurement<UnitType>.FormatStyle) -> Swift.Bool
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Foundation.Measurement<UnitType>
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Measurement.FormatStyle where UnitType == Foundation.UnitTemperature {
  public var hidesScaleName: Swift.Bool {
    get
    set
  }
  public init(width: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth = .abbreviated, locale: Foundation.Locale = .autoupdatingCurrent, usage: Foundation.MeasurementFormatUnitUsage<UnitType> = .general, hidesScaleName: Swift.Bool = false, numberFormatStyle: Foundation.FloatingPointFormatStyle<Swift.Double>? = nil)
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Measurement.FormatStyle where UnitType == Foundation.UnitInformationStorage {
  public struct ByteCount : Foundation.FormatStyle, Swift.Sendable {
    public typealias Style = Foundation.ByteCountFormatStyle.Style
    public typealias Units = Foundation.ByteCountFormatStyle.Units
    public var style: Foundation.Measurement<Foundation.UnitInformationStorage>.FormatStyle.ByteCount.Style
    public var allowedUnits: Foundation.Measurement<Foundation.UnitInformationStorage>.FormatStyle.ByteCount.Units
    public var spellsOutZero: Swift.Bool
    public var includesActualByteCount: Swift.Bool
    public var locale: Foundation.Locale
    public var attributed: Foundation.Measurement<Foundation.UnitInformationStorage>.AttributedStyle.ByteCount {
      get
    }
    public init(style: Foundation.Measurement<UnitType>.FormatStyle.ByteCount.Style, allowedUnits: Foundation.Measurement<UnitType>.FormatStyle.ByteCount.Units, spellsOutZero: Swift.Bool, includesActualByteCount: Swift.Bool, locale: Foundation.Locale)
    public func format(_ value: Foundation.Measurement<Foundation.UnitInformationStorage>) -> Swift.String
    public func locale(_ locale: Foundation.Locale) -> Foundation.Measurement<UnitType>.FormatStyle.ByteCount
    public static func == (a: Foundation.Measurement<UnitType>.FormatStyle.ByteCount, b: Foundation.Measurement<UnitType>.FormatStyle.ByteCount) -> Swift.Bool
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias FormatInput = Foundation.Measurement<Foundation.UnitInformationStorage>
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Measurement where UnitType : Foundation.Dimension {
  public func formatted<S>(_ style: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput == Foundation.Measurement<UnitType>
  public func formatted() -> Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  public static func measurement<UnitType>(width: Foundation.Measurement<UnitType>.FormatStyle.UnitWidth, usage: Foundation.MeasurementFormatUnitUsage<UnitType> = .general, numberFormatStyle: Foundation.FloatingPointFormatStyle<Swift.Double>? = nil) -> Self where Self == Foundation.Measurement<UnitType>.FormatStyle, UnitType : Foundation.Dimension
  public static func measurement(width: Foundation.Measurement<Foundation.UnitTemperature>.FormatStyle.UnitWidth = .abbreviated, usage: Foundation.MeasurementFormatUnitUsage<Foundation.UnitTemperature> = .general, hidesScaleName: Swift.Bool = false, numberFormatStyle: Foundation.FloatingPointFormatStyle<Swift.Double>? = nil) -> Self where Self == Foundation.Measurement<Foundation.UnitTemperature>.FormatStyle
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.FormatStyle where Self == Foundation.Measurement<Foundation.UnitInformationStorage>.FormatStyle.ByteCount {
  public static func byteCount(style: Foundation.Measurement<Foundation.UnitInformationStorage>.FormatStyle.ByteCount.Style, allowedUnits: Foundation.Measurement<Foundation.UnitInformationStorage>.FormatStyle.ByteCount.Units = .all, spellsOutZero: Swift.Bool = true, includesActualByteCount: Swift.Bool = false) -> Self
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLSessionWebSocketTask {
  public enum Message : Swift.Sendable {
    case data(Foundation.Data)
    case string(Swift.String)
  }
  @preconcurrency public func send(_ message: Foundation.URLSessionWebSocketTask.Message, completionHandler: @escaping @Sendable ((any Swift.Error)?) -> Swift.Void)
  @_silgen_name("_$sSo25NSURLSessionWebSocketTaskC10FoundationE4sendyyAbCE7MessageOYaKF")
  @_alwaysEmitIntoClient public func send(_ message: Foundation.URLSessionWebSocketTask.Message) async throws {
        try await withUnsafeThrowingContinuation { continuation in
            send(message) {
                if let error = $0 {
                    continuation.resume(throwing: error)
                } else {
                    continuation.resume(returning: ())
                }
            }
        } as Void
    }
  @preconcurrency public func receive(completionHandler: @escaping @Sendable (Swift.Result<Foundation.URLSessionWebSocketTask.Message, any Swift.Error>) -> Swift.Void)
  @_silgen_name("_$sSo25NSURLSessionWebSocketTaskC10FoundationE7receiveAbCE7MessageOyYaKF")
  @_alwaysEmitIntoClient public func receive() async throws -> Foundation.URLSessionWebSocketTask.Message {
        try await withUnsafeThrowingContinuation { continuation in
            receive {
                continuation.resume(with: $0)
            }
        }
    }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLSessionTaskTransactionMetrics {
  public var localPort: Swift.Int? {
    get
  }
  public var remotePort: Swift.Int? {
    get
  }
  public var negotiatedTLSProtocolVersion: Security.tls_protocol_version_t? {
    get
  }
  public var negotiatedTLSCipherSuite: Security.tls_ciphersuite_t? {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLSession {
  @_alwaysEmitIntoClient internal func makeState() -> Swift.ManagedBuffer<(isCancelled: Swift.Bool, task: Foundation.URLSessionTask?), Darwin.os_unfair_lock> {
        ManagedBuffer<(isCancelled: Bool, task: URLSessionTask?), os_unfair_lock>.create(minimumCapacity: 1) { buffer in
            buffer.withUnsafeMutablePointerToElements { $0.initialize(to: os_unfair_lock()) }
            return (isCancelled: false, task: nil)
        }
    }
  @_alwaysEmitIntoClient internal func cancel(state: Swift.ManagedBuffer<(isCancelled: Swift.Bool, task: Foundation.URLSessionTask?), Darwin.os_unfair_lock>) {
        state.withUnsafeMutablePointers { state, lock in
            os_unfair_lock_lock(lock)
            let task = state.pointee.task
            state.pointee = (isCancelled: true, task: nil)
            os_unfair_lock_unlock(lock)
            task?.cancel()
        }
    }
  @_alwaysEmitIntoClient internal func activate(state: Swift.ManagedBuffer<(isCancelled: Swift.Bool, task: Foundation.URLSessionTask?), Darwin.os_unfair_lock>, task: Foundation.URLSessionTask) {
        state.withUnsafeMutablePointers { state, lock in
            os_unfair_lock_lock(lock)
            if state.pointee.task != nil {
                fatalError("Cannot activate twice")
            }
            if state.pointee.isCancelled {
                os_unfair_lock_unlock(lock)
                task.cancel()
            } else {
                state.pointee = (isCancelled: false, task: task)
                os_unfair_lock_unlock(lock)
            }
        }
    }
}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Foundation.URLSession {
  public func data(for request: Foundation.URLRequest, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.Data, Foundation.URLResponse)
  public func data(from url: Foundation.URL, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.Data, Foundation.URLResponse)
  public func upload(for request: Foundation.URLRequest, fromFile fileURL: Foundation.URL, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.Data, Foundation.URLResponse)
  public func upload(for request: Foundation.URLRequest, from bodyData: Foundation.Data, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.Data, Foundation.URLResponse)
  public func download(for request: Foundation.URLRequest, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.URL, Foundation.URLResponse)
  public func download(from url: Foundation.URL, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.URL, Foundation.URLResponse)
  public func download(resumeFrom resumeData: Foundation.Data, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.URL, Foundation.URLResponse)
  public struct AsyncBytes : _Concurrency.AsyncSequence, Swift.Sendable {
    public var task: Foundation.URLSessionDataTask {
      get
    }
    public typealias Element = Swift.UInt8
    public typealias AsyncIterator = Foundation.URLSession.AsyncBytes.Iterator
    @frozen public struct Iterator : _Concurrency.AsyncIteratorProtocol, Swift.Sendable {
      public typealias Element = Swift.UInt8
      @usableFromInline
      internal var buffer: Foundation._AsyncBytesBuffer
      @inlinable @inline(__always) public mutating func next() async throws -> Swift.UInt8? {
                return try await buffer.next()
            }
      @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
      @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    }
    public __consuming func makeAsyncIterator() -> Foundation.URLSession.AsyncBytes.Iterator
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  }
  public func bytes(for request: Foundation.URLRequest, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.URLSession.AsyncBytes, Foundation.URLResponse)
  public func bytes(from url: Foundation.URL, delegate: (any Foundation.URLSessionTaskDelegate)? = nil) async throws -> (Foundation.URLSession.AsyncBytes, Foundation.URLResponse)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLSession {
  @_alwaysEmitIntoClient @_disfavoredOverload public func data(for request: Foundation.URLRequest) async throws -> (Foundation.Data, Foundation.URLResponse) {
        if #available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *) {
            return try await data(for: request, delegate: nil)
        }
        let cancelState = makeState()
        return try await withTaskCancellationHandler {
            try await withCheckedThrowingContinuation { continuation in
                let task = dataTask(with: request) { data, response, error in
                    if let error = error {
                        continuation.resume(throwing: error)
                    } else {
                        continuation.resume(returning: (data!, response!))
                    }
                }
                task.resume()
                activate(state: cancelState, task: task)
            }
        } onCancel: {
            cancel(state: cancelState)
        }
    }
  @_alwaysEmitIntoClient @_disfavoredOverload public func data(from url: Foundation.URL) async throws -> (Foundation.Data, Foundation.URLResponse) {
        if #available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *) {
            return try await data(from: url, delegate: nil)
        }
        let cancelState = makeState()
        return try await withTaskCancellationHandler {
            try await withCheckedThrowingContinuation { continuation in
                let task = dataTask(with: url) { data, response, error in
                    if let error = error {
                        continuation.resume(throwing: error)
                    } else {
                        continuation.resume(returning: (data!, response!))
                    }
                }
                task.resume()
                activate(state: cancelState, task: task)
            }
        } onCancel: {
            cancel(state: cancelState)
        }
    }
  @_alwaysEmitIntoClient @_disfavoredOverload public func upload(for request: Foundation.URLRequest, fromFile fileURL: Foundation.URL) async throws -> (Foundation.Data, Foundation.URLResponse) {
        if #available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *) {
            return try await upload(for: request, fromFile: fileURL, delegate: nil)
        }
        let cancelState = makeState()
        return try await withTaskCancellationHandler {
            try await withCheckedThrowingContinuation { continuation in
                let task = uploadTask(with: request, fromFile: fileURL) { data, response, error in
                    if let error = error {
                        continuation.resume(throwing: error)
                    } else {
                        continuation.resume(returning: (data!, response!))
                    }
                }
                task.resume()
                activate(state: cancelState, task: task)
            }
        } onCancel: {
            cancel(state: cancelState)
        }
    }
  @_alwaysEmitIntoClient @_disfavoredOverload public func upload(for request: Foundation.URLRequest, from bodyData: Foundation.Data) async throws -> (Foundation.Data, Foundation.URLResponse) {
        if #available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *) {
            return try await upload(for: request, from: bodyData, delegate: nil)
        }
        let cancelState = makeState()
        return try await withTaskCancellationHandler {
            try await withCheckedThrowingContinuation { continuation in
                let task = uploadTask(with: request, from: bodyData) { data, response, error in
                    if let error = error {
                        continuation.resume(throwing: error)
                    } else {
                        continuation.resume(returning: (data!, response!))
                    }
                }
                task.resume()
                activate(state: cancelState, task: task)
            }
        } onCancel: {
            cancel(state: cancelState)
        }
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSString : Swift.ExpressibleByStringLiteral {
  required convenience public init(stringLiteral value: Swift.StaticString)
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StaticString
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias StringLiteralType = Swift.StaticString
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias UnicodeScalarLiteralType = Swift.StaticString
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSString : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSString {
  convenience public init(format: __shared Foundation.NSString, _ args: any Swift.CVarArg...)
  convenience public init(format: __shared Foundation.NSString, locale: Foundation.Locale?, _ args: any Swift.CVarArg...)
  public class func localizedStringWithFormat(_ format: Foundation.NSString, _ args: any Swift.CVarArg...) -> Self
  public func appendingFormat(_ format: Foundation.NSString, _ args: any Swift.CVarArg...) -> Foundation.NSString
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSMutableString {
  public func appendFormat(_ format: Foundation.NSString, _ args: any Swift.CVarArg...)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSString {
  @nonobjc convenience public init(string aString: __shared Foundation.NSString)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSString : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSString.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSExpression {
  convenience public init(format expressionFormat: __shared Swift.String, _ args: any Swift.CVarArg...)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSExpression {
  convenience public init<Root, Value>(forKeyPath keyPath: Swift.KeyPath<Root, Value>)
}
extension Foundation.NotificationCenter {
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @preconcurrency public func notifications(named name: Foundation.Notification.Name, object: (any Swift.AnyObject & Swift.Sendable)? = nil) -> Foundation.NotificationCenter.Notifications
  @_hasMissingDesignatedInitializers @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  final public class Notifications : _Concurrency.AsyncSequence, Swift.Sendable {
    public typealias Element = Foundation.Notification
    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    public struct Iterator : _Concurrency.AsyncIteratorProtocol {
      public func next() async -> Foundation.Notification?
      @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
      public typealias Element = Foundation.Notification
      @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
      @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    }
    @objc deinit
    final public __consuming func makeAsyncIterator() -> Foundation.NotificationCenter.Notifications.Iterator
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias AsyncIterator = Foundation.NotificationCenter.Notifications.Iterator
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  }
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.NotificationCenter.Notifications.Iterator : Swift.Sendable {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct AffineTransform : Foundation.ReferenceConvertible, Swift.Hashable, Swift.CustomStringConvertible, Swift.Sendable {
  public var m11: CoreFoundation.CGFloat, m12: CoreFoundation.CGFloat, m21: CoreFoundation.CGFloat, m22: CoreFoundation.CGFloat, tX: CoreFoundation.CGFloat, tY: CoreFoundation.CGFloat
  public typealias ReferenceType = Foundation.NSAffineTransform
  public init(m11: CoreFoundation.CGFloat, m12: CoreFoundation.CGFloat, m21: CoreFoundation.CGFloat, m22: CoreFoundation.CGFloat, tX: CoreFoundation.CGFloat, tY: CoreFoundation.CGFloat)
  public init()
  public init(translationByX x: CoreFoundation.CGFloat, byY y: CoreFoundation.CGFloat)
  public init(scaleByX x: CoreFoundation.CGFloat, byY y: CoreFoundation.CGFloat)
  public init(scale factor: CoreFoundation.CGFloat)
  public init(rotationByRadians angle: CoreFoundation.CGFloat)
  public init(rotationByDegrees angle: CoreFoundation.CGFloat)
  public static let identity: Foundation.AffineTransform
  public mutating func translate(x: CoreFoundation.CGFloat, y: CoreFoundation.CGFloat)
  public mutating func rotate(byDegrees angle: CoreFoundation.CGFloat)
  public mutating func rotate(byRadians angle: CoreFoundation.CGFloat)
  public mutating func scale(_ scale: CoreFoundation.CGFloat)
  public mutating func scale(x: CoreFoundation.CGFloat, y: CoreFoundation.CGFloat)
  public mutating func invert()
  public func inverted() -> Foundation.AffineTransform?
  public mutating func append(_ transform: Foundation.AffineTransform)
  public mutating func prepend(_ transform: Foundation.AffineTransform)
  public func transform(_ point: Foundation.NSPoint) -> Foundation.NSPoint
  public func transform(_ size: Foundation.NSSize) -> Foundation.NSSize
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public static func == (lhs: Foundation.AffineTransform, rhs: Foundation.AffineTransform) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.AffineTransform : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSAffineTransform
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSAffineTransform, result: inout Foundation.AffineTransform?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSAffineTransform, result: inout Foundation.AffineTransform?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ x: Foundation.NSAffineTransform?) -> Foundation.AffineTransform
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSAffineTransform
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSAffineTransform : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.AffineTransform : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, watchOS 8, tvOS 15, *)
public struct PresentationIntent : Swift.Hashable, Swift.Codable, Swift.CustomDebugStringConvertible, Swift.Sendable {
  public var components: [Foundation.PresentationIntent.IntentType]
  public var count: Swift.Int {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public enum Kind : Swift.Hashable, Swift.Codable, Swift.CustomDebugStringConvertible, Swift.Sendable {
    case paragraph
    case header(level: Swift.Int)
    case orderedList
    case unorderedList
    case listItem(ordinal: Swift.Int)
    case codeBlock(languageHint: Swift.String?)
    case blockQuote
    case thematicBreak
    case table(columns: [Foundation.PresentationIntent.TableColumn])
    case tableHeaderRow
    case tableRow(rowIndex: Swift.Int)
    case tableCell(columnIndex: Swift.Int)
    public var debugDescription: Swift.String {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public static func == (a: Foundation.PresentationIntent.Kind, b: Foundation.PresentationIntent.Kind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct TableColumn : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public enum Alignment : Swift.Int, Swift.Hashable, Swift.Codable, Swift.Sendable {
      case left
      case center
      case right
      public init?(rawValue: Swift.Int)
      @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
    public var alignment: Foundation.PresentationIntent.TableColumn.Alignment
    public init(alignment: Foundation.PresentationIntent.TableColumn.Alignment)
    public static func == (a: Foundation.PresentationIntent.TableColumn, b: Foundation.PresentationIntent.TableColumn) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct IntentType : Swift.Hashable, Swift.Codable, Swift.CustomDebugStringConvertible, Swift.Sendable {
    public var kind: Foundation.PresentationIntent.Kind
    public var identity: Swift.Int
    public var debugDescription: Swift.String {
      get
    }
    public static func == (a: Foundation.PresentationIntent.IntentType, b: Foundation.PresentationIntent.IntentType) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public init(_ kind: Foundation.PresentationIntent.Kind, identity: Swift.Int, parent: Foundation.PresentationIntent? = nil)
  public init(types: [Foundation.PresentationIntent.IntentType])
  public var isValid: Swift.Bool {
    get
  }
  public var indentationLevel: Swift.Int {
    get
  }
  public static func == (a: Foundation.PresentationIntent, b: Foundation.PresentationIntent) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.PresentationIntent : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.__NSPresentationIntent
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.__NSPresentationIntent, result: inout Foundation.PresentationIntent?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.__NSPresentationIntent, result: inout Foundation.PresentationIntent?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.__NSPresentationIntent?) -> Foundation.PresentationIntent
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _ObjectiveCType = Foundation.__NSPresentationIntent
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct Notification : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable {
  public typealias ReferenceType = Foundation.NSNotification
  public var name: Foundation.Notification.Name
  public var object: Any?
  public var userInfo: [Swift.AnyHashable : Any]?
  public init(name: Foundation.Notification.Name, object: Any? = nil, userInfo: [Swift.AnyHashable : Any]? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public typealias Name = Foundation.NSNotification.Name
  public static func == (lhs: Foundation.Notification, rhs: Foundation.Notification) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS, unavailable, introduced: 10.10)
@available(iOS, unavailable, introduced: 8.0)
@available(tvOS, unavailable, introduced: 9.0)
@available(watchOS, unavailable, introduced: 2.0)
@available(*, unavailable)
extension Foundation.Notification : Swift.Sendable {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Notification : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Notification : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNotification
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNotification, result: inout Foundation.Notification?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNotification, result: inout Foundation.Notification?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNotification?) -> Foundation.Notification
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSNotification
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSNotification : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Data._Representation {
  @inlinable internal func withInteriorPointerReference<T>(_ work: (Foundation.NSData) throws -> T) rethrows -> T {
        switch self {
        case .empty:
            return try work(NSData())
        case .inline(let inline):
            return try inline.withUnsafeBytes {
                return try work(NSData(bytesNoCopy: UnsafeMutableRawPointer(mutating: $0.baseAddress ?? UnsafeRawPointer(bitPattern: 0xBAD0)!), length: $0.count, freeWhenDone: false))
            }
        case .slice(let slice):
            return try slice.storage.withInteriorPointerReference(slice.range, work)
        case .large(let slice):
            return try slice.storage.withInteriorPointerReference(slice.range, work)
        }
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.__DataStorage {
  @inlinable final internal func withInteriorPointerReference<T>(_ range: Swift.Range<Swift.Int>, _ work: (Foundation.NSData) throws -> T) rethrows -> T {
        if range.isEmpty {
            return try work(NSData())  
        }
        return try work(NSData(bytesNoCopy: _bytes!.advanced(by: range.lowerBound - _offset), length: range.upperBound - range.lowerBound, freeWhenDone: false))
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.__DataStorage {
  @usableFromInline
  final internal func replaceBytes(in range_: Foundation.NSRange, with replacementBytes: Swift.UnsafeRawPointer?, length replacementLength: Swift.Int)
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public struct AttributeContainer : Swift.Sendable {
  public init()
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeContainer {
  @preconcurrency public subscript<T>(_: T.Type) -> T.Value? where T : Foundation.AttributedStringKey, T.Value : Swift.Sendable {
    get
    set
  }
  @preconcurrency public subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> K.Value? where K : Foundation.AttributedStringKey, K.Value : Swift.Sendable {
    get
    set
  }
  public subscript<S>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) -> Foundation.ScopedAttributeContainer<S> where S : Foundation.AttributeScope {
    get
    _modify
  }
  public static subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> Foundation.AttributeContainer.Builder<K> where K : Foundation.AttributedStringKey {
    get
  }
  @_disfavoredOverload public subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> Foundation.AttributeContainer.Builder<K> where K : Foundation.AttributedStringKey {
    get
  }
  public struct Builder<T> : Swift.Sendable where T : Foundation.AttributedStringKey {
    @preconcurrency public func callAsFunction(_ value: T.Value) -> Foundation.AttributeContainer where T.Value : Swift.Sendable
  }
  public mutating func merge(_ other: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy = .keepNew)
  public func merging(_ other: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy = .keepNew) -> Foundation.AttributeContainer
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeContainer : Swift.Equatable {
  public static func == (a: Foundation.AttributeContainer, b: Foundation.AttributeContainer) -> Swift.Bool
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.AttributeContainer : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeContainer : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public struct AttributedString : Swift.Sendable {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public init()
  public init(_ string: Swift.String, attributes: Foundation.AttributeContainer = .init())
  public init(_ substring: Swift.Substring, attributes: Foundation.AttributeContainer = .init())
  public init<S>(_ elements: S, attributes: Foundation.AttributeContainer = .init()) where S : Swift.Sequence, S.Element == Swift.Character
  public init(_ substring: Foundation.AttributedSubstring)
  public init<S, T>(_ other: T, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) where S : Foundation.AttributeScope, T : Foundation.AttributedStringProtocol
  public init<S, T>(_ other: T, including scope: S.Type) where S : Foundation.AttributeScope, T : Foundation.AttributedStringProtocol
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public static func == (lhs: Foundation.AttributedString, rhs: Foundation.AttributedString) -> Swift.Bool
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias StringLiteralType = Swift.String
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public mutating func setAttributes(_ attributes: Foundation.AttributeContainer)
  public mutating func mergeAttributes(_ attributes: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy = .keepNew)
  public mutating func replaceAttributes(_ attributes: Foundation.AttributeContainer, with others: Foundation.AttributeContainer)
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString : Foundation.AttributedStringProtocol {
  public struct Index : Swift.Comparable, Swift.Sendable {
    public static func == (left: Foundation.AttributedString.Index, right: Foundation.AttributedString.Index) -> Swift.Bool
    public static func < (left: Foundation.AttributedString.Index, right: Foundation.AttributedString.Index) -> Swift.Bool
  }
  public var startIndex: Foundation.AttributedString.Index {
    get
  }
  public var endIndex: Foundation.AttributedString.Index {
    get
  }
  @preconcurrency public subscript<K>(_: K.Type) -> K.Value? where K : Foundation.AttributedStringKey, K.Value : Swift.Sendable {
    get
    set
  }
  @preconcurrency public subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> K.Value? where K : Foundation.AttributedStringKey, K.Value : Swift.Sendable {
    get
    set
  }
  public subscript<S>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) -> Foundation.ScopedAttributeContainer<S> where S : Foundation.AttributeScope {
    get
    _modify
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public mutating func append(_ s: some AttributedStringProtocol)
  public mutating func insert(_ s: some AttributedStringProtocol, at index: Foundation.AttributedString.Index)
  public mutating func removeSubrange(_ range: some RangeExpression<Index>)
  public mutating func replaceSubrange(_ range: some RangeExpression<Index>, with s: some AttributedStringProtocol)
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public static func + (lhs: Foundation.AttributedString, rhs: some AttributedStringProtocol) -> Foundation.AttributedString
  public static func += (lhs: inout Foundation.AttributedString, rhs: some AttributedStringProtocol)
  public static func + (lhs: Foundation.AttributedString, rhs: Foundation.AttributedString) -> Foundation.AttributedString
  public static func += (lhs: inout Foundation.AttributedString, rhs: Foundation.AttributedString)
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public subscript(bounds: some RangeExpression<Index>) -> Foundation.AttributedSubstring {
    get
    set
    _modify
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  @preconcurrency public struct SingleAttributeTransformer<T> : Swift.Sendable where T : Foundation.AttributedStringKey, T.Value : Swift.Sendable {
    public var range: Swift.Range<Foundation.AttributedString.Index>
    public var value: T.Value? {
      get
      set
    }
    @preconcurrency public mutating func replace<U>(with key: U.Type, value: U.Value) where U : Foundation.AttributedStringKey, U.Value : Swift.Sendable
    @preconcurrency public mutating func replace<U>(with keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, U>, value: U.Value) where U : Foundation.AttributedStringKey, U.Value : Swift.Sendable
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  @preconcurrency public func transformingAttributes<K>(_ k: K.Type, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K>) -> Swift.Void) -> Foundation.AttributedString where K : Foundation.AttributedStringKey, K.Value : Swift.Sendable
  @preconcurrency public func transformingAttributes<K1, K2>(_ k: K1.Type, _ k2: K2.Type, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K1.Value : Swift.Sendable, K2.Value : Swift.Sendable
  @preconcurrency public func transformingAttributes<K1, K2, K3>(_ k: K1.Type, _ k2: K2.Type, _ k3: K3.Type, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey, K1.Value : Swift.Sendable, K2.Value : Swift.Sendable, K3.Value : Swift.Sendable
  @preconcurrency public func transformingAttributes<K1, K2, K3, K4>(_ k: K1.Type, _ k2: K2.Type, _ k3: K3.Type, _ k4: K4.Type, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>, inout Foundation.AttributedString.SingleAttributeTransformer<K4>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey, K4 : Foundation.AttributedStringKey, K1.Value : Swift.Sendable, K2.Value : Swift.Sendable, K3.Value : Swift.Sendable, K4.Value : Swift.Sendable
  @preconcurrency public func transformingAttributes<K1, K2, K3, K4, K5>(_ k: K1.Type, _ k2: K2.Type, _ k3: K3.Type, _ k4: K4.Type, _ k5: K5.Type, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>, inout Foundation.AttributedString.SingleAttributeTransformer<K4>, inout Foundation.AttributedString.SingleAttributeTransformer<K5>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey, K4 : Foundation.AttributedStringKey, K5 : Foundation.AttributedStringKey, K1.Value : Swift.Sendable, K2.Value : Swift.Sendable, K3.Value : Swift.Sendable, K4.Value : Swift.Sendable, K5.Value : Swift.Sendable
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  @preconcurrency public func transformingAttributes<K>(_ k: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K>) -> Swift.Void) -> Foundation.AttributedString where K : Foundation.AttributedStringKey, K.Value : Swift.Sendable
  @preconcurrency public func transformingAttributes<K1, K2>(_ k: Swift.KeyPath<Foundation.AttributeDynamicLookup, K1>, _ k2: Swift.KeyPath<Foundation.AttributeDynamicLookup, K2>, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K1.Value : Swift.Sendable, K2.Value : Swift.Sendable
  @preconcurrency public func transformingAttributes<K1, K2, K3>(_ k: Swift.KeyPath<Foundation.AttributeDynamicLookup, K1>, _ k2: Swift.KeyPath<Foundation.AttributeDynamicLookup, K2>, _ k3: Swift.KeyPath<Foundation.AttributeDynamicLookup, K3>, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey, K1.Value : Swift.Sendable, K2.Value : Swift.Sendable, K3.Value : Swift.Sendable
  @preconcurrency public func transformingAttributes<K1, K2, K3, K4>(_ k: Swift.KeyPath<Foundation.AttributeDynamicLookup, K1>, _ k2: Swift.KeyPath<Foundation.AttributeDynamicLookup, K2>, _ k3: Swift.KeyPath<Foundation.AttributeDynamicLookup, K3>, _ k4: Swift.KeyPath<Foundation.AttributeDynamicLookup, K4>, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>, inout Foundation.AttributedString.SingleAttributeTransformer<K4>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey, K4 : Foundation.AttributedStringKey, K1.Value : Swift.Sendable, K2.Value : Swift.Sendable, K3.Value : Swift.Sendable, K4.Value : Swift.Sendable
  @preconcurrency public func transformingAttributes<K1, K2, K3, K4, K5>(_ k: Swift.KeyPath<Foundation.AttributeDynamicLookup, K1>, _ k2: Swift.KeyPath<Foundation.AttributeDynamicLookup, K2>, _ k3: Swift.KeyPath<Foundation.AttributeDynamicLookup, K3>, _ k4: Swift.KeyPath<Foundation.AttributeDynamicLookup, K4>, _ k5: Swift.KeyPath<Foundation.AttributeDynamicLookup, K5>, _ c: (inout Foundation.AttributedString.SingleAttributeTransformer<K1>, inout Foundation.AttributedString.SingleAttributeTransformer<K2>, inout Foundation.AttributedString.SingleAttributeTransformer<K3>, inout Foundation.AttributedString.SingleAttributeTransformer<K4>, inout Foundation.AttributedString.SingleAttributeTransformer<K5>) -> Swift.Void) -> Foundation.AttributedString where K1 : Foundation.AttributedStringKey, K2 : Foundation.AttributedStringKey, K3 : Foundation.AttributedStringKey, K4 : Foundation.AttributedStringKey, K5 : Foundation.AttributedStringKey, K1.Value : Swift.Sendable, K2.Value : Swift.Sendable, K3.Value : Swift.Sendable, K4.Value : Swift.Sendable, K5.Value : Swift.Sendable
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public struct CharacterView : Swift.Sendable {
    public init()
  }
  public var characters: Foundation.AttributedString.CharacterView {
    get
    set
    _modify
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.CharacterView : Swift.BidirectionalCollection {
  public typealias Element = Swift.Character
  public typealias Index = Foundation.AttributedString.Index
  public var startIndex: Foundation.AttributedString.Index {
    get
  }
  public var endIndex: Foundation.AttributedString.Index {
    get
  }
  @_alwaysEmitIntoClient public var count: Swift.Int {
    get {
        if #available(macOS 14, iOS 17, tvOS 17, watchOS 10, *) {
            return _count
        }
        return _defaultCount
    }
  }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @usableFromInline
  internal var _count: Swift.Int {
    get
  }
  public func index(before i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(after i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  @_alwaysEmitIntoClient public func index(_ i: Foundation.AttributedString.Index, offsetBy distance: Swift.Int) -> Foundation.AttributedString.Index {
        if #available(macOS 14, iOS 17, tvOS 17, watchOS 10, *) {
            return _index(i, offsetBy: distance)
        }
        return _defaultIndex(i, offsetBy: distance)
    }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @usableFromInline
  internal func _index(_ i: Foundation.AttributedString.Index, offsetBy distance: Swift.Int) -> Foundation.AttributedString.Index
  @_alwaysEmitIntoClient public func index(_ i: Foundation.AttributedString.Index, offsetBy distance: Swift.Int, limitedBy limit: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index? {
        if #available(macOS 14, iOS 17, tvOS 17, watchOS 10, *) {
            return _index(i, offsetBy: distance, limitedBy: limit)
        }
        return _defaultIndex(i, offsetBy: distance, limitedBy: limit)
    }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @usableFromInline
  internal func _index(_ i: Foundation.AttributedString.Index, offsetBy distance: Swift.Int, limitedBy limit: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index?
  @_alwaysEmitIntoClient public func distance(from start: Foundation.AttributedString.Index, to end: Foundation.AttributedString.Index) -> Swift.Int {
        if #available(macOS 14, iOS 17, tvOS 17, watchOS 10, *) {
            return _distance(from: start, to: end)
        }
        precondition(start >= startIndex && start <= endIndex, "AttributedString index out of bounds")
        precondition(end >= startIndex && end <= endIndex, "AttributedString index out of bounds")
        return _defaultDistance(from: start, to: end)
    }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @usableFromInline
  internal func _distance(from start: Foundation.AttributedString.Index, to end: Foundation.AttributedString.Index) -> Swift.Int
  public subscript(index: Foundation.AttributedString.Index) -> Swift.Character {
    get
    set
  }
  public subscript(bounds: Swift.Range<Foundation.AttributedString.Index>) -> Swift.Slice<Foundation.AttributedString.CharacterView> {
    get
    set
  }
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.CharacterView>
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias Iterator = Swift.IndexingIterator<Foundation.AttributedString.CharacterView>
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias SubSequence = Swift.Slice<Foundation.AttributedString.CharacterView>
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.CharacterView : Swift.RangeReplaceableCollection {
  public mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.AttributedString.CharacterView.Index>, with newElements: some Collection<Character>)
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public struct Runs : Swift.Sendable {
  }
  public var runs: Foundation.AttributedString.Runs {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Runs : Swift.Equatable {
  public static func == (lhs: Foundation.AttributedString.Runs, rhs: Foundation.AttributedString.Runs) -> Swift.Bool
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Runs : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Runs {
  public struct Index : Swift.Sendable {
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Runs.Index : Swift.Comparable {
  public static func == (lhs: Foundation.AttributedString.Runs.Index, rhs: Foundation.AttributedString.Runs.Index) -> Swift.Bool
  public static func < (lhs: Foundation.AttributedString.Runs.Index, rhs: Foundation.AttributedString.Runs.Index) -> Swift.Bool
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Runs.Index : Swift.Strideable {
  public func distance(to other: Foundation.AttributedString.Runs.Index) -> Swift.Int
  public func advanced(by n: Swift.Int) -> Foundation.AttributedString.Runs.Index
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias Stride = Swift.Int
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Runs : Swift.BidirectionalCollection {
  public typealias Element = Foundation.AttributedString.Runs.Run
  public var startIndex: Foundation.AttributedString.Runs.Index {
    get
  }
  public var endIndex: Foundation.AttributedString.Runs.Index {
    get
  }
  public func index(after i: Foundation.AttributedString.Runs.Index) -> Foundation.AttributedString.Runs.Index
  public func index(before i: Foundation.AttributedString.Runs.Index) -> Foundation.AttributedString.Runs.Index
  @_alwaysEmitIntoClient public func distance(from start: Foundation.AttributedString.Runs.Index, to end: Foundation.AttributedString.Runs.Index) -> Swift.Int {
        start.distance(to: end)
    }
  @_alwaysEmitIntoClient public func index(_ i: Foundation.AttributedString.Runs.Index, offsetBy distance: Swift.Int) -> Foundation.AttributedString.Runs.Index {
        if #available(macOS 14, iOS 17, tvOS 17, watchOS 10, *) {
            return _index(i, offsetBy: distance)
        }
        return i.advanced(by: distance)
    }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @usableFromInline
  internal func _index(_ index: Foundation.AttributedString.Runs.Index, offsetBy distance: Swift.Int) -> Foundation.AttributedString.Runs.Index
  @_alwaysEmitIntoClient public func index(_ i: Foundation.AttributedString.Runs.Index, offsetBy distance: Swift.Int, limitedBy limit: Foundation.AttributedString.Runs.Index) -> Foundation.AttributedString.Runs.Index? {
         
         
         
        let l = self.distance(from: i, to: limit)
        if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
            return nil
        }
        return index(i, offsetBy: distance)
    }
  public subscript(position: Foundation.AttributedString.Runs.Index) -> Foundation.AttributedString.Runs.Run {
    get
  }
  public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.Run {
    get
  }
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs>
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias Iterator = Swift.IndexingIterator<Foundation.AttributedString.Runs>
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs>
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Runs {
  @preconcurrency public struct AttributesSlice1<T> : Swift.BidirectionalCollection, Swift.Sendable where T : Foundation.AttributedStringKey, T.Value : Swift.Sendable {
    public typealias Index = Foundation.AttributedString.Index
    public typealias Element = (T.Value?, Swift.Range<Foundation.AttributedString.Index>)
    public struct Iterator : Swift.IteratorProtocol, Swift.Sendable {
      public typealias Element = Foundation.AttributedString.Runs.AttributesSlice1<T>.Element
      public mutating func next() -> Foundation.AttributedString.Runs.AttributesSlice1<T>.Iterator.Element?
    }
    public func makeIterator() -> Foundation.AttributedString.Runs.AttributesSlice1<T>.Iterator
    public var startIndex: Foundation.AttributedString.Runs.AttributesSlice1<T>.Index {
      get
    }
    public var endIndex: Foundation.AttributedString.Runs.AttributesSlice1<T>.Index {
      get
    }
    public func index(before i: Foundation.AttributedString.Runs.AttributesSlice1<T>.Index) -> Foundation.AttributedString.Runs.AttributesSlice1<T>.Index
    public func index(after i: Foundation.AttributedString.Runs.AttributesSlice1<T>.Index) -> Foundation.AttributedString.Runs.AttributesSlice1<T>.Index
    public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.AttributesSlice1<T>.Element {
      get
    }
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs.AttributesSlice1<T>>
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs.AttributesSlice1<T>>
  }
  @preconcurrency public subscript<T>(keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>) -> Foundation.AttributedString.Runs.AttributesSlice1<T> where T : Foundation.AttributedStringKey, T.Value : Swift.Sendable {
    get
  }
  @preconcurrency public subscript<T>(t: T.Type) -> Foundation.AttributedString.Runs.AttributesSlice1<T> where T : Foundation.AttributedStringKey, T.Value : Swift.Sendable {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Runs {
  @preconcurrency public struct AttributesSlice2<T, U> : Swift.BidirectionalCollection, Swift.Sendable where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, T.Value : Swift.Sendable, U.Value : Swift.Sendable {
    public typealias Index = Foundation.AttributedString.Index
    public typealias Element = (T.Value?, U.Value?, Swift.Range<Foundation.AttributedString.Index>)
    public struct Iterator : Swift.IteratorProtocol, Swift.Sendable {
      public typealias Element = Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Element
      public mutating func next() -> Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Iterator.Element?
    }
    public func makeIterator() -> Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Iterator
    public var startIndex: Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index {
      get
    }
    public var endIndex: Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index {
      get
    }
    public func index(before i: Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index) -> Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index
    public func index(after i: Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index) -> Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Index
    public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.AttributesSlice2<T, U>.Element {
      get
    }
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs.AttributesSlice2<T, U>>
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs.AttributesSlice2<T, U>>
  }
  @preconcurrency public subscript<T, U>(t: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>, u: Swift.KeyPath<Foundation.AttributeDynamicLookup, U>) -> Foundation.AttributedString.Runs.AttributesSlice2<T, U> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, T.Value : Swift.Sendable, U.Value : Swift.Sendable {
    get
  }
  @preconcurrency public subscript<T, U>(t: T.Type, u: U.Type) -> Foundation.AttributedString.Runs.AttributesSlice2<T, U> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, T.Value : Swift.Sendable, U.Value : Swift.Sendable {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Runs {
  @preconcurrency public struct AttributesSlice3<T, U, V> : Swift.BidirectionalCollection, Swift.Sendable where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, T.Value : Swift.Sendable, U.Value : Swift.Sendable, V.Value : Swift.Sendable {
    public typealias Index = Foundation.AttributedString.Index
    public typealias Element = (T.Value?, U.Value?, V.Value?, Swift.Range<Foundation.AttributedString.Index>)
    public struct Iterator : Swift.IteratorProtocol, Swift.Sendable {
      public typealias Element = Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Element
      public mutating func next() -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Iterator.Element?
    }
    public func makeIterator() -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Iterator
    public var startIndex: Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index {
      get
    }
    public var endIndex: Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index {
      get
    }
    public func index(before i: Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index) -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index
    public func index(after i: Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index) -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Index
    public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>.Element {
      get
    }
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>>
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs.AttributesSlice3<T, U, V>>
  }
  @preconcurrency public subscript<T, U, V>(t: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>, u: Swift.KeyPath<Foundation.AttributeDynamicLookup, U>, v: Swift.KeyPath<Foundation.AttributeDynamicLookup, V>) -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, T.Value : Swift.Sendable, U.Value : Swift.Sendable, V.Value : Swift.Sendable {
    get
  }
  @preconcurrency public subscript<T, U, V>(t: T.Type, u: U.Type, v: V.Type) -> Foundation.AttributedString.Runs.AttributesSlice3<T, U, V> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, T.Value : Swift.Sendable, U.Value : Swift.Sendable, V.Value : Swift.Sendable {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Runs {
  @preconcurrency public struct AttributesSlice4<T, U, V, W> : Swift.BidirectionalCollection, Swift.Sendable where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey, T.Value : Swift.Sendable, U.Value : Swift.Sendable, V.Value : Swift.Sendable, W.Value : Swift.Sendable {
    public typealias Index = Foundation.AttributedString.Index
    public typealias Element = (T.Value?, U.Value?, V.Value?, W.Value?, Swift.Range<Foundation.AttributedString.Index>)
    public struct Iterator : Swift.IteratorProtocol, Swift.Sendable {
      public typealias Element = Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Element
      public mutating func next() -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Iterator.Element?
    }
    public func makeIterator() -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Iterator
    public var startIndex: Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index {
      get
    }
    public var endIndex: Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index {
      get
    }
    public func index(before i: Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index) -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index
    public func index(after i: Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index) -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index
    public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>.Element {
      get
    }
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>>
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W>>
  }
  @preconcurrency public subscript<T, U, V, W>(t: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>, u: Swift.KeyPath<Foundation.AttributeDynamicLookup, U>, v: Swift.KeyPath<Foundation.AttributeDynamicLookup, V>, w: Swift.KeyPath<Foundation.AttributeDynamicLookup, W>) -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey, T.Value : Swift.Sendable, U.Value : Swift.Sendable, V.Value : Swift.Sendable, W.Value : Swift.Sendable {
    get
  }
  @preconcurrency public subscript<T, U, V, W>(t: T.Type, u: U.Type, v: V.Type, w: W.Type) -> Foundation.AttributedString.Runs.AttributesSlice4<T, U, V, W> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey, T.Value : Swift.Sendable, U.Value : Swift.Sendable, V.Value : Swift.Sendable, W.Value : Swift.Sendable {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Runs {
  @preconcurrency public struct AttributesSlice5<T, U, V, W, X> : Swift.BidirectionalCollection, Swift.Sendable where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey, X : Foundation.AttributedStringKey, T.Value : Swift.Sendable, U.Value : Swift.Sendable, V.Value : Swift.Sendable, W.Value : Swift.Sendable, X.Value : Swift.Sendable {
    public typealias Index = Foundation.AttributedString.Index
    public typealias Element = (T.Value?, U.Value?, V.Value?, W.Value?, X.Value?, Swift.Range<Foundation.AttributedString.Index>)
    public struct Iterator : Swift.IteratorProtocol, Swift.Sendable {
      public typealias Element = Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Element
      public mutating func next() -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Iterator.Element?
    }
    public func makeIterator() -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Iterator
    public var startIndex: Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index {
      get
    }
    public var endIndex: Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index {
      get
    }
    public func index(before i: Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index) -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index
    public func index(after i: Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index) -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index
    public subscript(position: Foundation.AttributedString.Index) -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Element {
      get
    }
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>>
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias SubSequence = Swift.Slice<Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X>>
  }
  @preconcurrency public subscript<T, U, V, W, X>(t: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>, u: Swift.KeyPath<Foundation.AttributeDynamicLookup, U>, v: Swift.KeyPath<Foundation.AttributeDynamicLookup, V>, w: Swift.KeyPath<Foundation.AttributeDynamicLookup, W>, x: Swift.KeyPath<Foundation.AttributeDynamicLookup, X>) -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey, X : Foundation.AttributedStringKey, T.Value : Swift.Sendable, U.Value : Swift.Sendable, V.Value : Swift.Sendable, W.Value : Swift.Sendable, X.Value : Swift.Sendable {
    get
  }
  @preconcurrency public subscript<T, U, V, W, X>(t: T.Type, u: U.Type, v: V.Type, w: W.Type, x: X.Type) -> Foundation.AttributedString.Runs.AttributesSlice5<T, U, V, W, X> where T : Foundation.AttributedStringKey, U : Foundation.AttributedStringKey, V : Foundation.AttributedStringKey, W : Foundation.AttributedStringKey, X : Foundation.AttributedStringKey, T.Value : Swift.Sendable, U.Value : Swift.Sendable, V.Value : Swift.Sendable, W.Value : Swift.Sendable, X.Value : Swift.Sendable {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Runs {
  @dynamicMemberLookup public struct Run : Swift.Sendable {
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Runs.Run : Swift.Equatable {
  public static func == (lhs: Foundation.AttributedString.Runs.Run, rhs: Foundation.AttributedString.Runs.Run) -> Swift.Bool
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Runs.Run : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Runs.Run {
  public var range: Swift.Range<Foundation.AttributedString.Index> {
    get
  }
  public var attributes: Foundation.AttributeContainer {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Runs.Run {
  @preconcurrency public subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> K.Value? where K : Foundation.AttributedStringKey, K.Value : Swift.Sendable {
    get
  }
  @preconcurrency public subscript<K>(_: K.Type) -> K.Value? where K : Foundation.AttributedStringKey, K.Value : Swift.Sendable {
    get
  }
  public subscript<S>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) -> Foundation.ScopedAttributeContainer<S> where S : Foundation.AttributeScope {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public struct UnicodeScalarView : Swift.Sendable {
    public init()
  }
  public var unicodeScalars: Foundation.AttributedString.UnicodeScalarView {
    get
    set
    _modify
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.UnicodeScalarView : Swift.BidirectionalCollection {
  public typealias Element = Swift.UnicodeScalar
  public typealias Index = Foundation.AttributedString.Index
  public var startIndex: Foundation.AttributedString.Index {
    get
  }
  public var endIndex: Foundation.AttributedString.Index {
    get
  }
  @_alwaysEmitIntoClient public var count: Swift.Int {
    get {
        if #available(macOS 14, iOS 17, tvOS 17, watchOS 10, *) {
            return _count
        }
        return _defaultCount
    }
  }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @usableFromInline
  internal var _count: Swift.Int {
    get
  }
  public func index(before i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(after i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(_ i: Foundation.AttributedString.Index, offsetBy distance: Swift.Int) -> Foundation.AttributedString.Index
  @_alwaysEmitIntoClient public func index(_ i: Foundation.AttributedString.Index, offsetBy distance: Swift.Int, limitedBy limit: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index? {
        if #available(macOS 14, iOS 17, tvOS 17, watchOS 10, *) {
            return _index(i, offsetBy: distance, limitedBy: limit)
        }
        return _defaultIndex(i, offsetBy: distance, limitedBy: limit)
    }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @usableFromInline
  internal func _index(_ i: Foundation.AttributedString.Index, offsetBy distance: Swift.Int, limitedBy limit: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index?
  @_alwaysEmitIntoClient public func distance(from start: Foundation.AttributedString.Index, to end: Foundation.AttributedString.Index) -> Swift.Int {
        if #available(macOS 14, iOS 17, tvOS 17, watchOS 10, *) {
            return _distance(from: start, to: end)
        }
        precondition(start >= startIndex && start <= endIndex, "AttributedString index out of bounds")
        precondition(end >= startIndex && end <= endIndex, "AttributedString index out of bounds")
        return _defaultDistance(from: start, to: end)
    }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @usableFromInline
  internal func _distance(from start: Foundation.AttributedString.Index, to end: Foundation.AttributedString.Index) -> Swift.Int
  public subscript(index: Foundation.AttributedString.Index) -> Swift.UnicodeScalar {
    get
  }
  public subscript(bounds: Swift.Range<Foundation.AttributedString.Index>) -> Swift.Slice<Foundation.AttributedString.UnicodeScalarView> {
    get
  }
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias Indices = Swift.DefaultIndices<Foundation.AttributedString.UnicodeScalarView>
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias Iterator = Swift.IndexingIterator<Foundation.AttributedString.UnicodeScalarView>
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias SubSequence = Swift.Slice<Foundation.AttributedString.UnicodeScalarView>
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.UnicodeScalarView : Swift.RangeReplaceableCollection {
  public mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.AttributedString.UnicodeScalarView.Index>, with newElements: some Collection<UnicodeScalar>)
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.AttributedString {
  public enum AttributeRunBoundaries : Swift.Hashable, Swift.Sendable {
    case paragraph
    case character(Swift.Character)
    public static func == (a: Foundation.AttributedString.AttributeRunBoundaries, b: Foundation.AttributedString.AttributeRunBoundaries) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.AttributedString {
  public struct AttributeInvalidationCondition : Swift.Hashable, Swift.Sendable {
    public static let textChanged: Foundation.AttributedString.AttributeInvalidationCondition
    public static func attributeChanged<T>(_ key: T.Type) -> Foundation.AttributedString.AttributeInvalidationCondition where T : Foundation.AttributedStringKey
    public static func attributeChanged<T>(_ key: Swift.KeyPath<Foundation.AttributeDynamicLookup, T>) -> Foundation.AttributedString.AttributeInvalidationCondition where T : Foundation.AttributedStringKey
    public static func == (a: Foundation.AttributedString.AttributeInvalidationCondition, b: Foundation.AttributedString.AttributeInvalidationCondition) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol AttributedStringKey {
  associatedtype Value : Swift.Hashable
  static var name: Swift.String { get }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  static var runBoundaries: Foundation.AttributedString.AttributeRunBoundaries? { get }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  static var inheritedByAddedText: Swift.Bool { get }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  static var invalidationConditions: Swift.Set<Foundation.AttributedString.AttributeInvalidationCondition>? { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedStringKey {
  public var description: Swift.String {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public static var runBoundaries: Foundation.AttributedString.AttributeRunBoundaries? {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public static var inheritedByAddedText: Swift.Bool {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public static var invalidationConditions: Swift.Set<Foundation.AttributedString.AttributeInvalidationCondition>? {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup @frozen public enum AttributeDynamicLookup {
  public subscript<T>(_: T.Type) -> T where T : Foundation.AttributedStringKey {
    get
  }
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeDynamicLookup : Swift.Sendable {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public struct ScopedAttributeContainer<S> : Swift.Sendable where S : Foundation.AttributeScope {
  @preconcurrency public subscript<T>(dynamicMember keyPath: Swift.KeyPath<S, T>) -> T.Value? where T : Foundation.AttributedStringKey, T.Value : Swift.Sendable {
    get
    set
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol EncodableAttributedStringKey : Foundation.AttributedStringKey {
  static func encode(_ value: Self.Value, to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol DecodableAttributedStringKey : Foundation.AttributedStringKey {
  static func decode(from decoder: any Swift.Decoder) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public typealias CodableAttributedStringKey = Foundation.DecodableAttributedStringKey & Foundation.EncodableAttributedStringKey
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.EncodableAttributedStringKey where Self.Value : Swift.Encodable {
  public static func encode(_ value: Self.Value, to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.DecodableAttributedStringKey where Self.Value : Swift.Decodable {
  public static func decode(from decoder: any Swift.Decoder) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol MarkdownDecodableAttributedStringKey : Foundation.AttributedStringKey {
  static func decodeMarkdown(from decoder: any Swift.Decoder) throws -> Self.Value
  static var markdownName: Swift.String { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.MarkdownDecodableAttributedStringKey {
  public static var markdownName: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.MarkdownDecodableAttributedStringKey where Self : Foundation.DecodableAttributedStringKey {
  public static func decodeMarkdown(from decoder: any Swift.Decoder) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.EncodableAttributedStringKey where Self.Value : ObjectiveC.NSObject, Self.Value : Foundation.NSSecureCoding {
  public static func encode(_ value: Self.Value, to encoder: any Swift.Encoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.DecodableAttributedStringKey where Self.Value : ObjectiveC.NSObject, Self.Value : Foundation.NSSecureCoding {
  public static func decode(from decoder: any Swift.Decoder) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public struct AttributeScopeCodableConfiguration : Swift.Sendable {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScope {
  public static var encodingConfiguration: Foundation.AttributeScopeCodableConfiguration {
    get
  }
  public static var decodingConfiguration: Foundation.AttributeScopeCodableConfiguration {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString : Foundation.CodableWithConfiguration {
  public func encode(to encoder: any Swift.Encoder, configuration: Foundation.AttributeScopeCodableConfiguration) throws
  public init(from decoder: any Swift.Decoder, configuration: Foundation.AttributeScopeCodableConfiguration) throws
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias DecodingConfiguration = Foundation.AttributeScopeCodableConfiguration
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias EncodingConfiguration = Foundation.AttributeScopeCodableConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeContainer : Foundation.CodableWithConfiguration {
  public func encode(to encoder: any Swift.Encoder, configuration: Foundation.AttributeScopeCodableConfiguration) throws
  public init(from decoder: any Swift.Decoder, configuration: Foundation.AttributeScopeCodableConfiguration) throws
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias DecodingConfiguration = Foundation.AttributeScopeCodableConfiguration
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias EncodingConfiguration = Foundation.AttributeScopeCodableConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.CodableConfiguration where ConfigurationProvider : Foundation.AttributeScope {
  public init(wrappedValue: T, from keyPath: Swift.KeyPath<Foundation.AttributeScopes, ConfigurationProvider.Type>)
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public enum AttributeMergePolicy : Swift.Sendable {
    case keepNew
    case keepCurrent
    public static func == (a: Foundation.AttributedString.AttributeMergePolicy, b: Foundation.AttributedString.AttributeMergePolicy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol AttributedStringAttributeMutation {
  mutating func setAttributes(_ attributes: Foundation.AttributeContainer)
  mutating func mergeAttributes(_ attributes: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy)
  mutating func replaceAttributes(_ attributes: Foundation.AttributeContainer, with others: Foundation.AttributeContainer)
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public protocol AttributedStringProtocol : Foundation.AttributedStringAttributeMutation, Swift.CustomStringConvertible, Swift.Hashable, Swift.Sendable {
  var startIndex: Foundation.AttributedString.Index { get }
  var endIndex: Foundation.AttributedString.Index { get }
  var runs: Foundation.AttributedString.Runs { get }
  var characters: Foundation.AttributedString.CharacterView { get }
  var unicodeScalars: Foundation.AttributedString.UnicodeScalarView { get }
  @preconcurrency subscript<K>(_: K.Type) -> K.Value? where K : Foundation.AttributedStringKey, K.Value : Swift.Sendable { get set }
  @preconcurrency subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> K.Value? where K : Foundation.AttributedStringKey, K.Value : Swift.Sendable { get set }
  subscript<S>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) -> Foundation.ScopedAttributeContainer<S> where S : Foundation.AttributeScope { get set }
  subscript<R>(bounds: R) -> Foundation.AttributedSubstring where R : Swift.RangeExpression, R.Bound == Foundation.AttributedString.Index { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedStringProtocol {
  public func settingAttributes(_ attributes: Foundation.AttributeContainer) -> Foundation.AttributedString
  public func mergingAttributes(_ attributes: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy = .keepNew) -> Foundation.AttributedString
  public func replacingAttributes(_ attributes: Foundation.AttributeContainer, with others: Foundation.AttributeContainer) -> Foundation.AttributedString
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedStringProtocol {
  public var description: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedStringProtocol {
  @_specialize(exported: false, kind: full, where Self == Foundation.AttributedString, RHS == Foundation.AttributedString)
  @_specialize(exported: false, kind: full, where Self == Foundation.AttributedString, RHS == Foundation.AttributedSubstring)
  @_specialize(exported: false, kind: full, where Self == Foundation.AttributedSubstring, RHS == Foundation.AttributedString)
  @_specialize(exported: false, kind: full, where Self == Foundation.AttributedSubstring, RHS == Foundation.AttributedSubstring)
  public static func == <RHS>(lhs: Self, rhs: RHS) -> Swift.Bool where RHS : Foundation.AttributedStringProtocol
  public func hash(into hasher: inout Swift.Hasher)
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedStringProtocol {
  public func index(afterCharacter i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(beforeCharacter i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(_ i: Foundation.AttributedString.Index, offsetByCharacters distance: Swift.Int) -> Foundation.AttributedString.Index
  public func index(afterUnicodeScalar i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(beforeUnicodeScalar i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(_ i: Foundation.AttributedString.Index, offsetByUnicodeScalars distance: Swift.Int) -> Foundation.AttributedString.Index
  public func index(afterRun i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(beforeRun i: Foundation.AttributedString.Index) -> Foundation.AttributedString.Index
  public func index(_ i: Foundation.AttributedString.Index, offsetByRuns distance: Swift.Int) -> Foundation.AttributedString.Index
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedStringProtocol {
  public func range<T>(of stringToFind: T, options: Swift.String.CompareOptions = [], locale: Foundation.Locale? = nil) -> Swift.Range<Foundation.AttributedString.Index>? where T : Swift.StringProtocol
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public struct AttributedSubstring : Swift.Sendable {
  public init()
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedSubstring {
  public var base: Foundation.AttributedString {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedSubstring {
  public var description: Swift.String {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedSubstring {
  public static func == (lhs: Foundation.AttributedSubstring, rhs: Foundation.AttributedSubstring) -> Swift.Bool
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedSubstring : Foundation.AttributedStringProtocol {
  public var startIndex: Foundation.AttributedString.Index {
    get
  }
  public var endIndex: Foundation.AttributedString.Index {
    get
  }
  public mutating func setAttributes(_ attributes: Foundation.AttributeContainer)
  public mutating func mergeAttributes(_ attributes: Foundation.AttributeContainer, mergePolicy: Foundation.AttributedString.AttributeMergePolicy = .keepNew)
  public mutating func replaceAttributes(_ attributes: Foundation.AttributeContainer, with others: Foundation.AttributeContainer)
  public var runs: Foundation.AttributedString.Runs {
    get
  }
  public var characters: Foundation.AttributedString.CharacterView {
    get
  }
  public var unicodeScalars: Foundation.AttributedString.UnicodeScalarView {
    get
  }
  public subscript(bounds: some RangeExpression<AttributedString.Index>) -> Foundation.AttributedSubstring {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedSubstring {
  @preconcurrency public subscript<K>(_: K.Type) -> K.Value? where K : Foundation.AttributedStringKey, K.Value : Swift.Sendable {
    get
    set
  }
  @preconcurrency public subscript<K>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeDynamicLookup, K>) -> K.Value? where K : Foundation.AttributedStringKey, K.Value : Swift.Sendable {
    get
    set
  }
  public subscript<S>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) -> Foundation.ScopedAttributeContainer<S> where S : Foundation.AttributeScope {
    get
    _modify
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol AttributeScope : Foundation.DecodingConfigurationProviding, Foundation.EncodingConfigurationProviding {
  static var decodingConfiguration: Foundation.AttributeScopeCodableConfiguration { get }
  static var encodingConfiguration: Foundation.AttributeScopeCodableConfiguration { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@frozen public enum AttributeScopes {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes : Swift.Sendable {
}
extension Swift.Collection {
  @_alwaysEmitIntoClient internal var _defaultCount: Swift.Int {
    get {
    distance(from: startIndex, to: endIndex)
  }
  }
  @_alwaysEmitIntoClient internal func _defaultDistanceForward(from start: Self.Index, to end: Self.Index) -> Swift.Int {
    precondition(start <= end,
                 "Only BidirectionalCollections can have end come before start")
    var start = start
    var count = 0
    while start != end {
      count = count + 1
      formIndex(after: &start)
    }
    return count
  }
  @_alwaysEmitIntoClient internal func _defaultAdvanceForward(_ i: Self.Index, by n: Swift.Int) -> Self.Index {
    precondition(n >= 0,
                 "Only BidirectionalCollections can be advanced by a negative amount")

    var i = i
    for _ in stride(from: 0, to: n, by: 1) {
      formIndex(after: &i)
    }
    return i
  }
  @_alwaysEmitIntoClient internal func _defaultAdvanceForward(_ i: Self.Index, by n: Swift.Int, limitedBy limit: Self.Index) -> Self.Index? {
    precondition(n >= 0,
                 "Only BidirectionalCollections can be advanced by a negative amount")

    var i = i
    for _ in stride(from: 0, to: n, by: 1) {
      if i == limit {
        return nil
      }
      formIndex(after: &i)
    }
    return i
  }
}
extension Swift.BidirectionalCollection {
  @_alwaysEmitIntoClient internal func _defaultDistance(from start: Self.Index, to end: Self.Index) -> Swift.Int {
    var start = start
    var count = 0
    
    if start < end {
      while start != end {
        count += 1
        formIndex(after: &start)
      }
    }
    else if start > end {
      while start != end {
        count -= 1
        formIndex(before: &start)
      }
    }
    
    return count
  }
  @_alwaysEmitIntoClient internal func _defaultIndex(_ i: Self.Index, offsetBy distance: Swift.Int) -> Self.Index {
    if distance >= 0 {
      return _defaultAdvanceForward(i, by: distance)
    }
    var i = i
    for _ in stride(from: 0, to: distance, by: -1) {
      formIndex(before: &i)
    }
    return i
  }
  @_alwaysEmitIntoClient internal func _defaultIndex(_ i: Self.Index, offsetBy distance: Swift.Int, limitedBy limit: Self.Index) -> Self.Index? {
    if distance >= 0 {
      return _defaultAdvanceForward(i, by: distance, limitedBy: limit)
    }
    var i = i
    for _ in stride(from: 0, to: distance, by: -1) {
      if i == limit {
        return nil
      }
      formIndex(before: &i)
    }
    return i
  }
}
extension Swift.String {
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public init(_ characters: Swift.Slice<Foundation.AttributedString.CharacterView>)
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @usableFromInline
  internal init(_characters: Foundation.AttributedString.CharacterView)
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol ObjectiveCConvertibleAttributedStringKey : Foundation.AttributedStringKey {
  associatedtype ObjectiveCValue : ObjectiveC.NSObject
  static func objectiveCValue(for value: Self.Value) throws -> Self.ObjectiveCValue
  static func value(for object: Self.ObjectiveCValue) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.ObjectiveCConvertibleAttributedStringKey where Self.ObjectiveCValue == Foundation.NSNumber, Self.Value : Swift.RawRepresentable, Self.Value.RawValue == Swift.Int {
  public static func objectiveCValue(for value: Self.Value) throws -> Self.ObjectiveCValue
  public static func value(for object: Self.ObjectiveCValue) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.ObjectiveCConvertibleAttributedStringKey where Self.ObjectiveCValue == Foundation.NSString, Self.Value : Swift.RawRepresentable, Self.Value.RawValue == Swift.String {
  public static func objectiveCValue(for value: Self.Value) throws -> Self.ObjectiveCValue
  public static func value(for object: Self.ObjectiveCValue) throws -> Self.Value
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeContainer {
  public init(_ dictionary: [Foundation.NSAttributedString.Key : Any])
  public init<S>(_ dictionary: [Foundation.NSAttributedString.Key : Any], including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) throws where S : Foundation.AttributeScope
  public init<S>(_ dictionary: [Foundation.NSAttributedString.Key : Any], including scope: S.Type) throws where S : Foundation.AttributeScope
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Dictionary where Key == Foundation.NSAttributedString.Key, Value == Any {
  public init(_ container: Foundation.AttributeContainer)
  public init<S>(_ container: Foundation.AttributeContainer, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) throws where S : Foundation.AttributeScope
  public init<S>(_ container: Foundation.AttributeContainer, including scope: S.Type) throws where S : Foundation.AttributeScope
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.NSAttributedString {
  convenience public init(_ attrStr: Foundation.AttributedString)
  convenience public init<S>(_ attrStr: Foundation.AttributedString, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) throws where S : Foundation.AttributeScope
  convenience public init<S>(_ attrStr: Foundation.AttributedString, including scope: S.Type) throws where S : Foundation.AttributeScope
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public init(_ nsStr: Foundation.NSAttributedString)
  public init<S>(_ nsStr: Foundation.NSAttributedString, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) throws where S : Foundation.AttributeScope
  public init<S>(_ nsStr: Foundation.NSAttributedString, including scope: S.Type) throws where S : Foundation.AttributeScope
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.String.Index {
  public init?<S>(_ sourcePosition: Foundation.AttributedString.Index, within target: S) where S : Swift.StringProtocol
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.Index {
  public init?<S>(_ sourcePosition: Swift.String.Index, within target: S) where S : Foundation.AttributedStringProtocol
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation._NSRange {
  public init<R, S>(_ region: R, in target: S) where R : Swift.RangeExpression, S : Foundation.AttributedStringProtocol, R.Bound == Foundation.AttributedString.Index
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public init?<S>(_ markdownSourcePosition: Foundation.AttributedString.MarkdownSourcePosition, in target: S) where S : Swift.StringProtocol
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Range where Bound == Foundation.AttributedString.Index {
  public init?<S>(_ range: Foundation.NSRange, in string: S) where S : Foundation.AttributedStringProtocol
  public init?<R, S>(_ region: R, in attributedString: S) where R : Swift.RangeExpression, S : Foundation.AttributedStringProtocol, R.Bound == Swift.String.Index
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Range where Bound == Swift.String.Index {
  public init?<R, S>(_ region: R, in string: S) where R : Swift.RangeExpression, S : Swift.StringProtocol, R.Bound == Foundation.AttributedString.Index
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public init?<S>(_ markdownSourcePosition: Foundation.AttributedString.MarkdownSourcePosition, in target: S) where S : Swift.StringProtocol
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes {
  public var foundation: Foundation.AttributeScopes.FoundationAttributes.Type {
    get
  }
  public struct FoundationAttributes : Foundation.AttributeScope {
    public let link: Foundation.AttributeScopes.FoundationAttributes.LinkAttribute
    public let languageIdentifier: Foundation.AttributeScopes.FoundationAttributes.LanguageIdentifierAttribute
    public let personNameComponent: Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute
    public let numberFormat: Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes
    public let dateField: Foundation.AttributeScopes.FoundationAttributes.DateFieldAttribute
    public let alternateDescription: Foundation.AttributeScopes.FoundationAttributes.AlternateDescriptionAttribute
    public let imageURL: Foundation.AttributeScopes.FoundationAttributes.ImageURLAttribute
    public let replacementIndex: Foundation.AttributeScopes.FoundationAttributes.ReplacementIndexAttribute
    public let measurement: Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute
    public let byteCount: Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public let durationField: Foundation.AttributeScopes.FoundationAttributes.DurationFieldAttribute
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public let agreementConcept: Foundation.AttributeScopes.FoundationAttributes.AgreementConceptAttribute
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public let agreementArgument: Foundation.AttributeScopes.FoundationAttributes.AgreementArgumentAttribute
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public let referentConcept: Foundation.AttributeScopes.FoundationAttributes.ReferentConceptAttribute
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public let localizedNumberFormat: Foundation.AttributeScopes.FoundationAttributes.LocalizedNumberFormatAttribute
    public let inlinePresentationIntent: Foundation.AttributeScopes.FoundationAttributes.InlinePresentationIntentAttribute
    public let presentationIntent: Foundation.AttributeScopes.FoundationAttributes.PresentationIntentAttribute
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public let markdownSourcePosition: Foundation.AttributeScopes.FoundationAttributes.MarkdownSourcePositionAttribute
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public let localizedStringArgumentAttributes: Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes
    public let inflectionAlternative: Foundation.AttributeScopes.FoundationAttributes.InflectionAlternativeAttribute
    public let morphology: Foundation.AttributeScopes.FoundationAttributes.MorphologyAttribute
    public let inflect: Foundation.AttributeScopes.FoundationAttributes.InflectionRuleAttribute
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias DecodingConfiguration = Foundation.AttributeScopeCodableConfiguration
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias EncodingConfiguration = Foundation.AttributeScopeCodableConfiguration
  }
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes : Swift.Sendable {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeDynamicLookup {
  public subscript<T>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes.FoundationAttributes, T>) -> T where T : Foundation.AttributedStringKey {
    get
  }
  public subscript<T>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes, T>) -> T where T : Foundation.AttributedStringKey {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public subscript<T>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes, T>) -> T where T : Foundation.AttributedStringKey {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes {
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum LinkAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.URL
    public static var name: Swift.String {
      get
      set
    }
  }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @frozen public enum ReferentConceptAttribute : Foundation.CodableAttributedStringKey, Foundation.MarkdownDecodableAttributedStringKey {
    public typealias Value = Swift.Int
    public static let name: Swift.String
    public static let markdownName: Swift.String
  }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @frozen public enum AgreementConceptAttribute : Foundation.CodableAttributedStringKey, Foundation.MarkdownDecodableAttributedStringKey {
    public typealias Value = Swift.Int
    public static let name: Swift.String
    public static let markdownName: Swift.String
  }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @frozen public enum AgreementArgumentAttribute : Foundation.CodableAttributedStringKey, Foundation.MarkdownDecodableAttributedStringKey {
    public typealias Value = Swift.Int
    public static let name: Swift.String
    public static let markdownName: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum MorphologyAttribute : Foundation.CodableAttributedStringKey, Foundation.MarkdownDecodableAttributedStringKey {
    public typealias Value = Foundation.Morphology
    public static let name: Swift.String
    public static let markdownName: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum InflectionRuleAttribute : Foundation.CodableAttributedStringKey, Foundation.MarkdownDecodableAttributedStringKey {
    public typealias Value = Foundation.InflectionRule
    public static let name: Swift.String
    public static let markdownName: Swift.String
  }
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
  @frozen public enum LocalizedNumberFormatAttribute : Foundation.CodableAttributedStringKey, Foundation.MarkdownDecodableAttributedStringKey {
    public struct Value : Swift.Equatable, Swift.Hashable, Swift.Codable, Swift.Sendable {
      public static var automatic: Foundation.AttributeScopes.FoundationAttributes.LocalizedNumberFormatAttribute.Value {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
      public func encode(to encoder: any Swift.Encoder) throws
      public static func == (a: Foundation.AttributeScopes.FoundationAttributes.LocalizedNumberFormatAttribute.Value, b: Foundation.AttributeScopes.FoundationAttributes.LocalizedNumberFormatAttribute.Value) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public static let name: Swift.String
    public static let markdownName: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum LanguageIdentifierAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Swift.String
    public static let name: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum PersonNameComponentAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component
    public static let name: Swift.String
    public enum Component : Swift.String, Swift.Codable, Swift.Sendable {
      case givenName, familyName, middleName, namePrefix, nameSuffix, nickname, delimiter
      public init?(rawValue: Swift.String)
      @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public struct NumberFormatAttributes : Foundation.AttributeScope {
    public let numberSymbol: Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute
    public let numberPart: Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute
    @frozen public enum NumberPartAttribute : Foundation.CodableAttributedStringKey {
      public enum NumberPart : Swift.Int, Swift.Codable, Swift.Sendable {
        case integer
        case fraction
        public init?(rawValue: Swift.Int)
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias RawValue = Swift.Int
        public var rawValue: Swift.Int {
          get
        }
      }
      public static let name: Swift.String
      public typealias Value = Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart
    }
    @frozen public enum SymbolAttribute : Foundation.CodableAttributedStringKey {
      public enum Symbol : Swift.Int, Swift.Codable, Swift.Sendable {
        case groupingSeparator
        case sign
        case decimalSeparator
        case currency
        case percent
        public init?(rawValue: Swift.Int)
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias RawValue = Swift.Int
        public var rawValue: Swift.Int {
          get
        }
      }
      public static let name: Swift.String
      public typealias Value = Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol
    }
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias DecodingConfiguration = Foundation.AttributeScopeCodableConfiguration
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias EncodingConfiguration = Foundation.AttributeScopeCodableConfiguration
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum DateFieldAttribute : Foundation.CodableAttributedStringKey {
    public enum Field : Swift.Hashable, Swift.Codable, Swift.Sendable {
      case era
      case year
      case relatedGregorianYear
      case quarter
      case month
      case weekOfYear
      case weekOfMonth
      case weekday
      case weekdayOrdinal
      case day
      case dayOfYear
      case amPM
      case hour
      case minute
      case second
      case secondFraction
      case timeZone
      public init(from decoder: any Swift.Decoder) throws
      public func encode(to encoder: any Swift.Encoder) throws
      public static func == (a: Foundation.AttributeScopes.FoundationAttributes.DateFieldAttribute.Field, b: Foundation.AttributeScopes.FoundationAttributes.DateFieldAttribute.Field) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public static let name: Swift.String
    public typealias Value = Foundation.AttributeScopes.FoundationAttributes.DateFieldAttribute.Field
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum InflectionAlternativeAttribute : Foundation.CodableAttributedStringKey, Foundation.MarkdownDecodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey {
    public typealias Value = Foundation.AttributedString
    public typealias ObjectiveCValue = ObjectiveC.NSObject
    public static let name: Swift.String
    public static let markdownName: Swift.String
    public static func decodeMarkdown(from decoder: any Swift.Decoder) throws -> Foundation.AttributedString
    public static func objectiveCValue(for value: Foundation.AttributedString) throws -> ObjectiveC.NSObject
    public static func value(for object: ObjectiveC.NSObject) throws -> Foundation.AttributedString
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum InlinePresentationIntentAttribute : Foundation.CodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey {
    public typealias Value = Foundation.InlinePresentationIntent
    public typealias ObjectiveCValue = Foundation.NSNumber
    public static let name: Swift.String
    public static func objectiveCValue(for value: Foundation.InlinePresentationIntent) throws -> Foundation.NSNumber
    public static func value(for object: Foundation.NSNumber) throws -> Foundation.InlinePresentationIntent
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum PresentationIntentAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.PresentationIntent
    public static let name: Swift.String
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @frozen public enum MarkdownSourcePositionAttribute : Foundation.CodableAttributedStringKey {
    public static let name: Swift.String
    public typealias Value = Foundation.AttributedString.MarkdownSourcePosition
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum AlternateDescriptionAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Swift.String
    public static let name: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum ImageURLAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.URL
    public static let name: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum ReplacementIndexAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Swift.Int
    public static let name: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public struct MeasurementAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute.Component
    public static let name: Swift.String
    public enum Component : Swift.Int, Swift.Codable, Swift.Sendable {
      case value
      case unit
      public init?(rawValue: Swift.Int)
      @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum ByteCountAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Component
    public static let name: Swift.String
    public enum Component : Swift.Codable, Swift.Hashable, Swift.Sendable {
      case value
      case spelledOutValue
      case unit(Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit)
      case actualByteCount
      public static func == (a: Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Component, b: Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Component) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public enum Unit : Swift.Codable, Swift.Sendable {
      case byte
      case kb
      case mb
      case gb
      case tb
      case pb
      case eb
      case zb
      case yb
      public static func == (a: Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit, b: Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  @frozen public enum DurationFieldAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.AttributeScopes.FoundationAttributes.DurationFieldAttribute.Field
    public static let name: Swift.String
    public enum Field : Swift.Int, Swift.Codable, Swift.Sendable {
      case weeks
      case days
      case hours
      case minutes
      case seconds
      case microseconds
      case milliseconds
      case nanoseconds
      public init?(rawValue: Swift.Int)
      @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct LocalizedStringArgumentAttributes {
    public let localizedNumericArgument: Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedNumericArgumentAttribute
    public let localizedDateArgument: Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedDateArgumentAttribute
    public let localizedDateIntervalArgument: Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedDateIntervalArgumentAttribute
    public let localizedURLArgument: Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedURLArgumentAttribute
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    @frozen public enum LocalizedNumericArgumentAttribute : Foundation.CodableAttributedStringKey {
      public static let name: Swift.String
      public enum Value : Swift.Hashable, Swift.Codable, Swift.Sendable {
        case uint(Swift.UInt64)
        case int(Swift.Int64)
        case double(Swift.Double)
        case decimal(Foundation.Decimal)
        public static func == (a: Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedNumericArgumentAttribute.Value, b: Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedNumericArgumentAttribute.Value) -> Swift.Bool
        public func encode(to encoder: any Swift.Encoder) throws
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
        public init(from decoder: any Swift.Decoder) throws
      }
    }
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    @frozen public enum LocalizedDateArgumentAttribute : Foundation.CodableAttributedStringKey {
      public typealias Value = Foundation.Date
      public static let name: Swift.String
    }
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    @frozen public enum LocalizedDateIntervalArgumentAttribute : Foundation.CodableAttributedStringKey {
      public typealias Value = Swift.Range<Foundation.Date>
      public static let name: Swift.String
    }
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    @frozen public enum LocalizedURLArgumentAttribute : Foundation.CodableAttributedStringKey {
      public typealias Value = Foundation.URL
      public static let name: Swift.String
    }
  }
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.LinkAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.LanguageIdentifierAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.DateFieldAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.AlternateDescriptionAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.ImageURLAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.ReplacementIndexAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 13.0)
@available(iOS, unavailable, introduced: 16.0)
@available(tvOS, unavailable, introduced: 16.0)
@available(watchOS, unavailable, introduced: 9.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.DurationFieldAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 14.0)
@available(iOS, unavailable, introduced: 17.0)
@available(tvOS, unavailable, introduced: 17.0)
@available(watchOS, unavailable, introduced: 10.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.ReferentConceptAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 14.0)
@available(iOS, unavailable, introduced: 17.0)
@available(tvOS, unavailable, introduced: 17.0)
@available(watchOS, unavailable, introduced: 10.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.AgreementConceptAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 14.0)
@available(iOS, unavailable, introduced: 17.0)
@available(tvOS, unavailable, introduced: 17.0)
@available(watchOS, unavailable, introduced: 10.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.AgreementArgumentAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.MorphologyAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.InflectionRuleAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 15.0)
@available(iOS, unavailable, introduced: 18.0)
@available(tvOS, unavailable, introduced: 18.0)
@available(watchOS, unavailable, introduced: 11.0)
@available(visionOS, unavailable, introduced: 2.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedNumberFormatAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.InflectionAlternativeAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.InlinePresentationIntentAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 12.0)
@available(iOS, unavailable, introduced: 15.0)
@available(tvOS, unavailable, introduced: 15.0)
@available(watchOS, unavailable, introduced: 8.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.PresentationIntentAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 13.0)
@available(iOS, unavailable, introduced: 16.0)
@available(tvOS, unavailable, introduced: 16.0)
@available(watchOS, unavailable, introduced: 9.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.MarkdownSourcePositionAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 13.0)
@available(iOS, unavailable, introduced: 16.0)
@available(tvOS, unavailable, introduced: 16.0)
@available(watchOS, unavailable, introduced: 9.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 13.0)
@available(iOS, unavailable, introduced: 16.0)
@available(tvOS, unavailable, introduced: 16.0)
@available(watchOS, unavailable, introduced: 9.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedNumericArgumentAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 13.0)
@available(iOS, unavailable, introduced: 16.0)
@available(tvOS, unavailable, introduced: 16.0)
@available(watchOS, unavailable, introduced: 9.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedURLArgumentAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 13.0)
@available(iOS, unavailable, introduced: 16.0)
@available(tvOS, unavailable, introduced: 16.0)
@available(watchOS, unavailable, introduced: 9.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedDateArgumentAttribute : Swift.Sendable {
}
@available(macOS, unavailable, introduced: 13.0)
@available(iOS, unavailable, introduced: 16.0)
@available(tvOS, unavailable, introduced: 16.0)
@available(watchOS, unavailable, introduced: 9.0)
@available(*, unavailable)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedDateIntervalArgumentAttribute : Swift.Sendable {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.LinkAttribute : Foundation.ObjectiveCConvertibleAttributedStringKey {
  public typealias ObjectiveCValue = ObjectiveC.NSObject
  public static func objectiveCValue(for value: Foundation.URL) throws -> ObjectiveC.NSObject
  public static func value(for object: ObjectiveC.NSObject) throws -> Foundation.URL
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.LanguageIdentifierAttribute : Foundation.MarkdownDecodableAttributedStringKey {
  public static let markdownName: Swift.String
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute : Foundation.ObjectiveCConvertibleAttributedStringKey {
  public typealias ObjectiveCValue = Foundation.NSString
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedNumberFormatAttribute.Value : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> Foundation.__NSLocalizedNumberFormatRule
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.__NSLocalizedNumberFormatRule, result: inout Foundation.AttributeScopes.FoundationAttributes.LocalizedNumberFormatAttribute.Value?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.__NSLocalizedNumberFormatRule, result: inout Foundation.AttributeScopes.FoundationAttributes.LocalizedNumberFormatAttribute.Value?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.__NSLocalizedNumberFormatRule?) -> Foundation.AttributeScopes.FoundationAttributes.LocalizedNumberFormatAttribute.Value
  public typealias _ObjectiveCType = Foundation.__NSLocalizedNumberFormatRule
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct Calendar : Swift.Hashable, Swift.Equatable, Swift.Sendable {
  public enum Identifier : Swift.Sendable, Swift.CustomDebugStringConvertible {
    case gregorian
    case buddhist
    case chinese
    case coptic
    case ethiopicAmeteMihret
    case ethiopicAmeteAlem
    case hebrew
    case iso8601
    case indian
    case islamic
    case islamicCivil
    case japanese
    case persian
    case republicOfChina
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    case islamicTabular
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    case islamicUmmAlQura
    public var debugDescription: Swift.String {
      get
    }
    public static func == (a: Foundation.Calendar.Identifier, b: Foundation.Calendar.Identifier) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Component : Swift.Sendable {
    case era
    case year
    case month
    case day
    case hour
    case minute
    case second
    case weekday
    case weekdayOrdinal
    case quarter
    case weekOfMonth
    case weekOfYear
    case yearForWeekOfYear
    case nanosecond
    case calendar
    case timeZone
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    case isLeapMonth
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    case dayOfYear
    public static func == (a: Foundation.Calendar.Component, b: Foundation.Calendar.Component) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var current: Foundation.Calendar {
    get
  }
  public static var autoupdatingCurrent: Foundation.Calendar {
    get
  }
  public init(identifier: __shared Foundation.Calendar.Identifier)
  public var identifier: Foundation.Calendar.Identifier {
    get
  }
  public var locale: Foundation.Locale? {
    get
    set
  }
  public var timeZone: Foundation.TimeZone {
    get
    set
  }
  public var firstWeekday: Swift.Int {
    get
    set
  }
  public var minimumDaysInFirstWeek: Swift.Int {
    get
    set
  }
  public func minimumRange(of component: Foundation.Calendar.Component) -> Swift.Range<Swift.Int>?
  public func maximumRange(of component: Foundation.Calendar.Component) -> Swift.Range<Swift.Int>?
  public func range(of smaller: Foundation.Calendar.Component, in larger: Foundation.Calendar.Component, for date: Foundation.Date) -> Swift.Range<Swift.Int>?
  public func dateInterval(of component: Foundation.Calendar.Component, start: inout Foundation.Date, interval: inout Foundation.TimeInterval, for date: Foundation.Date) -> Swift.Bool
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func dateInterval(of component: Foundation.Calendar.Component, for date: Foundation.Date) -> Foundation.DateInterval?
  public func ordinality(of smaller: Foundation.Calendar.Component, in larger: Foundation.Calendar.Component, for date: Foundation.Date) -> Swift.Int?
  public func date(byAdding components: Foundation.DateComponents, to date: Foundation.Date, wrappingComponents: Swift.Bool = false) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func date(byAdding component: Foundation.Calendar.Component, value: Swift.Int, to date: Foundation.Date, wrappingComponents: Swift.Bool = false) -> Foundation.Date?
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
  public func dates(byAdding component: Foundation.Calendar.Component, value: Swift.Int = 1, startingAt start: Foundation.Date, in range: Swift.Range<Foundation.Date>? = nil, wrappingComponents: Swift.Bool = false) -> some Swift.Sendable & Swift.Sequence<Foundation.Date>
  
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
  public func dates(byAdding components: Foundation.DateComponents, startingAt start: Foundation.Date, in range: Swift.Range<Foundation.Date>? = nil, wrappingComponents: Swift.Bool = false) -> some Swift.Sendable & Swift.Sequence<Foundation.Date>
  
  public func date(from components: Foundation.DateComponents) -> Foundation.Date?
  public func dateComponents(_ components: Swift.Set<Foundation.Calendar.Component>, from date: Foundation.Date) -> Foundation.DateComponents
  @available(iOS 8.0, *)
  public func dateComponents(in timeZone: Foundation.TimeZone, from date: Foundation.Date) -> Foundation.DateComponents
  public func dateComponents(_ components: Swift.Set<Foundation.Calendar.Component>, from start: Foundation.Date, to end: Foundation.Date) -> Foundation.DateComponents
  @available(iOS 8.0, *)
  public func dateComponents(_ components: Swift.Set<Foundation.Calendar.Component>, from start: Foundation.DateComponents, to end: Foundation.DateComponents) -> Foundation.DateComponents
  @available(iOS 8.0, *)
  public func component(_ component: Foundation.Calendar.Component, from date: Foundation.Date) -> Swift.Int
  @available(iOS 8.0, *)
  public func startOfDay(for date: Foundation.Date) -> Foundation.Date
  @available(iOS 8.0, *)
  public func compare(_ date1: Foundation.Date, to date2: Foundation.Date, toGranularity component: Foundation.Calendar.Component) -> Foundation.ComparisonResult
  @available(iOS 8.0, *)
  public func isDate(_ date1: Foundation.Date, equalTo date2: Foundation.Date, toGranularity component: Foundation.Calendar.Component) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDate(_ date1: Foundation.Date, inSameDayAs date2: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDateInToday(_ date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDateInYesterday(_ date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDateInTomorrow(_ date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func isDateInWeekend(_ date: Foundation.Date) -> Swift.Bool
  @available(iOS 8.0, *)
  public func dateIntervalOfWeekend(containing date: Foundation.Date, start: inout Foundation.Date, interval: inout Foundation.TimeInterval) -> Swift.Bool
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func dateIntervalOfWeekend(containing date: Foundation.Date) -> Foundation.DateInterval?
  @available(iOS 8.0, *)
  public func nextWeekend(startingAfter date: Foundation.Date, start: inout Foundation.Date, interval: inout Foundation.TimeInterval, direction: Foundation.Calendar.SearchDirection = .forward) -> Swift.Bool
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public func nextWeekend(startingAfter date: Foundation.Date, direction: Foundation.Calendar.SearchDirection = .forward) -> Foundation.DateInterval?
  public enum SearchDirection : Swift.Sendable {
    case forward
    case backward
    public static func == (a: Foundation.Calendar.SearchDirection, b: Foundation.Calendar.SearchDirection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum RepeatedTimePolicy : Swift.Sendable {
    case first
    case last
    public static func == (a: Foundation.Calendar.RepeatedTimePolicy, b: Foundation.Calendar.RepeatedTimePolicy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum MatchingPolicy : Swift.Sendable, Swift.Equatable {
    case nextTime
    case nextTimePreservingSmallerComponents
    case previousTimePreservingSmallerComponents
    case strict
    public static func == (a: Foundation.Calendar.MatchingPolicy, b: Foundation.Calendar.MatchingPolicy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(iOS 8.0, *)
  public func enumerateDates(startingAfter start: Foundation.Date, matching components: Foundation.DateComponents, matchingPolicy: Foundation.Calendar.MatchingPolicy, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, direction: Foundation.Calendar.SearchDirection = .forward, using block: (_ result: Foundation.Date?, _ exactMatch: Swift.Bool, _ stop: inout Swift.Bool) -> Swift.Void)
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
  public func dates(byMatching components: Foundation.DateComponents, startingAt start: Foundation.Date, in range: Swift.Range<Foundation.Date>? = nil, matchingPolicy: Foundation.Calendar.MatchingPolicy = .nextTime, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, direction: Foundation.Calendar.SearchDirection = .forward) -> some Swift.Sendable & Swift.Sequence<Foundation.Date>
  
  @available(iOS 8.0, *)
  public func nextDate(after date: Foundation.Date, matching components: Foundation.DateComponents, matchingPolicy: Foundation.Calendar.MatchingPolicy, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, direction: Foundation.Calendar.SearchDirection = .forward) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func date(bySetting component: Foundation.Calendar.Component, value: Swift.Int, of date: Foundation.Date) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func date(bySettingHour hour: Swift.Int, minute: Swift.Int, second: Swift.Int, of date: Foundation.Date, matchingPolicy: Foundation.Calendar.MatchingPolicy = .nextTime, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, direction: Foundation.Calendar.SearchDirection = .forward) -> Foundation.Date?
  @available(iOS 8.0, *)
  public func date(_ date: Foundation.Date, matchesComponents components: Foundation.DateComponents) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.Calendar, rhs: Foundation.Calendar) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Calendar : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Calendar : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Calendar.Identifier : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Calendar.MatchingPolicy : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Calendar.RepeatedTimePolicy : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Calendar : Foundation.ReferenceConvertible {
  public typealias ReferenceType = Foundation.NSCalendar
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Calendar : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSCalendar
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSCalendar, result: inout Foundation.Calendar?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSCalendar, result: inout Foundation.Calendar?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSCalendar?) -> Foundation.Calendar
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSCalendar
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSCalendar : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public func formatted<F>(_ format: F) -> F.FormatOutput where F : Foundation.FormatStyle, F.FormatInput == Foundation.Date
  public init<T>(_ value: T.ParseInput, strategy: T) throws where T : Foundation.ParseStrategy, T.ParseOutput == Foundation.Date
  @_disfavoredOverload public init<T, Value>(_ value: Value, strategy: T) throws where T : Foundation.ParseStrategy, Value : Swift.StringProtocol, T.ParseInput == Swift.String, T.ParseOutput == Foundation.Date
}
@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct DateComponents : Swift.Hashable, Swift.Equatable, Swift.Sendable {
  public init(calendar: Foundation.Calendar? = nil, timeZone: Foundation.TimeZone? = nil, era: Swift.Int? = nil, year: Swift.Int? = nil, month: Swift.Int? = nil, day: Swift.Int? = nil, hour: Swift.Int? = nil, minute: Swift.Int? = nil, second: Swift.Int? = nil, nanosecond: Swift.Int? = nil, weekday: Swift.Int? = nil, weekdayOrdinal: Swift.Int? = nil, quarter: Swift.Int? = nil, weekOfMonth: Swift.Int? = nil, weekOfYear: Swift.Int? = nil, yearForWeekOfYear: Swift.Int? = nil)
  public var calendar: Foundation.Calendar? {
    get
    set
  }
  public var timeZone: Foundation.TimeZone? {
    get
    set
  }
  public var era: Swift.Int? {
    get
    set
  }
  public var year: Swift.Int? {
    get
    set
  }
  public var month: Swift.Int? {
    get
    set
  }
  public var day: Swift.Int? {
    get
    set
  }
  public var hour: Swift.Int? {
    get
    set
  }
  public var minute: Swift.Int? {
    get
    set
  }
  public var second: Swift.Int? {
    get
    set
  }
  public var nanosecond: Swift.Int? {
    get
    set
  }
  public var weekday: Swift.Int? {
    get
    set
  }
  public var weekdayOrdinal: Swift.Int? {
    get
    set
  }
  public var quarter: Swift.Int? {
    get
    set
  }
  public var weekOfMonth: Swift.Int? {
    get
    set
  }
  public var weekOfYear: Swift.Int? {
    get
    set
  }
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
  public var dayOfYear: Swift.Int? {
    get
    set
  }
  public var yearForWeekOfYear: Swift.Int? {
    get
    set
  }
  public var isLeapMonth: Swift.Bool? {
    get
    set
  }
  public var date: Foundation.Date? {
    get
  }
  @available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public mutating func setValue(_ value: Swift.Int?, for component: Foundation.Calendar.Component)
  @available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public func value(for component: Foundation.Calendar.Component) -> Swift.Int?
  @available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public var isValidDate: Swift.Bool {
    get
  }
  @available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public func isValidDate(in calendar: Foundation.Calendar) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.DateComponents, rhs: Foundation.DateComponents) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.DateComponents : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.DateComponents : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.DateComponents : Foundation.ReferenceConvertible, Swift._ObjectiveCBridgeable {
  public typealias ReferenceType = Foundation.NSDateComponents
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDateComponents
  public static func _forceBridgeFromObjectiveC(_ dateComponents: Foundation.NSDateComponents, result: inout Foundation.DateComponents?)
  public static func _conditionallyBridgeFromObjectiveC(_ ns: Foundation.NSDateComponents, result: inout Foundation.DateComponents?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSDateComponents?) -> Foundation.DateComponents
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSDateComponents
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSDateComponents : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.Calendar {
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
  public struct RecurrenceRule : Swift.Sendable, Swift.Equatable {
    public var calendar: Foundation.Calendar
    public var matchingPolicy: Foundation.Calendar.MatchingPolicy
    public var repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy
    public enum Frequency : Swift.Int, Swift.Sendable, Swift.Codable, Swift.Equatable {
      case minutely
      case hourly
      case daily
      case weekly
      case monthly
      case yearly
      public init?(rawValue: Swift.Int)
      @available(iOS 18, tvOS 18, watchOS 11, macOS 15, *)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
    public var frequency: Foundation.Calendar.RecurrenceRule.Frequency
    public var interval: Swift.Int
    public struct End : Swift.Sendable, Swift.Equatable {
      public static func afterOccurrences(_ count: Swift.Int) -> Foundation.Calendar.RecurrenceRule.End
      public static func afterDate(_ date: Foundation.Date) -> Foundation.Calendar.RecurrenceRule.End
      public static var never: Foundation.Calendar.RecurrenceRule.End {
        get
      }
      @available(macOS 15.2, iOS 18.2, tvOS 18.2, watchOS 11.2, *)
      public var occurrences: Swift.Int? {
        get
      }
      @available(macOS 15.2, iOS 18.2, tvOS 18.2, watchOS 11.2, *)
      public var date: Foundation.Date? {
        get
      }
      public static func == (a: Foundation.Calendar.RecurrenceRule.End, b: Foundation.Calendar.RecurrenceRule.End) -> Swift.Bool
    }
    public var end: Foundation.Calendar.RecurrenceRule.End
    public enum Weekday : Swift.Sendable, Swift.Equatable {
      case every(Foundation.Locale.Weekday)
      case nth(Swift.Int, Foundation.Locale.Weekday)
      public static func == (a: Foundation.Calendar.RecurrenceRule.Weekday, b: Foundation.Calendar.RecurrenceRule.Weekday) -> Swift.Bool
    }
    public struct Month : Swift.Sendable, Swift.ExpressibleByIntegerLiteral, Swift.Equatable {
      public typealias IntegerLiteralType = Swift.Int
      public var index: Swift.Int
      public var isLeap: Swift.Bool
      public init(_ index: Swift.Int, isLeap: Swift.Bool = false)
      public init(integerLiteral value: Swift.Int)
      public static func == (a: Foundation.Calendar.RecurrenceRule.Month, b: Foundation.Calendar.RecurrenceRule.Month) -> Swift.Bool
    }
    public var seconds: [Swift.Int]
    public var minutes: [Swift.Int]
    public var hours: [Swift.Int]
    public var weekdays: [Foundation.Calendar.RecurrenceRule.Weekday]
    public var daysOfTheMonth: [Swift.Int]
    public var daysOfTheYear: [Swift.Int]
    public var months: [Foundation.Calendar.RecurrenceRule.Month]
    public var weeks: [Swift.Int]
    public var setPositions: [Swift.Int]
    public init(calendar: Foundation.Calendar, frequency: Foundation.Calendar.RecurrenceRule.Frequency, interval: Swift.Int = 1, end: Foundation.Calendar.RecurrenceRule.End = .never, matchingPolicy: Foundation.Calendar.MatchingPolicy = .nextTimePreservingSmallerComponents, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, months: [Foundation.Calendar.RecurrenceRule.Month] = [], daysOfTheYear: [Swift.Int] = [], daysOfTheMonth: [Swift.Int] = [], weeks: [Swift.Int] = [], weekdays: [Foundation.Calendar.RecurrenceRule.Weekday] = [], hours: [Swift.Int] = [], minutes: [Swift.Int] = [], seconds: [Swift.Int] = [], setPositions: [Swift.Int] = [])
    public func recurrences(of start: Foundation.Date, in range: Swift.Range<Foundation.Date>? = nil) -> some Swift.Sendable & Swift.Sequence<Foundation.Date>
    
    public static func minutely(calendar: Foundation.Calendar, interval: Swift.Int = 1, end: Foundation.Calendar.RecurrenceRule.End = .never, matchingPolicy: Foundation.Calendar.MatchingPolicy = .nextTimePreservingSmallerComponents, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, months: [Foundation.Calendar.RecurrenceRule.Month] = [], daysOfTheYear: [Swift.Int] = [], daysOfTheMonth: [Swift.Int] = [], weekdays: [Foundation.Calendar.RecurrenceRule.Weekday] = [], hours: [Swift.Int] = [], minutes: [Swift.Int] = [], seconds: [Swift.Int] = [], setPositions: [Swift.Int] = []) -> Foundation.Calendar.RecurrenceRule
    public static func hourly(calendar: Foundation.Calendar, interval: Swift.Int = 1, end: Foundation.Calendar.RecurrenceRule.End = .never, matchingPolicy: Foundation.Calendar.MatchingPolicy = .nextTimePreservingSmallerComponents, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, months: [Foundation.Calendar.RecurrenceRule.Month] = [], daysOfTheYear: [Swift.Int] = [], daysOfTheMonth: [Swift.Int] = [], weekdays: [Foundation.Calendar.RecurrenceRule.Weekday] = [], hours: [Swift.Int] = [], minutes: [Swift.Int] = [], seconds: [Swift.Int] = [], setPositions: [Swift.Int] = []) -> Foundation.Calendar.RecurrenceRule
    public static func daily(calendar: Foundation.Calendar, interval: Swift.Int = 1, end: Foundation.Calendar.RecurrenceRule.End = .never, matchingPolicy: Foundation.Calendar.MatchingPolicy = .nextTimePreservingSmallerComponents, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, months: [Foundation.Calendar.RecurrenceRule.Month] = [], daysOfTheMonth: [Swift.Int] = [], weekdays: [Foundation.Calendar.RecurrenceRule.Weekday] = [], hours: [Swift.Int] = [], minutes: [Swift.Int] = [], seconds: [Swift.Int] = [], setPositions: [Swift.Int] = []) -> Foundation.Calendar.RecurrenceRule
    public static func weekly(calendar: Foundation.Calendar, interval: Swift.Int = 1, end: Foundation.Calendar.RecurrenceRule.End = .never, matchingPolicy: Foundation.Calendar.MatchingPolicy = .nextTimePreservingSmallerComponents, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, months: [Foundation.Calendar.RecurrenceRule.Month] = [], weekdays: [Foundation.Calendar.RecurrenceRule.Weekday] = [], hours: [Swift.Int] = [], minutes: [Swift.Int] = [], seconds: [Swift.Int] = [], setPositions: [Swift.Int] = []) -> Foundation.Calendar.RecurrenceRule
    public static func monthly(calendar: Foundation.Calendar, interval: Swift.Int = 1, end: Foundation.Calendar.RecurrenceRule.End = .never, matchingPolicy: Foundation.Calendar.MatchingPolicy = .nextTimePreservingSmallerComponents, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, months: [Foundation.Calendar.RecurrenceRule.Month] = [], daysOfTheMonth: [Swift.Int] = [], weekdays: [Foundation.Calendar.RecurrenceRule.Weekday] = [], hours: [Swift.Int] = [], minutes: [Swift.Int] = [], seconds: [Swift.Int] = [], setPositions: [Swift.Int] = []) -> Foundation.Calendar.RecurrenceRule
    public static func yearly(calendar: Foundation.Calendar, interval: Swift.Int = 1, end: Foundation.Calendar.RecurrenceRule.End = .never, matchingPolicy: Foundation.Calendar.MatchingPolicy = .nextTimePreservingSmallerComponents, repeatedTimePolicy: Foundation.Calendar.RepeatedTimePolicy = .first, months: [Foundation.Calendar.RecurrenceRule.Month] = [], daysOfTheYear: [Swift.Int] = [], daysOfTheMonth: [Swift.Int] = [], weeks: [Swift.Int] = [], weekdays: [Foundation.Calendar.RecurrenceRule.Weekday] = [], hours: [Swift.Int] = [], minutes: [Swift.Int] = [], seconds: [Swift.Int] = [], setPositions: [Swift.Int] = []) -> Foundation.Calendar.RecurrenceRule
    public static func == (a: Foundation.Calendar.RecurrenceRule, b: Foundation.Calendar.RecurrenceRule) -> Swift.Bool
  }
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Calendar.RecurrenceRule.End : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Calendar.RecurrenceRule.Weekday : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Calendar.RecurrenceRule.Month : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Calendar.RecurrenceRule : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 15.2, iOS 18.2, tvOS 18.2, watchOS 11.2, *)
extension Foundation.Calendar.RecurrenceRule.End : Swift.CustomStringConvertible, Swift.Hashable {
  public var description: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.2, iOS 18.2, tvOS 18.2, watchOS 11.2, *)
extension Foundation.Calendar.RecurrenceRule.Month : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.2, iOS 18.2, tvOS 18.2, watchOS 11.2, *)
extension Foundation.Calendar.RecurrenceRule.Weekday : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.2, iOS 18.2, tvOS 18.2, watchOS 11.2, *)
extension Foundation.Calendar.RecurrenceRule : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Array : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.CollectionOfOne<Swift.Array<Swift.UInt8>> {
    get
  }
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Regions = Swift.CollectionOfOne<Swift.Array<Swift.UInt8>>
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.ArraySlice : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.CollectionOfOne<Swift.ArraySlice<Swift.UInt8>> {
    get
  }
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Regions = Swift.CollectionOfOne<Swift.ArraySlice<Swift.UInt8>>
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.ContiguousArray : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.CollectionOfOne<Swift.ContiguousArray<Swift.UInt8>> {
    get
  }
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Regions = Swift.CollectionOfOne<Swift.ContiguousArray<Swift.UInt8>>
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.EmptyCollection : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.EmptyCollection<Foundation.Data> {
    get
  }
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Regions = Swift.EmptyCollection<Foundation.Data>
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Repeated : Foundation.DataProtocol where Element == Swift.UInt8 {
  public typealias Regions = Swift.Repeated<Foundation.Data>
  public var regions: Swift.Repeated<Foundation.Data> {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Array : Foundation.MutableDataProtocol where Element == Swift.UInt8 {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.ContiguousArray : Foundation.MutableDataProtocol where Element == Swift.UInt8 {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol ContiguousBytes {
  func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Array : Foundation.ContiguousBytes where Element == Swift.UInt8 {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.ArraySlice : Foundation.ContiguousBytes where Element == Swift.UInt8 {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.ContiguousArray : Foundation.ContiguousBytes where Element == Swift.UInt8 {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.UnsafeRawBufferPointer : Foundation.ContiguousBytes {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(self)
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.UnsafeMutableRawBufferPointer : Foundation.ContiguousBytes {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(self))
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.UnsafeBufferPointer : Foundation.ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(self))
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.UnsafeMutableBufferPointer : Foundation.ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(self))
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.EmptyCollection : Foundation.ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        return try body(UnsafeRawBufferPointer(start: nil, count: 0))
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.CollectionOfOne : Foundation.ContiguousBytes where Element == Swift.UInt8 {
  @inlinable public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R {
        let element = self.first!
        return try Swift.withUnsafeBytes(of: element) {
            return try body($0)
        }
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Slice : Foundation.ContiguousBytes where Base : Foundation.ContiguousBytes {
  public func withUnsafeBytes<ResultType>(_ body: (Swift.UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType
}
@_alwaysEmitIntoClient internal func _withStackOrHeapBuffer(capacity: Swift.Int, _ body: (Swift.UnsafeMutableBufferPointer<Swift.UInt8>) -> Swift.Void) {
    guard capacity > 0 else {
        body(UnsafeMutableBufferPointer(start: nil, count: 0))
        return
    }
    typealias InlineBuffer = (  
        UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8,
        UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8,
        UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8,
        UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8
    )
    let inlineCount = MemoryLayout<InlineBuffer>.size
    if capacity <= inlineCount {
        var buffer: InlineBuffer = (
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0
        )
        withUnsafeMutableBytes(of: &buffer) { buffer in
            assert(buffer.count == inlineCount)
            buffer.withMemoryRebound(to: UInt8.self) {
                body(UnsafeMutableBufferPointer(start: $0.baseAddress, count: capacity))
            }
        }
        return
    }

    let buffer = UnsafeMutableBufferPointer<UInt8>.allocate(capacity: capacity)
    defer { buffer.deallocate() }
    body(buffer)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@usableFromInline
final internal class __DataStorage : @unchecked Swift.Sendable {
  @usableFromInline
  internal static let maxSize: Swift.Int
  @usableFromInline
  internal static let vmOpsThreshold: Swift.Int
  @usableFromInline
  internal static func move(_ dest_: Swift.UnsafeMutableRawPointer, _ source_: Swift.UnsafeRawPointer?, _ num_: Swift.Int)
  @inlinable internal static func shouldAllocateCleared(_ size: Swift.Int) -> Swift.Bool {
        return (size > (128 * 1024))
    }
  @usableFromInline
  final internal var _bytes: Swift.UnsafeMutableRawPointer?
  @usableFromInline
  final internal var _length: Swift.Int
  @usableFromInline
  final internal var _capacity: Swift.Int
  @usableFromInline
  final internal var _offset: Swift.Int
  @usableFromInline
  final internal var _deallocator: ((Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void)?
  @usableFromInline
  final internal var _needToZero: Swift.Bool
  @inlinable final internal var bytes: Swift.UnsafeRawPointer? {
    get {
        return UnsafeRawPointer(_bytes)?.advanced(by: -_offset)
    }
  }
  @discardableResult
  @inlinable final internal func withUnsafeBytes<Result>(in range: Swift.Range<Swift.Int>, apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
        return try apply(UnsafeRawBufferPointer(start: _bytes?.advanced(by: range.lowerBound - _offset), count: Swift.min(range.upperBound - range.lowerBound, _length)))
    }
  @discardableResult
  @inlinable final internal func withUnsafeMutableBytes<Result>(in range: Swift.Range<Swift.Int>, apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
        return try apply(UnsafeMutableRawBufferPointer(start: _bytes!.advanced(by:range.lowerBound - _offset), count: Swift.min(range.upperBound - range.lowerBound, _length)))
    }
  @inlinable final internal var mutableBytes: Swift.UnsafeMutableRawPointer? {
    get {
        return _bytes?.advanced(by: -_offset)
    }
  }
  @inlinable final internal var capacity: Swift.Int {
    get {
        return _capacity
    }
  }
  @inlinable final internal var length: Swift.Int {
    get {
            return _length
        }
    set {
            setLength(newValue)
        }
  }
  @inlinable final internal var isExternallyOwned: Swift.Bool {
    get {
         
         
        return _capacity == 0
    }
  }
  @usableFromInline
  final internal func ensureUniqueBufferReference(growingTo newLength: Swift.Int = 0, clear: Swift.Bool = false)
  @inlinable final internal func _freeBytes() {
        if let bytes = _bytes {
            if let dealloc = _deallocator {
                dealloc(bytes, length)
            } else {
                free(bytes)
            }
        }
        _deallocator = nil
    }
  @inlinable final internal func enumerateBytes(in range: Swift.Range<Swift.Int>, _ block: (_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>, _ byteIndex: Foundation.Data.Index, _ stop: inout Swift.Bool) -> Swift.Void) {
        var stopv: Bool = false
        let buffer = UnsafeRawBufferPointer(start: _bytes, count: Swift.min(range.upperBound - range.lowerBound, _length))
        buffer.withMemoryRebound(to: UInt8.self) { block($0, 0, &stopv) }
    }
  @inlinable final internal func setLength(_ length: Swift.Int) {
        let origLength = _length
        let newLength = length
        if _capacity < newLength || _bytes == nil {
            ensureUniqueBufferReference(growingTo: newLength, clear: true)
        } else if origLength < newLength && _needToZero {
            _ = memset(_bytes! + origLength, 0, newLength - origLength)
        } else if newLength < origLength {
            _needToZero = true
        }
        _length = newLength
    }
  @inlinable final internal func append(_ bytes: Swift.UnsafeRawPointer, length: Swift.Int) {
        precondition(length >= 0, "Length of appending bytes must not be negative")
        let origLength = _length
        let newLength = origLength + length
        if _capacity < newLength || _bytes == nil {
            ensureUniqueBufferReference(growingTo: newLength, clear: false)
        }
        _length = newLength
        __DataStorage.move(_bytes!.advanced(by: origLength), bytes, length)
    }
  @inlinable final internal func get(_ index: Swift.Int) -> Swift.UInt8 {
         
        return _bytes!.load(fromByteOffset: index - _offset, as: UInt8.self)
    }
  @inlinable final internal func set(_ index: Swift.Int, to value: Swift.UInt8) {
         
        ensureUniqueBufferReference()
        _bytes!.storeBytes(of: value, toByteOffset: index - _offset, as: UInt8.self)
    }
  @inlinable final internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
        let offsetPointer = UnsafeRawBufferPointer(start: _bytes?.advanced(by: range.lowerBound - _offset), count: Swift.min(range.upperBound - range.lowerBound, _length))
        UnsafeMutableRawBufferPointer(start: pointer, count: range.upperBound - range.lowerBound).copyMemory(from: offsetPointer)
    }
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  @usableFromInline
  final internal func replaceBytes(in range_: Swift.Range<Swift.Int>, with replacementBytes: Swift.UnsafeRawPointer?, length replacementLength: Swift.Int)
  @usableFromInline
  final internal func resetBytes(in range_: Swift.Range<Swift.Int>)
  @usableFromInline
  internal init(length: Swift.Int)
  @usableFromInline
  internal init(capacity capacity_: Swift.Int = 0)
  @usableFromInline
  internal init(bytes: Swift.UnsafeRawPointer?, length: Swift.Int)
  @usableFromInline
  internal init(bytes: Swift.UnsafeMutableRawPointer?, length: Swift.Int, copy: Swift.Bool, deallocator: ((Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void)?, offset: Swift.Int)
  @usableFromInline
  internal init(offset: Swift.Int, bytes: Swift.UnsafeMutableRawPointer, capacity: Swift.Int, needToZero: Swift.Bool, length: Swift.Int, deallocator: ((Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void)?)
  @objc deinit
  @inlinable final internal func mutableCopy(_ range: Swift.Range<Swift.Int>) -> Foundation.__DataStorage {
        return __DataStorage(bytes: _bytes?.advanced(by: range.lowerBound - _offset), length: range.upperBound - range.lowerBound, copy: true, deallocator: nil, offset: range.lowerBound)
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@frozen public struct Data : Swift.Equatable, Swift.Hashable, Swift.RandomAccessCollection, Swift.MutableCollection, Swift.RangeReplaceableCollection, Foundation.MutableDataProtocol, Foundation.ContiguousBytes, Swift.Sendable {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @usableFromInline
  @frozen internal struct InlineData : Swift.Sendable {
    @usableFromInline
    internal typealias Buffer = (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8)
    @usableFromInline
    internal var bytes: Foundation.Data.InlineData.Buffer
    @usableFromInline
    internal var length: Swift.UInt8
    @inlinable internal static func canStore(count: Swift.Int) -> Swift.Bool {
            return count <= MemoryLayout<Buffer>.size
        }
    @inlinable internal init(_ srcBuffer: Swift.UnsafeRawBufferPointer) {
            self.init(count: srcBuffer.count)
            if !srcBuffer.isEmpty {
                Swift.withUnsafeMutableBytes(of: &bytes) { dstBuffer in
                    dstBuffer.baseAddress?.copyMemory(from: srcBuffer.baseAddress!, byteCount: srcBuffer.count)
                }
            }
        }
    @inlinable internal init(count: Swift.Int = 0) {
            assert(count <= MemoryLayout<Buffer>.size)
            bytes = (UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0), UInt8(0))
            length = UInt8(count)
        }
    @inlinable internal init(_ slice: Foundation.Data.InlineSlice, count: Swift.Int) {
            self.init(count: count)
            Swift.withUnsafeMutableBytes(of: &bytes) { dstBuffer in
                slice.withUnsafeBytes { srcBuffer in
                    dstBuffer.copyMemory(from: UnsafeRawBufferPointer(start: srcBuffer.baseAddress, count: count))
                }
            }
        }
    @inlinable internal init(_ slice: Foundation.Data.LargeSlice, count: Swift.Int) {
            self.init(count: count)
            Swift.withUnsafeMutableBytes(of: &bytes) { dstBuffer in
                slice.withUnsafeBytes { srcBuffer in
                    dstBuffer.copyMemory(from: UnsafeRawBufferPointer(start: srcBuffer.baseAddress, count: count))
                }
            }
        }
    @inlinable internal var capacity: Swift.Int {
      get {
            return MemoryLayout<Buffer>.size
        }
    }
    @inlinable internal var count: Swift.Int {
      get {
                return Int(length)
            }
      set(newValue) {
                assert(newValue <= MemoryLayout<Buffer>.size)
                if newValue > length {
                    resetBytes(in: Int(length) ..< newValue)  
                } else {
                    length = UInt8(newValue)
                }
            }
    }
    @inlinable internal var startIndex: Swift.Int {
      get {
            return 0
        }
    }
    @inlinable internal var endIndex: Swift.Int {
      get {
            return count
        }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            let count = Int(length)
            return try Swift.withUnsafeBytes(of: bytes) { (rawBuffer) throws -> Result in
                return try apply(UnsafeRawBufferPointer(start: rawBuffer.baseAddress, count: count))
            }
        }
    @inlinable internal mutating func withUnsafeMutableBytes<Result>(_ apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            let count = Int(length)
            return try Swift.withUnsafeMutableBytes(of: &bytes) { (rawBuffer) throws -> Result in
                return try apply(UnsafeMutableRawBufferPointer(start: rawBuffer.baseAddress, count: count))
            }
        }
    @inlinable internal mutating func append(byte: Swift.UInt8) {
            let count = self.count
            assert(count + 1 <= MemoryLayout<Buffer>.size)
            Swift.withUnsafeMutableBytes(of: &bytes) { $0[count] = byte }
            self.length += 1
        }
    @inlinable internal mutating func append(contentsOf buffer: Swift.UnsafeRawBufferPointer) {
            guard !buffer.isEmpty else { return }
            assert(count + buffer.count <= MemoryLayout<Buffer>.size)
            let cnt = count
            _ = Swift.withUnsafeMutableBytes(of: &bytes) { rawBuffer in
                rawBuffer.baseAddress?.advanced(by: cnt).copyMemory(from: buffer.baseAddress!, byteCount: buffer.count)
            }

            length += UInt8(buffer.count)
        }
    @inlinable internal subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
      get {
                assert(index <= MemoryLayout<Buffer>.size)
                precondition(index < length, "index \(index) is out of bounds of 0..<\(length)")
                return Swift.withUnsafeBytes(of: bytes) { rawBuffer -> UInt8 in
                    return rawBuffer[index]
                }
            }
      set(newValue) {
                assert(index <= MemoryLayout<Buffer>.size)
                precondition(index < length, "index \(index) is out of bounds of 0..<\(length)")
                Swift.withUnsafeMutableBytes(of: &bytes) { rawBuffer in
                    rawBuffer[index] = newValue
                }
            }
    }
    @inlinable internal mutating func resetBytes(in range: Swift.Range<Foundation.Data.Index>) {
            assert(range.lowerBound <= MemoryLayout<Buffer>.size)
            assert(range.upperBound <= MemoryLayout<Buffer>.size)
            precondition(range.lowerBound <= length, "index \(range.lowerBound) is out of bounds of 0..<\(length)")
            if length < range.upperBound {
                length = UInt8(range.upperBound)
            }

            let _ = Swift.withUnsafeMutableBytes(of: &bytes) { rawBuffer in
              memset(rawBuffer.baseAddress!.advanced(by: range.lowerBound), 0, range.upperBound - range.lowerBound)
            }
        }
    @usableFromInline
    internal mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with replacementBytes: Swift.UnsafeRawPointer?, count replacementLength: Swift.Int)
    @inlinable internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
            precondition(startIndex <= range.lowerBound, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= range.upperBound, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.upperBound <= endIndex, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")

            Swift.withUnsafeBytes(of: bytes) {
                let cnt = Swift.min($0.count, range.upperBound - range.lowerBound)
                guard cnt > 0 else { return }
                pointer.copyMemory(from: $0.baseAddress!.advanced(by: range.lowerBound), byteCount: cnt)
            }
        }
  }
  @usableFromInline
  internal typealias HalfInt = Swift.Int32
  @usableFromInline
  @frozen internal struct InlineSlice : Swift.Sendable {
    @usableFromInline
    internal var slice: Swift.Range<Foundation.Data.HalfInt>
    @usableFromInline
    internal var storage: Foundation.__DataStorage
    @inlinable internal static func canStore(count: Swift.Int) -> Swift.Bool {
            return count < HalfInt.max
        }
    @inlinable internal init(_ buffer: Swift.UnsafeRawBufferPointer) {
            assert(buffer.count < HalfInt.max)
            self.init(__DataStorage(bytes: buffer.baseAddress, length: buffer.count), count: buffer.count)
        }
    @inlinable internal init(capacity: Swift.Int) {
            assert(capacity < HalfInt.max)
            self.init(__DataStorage(capacity: capacity), count: 0)
        }
    @inlinable internal init(count: Swift.Int) {
            assert(count < HalfInt.max)
            self.init(__DataStorage(length: count), count: count)
        }
    @inlinable internal init(_ inline: Foundation.Data.InlineData) {
            assert(inline.count < HalfInt.max)
            self.init(inline.withUnsafeBytes { return __DataStorage(bytes: $0.baseAddress, length: $0.count) }, count: inline.count)
        }
    @inlinable internal init(_ inline: Foundation.Data.InlineData, range: Swift.Range<Swift.Int>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            self.init(inline.withUnsafeBytes { return __DataStorage(bytes: $0.baseAddress, length: $0.count) }, range: range)
        }
    @inlinable internal init(_ large: Foundation.Data.LargeSlice) {
            assert(large.range.lowerBound < HalfInt.max)
            assert(large.range.upperBound < HalfInt.max)
            self.init(large.storage, range: large.range)
        }
    @inlinable internal init(_ large: Foundation.Data.LargeSlice, range: Swift.Range<Swift.Int>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            self.init(large.storage, range: range)
        }
    @inlinable internal init(_ storage: Foundation.__DataStorage, count: Swift.Int) {
            assert(count < HalfInt.max)
            self.storage = storage
            slice = 0..<HalfInt(count)
        }
    @inlinable internal init(_ storage: Foundation.__DataStorage, range: Swift.Range<Swift.Int>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            self.storage = storage
            slice = HalfInt(range.lowerBound)..<HalfInt(range.upperBound)
        }
    @inlinable internal mutating func ensureUniqueReference() {
            if !isKnownUniquelyReferenced(&storage) {
                storage = storage.mutableCopy(self.range)
            }
        }
    @inlinable internal var startIndex: Swift.Int {
      get {
            return Int(slice.lowerBound)
        }
    }
    @inlinable internal var endIndex: Swift.Int {
      get {
            return Int(slice.upperBound)
        }
    }
    @inlinable internal var capacity: Swift.Int {
      get {
            return storage.capacity
        }
    }
    @inlinable internal mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
            ensureUniqueReference()
             
            storage.ensureUniqueBufferReference(growingTo: Swift.max(minimumCapacity, count))
        }
    @inlinable internal var count: Swift.Int {
      get {
                return Int(slice.upperBound - slice.lowerBound)
            }
      set(newValue) {
                assert(newValue < HalfInt.max)
                ensureUniqueReference()

                let difference = newValue - count
                if difference > 0 {
                    let additionalRange = Int(slice.upperBound) ..< Int(slice.upperBound) + difference
                    storage.resetBytes(in: additionalRange)  
                } else {
                    storage.length += difference
                }
                slice = slice.lowerBound..<(slice.lowerBound + HalfInt(newValue))
            }
    }
    @inlinable internal var range: Swift.Range<Swift.Int> {
      get {
                return Int(slice.lowerBound)..<Int(slice.upperBound)
            }
      set(newValue) {
                assert(newValue.lowerBound < HalfInt.max)
                assert(newValue.upperBound < HalfInt.max)
                slice = HalfInt(newValue.lowerBound)..<HalfInt(newValue.upperBound)
            }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            return try storage.withUnsafeBytes(in: range, apply: apply)
        }
    @inlinable internal mutating func withUnsafeMutableBytes<Result>(_ apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            ensureUniqueReference()
            return try storage.withUnsafeMutableBytes(in: range, apply: apply)
        }
    @inlinable internal mutating func append(contentsOf buffer: Swift.UnsafeRawBufferPointer) {
            assert(endIndex + buffer.count < HalfInt.max)
            ensureUniqueReference()
            let upperbound = storage.length + storage._offset
            if #available(macOS 14, iOS 17, watchOS 10, tvOS 17, *) {
                storage.replaceBytes(
                    in: range.upperBound ..< upperbound,
                    with: buffer.baseAddress,
                    length: buffer.count)
            } else {
                storage.replaceBytes(
                    in: NSRange(
                        location: range.upperBound,
                        length: storage.length - (range.upperBound - storage._offset)),
                    with: buffer.baseAddress,
                    length: buffer.count)
            }
            slice = slice.lowerBound..<HalfInt(Int(slice.upperBound) + buffer.count)
        }
    @inlinable internal subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
      get {
                assert(index < HalfInt.max)
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                return storage.get(index)
            }
      set(newValue) {
                assert(index < HalfInt.max)
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                ensureUniqueReference()
                storage.set(index, to: newValue)
            }
    }
    @inlinable internal mutating func resetBytes(in range: Swift.Range<Foundation.Data.Index>) {
            assert(range.lowerBound < HalfInt.max)
            assert(range.upperBound < HalfInt.max)
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            ensureUniqueReference()
            storage.resetBytes(in: range)
            if slice.upperBound < range.upperBound {
                slice = slice.lowerBound..<HalfInt(range.upperBound)
            }
        }
    @inlinable internal mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with bytes: Swift.UnsafeRawPointer?, count cnt: Swift.Int) {
            precondition(startIndex <= subrange.lowerBound, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.lowerBound <= endIndex, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= subrange.upperBound, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.upperBound <= endIndex, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")

            ensureUniqueReference()
            let upper = range.upperBound
            if #available(macOS 14, iOS 17, watchOS 10, tvOS 17, *) {
                storage.replaceBytes(in: subrange, with: bytes, length: cnt)
            } else {
                let nsRange = NSRange(
                    location: subrange.lowerBound,
                    length: subrange.upperBound - subrange.lowerBound)
                storage.replaceBytes(in: nsRange, with: bytes, length: cnt)
            }
            let resultingUpper = upper - (subrange.upperBound - subrange.lowerBound) + cnt
            slice = slice.lowerBound..<HalfInt(resultingUpper)
        }
    @inlinable internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
            precondition(startIndex <= range.lowerBound, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= range.upperBound, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.upperBound <= endIndex, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            storage.copyBytes(to: pointer, from: range)
        }
  }
  @usableFromInline
  @_fixed_layout final internal class RangeReference : @unchecked Swift.Sendable {
    @usableFromInline
    final internal var range: Swift.Range<Swift.Int>
    @inlinable @inline(__always) final internal var lowerBound: Swift.Int {
      get {
            return range.lowerBound
        }
    }
    @inlinable @inline(__always) final internal var upperBound: Swift.Int {
      get {
            return range.upperBound
        }
    }
    @inlinable @inline(__always) final internal var count: Swift.Int {
      get {
            return range.upperBound - range.lowerBound
        }
    }
    @inlinable @inline(__always) internal init(_ range: Swift.Range<Swift.Int>) {
            self.range = range
        }
    @objc @usableFromInline
    deinit
  }
  @usableFromInline
  @frozen internal struct LargeSlice : Swift.Sendable {
    @usableFromInline
    internal var slice: Foundation.Data.RangeReference
    @usableFromInline
    internal var storage: Foundation.__DataStorage
    @inlinable internal init(_ buffer: Swift.UnsafeRawBufferPointer) {
            self.init(__DataStorage(bytes: buffer.baseAddress, length: buffer.count), count: buffer.count)
        }
    @inlinable internal init(capacity: Swift.Int) {
            self.init(__DataStorage(capacity: capacity), count: 0)
        }
    @inlinable internal init(count: Swift.Int) {
            self.init(__DataStorage(length: count), count: count)
        }
    @inlinable internal init(_ inline: Foundation.Data.InlineData) {
            let storage = inline.withUnsafeBytes { return __DataStorage(bytes: $0.baseAddress, length: $0.count) }
            self.init(storage, count: inline.count)
        }
    @inlinable internal init(_ slice: Foundation.Data.InlineSlice) {
            self.storage = slice.storage
            self.slice = RangeReference(slice.range)
        }
    @inlinable internal init(_ storage: Foundation.__DataStorage, count: Swift.Int) {
            self.storage = storage
            self.slice = RangeReference(0..<count)
        }
    @inlinable internal mutating func ensureUniqueReference() {
            if !isKnownUniquelyReferenced(&storage) {
                storage = storage.mutableCopy(range)
            }
            if !isKnownUniquelyReferenced(&slice) {
                slice = RangeReference(range)
            }
        }
    @inlinable internal var startIndex: Swift.Int {
      get {
            return slice.range.lowerBound
        }
    }
    @inlinable internal var endIndex: Swift.Int {
      get {
          return slice.range.upperBound
        }
    }
    @inlinable internal var capacity: Swift.Int {
      get {
            return storage.capacity
        }
    }
    @inlinable internal mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
            ensureUniqueReference()
             
            storage.ensureUniqueBufferReference(growingTo: Swift.max(minimumCapacity, count))
        }
    @inlinable internal var count: Swift.Int {
      get {
                return slice.count
            }
      set(newValue) {
                ensureUniqueReference()
                let difference = newValue - count
                if difference > 0 {
                    let additionalRange = Int(slice.upperBound) ..< Int(slice.upperBound) + difference
                    storage.resetBytes(in: additionalRange)  
                } else {
                    storage.length += difference
                }
                slice.range = slice.range.lowerBound..<(slice.range.lowerBound + newValue)
            }
    }
    @inlinable internal var range: Swift.Range<Swift.Int> {
      get {
            return slice.range
        }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            return try storage.withUnsafeBytes(in: range, apply: apply)
        }
    @inlinable internal mutating func withUnsafeMutableBytes<Result>(_ apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            ensureUniqueReference()
            return try storage.withUnsafeMutableBytes(in: range, apply: apply)
        }
    @inlinable internal mutating func append(contentsOf buffer: Swift.UnsafeRawBufferPointer) {
            ensureUniqueReference()
            let upperbound = storage.length + storage._offset
            if #available(macOS 14, iOS 17, watchOS 10, tvOS 17, *) {
                storage.replaceBytes(
                    in: range.upperBound ..< upperbound,
                    with: buffer.baseAddress,
                    length: buffer.count)
            } else {
                storage.replaceBytes(
                    in: NSRange(
                        location: range.upperBound,
                        length: storage.length - (range.upperBound - storage._offset)),
                    with: buffer.baseAddress,
                    length: buffer.count)
            }
            slice.range = slice.range.lowerBound..<slice.range.upperBound + buffer.count
        }
    @inlinable internal subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
      get {
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                return storage.get(index)
            }
      set(newValue) {
                precondition(startIndex <= index, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                precondition(index < endIndex, "index \(index) is out of bounds of \(startIndex)..<\(endIndex)")
                ensureUniqueReference()
                storage.set(index, to: newValue)
            }
    }
    @inlinable internal mutating func resetBytes(in range: Swift.Range<Swift.Int>) {
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            ensureUniqueReference()
            storage.resetBytes(in: range)
            if slice.range.upperBound < range.upperBound {
                slice.range = slice.range.lowerBound..<range.upperBound
            }
        }
    @inlinable internal mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with bytes: Swift.UnsafeRawPointer?, count cnt: Swift.Int) {
            precondition(startIndex <= subrange.lowerBound, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.lowerBound <= endIndex, "index \(subrange.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= subrange.upperBound, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(subrange.upperBound <= endIndex, "index \(subrange.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")

            ensureUniqueReference()
            let upper = range.upperBound
            if #available(macOS 14, iOS 17, watchOS 10, tvOS 17, *) {
                storage.replaceBytes(in: subrange, with: bytes, length: cnt)
            } else {
                let nsRange = NSRange(
                    location: subrange.lowerBound,
                    length: subrange.upperBound - subrange.lowerBound)
                storage.replaceBytes(in: nsRange, with: bytes, length: cnt)
            }
            let resultingUpper = upper - (subrange.upperBound - subrange.lowerBound) + cnt
            slice.range = slice.range.lowerBound..<resultingUpper
        }
    @inlinable internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
            precondition(startIndex <= range.lowerBound, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(startIndex <= range.upperBound, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            precondition(range.upperBound <= endIndex, "index \(range.upperBound) is out of bounds of \(startIndex)..<\(endIndex)")
            storage.copyBytes(to: pointer, from: range)
        }
  }
  @usableFromInline
  @frozen internal enum _Representation : Swift.Sendable {
    case empty
    case inline(Foundation.Data.InlineData)
    case slice(Foundation.Data.InlineSlice)
    case large(Foundation.Data.LargeSlice)
    @inlinable internal init(_ buffer: Swift.UnsafeRawBufferPointer) {
            if buffer.isEmpty {
                self = .empty
            } else if InlineData.canStore(count: buffer.count) {
                self = .inline(InlineData(buffer))
            } else if InlineSlice.canStore(count: buffer.count) {
                self = .slice(InlineSlice(buffer))
            } else {
                self = .large(LargeSlice(buffer))
            }
        }
    @inlinable internal init(_ buffer: Swift.UnsafeRawBufferPointer, owner: Swift.AnyObject) {
            if buffer.isEmpty {
                self = .empty
            } else if InlineData.canStore(count: buffer.count) {
                self = .inline(InlineData(buffer))
            } else {
                let count = buffer.count
                let storage = __DataStorage(bytes: UnsafeMutableRawPointer(mutating: buffer.baseAddress), length: count, copy: false, deallocator: { _, _ in
                    _fixLifetime(owner)
                }, offset: 0)
                if InlineSlice.canStore(count: count) {
                    self = .slice(InlineSlice(storage, count: count))
                } else {
                    self = .large(LargeSlice(storage, count: count))
                }
            }
        }
    @inlinable internal init(capacity: Swift.Int) {
            if capacity == 0 {
                self = .empty
            } else if InlineData.canStore(count: capacity) {
                self = .inline(InlineData())
            } else if InlineSlice.canStore(count: capacity) {
                self = .slice(InlineSlice(capacity: capacity))
            } else {
                self = .large(LargeSlice(capacity: capacity))
            }
        }
    @inlinable internal init(count: Swift.Int) {
            if count == 0 {
                self = .empty
            } else if InlineData.canStore(count: count) {
                self = .inline(InlineData(count: count))
            } else if InlineSlice.canStore(count: count) {
                self = .slice(InlineSlice(count: count))
            } else {
                self = .large(LargeSlice(count: count))
            }
        }
    @inlinable internal init(_ storage: Foundation.__DataStorage, count: Swift.Int) {
            if count == 0 {
                self = .empty
            } else if InlineData.canStore(count: count) {
                self = .inline(storage.withUnsafeBytes(in: 0..<count) { InlineData($0) })
            } else if InlineSlice.canStore(count: count) {
                self = .slice(InlineSlice(storage, count: count))
            } else {
                self = .large(LargeSlice(storage, count: count))
            }
        }
    @usableFromInline
    internal mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
    @inlinable internal var count: Swift.Int {
      get {
                switch self {
                case .empty: return 0
                case .inline(let inline): return inline.count
                case .slice(let slice): return slice.count
                case .large(let slice): return slice.count
                }
            }
      set(newValue) {
                 
                 
                @inline(__always)
                func apply(_ representation: inout _Representation, _ newValue: Int) -> _Representation? {
                    switch representation {
                    case .empty:
                        if newValue == 0 {
                            return nil
                        } else if InlineData.canStore(count: newValue) {
                            return .inline(InlineData(count: newValue))
                        } else if InlineSlice.canStore(count: newValue) {
                            return .slice(InlineSlice(count: newValue))
                        } else {
                            return .large(LargeSlice(count: newValue))
                        }
                    case .inline(var inline):
                        if newValue == 0 {
                            return .empty
                        } else if InlineData.canStore(count: newValue) {
                            guard inline.count != newValue else { return nil }
                            inline.count = newValue
                            return .inline(inline)
                        } else if InlineSlice.canStore(count: newValue) {
                            var slice = InlineSlice(inline)
                            slice.count = newValue
                            return .slice(slice)
                        } else {
                            var slice = LargeSlice(inline)
                            slice.count = newValue
                            return .large(slice)
                        }
                    case .slice(var slice):
                        if newValue == 0 && slice.startIndex == 0 {
                            return .empty
                        } else if slice.startIndex == 0 && InlineData.canStore(count: newValue) {
                            return .inline(InlineData(slice, count: newValue))
                        } else if InlineSlice.canStore(count: newValue + slice.startIndex) {
                            guard slice.count != newValue else { return nil }
                            representation = .empty  
                            slice.count = newValue
                            return .slice(slice)
                        } else {
                            var newSlice = LargeSlice(slice)
                            newSlice.count = newValue
                            return .large(newSlice)
                        }
                    case .large(var slice):
                        if newValue == 0 && slice.startIndex == 0 {
                            return .empty
                        } else if slice.startIndex == 0 && InlineData.canStore(count: newValue) {
                            return .inline(InlineData(slice, count: newValue))
                        } else {
                            guard slice.count != newValue else { return nil}
                            representation = .empty  
                            slice.count = newValue
                            return .large(slice)
                        }
                    }
                }

                if let rep = apply(&self, newValue) {
                    self = rep
                }
            }
    }
    @inlinable internal func withUnsafeBytes<Result>(_ apply: (Swift.UnsafeRawBufferPointer) throws -> Result) rethrows -> Result {
            switch self {
            case .empty:
                let empty = InlineData()
                return try empty.withUnsafeBytes(apply)
            case .inline(let inline):
                return try inline.withUnsafeBytes(apply)
            case .slice(let slice):
                return try slice.withUnsafeBytes(apply)
            case .large(let slice):
                return try slice.withUnsafeBytes(apply)
            }
        }
    @inlinable internal mutating func withUnsafeMutableBytes<Result>(_ apply: (Swift.UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result {
            switch self {
            case .empty:
                var empty = InlineData()
                return try empty.withUnsafeMutableBytes(apply)
            case .inline(var inline):
                defer { self = .inline(inline) }
                return try inline.withUnsafeMutableBytes(apply)
            case .slice(var slice):
                self = .empty
                defer { self = .slice(slice) }
                return try slice.withUnsafeMutableBytes(apply)
            case .large(var slice):
                self = .empty
                defer { self = .large(slice) }
                return try slice.withUnsafeMutableBytes(apply)
            }
        }
    @usableFromInline
    internal func enumerateBytes(_ block: (_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>, _ byteIndex: Foundation.Data.Index, _ stop: inout Swift.Bool) -> Swift.Void)
    @inlinable internal mutating func append(contentsOf buffer: Swift.UnsafeRawBufferPointer) {
            switch self {
            case .empty:
                self = _Representation(buffer)
            case .inline(var inline):
                if InlineData.canStore(count: inline.count + buffer.count) {
                    inline.append(contentsOf: buffer)
                    self = .inline(inline)
                } else if InlineSlice.canStore(count: inline.count + buffer.count) {
                    var newSlice = InlineSlice(inline)
                    newSlice.append(contentsOf: buffer)
                    self = .slice(newSlice)
                } else {
                    var newSlice = LargeSlice(inline)
                    newSlice.append(contentsOf: buffer)
                    self = .large(newSlice)
                }
            case .slice(var slice):
                if InlineSlice.canStore(count: slice.range.upperBound + buffer.count) {
                    self = .empty
                    defer { self = .slice(slice) }
                    slice.append(contentsOf: buffer)
                } else {
                    self = .empty
                    var newSlice = LargeSlice(slice)
                    newSlice.append(contentsOf: buffer)
                    self = .large(newSlice)
                }
            case .large(var slice):
                self = .empty
                defer { self = .large(slice) }
                slice.append(contentsOf: buffer)
            }
        }
    @inlinable internal mutating func resetBytes(in range: Swift.Range<Foundation.Data.Index>) {
            switch self {
            case .empty:
                if range.upperBound == 0 {
                    self = .empty
                } else if InlineData.canStore(count: range.upperBound) {
                    precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
                    self = .inline(InlineData(count: range.upperBound))
                } else if InlineSlice.canStore(count: range.upperBound) {
                    precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
                    self = .slice(InlineSlice(count: range.upperBound))
                } else {
                    precondition(range.lowerBound <= endIndex, "index \(range.lowerBound) is out of bounds of \(startIndex)..<\(endIndex)")
                    self = .large(LargeSlice(count: range.upperBound))
                }
            case .inline(var inline):
                if inline.count < range.upperBound {
                    if InlineSlice.canStore(count: range.upperBound) {
                        var slice = InlineSlice(inline)
                        slice.resetBytes(in: range)
                        self = .slice(slice)
                    } else {
                        var slice = LargeSlice(inline)
                        slice.resetBytes(in: range)
                        self = .large(slice)
                    }
                } else {
                    inline.resetBytes(in: range)
                    self = .inline(inline)
                }
            case .slice(var slice):
                if InlineSlice.canStore(count: range.upperBound) {
                    self = .empty
                    slice.resetBytes(in: range)
                    self = .slice(slice)
                } else {
                    self = .empty
                    var newSlice = LargeSlice(slice)
                    newSlice.resetBytes(in: range)
                    self = .large(newSlice)
                }
            case .large(var slice):
                self = .empty
                slice.resetBytes(in: range)
                self = .large(slice)
            }
        }
    @usableFromInline
    internal mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with bytes: Swift.UnsafeRawPointer?, count cnt: Swift.Int)
    @inlinable internal subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
      get {
                switch self {
                case .empty: preconditionFailure("index \(index) out of range of 0")
                case .inline(let inline): return inline[index]
                case .slice(let slice): return slice[index]
                case .large(let slice): return slice[index]
                }
            }
      set(newValue) {
                switch self {
                case .empty: preconditionFailure("index \(index) out of range of 0")
                case .inline(var inline):
                    inline[index] = newValue
                    self = .inline(inline)
                case .slice(var slice):
                    self = .empty
                    slice[index] = newValue
                    self = .slice(slice)
                case .large(var slice):
                    self = .empty
                    slice[index] = newValue
                    self = .large(slice)
                }
            }
    }
    @inlinable internal subscript(bounds: Swift.Range<Foundation.Data.Index>) -> Foundation.Data {
      get {
                switch self {
                case .empty:
                    precondition(bounds.lowerBound == 0 && (bounds.upperBound - bounds.lowerBound) == 0, "Range \(bounds) out of bounds 0..<0")
                    return Data()
                case .inline(let inline):
                    precondition(bounds.upperBound <= inline.count, "Range \(bounds) out of bounds 0..<\(inline.count)")
                    if bounds.lowerBound == 0 {
                        var newInline = inline
                        newInline.count = bounds.upperBound
                        return Data(representation: .inline(newInline))
                    } else {
                        return Data(representation: .slice(InlineSlice(inline, range: bounds)))
                    }
                case .slice(let slice):
                    precondition(slice.startIndex <= bounds.lowerBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.lowerBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(slice.startIndex <= bounds.upperBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.upperBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    if bounds.lowerBound == 0 && bounds.upperBound == 0 {
                        return Data()
                    } else if bounds.lowerBound == 0 && InlineData.canStore(count: bounds.count) {
                        return Data(representation: .inline(InlineData(slice, count: bounds.count)))
                    } else {
                        var newSlice = slice
                        newSlice.range = bounds
                        return Data(representation: .slice(newSlice))
                    }
                case .large(let slice):
                    precondition(slice.startIndex <= bounds.lowerBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.lowerBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(slice.startIndex <= bounds.upperBound, "Range \(bounds) out of bounds \(slice.range)")
                    precondition(bounds.upperBound <= slice.endIndex, "Range \(bounds) out of bounds \(slice.range)")
                    if bounds.lowerBound == 0 && bounds.upperBound == 0 {
                        return Data()
                    } else if bounds.lowerBound == 0 && InlineData.canStore(count: bounds.upperBound) {
                        return Data(representation: .inline(InlineData(slice, count: bounds.upperBound)))
                    } else if InlineSlice.canStore(count: bounds.lowerBound) && InlineSlice.canStore(count: bounds.upperBound) {
                        return Data(representation: .slice(InlineSlice(slice, range: bounds)))
                    } else {
                        var newSlice = slice
                        newSlice.slice = RangeReference(bounds)
                        return Data(representation: .large(newSlice))
                    }
                }
            }
    }
    @inlinable internal var startIndex: Swift.Int {
      get {
            switch self {
            case .empty: return 0
            case .inline: return 0
            case .slice(let slice): return slice.startIndex
            case .large(let slice): return slice.startIndex
            }
        }
    }
    @inlinable internal var endIndex: Swift.Int {
      get {
            switch self {
            case .empty: return 0
            case .inline(let inline): return inline.count
            case .slice(let slice): return slice.endIndex
            case .large(let slice): return slice.endIndex
            }
        }
    }
    @inlinable internal func copyBytes(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
            switch self {
            case .empty:
                precondition(range.lowerBound == 0 && range.upperBound == 0, "Range \(range) out of bounds 0..<0")
                return
            case .inline(let inline):
                inline.copyBytes(to: pointer, from: range)
            case .slice(let slice):
                slice.copyBytes(to: pointer, from: range)
            case .large(let slice):
                slice.copyBytes(to: pointer, from: range)
            }
        }
  }
  @usableFromInline
  internal var _representation: Foundation.Data._Representation
  public enum Deallocator {
    case virtualMemory
    case unmap
    case free
    case none
    case custom((Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void)
    @usableFromInline
    internal var _deallocator: (Swift.UnsafeMutableRawPointer, Swift.Int) -> Swift.Void {
      get
    }
  }
  @inlinable public init(bytes: Swift.UnsafeRawPointer, count: Swift.Int) {
        _representation = _Representation(UnsafeRawBufferPointer(start: bytes, count: count))
    }
  @inlinable public init<SourceType>(buffer: Swift.UnsafeBufferPointer<SourceType>) {
        _representation = _Representation(UnsafeRawBufferPointer(buffer))
    }
  @inlinable public init<SourceType>(buffer: Swift.UnsafeMutableBufferPointer<SourceType>) {
        _representation = _Representation(UnsafeRawBufferPointer(buffer))
    }
  @inlinable public init(repeating repeatedValue: Swift.UInt8, count: Swift.Int) {
        self.init(count: count)
        withUnsafeMutableBytes { (buffer: UnsafeMutableRawBufferPointer) -> Void in
            _ = memset(buffer.baseAddress!, Int32(repeatedValue), buffer.count)
        }
    }
  @inlinable public init(capacity: Swift.Int) {
        _representation = _Representation(capacity: capacity)
    }
  @inlinable public init(count: Swift.Int) {
        _representation = _Representation(count: count)
    }
  @inlinable public init() {
        _representation = .empty
    }
  @inlinable public init(bytesNoCopy bytes: Swift.UnsafeMutableRawPointer, count: Swift.Int, deallocator: Foundation.Data.Deallocator) {
        let whichDeallocator = deallocator._deallocator
        if count == 0 {
            deallocator._deallocator(bytes, count)
            _representation = .empty
        } else {
            _representation = _Representation(__DataStorage(bytes: bytes, length: count, copy: false, deallocator: whichDeallocator, offset: 0), count: count)
        }
    }
  @inlinable public init<S>(_ elements: S) where S : Swift.Sequence, S.Element == Swift.UInt8 {
         
        if let contiguous = elements as? ContiguousBytes {
            _representation = contiguous.withUnsafeBytes { return _Representation($0) }
            return
        }

         
         
        let representation = elements.withContiguousStorageIfAvailable {
            _Representation(UnsafeRawBufferPointer($0))
        }
        if let representation = representation {
            _representation = representation
            return
        }

         
        let underestimatedCount = elements.underestimatedCount
        _representation = _Representation(count: underestimatedCount)
        var (iter, endIndex): (S.Iterator, Int) = _representation.withUnsafeMutableBytes { buffer in
            buffer.withMemoryRebound(to: UInt8.self) {
                elements._copyContents(initializing: $0)
            }
        }
        guard endIndex == _representation.count else {
             
             
            _representation.replaceSubrange(endIndex ..< _representation.endIndex, with: nil, count: 0)
            return
        }

         
        var buffer = InlineData()
        while let element = iter.next() {
            buffer.append(byte: element)
            if buffer.count == buffer.capacity {
                buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
                buffer.count = 0
            }
        }

         
        if buffer.count > 0 {
            buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
            buffer.count = 0
        }
    }
  @available(swift 4.2)
  @available(swift, deprecated: 5, message: "use `init(_:)` instead")
  public init<S>(bytes elements: S) where S : Swift.Sequence, S.Element == Swift.UInt8
  @available(swift, obsoleted: 4.2)
  public init(bytes: Swift.Array<Swift.UInt8>)
  @available(swift, obsoleted: 4.2)
  public init(bytes: Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init(representation: Foundation.Data._Representation) {
        _representation = representation
    }
  public typealias ReadingOptions = Foundation.NSData.ReadingOptions
  public typealias WritingOptions = Foundation.NSData.WritingOptions
  public init(contentsOf url: __shared Foundation.URL, options: Foundation.Data.ReadingOptions = []) throws
  @inlinable public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
        _representation.reserveCapacity(minimumCapacity)
    }
  @inlinable public var count: Swift.Int {
    get {
            return _representation.count
        }
    set(newValue) {
            precondition(newValue >= 0, "count must not be negative")
            _representation.count = newValue
        }
  }
  @inlinable public var regions: Swift.CollectionOfOne<Foundation.Data> {
    get {
        return CollectionOfOne(self)
    }
  }
  @available(swift, deprecated: 5, message: "use `withUnsafeBytes<R>(_: (UnsafeRawBufferPointer) throws -> R) rethrows -> R` instead")
  public func withUnsafeBytes<ResultType, ContentType>(_ body: (Swift.UnsafePointer<ContentType>) throws -> ResultType) rethrows -> ResultType
  @inlinable public func withUnsafeBytes<ResultType>(_ body: (Swift.UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType {
        return try _representation.withUnsafeBytes(body)
    }
  @_alwaysEmitIntoClient public func withContiguousStorageIfAvailable<ResultType>(_ body: (_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> ResultType) rethrows -> ResultType? {
        return try _representation.withUnsafeBytes {
            return try $0.withMemoryRebound(to: UInt8.self, body)
        }
    }
  @available(swift, deprecated: 5, message: "use `withUnsafeMutableBytes<R>(_: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R` instead")
  public mutating func withUnsafeMutableBytes<ResultType, ContentType>(_ body: (Swift.UnsafeMutablePointer<ContentType>) throws -> ResultType) rethrows -> ResultType
  @inlinable public mutating func withUnsafeMutableBytes<ResultType>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> ResultType) rethrows -> ResultType {
        return try _representation.withUnsafeMutableBytes(body)
    }
  @inlinable public func copyBytes(to pointer: Swift.UnsafeMutablePointer<Swift.UInt8>, count: Swift.Int) {
        precondition(count >= 0, "count of bytes to copy must not be negative")
        if count == 0 { return }
        _copyBytesHelper(to: UnsafeMutableRawPointer(pointer), from: startIndex..<(startIndex + count))
    }
  @inlinable internal func _copyBytesHelper(to pointer: Swift.UnsafeMutableRawPointer, from range: Swift.Range<Swift.Int>) {
        if range.isEmpty { return }
        _representation.copyBytes(to: pointer, from: range)
    }
  @inlinable public func copyBytes(to pointer: Swift.UnsafeMutablePointer<Swift.UInt8>, from range: Swift.Range<Foundation.Data.Index>) {
        _copyBytesHelper(to: pointer, from: range)
    }
  @inlinable public func copyBytes<DestinationType>(to buffer: Swift.UnsafeMutableBufferPointer<DestinationType>, from range: Swift.Range<Foundation.Data.Index>? = nil) -> Swift.Int {
        let cnt = count
        guard cnt > 0 else { return 0 }

        let copyRange : Range<Index>
        if let r = range {
            guard !r.isEmpty else { return 0 }
            copyRange = r.lowerBound..<(r.lowerBound + Swift.min(buffer.count * MemoryLayout<DestinationType>.stride, r.upperBound - r.lowerBound))
        } else {
            copyRange = startIndex..<(startIndex + Swift.min(buffer.count * MemoryLayout<DestinationType>.stride, cnt))
        }

        guard !copyRange.isEmpty else { return 0 }

        _copyBytesHelper(to: buffer.baseAddress!, from: copyRange)
        return copyRange.upperBound - copyRange.lowerBound
    }
  @available(swift, deprecated: 5, message: "use `regions` or `for-in` instead")
  public func enumerateBytes(_ block: (_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>, _ byteIndex: Foundation.Data.Index, _ stop: inout Swift.Bool) -> Swift.Void)
  @inlinable internal mutating func _append<SourceType>(_ buffer: Swift.UnsafeBufferPointer<SourceType>) {
        if buffer.isEmpty { return }
        _representation.append(contentsOf: UnsafeRawBufferPointer(buffer))
    }
  @inlinable public mutating func append(_ bytes: Swift.UnsafePointer<Swift.UInt8>, count: Swift.Int) {
        if count == 0 { return }
        _append(UnsafeBufferPointer(start: bytes, count: count))
    }
  public mutating func append(_ other: Foundation.Data)
  @inlinable public mutating func append<SourceType>(_ buffer: Swift.UnsafeBufferPointer<SourceType>) {
        _append(buffer)
    }
  @inlinable public mutating func append(contentsOf bytes: [Swift.UInt8]) {
        bytes.withUnsafeBufferPointer { (buffer: UnsafeBufferPointer<UInt8>) -> Void in
            _append(buffer)
        }
    }
  @inlinable public mutating func append<S>(contentsOf elements: S) where S : Swift.Sequence, S.Element == Swift.UInt8 {
         
        if let contiguous = elements as? ContiguousBytes {
            contiguous.withUnsafeBytes {
                _representation.append(contentsOf: $0)
            }

            return
        }

         
         
        let appended: Void? = elements.withContiguousStorageIfAvailable {
            _representation.append(contentsOf: UnsafeRawBufferPointer($0))
        }
        guard appended == nil else { return }

         
         
        let underestimatedCount = elements.underestimatedCount
        let originalCount = _representation.count
        resetBytes(in: self.endIndex ..< self.endIndex + underestimatedCount)
        var (iter, copiedCount): (S.Iterator, Int) = _representation.withUnsafeMutableBytes { buffer in
            assert(buffer.count == originalCount + underestimatedCount)
            let start = buffer.baseAddress?.advanced(by: originalCount)
            let b = UnsafeMutableRawBufferPointer(start: start, count: buffer.count - originalCount)
            return b.withMemoryRebound(to: UInt8.self, elements._copyContents(initializing:))
        }
        guard copiedCount == underestimatedCount else {
             
             
            _representation.replaceSubrange(startIndex + originalCount + copiedCount ..< endIndex, with: nil, count: 0)
            return
        }

         
        var buffer = InlineData()
        while let element = iter.next() {
            buffer.append(byte: element)
            if buffer.count == buffer.capacity {
                buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
                buffer.count = 0
            }
        }

         
        if buffer.count > 0 {
            buffer.withUnsafeBytes { _representation.append(contentsOf: $0) }
            buffer.count = 0
        }
    }
  @inlinable public mutating func resetBytes(in range: Swift.Range<Foundation.Data.Index>) {
         
        precondition(range.lowerBound >= 0, "Ranges must not be negative bounds")
        precondition(range.upperBound >= 0, "Ranges must not be negative bounds")
        _representation.resetBytes(in: range)
    }
  @inlinable public mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with data: Foundation.Data) {
        data.withUnsafeBytes { (buffer: UnsafeRawBufferPointer) in
            _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: buffer.count)
        }
    }
  @inlinable public mutating func replaceSubrange<SourceType>(_ subrange: Swift.Range<Foundation.Data.Index>, with buffer: Swift.UnsafeBufferPointer<SourceType>) {
        guard !buffer.isEmpty  else { return }
        replaceSubrange(subrange, with: buffer.baseAddress!, count: buffer.count * MemoryLayout<SourceType>.stride)
    }
  @inlinable public mutating func replaceSubrange<ByteCollection>(_ subrange: Swift.Range<Foundation.Data.Index>, with newElements: ByteCollection) where ByteCollection : Swift.Collection, ByteCollection.Element == Swift.UInt8 {
         
        if let contiguous = newElements as? ContiguousBytes {
            contiguous.withUnsafeBytes { buffer in
                _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: buffer.count)
            }
            return
        }
         
         
        let replaced: Void? = newElements.withContiguousStorageIfAvailable { buffer in
            _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: buffer.count)
        }
        guard replaced == nil else { return }

        let totalCount = Int(newElements.count)
        _withStackOrHeapBuffer(capacity: totalCount) { buffer in
            var (iterator, index) = newElements._copyContents(initializing: buffer)
            precondition(index == buffer.endIndex, "Collection has less elements than its count")
            precondition(iterator.next() == nil, "Collection has more elements than its count")
            _representation.replaceSubrange(subrange, with: buffer.baseAddress, count: totalCount)
        }
    }
  @inlinable public mutating func replaceSubrange(_ subrange: Swift.Range<Foundation.Data.Index>, with bytes: Swift.UnsafeRawPointer, count cnt: Swift.Int) {
        _representation.replaceSubrange(subrange, with: bytes, count: cnt)
    }
  public func subdata(in range: Swift.Range<Foundation.Data.Index>) -> Foundation.Data
  public func write(to url: Foundation.URL, options: Foundation.Data.WritingOptions = []) throws
  @inline(never) public func hash(into hasher: inout Swift.Hasher)
  public func advanced(by amount: Swift.Int) -> Foundation.Data
  @inlinable public subscript(index: Foundation.Data.Index) -> Swift.UInt8 {
    get {
            return _representation[index]
        }
    set(newValue) {
            _representation[index] = newValue
        }
  }
  @inlinable public subscript(bounds: Swift.Range<Foundation.Data.Index>) -> Foundation.Data {
    get {
            return _representation[bounds]
        }
    set {
            replaceSubrange(bounds, with: newValue)
        }
  }
  @inlinable public subscript<R>(rangeExpression: R) -> Foundation.Data where R : Swift.RangeExpression, R.Bound : Swift.FixedWidthInteger {
    get {
            let lower = R.Bound(startIndex)
            let upper = R.Bound(endIndex)
            let range = rangeExpression.relative(to: lower..<upper)
            let start = Int(range.lowerBound)
            let end = Int(range.upperBound)
            let r: Range<Int> = start..<end
            return _representation[r]
        }
    set {
            let lower = R.Bound(startIndex)
            let upper = R.Bound(endIndex)
            let range = rangeExpression.relative(to: lower..<upper)
            let start = Int(range.lowerBound)
            let end = Int(range.upperBound)
            let r: Range<Int> = start..<end
            replaceSubrange(r, with: newValue)
        }
  }
  @inlinable public var startIndex: Foundation.Data.Index {
    get {
            return _representation.startIndex
        }
  }
  @inlinable public var endIndex: Foundation.Data.Index {
    get {
            return _representation.endIndex
        }
  }
  @inlinable public func index(before i: Foundation.Data.Index) -> Foundation.Data.Index {
        return i - 1
    }
  @inlinable public func index(after i: Foundation.Data.Index) -> Foundation.Data.Index {
        return i + 1
    }
  @inlinable public var indices: Swift.Range<Swift.Int> {
    get {
            return startIndex..<endIndex
        }
  }
  @inlinable public func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Swift.UInt8>) -> (Foundation.Data.Iterator, Swift.UnsafeMutableBufferPointer<Swift.UInt8>.Index) {
        guard !isEmpty else { return (makeIterator(), buffer.startIndex) }
        let cnt = Swift.min(count, buffer.count)

        withUnsafeBytes { (bytes: UnsafeRawBufferPointer) in
            _ = memcpy(UnsafeMutableRawPointer(buffer.baseAddress!), bytes.baseAddress!, cnt)
        }

        return (Iterator(self, at: startIndex + cnt), buffer.index(buffer.startIndex, offsetBy: cnt))
    }
  @inlinable public func makeIterator() -> Foundation.Data.Iterator {
        return Iterator(self, at: startIndex)
    }
  public struct Iterator : Swift.IteratorProtocol, Swift.Sendable {
    @usableFromInline
    internal typealias Buffer = (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8)
    @usableFromInline
    internal let _data: Foundation.Data
    @usableFromInline
    internal var _buffer: Foundation.Data.Iterator.Buffer
    @usableFromInline
    internal var _idx: Foundation.Data.Index
    @usableFromInline
    internal let _endIdx: Foundation.Data.Index
    @usableFromInline
    internal init(_ data: Foundation.Data, at loc: Foundation.Data.Index)
    public mutating func next() -> Swift.UInt8?
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Element = Swift.UInt8
  }
  public func range(of dataToFind: Foundation.Data, options: Foundation.Data.SearchOptions = [], in range: Swift.Range<Foundation.Data.Index>? = nil) -> Swift.Range<Foundation.Data.Index>?
  @inlinable public static func == (d1: Foundation.Data, d2: Foundation.Data) -> Swift.Bool {
        let length1 = d1.count
        if length1 != d2.count {
            return false
        }
        if length1 > 0 {
            return d1.withUnsafeBytes { (b1: UnsafeRawBufferPointer) in
                return d2.withUnsafeBytes { (b2: UnsafeRawBufferPointer) in
                    return memcmp(b1.baseAddress!, b2.baseAddress!, b2.count) == 0
                }
            }
        }
        return true
    }
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Element = Swift.UInt8
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Regions = Swift.CollectionOfOne<Foundation.Data>
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias SubSequence = Foundation.Data
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS, unavailable, introduced: 10.10)
@available(iOS, unavailable, introduced: 8.0)
@available(tvOS, unavailable, introduced: 9.0)
@available(watchOS, unavailable, introduced: 2.0)
@available(*, unavailable)
extension Foundation.Data.Deallocator : Swift.Sendable {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Data {
  public typealias SearchOptions = Foundation.NSData.SearchOptions
  public typealias Base64EncodingOptions = Foundation.NSData.Base64EncodingOptions
  public typealias Base64DecodingOptions = Foundation.NSData.Base64DecodingOptions
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Data : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Data : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Data {
  public init?(base64Encoded base64String: __shared Swift.String, options: Foundation.Data.Base64DecodingOptions = [])
  public init?(base64Encoded base64Data: __shared Foundation.Data, options: Foundation.Data.Base64DecodingOptions = [])
  public func base64EncodedString(options: Foundation.Data.Base64EncodingOptions = []) -> Swift.String
  public func base64EncodedData(options: Foundation.Data.Base64EncodingOptions = []) -> Foundation.Data
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol DataProtocol : Swift.RandomAccessCollection where Self.Element == Swift.UInt8, Self.SubSequence : Foundation.DataProtocol {
  associatedtype Regions : Swift.BidirectionalCollection where Self.Regions.Element : Foundation.ContiguousBytes, Self.Regions.Element : Foundation.DataProtocol, Self.Regions.Element.SubSequence : Foundation.ContiguousBytes
  var regions: Self.Regions { get }
  func firstRange<D, R>(of: D, in: R) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
  func lastRange<D, R>(of: D, in: R) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
  @discardableResult
  func copyBytes(to: Swift.UnsafeMutableRawBufferPointer, count: Swift.Int) -> Swift.Int
  @discardableResult
  func copyBytes<DestinationType>(to: Swift.UnsafeMutableBufferPointer<DestinationType>, count: Swift.Int) -> Swift.Int
  @discardableResult
  func copyBytes<R>(to: Swift.UnsafeMutableRawBufferPointer, from: R) -> Swift.Int where R : Swift.RangeExpression, Self.Index == R.Bound
  @discardableResult
  func copyBytes<DestinationType, R>(to: Swift.UnsafeMutableBufferPointer<DestinationType>, from: R) -> Swift.Int where R : Swift.RangeExpression, Self.Index == R.Bound
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol MutableDataProtocol : Foundation.DataProtocol, Swift.MutableCollection, Swift.RangeReplaceableCollection {
  mutating func resetBytes<R>(in range: R) where R : Swift.RangeExpression, Self.Index == R.Bound
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.DataProtocol {
  public func firstRange<D>(of data: D) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol
  public func lastRange<D>(of data: D) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol
  @discardableResult
  public func copyBytes(to ptr: Swift.UnsafeMutableRawBufferPointer) -> Swift.Int
  @discardableResult
  public func copyBytes<DestinationType>(to ptr: Swift.UnsafeMutableBufferPointer<DestinationType>) -> Swift.Int
  @discardableResult
  public func copyBytes(to ptr: Swift.UnsafeMutableRawBufferPointer, count: Swift.Int) -> Swift.Int
  @discardableResult
  public func copyBytes<DestinationType>(to ptr: Swift.UnsafeMutableBufferPointer<DestinationType>, count: Swift.Int) -> Swift.Int
  @discardableResult
  public func copyBytes<R>(to ptr: Swift.UnsafeMutableRawBufferPointer, from range: R) -> Swift.Int where R : Swift.RangeExpression, Self.Index == R.Bound
  @discardableResult
  public func copyBytes<DestinationType, R>(to ptr: Swift.UnsafeMutableBufferPointer<DestinationType>, from range: R) -> Swift.Int where R : Swift.RangeExpression, Self.Index == R.Bound
  public func firstRange<D, R>(of data: D, in range: R) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
  public func lastRange<D, R>(of data: D, in range: R) -> Swift.Range<Self.Index>? where D : Foundation.DataProtocol, R : Swift.RangeExpression, Self.Index == R.Bound
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.DataProtocol where Self : Foundation.ContiguousBytes {
  public func copyBytes<DestinationType, R>(to ptr: Swift.UnsafeMutableBufferPointer<DestinationType>, from range: R) where R : Swift.RangeExpression, Self.Index == R.Bound
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.MutableDataProtocol {
  public mutating func resetBytes<R>(in range: R) where R : Swift.RangeExpression, Self.Index == R.Bound
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Slice : Foundation.DataProtocol where Base : Foundation.DataProtocol {
  public typealias Regions = [Base.Regions.Element.SubSequence]
  public var regions: [Base.Regions.Element.SubSequence] {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.UnsafeRawBufferPointer : Foundation.DataProtocol {
  public var regions: Swift.CollectionOfOne<Swift.UnsafeRawBufferPointer> {
    get
  }
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Regions = Swift.CollectionOfOne<Swift.UnsafeRawBufferPointer>
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.UnsafeBufferPointer : Foundation.DataProtocol where Element == Swift.UInt8 {
  public var regions: Swift.CollectionOfOne<Swift.UnsafeBufferPointer<Swift.UInt8>> {
    get
  }
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Regions = Swift.CollectionOfOne<Swift.UnsafeBufferPointer<Swift.UInt8>>
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Decimal {
  public typealias RoundingMode = Foundation.NSDecimalNumber.RoundingMode
  public typealias CalculationError = Foundation.NSDecimalNumber.CalculationError
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Decimal {
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent public mutating func add(_ other: Foundation.Decimal) {
        self += other
    }
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent public mutating func subtract(_ other: Foundation.Decimal) {
        self -= other
    }
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent public mutating func multiply(by other: Foundation.Decimal) {
        self *= other
    }
  @available(swift, obsoleted: 4, message: "Please use arithmetic operators instead")
  @_transparent public mutating func divide(by other: Foundation.Decimal) {
        self /= other
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Decimal : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDecimalNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSDecimalNumber, result: inout Foundation.Decimal?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSDecimalNumber, result: inout Foundation.Decimal?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSDecimalNumber?) -> Foundation.Decimal
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSDecimalNumber
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func pow(_ x: Foundation.Decimal, _ y: Swift.Int) -> Foundation.Decimal
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@usableFromInline
internal func NSDecimalAdd(_ result: Swift.UnsafeMutablePointer<Foundation.Decimal>, _ leftOperand: Swift.UnsafePointer<Foundation.Decimal>, _ rightOperand: Swift.UnsafePointer<Foundation.Decimal>, _ roundingMode: Foundation.NSDecimalNumber.RoundingMode) -> Foundation.NSDecimalNumber.CalculationError
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@usableFromInline
internal func NSDecimalSubtract(_ result: Swift.UnsafeMutablePointer<Foundation.Decimal>, _ leftOperand: Swift.UnsafePointer<Foundation.Decimal>, _ rightOperand: Swift.UnsafePointer<Foundation.Decimal>, _ roundingMode: Foundation.NSDecimalNumber.RoundingMode) -> Foundation.NSDecimalNumber.CalculationError
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@usableFromInline
internal func NSDecimalMultiply(_ result: Swift.UnsafeMutablePointer<Foundation.Decimal>, _ leftOperand: Swift.UnsafePointer<Foundation.Decimal>, _ rightOperand: Swift.UnsafePointer<Foundation.Decimal>, _ roundingMode: Foundation.NSDecimalNumber.RoundingMode) -> Foundation.NSDecimalNumber.CalculationError
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@usableFromInline
internal func NSDecimalDivide(_ result: Swift.UnsafeMutablePointer<Foundation.Decimal>, _ leftOperand: Swift.UnsafePointer<Foundation.Decimal>, _ rightOperand: Swift.UnsafePointer<Foundation.Decimal>, _ roundingMode: Foundation.NSDecimalNumber.RoundingMode) -> Foundation.NSDecimalNumber.CalculationError
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@usableFromInline
internal func NSDecimalPower(_ result: Swift.UnsafeMutablePointer<Foundation.Decimal>, _ number: Swift.UnsafePointer<Foundation.Decimal>, _ power: Swift.Int, _ roundingMode: Foundation.NSDecimalNumber.RoundingMode) -> Foundation.NSDecimalNumber.CalculationError
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@usableFromInline
internal func NSDecimalMultiplyByPowerOf10(_ result: Swift.UnsafeMutablePointer<Foundation.Decimal>, _ number: Swift.UnsafePointer<Foundation.Decimal>, _ power: Swift.Int16, _ roundingMode: Foundation.NSDecimalNumber.RoundingMode) -> Foundation.NSDecimalNumber.CalculationError
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@usableFromInline
internal func NSDecimalCompare(_ leftOperand: Swift.UnsafePointer<Foundation.Decimal>, _ rightOperand: Swift.UnsafePointer<Foundation.Decimal>) -> Foundation.ComparisonResult
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@usableFromInline
internal func NSDecimalRound(_ result: Swift.UnsafeMutablePointer<Foundation.Decimal>, _ number: Swift.UnsafePointer<Foundation.Decimal>, _ scale: Swift.Int, _ roundingMode: Foundation.NSDecimalNumber.RoundingMode)
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@usableFromInline
internal func NSDecimalNormalize(_ number1: Swift.UnsafeMutablePointer<Foundation.Decimal>, _ number2: Swift.UnsafeMutablePointer<Foundation.Decimal>, _ roundingMode: Foundation.NSDecimalNumber.RoundingMode) -> Foundation.NSDecimalNumber.CalculationError
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@usableFromInline
internal func NSDecimalCompact(_ number: Swift.UnsafeMutablePointer<Foundation.Decimal>)
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
@usableFromInline
internal func NSDecimalString(_ dcm: Swift.UnsafePointer<Foundation.Decimal>, _ locale: Any?) -> Swift.String
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Decimal : Swift.CustomStringConvertible {
  public init?(string: __shared Swift.String, locale: __shared Foundation.Locale? = nil)
  public var description: Swift.String {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Decimal {
  public static let leastFiniteMagnitude: Foundation.Decimal
  public static let greatestFiniteMagnitude: Foundation.Decimal
  public static let leastNormalMagnitude: Foundation.Decimal
  public static let leastNonzeroMagnitude: Foundation.Decimal
  public static let pi: Foundation.Decimal
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  public static var infinity: Foundation.Decimal {
    get
  }
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  public static var signalingNaN: Foundation.Decimal {
    get
  }
  public static var quietNaN: Foundation.Decimal {
    get
  }
  public static var nan: Foundation.Decimal {
    get
  }
  public static var radix: Swift.Int {
    get
  }
  public init(_ value: Swift.UInt8)
  public init(_ value: Swift.Int8)
  public init(_ value: Swift.UInt16)
  public init(_ value: Swift.Int16)
  public init(_ value: Swift.UInt32)
  public init(_ value: Swift.Int32)
  public init(_ value: Swift.UInt64)
  public init(_ value: Swift.Int64)
  public init(_ value: Swift.UInt)
  public init(_ value: Swift.Int)
  public init(_ value: Swift.Double)
  public init(sign: Swift.FloatingPointSign, exponent: Swift.Int, significand: Foundation.Decimal)
  public init(signOf: Foundation.Decimal, magnitudeOf magnitude: Foundation.Decimal)
  public var exponent: Swift.Int {
    get
  }
  public var significand: Foundation.Decimal {
    get
  }
  public var sign: Swift.FloatingPointSign {
    get
  }
  public var ulp: Foundation.Decimal {
    get
  }
  public var floatingPointClass: Swift.FloatingPointClassification {
    get
  }
  public var isCanonical: Swift.Bool {
    get
  }
  public var isSignMinus: Swift.Bool {
    get
  }
  public var isZero: Swift.Bool {
    get
  }
  public var isSubnormal: Swift.Bool {
    get
  }
  public var isNormal: Swift.Bool {
    get
  }
  public var isFinite: Swift.Bool {
    get
  }
  public var isInfinite: Swift.Bool {
    get
  }
  public var isNaN: Swift.Bool {
    get
  }
  public var isSignaling: Swift.Bool {
    get
  }
  public var isSignalingNaN: Swift.Bool {
    get
  }
  @available(*, unavailable, message: "Decimal does not yet fully adopt FloatingPoint.")
  public mutating func formTruncatingRemainder(dividingBy other: Foundation.Decimal)
  public var nextUp: Foundation.Decimal {
    get
  }
  public var nextDown: Foundation.Decimal {
    get
  }
  public func isEqual(to other: Foundation.Decimal) -> Swift.Bool
  public func isLess(than other: Foundation.Decimal) -> Swift.Bool
  public func isLessThanOrEqualTo(_ other: Foundation.Decimal) -> Swift.Bool
  public func isTotallyOrdered(belowOrEqualTo other: Foundation.Decimal) -> Swift.Bool
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Decimal : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.Double)
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias FloatLiteralType = Swift.Double
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Decimal : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int)
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias IntegerLiteralType = Swift.Int
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Decimal : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Decimal : Swift.Equatable {
  public static func == (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Swift.Bool
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Decimal : Swift.Comparable {
  public static func < (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Swift.Bool
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Decimal : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Decimal : Swift.SignedNumeric {
  public var magnitude: Foundation.Decimal {
    get
  }
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  @usableFromInline
  internal static var __zeroForABI: Foundation.Decimal {
    @_silgen_name("$sSo9NSDecimala10FoundationE4zeroABvgZ")
    get
  }
  public static func += (lhs: inout Foundation.Decimal, rhs: Foundation.Decimal)
  public static func -= (lhs: inout Foundation.Decimal, rhs: Foundation.Decimal)
  public static func *= (lhs: inout Foundation.Decimal, rhs: Foundation.Decimal)
  public static func /= (lhs: inout Foundation.Decimal, rhs: Foundation.Decimal)
  public static func + (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Foundation.Decimal
  public static func - (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Foundation.Decimal
  public static func * (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Foundation.Decimal
  public static func / (lhs: Foundation.Decimal, rhs: Foundation.Decimal) -> Foundation.Decimal
  public mutating func negate()
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Magnitude = Foundation.Decimal
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Decimal : Swift.Strideable {
  public func distance(to other: Foundation.Decimal) -> Foundation.Decimal
  public func advanced(by n: Foundation.Decimal) -> Foundation.Decimal
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Stride = Foundation.Decimal
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct CocoaError : Foundation._BridgedStoredNSError {
  public let _nsError: Foundation.NSError
  public init(_nsError error: Foundation.NSError)
  public static var errorDomain: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol _ErrorCodeProtocol : Swift.Equatable {
  associatedtype _ErrorType : Foundation._BridgedStoredNSError where Self == Self._ErrorType.Code
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._ErrorCodeProtocol {
  public static func ~= (match: Self, error: any Swift.Error) -> Swift.Bool
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.CocoaError.Code : Foundation._ErrorCodeProtocol {
  public typealias _ErrorType = Foundation.CocoaError
}
extension Foundation.CocoaError {
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public struct Code : Swift.RawRepresentable, Swift.Hashable, Swift.Sendable {
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias RawValue = Swift.Int
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.CocoaError {
  public var filePath: Swift.String? {
    get
  }
  public var stringEncoding: Swift.String.Encoding? {
    get
  }
  public var underlying: (any Swift.Error)? {
    get
  }
  @available(macOS 11.3, iOS 14.5, watchOS 7.4, tvOS 14.5, *)
  public var underlyingErrors: [any Swift.Error] {
    get
  }
  public var url: Foundation.URL? {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.CocoaError {
  public static func error(_ code: Foundation.CocoaError.Code, userInfo: [Swift.AnyHashable : Any]? = nil, url: Foundation.URL? = nil) -> any Swift.Error
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol LocalizedError : Swift.Error {
  var errorDescription: Swift.String? { get }
  var failureReason: Swift.String? { get }
  var recoverySuggestion: Swift.String? { get }
  var helpAnchor: Swift.String? { get }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
  public var recoverySuggestion: Swift.String? {
    get
  }
  public var helpAnchor: Swift.String? {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol CustomNSError : Swift.Error {
  static var errorDomain: Swift.String { get }
  var errorCode: Swift.Int { get }
  var errorUserInfo: [Swift.String : Any] { get }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Error where Self : Foundation.CustomNSError {
  public var _domain: Swift.String {
    get
  }
  public var _code: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Error where Self : Foundation.CustomNSError, Self : Swift.RawRepresentable, Self.RawValue : Swift.FixedWidthInteger {
  public var _code: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Error {
  public var localizedDescription: Swift.String {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.CocoaError.Code {
  public static var fileNoSuchFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileLocking: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadUnknown: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadNoPermission: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadInvalidFileName: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadCorruptFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadNoSuchFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadInapplicableStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadUnsupportedScheme: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var fileReadTooLarge: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var fileReadUnknownStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteUnknown: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteNoPermission: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteInvalidFileName: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var fileWriteFileExists: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteInapplicableStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteUnsupportedScheme: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteOutOfSpace: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var fileWriteVolumeReadOnly: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountUnknown: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountBusy: Foundation.CocoaError.Code {
    get
  }
  public static var keyValueValidation: Foundation.CocoaError.Code {
    get
  }
  public static var formatting: Foundation.CocoaError.Code {
    get
  }
  public static var userCancelled: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var featureUnsupported: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var executableNotLoadable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var executableArchitectureMismatch: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var executableRuntimeMismatch: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var executableLoad: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var executableLink: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var propertyListReadCorrupt: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var propertyListReadUnknownVersion: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var propertyListReadStream: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var propertyListWriteStream: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var propertyListWriteInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var xpcConnectionInterrupted: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var xpcConnectionInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var xpcConnectionReplyInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var ubiquitousFileUnavailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var ubiquitousFileNotUploadedDueToQuota: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var ubiquitousFileUbiquityServerNotAvailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityHandoffFailed: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityConnectionUnavailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityRemoteApplicationTimedOut: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityHandoffUserInfoTooLarge: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var coderReadCorrupt: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var coderValueNotFound: Foundation.CocoaError.Code {
    get
  }
  public static var coderInvalidValue: Foundation.CocoaError.Code {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.CocoaError {
  public static var fileNoSuchFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileLocking: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadUnknown: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadNoPermission: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadInvalidFileName: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadCorruptFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadNoSuchFile: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadInapplicableStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileReadUnsupportedScheme: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var fileReadTooLarge: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var fileReadUnknownStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteUnknown: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteNoPermission: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteInvalidFileName: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var fileWriteFileExists: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteInapplicableStringEncoding: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteUnsupportedScheme: Foundation.CocoaError.Code {
    get
  }
  public static var fileWriteOutOfSpace: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var fileWriteVolumeReadOnly: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountUnknown: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  public static var fileManagerUnmountBusy: Foundation.CocoaError.Code {
    get
  }
  public static var keyValueValidation: Foundation.CocoaError.Code {
    get
  }
  public static var formatting: Foundation.CocoaError.Code {
    get
  }
  public static var userCancelled: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var featureUnsupported: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var executableNotLoadable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var executableArchitectureMismatch: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var executableRuntimeMismatch: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var executableLoad: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var executableLink: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var propertyListReadCorrupt: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var propertyListReadUnknownVersion: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var propertyListReadStream: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var propertyListWriteStream: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var propertyListWriteInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var xpcConnectionInterrupted: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var xpcConnectionInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var xpcConnectionReplyInvalid: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var ubiquitousFileUnavailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var ubiquitousFileNotUploadedDueToQuota: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var ubiquitousFileUbiquityServerNotAvailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityHandoffFailed: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityConnectionUnavailable: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityRemoteApplicationTimedOut: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var userActivityHandoffUserInfoTooLarge: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var coderReadCorrupt: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var coderValueNotFound: Foundation.CocoaError.Code {
    get
  }
  public static var coderInvalidValue: Foundation.CocoaError.Code {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.CocoaError {
  @available(macOS 10.11, iOS 9.0, *)
  public var isCoderError: Swift.Bool {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var isExecutableError: Swift.Bool {
    get
  }
  public var isFileError: Swift.Bool {
    get
  }
  public var isFormattingError: Swift.Bool {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var isPropertyListError: Swift.Bool {
    get
  }
  public var isValidationError: Swift.Bool {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var isUbiquitousFileError: Swift.Bool {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var isUserActivityError: Swift.Bool {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public var isXPCConnectionError: Swift.Bool {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct POSIXError : Foundation._BridgedStoredNSError {
  public let _nsError: Foundation.NSError
  public init(_nsError error: Foundation.NSError)
  public static var errorDomain: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public typealias Code = _errno.POSIXErrorCode
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension _errno.POSIXErrorCode : Foundation._ErrorCodeProtocol {
  public typealias _ErrorType = Foundation.POSIXError
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.POSIXError {
  public static var EPERM: _errno.POSIXErrorCode {
    get
  }
  public static var ENOENT: _errno.POSIXErrorCode {
    get
  }
  public static var ESRCH: _errno.POSIXErrorCode {
    get
  }
  public static var EINTR: _errno.POSIXErrorCode {
    get
  }
  public static var EIO: _errno.POSIXErrorCode {
    get
  }
  public static var ENXIO: _errno.POSIXErrorCode {
    get
  }
  public static var E2BIG: _errno.POSIXErrorCode {
    get
  }
  public static var ENOEXEC: _errno.POSIXErrorCode {
    get
  }
  public static var EBADF: _errno.POSIXErrorCode {
    get
  }
  public static var ECHILD: _errno.POSIXErrorCode {
    get
  }
  public static var EDEADLK: _errno.POSIXErrorCode {
    get
  }
  public static var ENOMEM: _errno.POSIXErrorCode {
    get
  }
  public static var EACCES: _errno.POSIXErrorCode {
    get
  }
  public static var EFAULT: _errno.POSIXErrorCode {
    get
  }
  public static var ENOTBLK: _errno.POSIXErrorCode {
    get
  }
  public static var EBUSY: _errno.POSIXErrorCode {
    get
  }
  public static var EEXIST: _errno.POSIXErrorCode {
    get
  }
  public static var EXDEV: _errno.POSIXErrorCode {
    get
  }
  public static var ENODEV: _errno.POSIXErrorCode {
    get
  }
  public static var ENOTDIR: _errno.POSIXErrorCode {
    get
  }
  public static var EISDIR: _errno.POSIXErrorCode {
    get
  }
  public static var EINVAL: _errno.POSIXErrorCode {
    get
  }
  public static var ENFILE: _errno.POSIXErrorCode {
    get
  }
  public static var EMFILE: _errno.POSIXErrorCode {
    get
  }
  public static var ENOTTY: _errno.POSIXErrorCode {
    get
  }
  public static var ETXTBSY: _errno.POSIXErrorCode {
    get
  }
  public static var EFBIG: _errno.POSIXErrorCode {
    get
  }
  public static var ENOSPC: _errno.POSIXErrorCode {
    get
  }
  public static var ESPIPE: _errno.POSIXErrorCode {
    get
  }
  public static var EROFS: _errno.POSIXErrorCode {
    get
  }
  public static var EMLINK: _errno.POSIXErrorCode {
    get
  }
  public static var EPIPE: _errno.POSIXErrorCode {
    get
  }
  public static var EDOM: _errno.POSIXErrorCode {
    get
  }
  public static var ERANGE: _errno.POSIXErrorCode {
    get
  }
  public static var EAGAIN: _errno.POSIXErrorCode {
    get
  }
  public static var EWOULDBLOCK: _errno.POSIXErrorCode {
    get
  }
  public static var EINPROGRESS: _errno.POSIXErrorCode {
    get
  }
  public static var EALREADY: _errno.POSIXErrorCode {
    get
  }
  public static var ENOTSOCK: _errno.POSIXErrorCode {
    get
  }
  public static var EDESTADDRREQ: _errno.POSIXErrorCode {
    get
  }
  public static var EMSGSIZE: _errno.POSIXErrorCode {
    get
  }
  public static var EPROTOTYPE: _errno.POSIXErrorCode {
    get
  }
  public static var ENOPROTOOPT: _errno.POSIXErrorCode {
    get
  }
  public static var EPROTONOSUPPORT: _errno.POSIXErrorCode {
    get
  }
  public static var ESOCKTNOSUPPORT: _errno.POSIXErrorCode {
    get
  }
  public static var ENOTSUP: _errno.POSIXErrorCode {
    get
  }
  public static var EPFNOSUPPORT: _errno.POSIXErrorCode {
    get
  }
  public static var EAFNOSUPPORT: _errno.POSIXErrorCode {
    get
  }
  public static var EADDRINUSE: _errno.POSIXErrorCode {
    get
  }
  public static var EADDRNOTAVAIL: _errno.POSIXErrorCode {
    get
  }
  public static var ENETDOWN: _errno.POSIXErrorCode {
    get
  }
  public static var ENETUNREACH: _errno.POSIXErrorCode {
    get
  }
  public static var ENETRESET: _errno.POSIXErrorCode {
    get
  }
  public static var ECONNABORTED: _errno.POSIXErrorCode {
    get
  }
  public static var ECONNRESET: _errno.POSIXErrorCode {
    get
  }
  public static var ENOBUFS: _errno.POSIXErrorCode {
    get
  }
  public static var EISCONN: _errno.POSIXErrorCode {
    get
  }
  public static var ENOTCONN: _errno.POSIXErrorCode {
    get
  }
  public static var ESHUTDOWN: _errno.POSIXErrorCode {
    get
  }
  public static var ETOOMANYREFS: _errno.POSIXErrorCode {
    get
  }
  public static var ETIMEDOUT: _errno.POSIXErrorCode {
    get
  }
  public static var ECONNREFUSED: _errno.POSIXErrorCode {
    get
  }
  public static var ELOOP: _errno.POSIXErrorCode {
    get
  }
  public static var ENAMETOOLONG: _errno.POSIXErrorCode {
    get
  }
  public static var EHOSTDOWN: _errno.POSIXErrorCode {
    get
  }
  public static var EHOSTUNREACH: _errno.POSIXErrorCode {
    get
  }
  public static var ENOTEMPTY: _errno.POSIXErrorCode {
    get
  }
  public static var EPROCLIM: _errno.POSIXErrorCode {
    get
  }
  public static var EUSERS: _errno.POSIXErrorCode {
    get
  }
  public static var EDQUOT: _errno.POSIXErrorCode {
    get
  }
  public static var ESTALE: _errno.POSIXErrorCode {
    get
  }
  public static var EREMOTE: _errno.POSIXErrorCode {
    get
  }
  public static var EBADRPC: _errno.POSIXErrorCode {
    get
  }
  public static var ERPCMISMATCH: _errno.POSIXErrorCode {
    get
  }
  public static var EPROGUNAVAIL: _errno.POSIXErrorCode {
    get
  }
  public static var EPROGMISMATCH: _errno.POSIXErrorCode {
    get
  }
  public static var EPROCUNAVAIL: _errno.POSIXErrorCode {
    get
  }
  public static var ENOLCK: _errno.POSIXErrorCode {
    get
  }
  public static var ENOSYS: _errno.POSIXErrorCode {
    get
  }
  public static var EFTYPE: _errno.POSIXErrorCode {
    get
  }
  public static var EAUTH: _errno.POSIXErrorCode {
    get
  }
  public static var ENEEDAUTH: _errno.POSIXErrorCode {
    get
  }
  public static var EPWROFF: _errno.POSIXErrorCode {
    get
  }
  public static var EDEVERR: _errno.POSIXErrorCode {
    get
  }
  public static var EOVERFLOW: _errno.POSIXErrorCode {
    get
  }
  public static var EBADEXEC: _errno.POSIXErrorCode {
    get
  }
  public static var EBADARCH: _errno.POSIXErrorCode {
    get
  }
  public static var ESHLIBVERS: _errno.POSIXErrorCode {
    get
  }
  public static var EBADMACHO: _errno.POSIXErrorCode {
    get
  }
  public static var ECANCELED: _errno.POSIXErrorCode {
    get
  }
  public static var EIDRM: _errno.POSIXErrorCode {
    get
  }
  public static var ENOMSG: _errno.POSIXErrorCode {
    get
  }
  public static var EILSEQ: _errno.POSIXErrorCode {
    get
  }
  public static var ENOATTR: _errno.POSIXErrorCode {
    get
  }
  public static var EBADMSG: _errno.POSIXErrorCode {
    get
  }
  public static var EMULTIHOP: _errno.POSIXErrorCode {
    get
  }
  public static var ENODATA: _errno.POSIXErrorCode {
    get
  }
  public static var ENOLINK: _errno.POSIXErrorCode {
    get
  }
  public static var ENOSR: _errno.POSIXErrorCode {
    get
  }
  public static var ENOSTR: _errno.POSIXErrorCode {
    get
  }
  public static var EPROTO: _errno.POSIXErrorCode {
    get
  }
  public static var ETIME: _errno.POSIXErrorCode {
    get
  }
  public static var ENOPOLICY: _errno.POSIXErrorCode {
    get
  }
  public static var ENOTRECOVERABLE: _errno.POSIXErrorCode {
    get
  }
  public static var EOWNERDEAD: _errno.POSIXErrorCode {
    get
  }
  public static var EQFULL: _errno.POSIXErrorCode {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public func ISO8601Format(_ style: Foundation.Date.ISO8601FormatStyle = .init()) -> Swift.String
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date {
  public struct ISO8601FormatStyle : Swift.Sendable {
    public enum TimeZoneSeparator : Swift.String, Swift.Codable, Swift.Sendable {
      case colon
      case omitted
      public init?(rawValue: Swift.String)
      @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public enum DateSeparator : Swift.String, Swift.Codable, Swift.Sendable {
      case dash
      case omitted
      public init?(rawValue: Swift.String)
      @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public enum TimeSeparator : Swift.String, Swift.Codable, Swift.Sendable {
      case colon
      case omitted
      public init?(rawValue: Swift.String)
      @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public enum DateTimeSeparator : Swift.String, Swift.Codable, Swift.Sendable {
      case space
      case standard
      public init?(rawValue: Swift.String)
      @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public var timeSeparator: Foundation.Date.ISO8601FormatStyle.TimeSeparator {
      get
    }
    public var includingFractionalSeconds: Swift.Bool {
      get
    }
    public var timeZoneSeparator: Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator {
      get
    }
    public var dateSeparator: Foundation.Date.ISO8601FormatStyle.DateSeparator {
      get
    }
    public var dateTimeSeparator: Foundation.Date.ISO8601FormatStyle.DateTimeSeparator {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Date.ISO8601FormatStyle, rhs: Foundation.Date.ISO8601FormatStyle) -> Swift.Bool
    public var timeZone: Foundation.TimeZone {
      get
      set
    }
    @_disfavoredOverload public init(dateSeparator: Foundation.Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Foundation.Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeZone: Foundation.TimeZone = TimeZone(secondsFromGMT: 0)!)
    public init(dateSeparator: Foundation.Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Foundation.Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeSeparator: Foundation.Date.ISO8601FormatStyle.TimeSeparator = .colon, timeZoneSeparator: Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator = .omitted, includingFractionalSeconds: Swift.Bool = false, timeZone: Foundation.TimeZone = TimeZone(secondsFromGMT: 0)!)
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle {
  public func year() -> Foundation.Date.ISO8601FormatStyle
  public func weekOfYear() -> Foundation.Date.ISO8601FormatStyle
  public func month() -> Foundation.Date.ISO8601FormatStyle
  public func day() -> Foundation.Date.ISO8601FormatStyle
  public func time(includingFractionalSeconds: Swift.Bool) -> Foundation.Date.ISO8601FormatStyle
  public func timeZone(separator: Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator) -> Foundation.Date.ISO8601FormatStyle
  public func dateSeparator(_ separator: Foundation.Date.ISO8601FormatStyle.DateSeparator) -> Foundation.Date.ISO8601FormatStyle
  public func dateTimeSeparator(_ separator: Foundation.Date.ISO8601FormatStyle.DateTimeSeparator) -> Foundation.Date.ISO8601FormatStyle
  public func timeSeparator(_ separator: Foundation.Date.ISO8601FormatStyle.TimeSeparator) -> Foundation.Date.ISO8601FormatStyle
  public func timeZoneSeparator(_ separator: Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator) -> Foundation.Date.ISO8601FormatStyle
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle : Foundation.FormatStyle {
  public func format(_ value: Foundation.Date) -> Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatInput = Foundation.Date
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias FormatOutput = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.ISO8601FormatStyle {
  public static var iso8601: Foundation.Date.ISO8601FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.Date.ISO8601FormatStyle {
  public static var iso8601: Foundation.Date.ISO8601FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseStrategy where Self == Foundation.Date.ISO8601FormatStyle {
  @_disfavoredOverload public static var iso8601: Foundation.Date.ISO8601FormatStyle {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle : Foundation.ParseStrategy {
  public func parse(_ value: Swift.String) throws -> Foundation.Date
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias ParseInput = Swift.String
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias ParseOutput = Foundation.Date
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.Date.ISO8601FormatStyle {
    get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Strategy = Foundation.Date.ISO8601FormatStyle
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.Date.ISO8601FormatStyle : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = Foundation.Date
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: Foundation.Date)?
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension _StringProcessing.RegexComponent where Self == Foundation.Date.ISO8601FormatStyle {
  @_disfavoredOverload public static var iso8601: Foundation.Date.ISO8601FormatStyle {
    get
  }
  public static func iso8601WithTimeZone(includingFractionalSeconds: Swift.Bool = false, dateSeparator: Foundation.Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Foundation.Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeSeparator: Foundation.Date.ISO8601FormatStyle.TimeSeparator = .colon, timeZoneSeparator: Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator = .omitted) -> Self
  public static func iso8601(timeZone: Foundation.TimeZone, includingFractionalSeconds: Swift.Bool = false, dateSeparator: Foundation.Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Foundation.Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeSeparator: Foundation.Date.ISO8601FormatStyle.TimeSeparator = .colon) -> Self
  public static func iso8601Date(timeZone: Foundation.TimeZone, dateSeparator: Foundation.Date.ISO8601FormatStyle.DateSeparator = .dash) -> Self
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
public protocol DiscreteFormatStyle<FormatInput, FormatOutput> : Foundation.FormatStyle {
  func discreteInput(before input: Self.FormatInput) -> Self.FormatInput?
  func discreteInput(after input: Self.FormatInput) -> Self.FormatInput?
  func input(before input: Self.FormatInput) -> Self.FormatInput?
  func input(after input: Self.FormatInput) -> Self.FormatInput?
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.DiscreteFormatStyle where Self.FormatInput : Swift.FloatingPoint {
  public func input(before input: Self.FormatInput) -> Self.FormatInput?
  public func input(after input: Self.FormatInput) -> Self.FormatInput?
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.DiscreteFormatStyle where Self.FormatInput : Swift.FixedWidthInteger {
  public func input(before input: Self.FormatInput) -> Self.FormatInput?
  public func input(after input: Self.FormatInput) -> Self.FormatInput?
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.DiscreteFormatStyle where Self.FormatInput == Foundation.Date {
  public func input(before input: Self.FormatInput) -> Self.FormatInput?
  public func input(after input: Self.FormatInput) -> Self.FormatInput?
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.DiscreteFormatStyle where Self.FormatInput == Swift.Duration {
  public func input(before input: Self.FormatInput) -> Self.FormatInput?
  public func input(after input: Self.FormatInput) -> Self.FormatInput?
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol FormatStyle<FormatInput, FormatOutput> : Swift.Decodable, Swift.Encodable, Swift.Hashable {
  associatedtype FormatInput
  associatedtype FormatOutput
  func format(_ value: Self.FormatInput) -> Self.FormatOutput
  func locale(_ locale: Foundation.Locale) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle {
  public func locale(_ locale: Foundation.Locale) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol ParseableFormatStyle : Foundation.FormatStyle {
  associatedtype Strategy : Foundation.ParseStrategy where Self.FormatInput == Self.Strategy.ParseOutput, Self.FormatOutput == Self.Strategy.ParseInput
  var parseStrategy: Self.Strategy { get }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol ParseStrategy : Swift.Decodable, Swift.Encodable, Swift.Hashable {
  associatedtype ParseInput
  associatedtype ParseOutput
  func parse(_ value: Self.ParseInput) throws -> Self.ParseOutput
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@_objcRuntimeName(_TtC10Foundation13__JSONDecoder) open class JSONDecoder {
  public enum DateDecodingStrategy : Swift.Sendable {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
    case iso8601
    case formatted(Foundation.DateFormatter)
    @preconcurrency case custom(@Sendable (_ decoder: any Swift.Decoder) throws -> Foundation.Date)
  }
  public enum DataDecodingStrategy : Swift.Sendable {
    case deferredToData
    case base64
    @preconcurrency case custom(@Sendable (_ decoder: any Swift.Decoder) throws -> Foundation.Data)
  }
  public enum NonConformingFloatDecodingStrategy : Swift.Sendable {
    case `throw`
    case convertFromString(positiveInfinity: Swift.String, negativeInfinity: Swift.String, nan: Swift.String)
  }
  public enum KeyDecodingStrategy : Swift.Sendable {
    case useDefaultKeys
    case convertFromSnakeCase
    @preconcurrency case custom(@Sendable (_ codingPath: [any Swift.CodingKey]) -> any Swift.CodingKey)
  }
  open var dateDecodingStrategy: Foundation.JSONDecoder.DateDecodingStrategy {
    get
    set
    _modify
  }
  open var dataDecodingStrategy: Foundation.JSONDecoder.DataDecodingStrategy {
    get
    set
    _modify
  }
  open var nonConformingFloatDecodingStrategy: Foundation.JSONDecoder.NonConformingFloatDecodingStrategy {
    get
    set
    _modify
  }
  open var keyDecodingStrategy: Foundation.JSONDecoder.KeyDecodingStrategy {
    get
    set
    _modify
  }
  @preconcurrency open var userInfo: [Swift.CodingUserInfoKey : any Swift.Sendable] {
    get
    set
    _modify
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  open var allowsJSON5: Swift.Bool {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  open var assumesTopLevelDictionary: Swift.Bool {
    get
    set
  }
  public init()
  open func decode<T>(_ type: T.Type, from data: Foundation.Data) throws -> T where T : Swift.Decodable
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  open func decode<T>(_ type: T.Type, from data: Foundation.Data, configuration: T.DecodingConfiguration) throws -> T where T : Foundation.DecodableWithConfiguration
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  open func decode<T, C>(_ type: T.Type, from data: Foundation.Data, configuration: C.Type) throws -> T where T : Foundation.DecodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  @objc deinit
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.JSONDecoder : @unchecked Swift.Sendable {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@_objcRuntimeName(_TtC10Foundation13__JSONEncoder) open class JSONEncoder {
  public struct OutputFormatting : Swift.OptionSet, Swift.Sendable {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let prettyPrinted: Foundation.JSONEncoder.OutputFormatting
    @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
    public static let sortedKeys: Foundation.JSONEncoder.OutputFormatting
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public static let withoutEscapingSlashes: Foundation.JSONEncoder.OutputFormatting
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias ArrayLiteralElement = Foundation.JSONEncoder.OutputFormatting
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Element = Foundation.JSONEncoder.OutputFormatting
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias RawValue = Swift.UInt
  }
  public enum DateEncodingStrategy : Swift.Sendable {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
    case iso8601
    case formatted(Foundation.DateFormatter)
    @preconcurrency case custom(@Sendable (Foundation.Date, any Swift.Encoder) throws -> Swift.Void)
  }
  public enum DataEncodingStrategy : Swift.Sendable {
    case deferredToData
    case base64
    @preconcurrency case custom(@Sendable (Foundation.Data, any Swift.Encoder) throws -> Swift.Void)
  }
  public enum NonConformingFloatEncodingStrategy : Swift.Sendable {
    case `throw`
    case convertToString(positiveInfinity: Swift.String, negativeInfinity: Swift.String, nan: Swift.String)
  }
  public enum KeyEncodingStrategy : Swift.Sendable {
    case useDefaultKeys
    case convertToSnakeCase
    @preconcurrency case custom(@Sendable (_ codingPath: [any Swift.CodingKey]) -> any Swift.CodingKey)
  }
  open var outputFormatting: Foundation.JSONEncoder.OutputFormatting {
    get
    set
    _modify
  }
  open var dateEncodingStrategy: Foundation.JSONEncoder.DateEncodingStrategy {
    get
    set
    _modify
  }
  open var dataEncodingStrategy: Foundation.JSONEncoder.DataEncodingStrategy {
    get
    set
    _modify
  }
  open var nonConformingFloatEncodingStrategy: Foundation.JSONEncoder.NonConformingFloatEncodingStrategy {
    get
    set
    _modify
  }
  open var keyEncodingStrategy: Foundation.JSONEncoder.KeyEncodingStrategy {
    get
    set
    _modify
  }
  @preconcurrency open var userInfo: [Swift.CodingUserInfoKey : any Swift.Sendable] {
    get
    set
    _modify
  }
  public init()
  open func encode<T>(_ value: T) throws -> Foundation.Data where T : Swift.Encodable
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  open func encode<T>(_ value: T, configuration: T.EncodingConfiguration) throws -> Foundation.Data where T : Foundation.EncodableWithConfiguration
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  open func encode<T, C>(_ value: T, configuration: C.Type) throws -> Foundation.Data where T : Foundation.EncodableWithConfiguration, C : Foundation.EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration
  @objc deinit
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.JSONEncoder : @unchecked Swift.Sendable {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct Locale : Swift.Hashable, Swift.Equatable, Swift.Sendable {
  public typealias LanguageDirection = Foundation.NSLocale.LanguageDirection
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public enum IdentifierType : Swift.Sendable {
    case icu
    case bcp47
    case cldr
    public static func == (a: Foundation.Locale.IdentifierType, b: Foundation.Locale.IdentifierType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var autoupdatingCurrent: Foundation.Locale {
    get
  }
  public static var current: Foundation.Locale {
    get
  }
  public init(identifier: Swift.String)
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public init(components: Foundation.Locale.Components)
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public init(languageComponents: Foundation.Locale.Language.Components)
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public init(languageCode: Foundation.Locale.LanguageCode? = nil, script: Foundation.Locale.Script? = nil, languageRegion: Foundation.Locale.Region? = nil)
  public func localizedString(forIdentifier identifier: Swift.String) -> Swift.String?
  public func localizedString(forLanguageCode languageCode: Swift.String) -> Swift.String?
  public func localizedString(forRegionCode regionCode: Swift.String) -> Swift.String?
  public func localizedString(forScriptCode scriptCode: Swift.String) -> Swift.String?
  public func localizedString(forVariantCode variantCode: Swift.String) -> Swift.String?
  public func localizedString(for calendarIdentifier: Foundation.Calendar.Identifier) -> Swift.String?
  public func localizedString(forCurrencyCode currencyCode: Swift.String) -> Swift.String?
  public func localizedString(forCollationIdentifier collationIdentifier: Swift.String) -> Swift.String?
  public func localizedString(forCollatorIdentifier collatorIdentifier: Swift.String) -> Swift.String?
  public var identifier: Swift.String {
    @_effects(releasenone) get
  }
  @available(macOS, deprecated: 13, renamed: "language.languageCode.identifier")
  @available(iOS, deprecated: 16, renamed: "language.languageCode.identifier")
  @available(tvOS, deprecated: 16, renamed: "language.languageCode.identifier")
  @available(watchOS, deprecated: 9, renamed: "language.languageCode.identifier")
  public var languageCode: Swift.String? {
    get
  }
  @available(macOS, deprecated: 13, renamed: "region.identifier")
  @available(iOS, deprecated: 16, renamed: "region.identifier")
  @available(tvOS, deprecated: 16, renamed: "region.identifier")
  @available(watchOS, deprecated: 9, renamed: "region.identifier")
  public var regionCode: Swift.String? {
    get
  }
  @available(macOS, deprecated: 13, renamed: "language.script.identifier")
  @available(iOS, deprecated: 16, renamed: "language.script.identifier")
  @available(tvOS, deprecated: 16, renamed: "language.script.identifier")
  @available(watchOS, deprecated: 9, renamed: "language.script.identifier")
  public var scriptCode: Swift.String? {
    get
  }
  @available(macOS, deprecated: 13, renamed: "variant.identifier")
  @available(iOS, deprecated: 16, renamed: "variant.identifier")
  @available(tvOS, deprecated: 16, renamed: "variant.identifier")
  @available(watchOS, deprecated: 9, renamed: "variant.identifier")
  public var variantCode: Swift.String? {
    get
  }
  public var exemplarCharacterSet: Foundation.CharacterSet? {
    get
  }
  public var calendar: Foundation.Calendar {
    get
  }
  @available(macOS, deprecated: 13, renamed: "collation.identifier")
  @available(iOS, deprecated: 16, renamed: "collation.identifier")
  @available(tvOS, deprecated: 16, renamed: "collation.identifier")
  @available(watchOS, deprecated: 9, renamed: "collation.identifier")
  public var collationIdentifier: Swift.String? {
    get
  }
  @available(macOS, deprecated: 13, message: "Use `measurementSystem` instead")
  @available(iOS, deprecated: 16, message: "Use `measurementSystem` instead")
  @available(tvOS, deprecated: 16, message: "Use `measurementSystem` instead")
  @available(watchOS, deprecated: 9, message: "Use `measurementSystem` instead")
  public var usesMetricSystem: Swift.Bool {
    get
  }
  public var decimalSeparator: Swift.String? {
    get
  }
  public var groupingSeparator: Swift.String? {
    get
  }
  public var currencySymbol: Swift.String? {
    get
  }
  @available(macOS, deprecated: 13, renamed: "currency.identifier")
  @available(iOS, deprecated: 16, renamed: "currency.identifier")
  @available(tvOS, deprecated: 16, renamed: "currency.identifier")
  @available(watchOS, deprecated: 9, renamed: "currency.identifier")
  public var currencyCode: Swift.String? {
    get
  }
  public var collatorIdentifier: Swift.String? {
    get
  }
  public var quotationBeginDelimiter: Swift.String? {
    get
  }
  public var quotationEndDelimiter: Swift.String? {
    get
  }
  public var alternateQuotationBeginDelimiter: Swift.String? {
    get
  }
  public var alternateQuotationEndDelimiter: Swift.String? {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var measurementSystem: Foundation.Locale.MeasurementSystem {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var currency: Foundation.Locale.Currency? {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var numberingSystem: Foundation.Locale.NumberingSystem {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var availableNumberingSystems: [Foundation.Locale.NumberingSystem] {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var firstDayOfWeek: Foundation.Locale.Weekday {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var language: Foundation.Locale.Language {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public func identifier(_ type: Foundation.Locale.IdentifierType) -> Swift.String
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var hourCycle: Foundation.Locale.HourCycle {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var collation: Foundation.Locale.Collation {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var region: Foundation.Locale.Region? {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var timeZone: Foundation.TimeZone? {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var subdivision: Foundation.Locale.Subdivision? {
    get
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public var variant: Foundation.Locale.Variant? {
    get
  }
  public static var preferredLanguages: [Swift.String] {
    get
  }
  public static func identifier(fromComponents components: [Swift.String : Swift.String]) -> Swift.String
  @available(macOS, deprecated: 13, renamed: "identifier(_:from:)")
  @available(iOS, deprecated: 16, renamed: "identifier(_:from:)")
  @available(tvOS, deprecated: 16, renamed: "identifier(_:from:)")
  @available(watchOS, deprecated: 9, renamed: "identifier(_:from:)")
  public static func canonicalIdentifier(from string: Swift.String) -> Swift.String
  public static func canonicalLanguageIdentifier(from string: Swift.String) -> Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.Locale, rhs: Foundation.Locale) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Locale : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Locale : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Foundation.Locale {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct Components : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var languageComponents: Foundation.Locale.Language.Components
    public var calendar: Foundation.Calendar.Identifier?
    public var collation: Foundation.Locale.Collation?
    public var currency: Foundation.Locale.Currency?
    public var numberingSystem: Foundation.Locale.NumberingSystem?
    public var firstDayOfWeek: Foundation.Locale.Weekday?
    public var hourCycle: Foundation.Locale.HourCycle?
    public var measurementSystem: Foundation.Locale.MeasurementSystem?
    public var region: Foundation.Locale.Region?
    public var subdivision: Foundation.Locale.Subdivision?
    public var timeZone: Foundation.TimeZone?
    public var variant: Foundation.Locale.Variant?
    public init(languageCode: Foundation.Locale.LanguageCode? = nil, script: Foundation.Locale.Script? = nil, languageRegion: Foundation.Locale.Region? = nil)
    public static func == (a: Foundation.Locale.Components, b: Foundation.Locale.Components) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Locale.LanguageCode : Swift.CustomDebugStringConvertible {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Locale.Script : Swift.CustomDebugStringConvertible {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Locale.Region : Swift.CustomDebugStringConvertible {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Locale.Currency : Swift.CustomDebugStringConvertible {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Locale.Collation : Swift.CustomDebugStringConvertible {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Locale.NumberingSystem : Swift.CustomDebugStringConvertible {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Locale.Subdivision : Swift.CustomDebugStringConvertible {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Locale.Variant : Swift.CustomDebugStringConvertible {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Locale.MeasurementSystem : Swift.CustomDebugStringConvertible {
}
extension Foundation.Locale {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct LanguageCode : Swift.Hashable, Swift.Codable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public init(_ identifier: Swift.String)
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var debugDescription: Swift.String {
      get
    }
    public var identifier: Swift.String {
      get
      set
    }
    public enum IdentifierType : Swift.Sendable {
      case alpha2
      case alpha3
      public static func == (a: Foundation.Locale.LanguageCode.IdentifierType, b: Foundation.Locale.LanguageCode.IdentifierType) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public static let unidentified: Foundation.Locale.LanguageCode
    public static let uncoded: Foundation.Locale.LanguageCode
    public static let multiple: Foundation.Locale.LanguageCode
    public static let unavailable: Foundation.Locale.LanguageCode
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.LanguageCode, rhs: Foundation.Locale.LanguageCode) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias StringLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct Script : Swift.Hashable, Swift.Codable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public var identifier: Swift.String {
      get
      set
    }
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var debugDescription: Swift.String {
      get
    }
    public init(_ identifier: Swift.String)
    public static let unknown: Foundation.Locale.Script
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.Script, rhs: Foundation.Locale.Script) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias StringLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct Region : Swift.Hashable, Swift.Codable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var debugDescription: Swift.String {
      get
    }
    public var identifier: Swift.String {
      get
      set
    }
    public init(_ identifier: Swift.String)
    public static let unknown: Foundation.Locale.Region
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.Region, rhs: Foundation.Locale.Region) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias StringLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct Collation : Swift.Hashable, Swift.Codable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public var identifier: Swift.String {
      get
      set
    }
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var debugDescription: Swift.String {
      get
    }
    public init(_ identifier: Swift.String)
    public static let searchRules: Foundation.Locale.Collation
    public static let standard: Foundation.Locale.Collation
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.Collation, rhs: Foundation.Locale.Collation) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias StringLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct Currency : Swift.Hashable, Swift.Codable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public var identifier: Swift.String {
      get
      set
    }
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var debugDescription: Swift.String {
      get
    }
    public init(_ identifier: Swift.String)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.Currency, rhs: Foundation.Locale.Currency) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias StringLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct NumberingSystem : Swift.Hashable, Swift.Codable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public var identifier: Swift.String {
      get
      set
    }
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var debugDescription: Swift.String {
      get
    }
    public init(_ identifier: Swift.String)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.NumberingSystem, rhs: Foundation.Locale.NumberingSystem) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias StringLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public enum Weekday : Swift.String, Swift.Codable, Swift.Hashable, Swift.Sendable {
    case sunday
    case monday
    case tuesday
    case wednesday
    case thursday
    case friday
    case saturday
    public init?(rawValue: Swift.String)
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public enum HourCycle : Swift.String, Swift.Codable, Swift.Hashable, Swift.Sendable {
    case zeroToEleven
    case oneToTwelve
    case zeroToTwentyThree
    case oneToTwentyFour
    public init?(rawValue: Swift.String)
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct MeasurementSystem : Swift.Codable, Swift.Hashable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public var identifier: Swift.String {
      get
      set
    }
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var debugDescription: Swift.String {
      get
    }
    public init(_ identifier: Swift.String)
    public static let metric: Foundation.Locale.MeasurementSystem
    public static let us: Foundation.Locale.MeasurementSystem
    public static let uk: Foundation.Locale.MeasurementSystem
    public static var measurementSystems: [Foundation.Locale.MeasurementSystem] {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.MeasurementSystem, rhs: Foundation.Locale.MeasurementSystem) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias StringLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct Subdivision : Swift.Hashable, Swift.Codable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public var identifier: Swift.String {
      get
      set
    }
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var debugDescription: Swift.String {
      get
    }
    public init(_ identifier: Swift.String)
    public static func subdivision(for region: Foundation.Locale.Region) -> Foundation.Locale.Subdivision
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.Subdivision, rhs: Foundation.Locale.Subdivision) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias StringLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct Variant : Swift.Codable, Swift.Hashable, Swift.Sendable, Swift.ExpressibleByStringLiteral {
    public init(stringLiteral value: Swift.String)
    public var identifier: Swift.String {
      get
      set
    }
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var debugDescription: Swift.String {
      get
    }
    public init(_ identifier: Swift.String)
    public static let posix: Foundation.Locale.Variant
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Foundation.Locale.Variant, rhs: Foundation.Locale.Variant) -> Swift.Bool
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias StringLiteralType = Swift.String
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.LanguageCode {
  @_alwaysEmitIntoClient public static var ainu: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ain") }
  }
  @_alwaysEmitIntoClient public static var albanian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sq") }
  }
  @_alwaysEmitIntoClient public static var amharic: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("am") }
  }
  @_alwaysEmitIntoClient public static var apacheWestern: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("apw") }
  }
  @_alwaysEmitIntoClient public static var arabic: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ar") }
  }
  @_alwaysEmitIntoClient public static var armenian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("hy") }
  }
  @_alwaysEmitIntoClient public static var assamese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("as") }
  }
  @_alwaysEmitIntoClient public static var assyrian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("syr") }
  }
  @_alwaysEmitIntoClient public static var azerbaijani: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("az") }
  }
  @_alwaysEmitIntoClient public static var bangla: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("bn") }
  }
  @_alwaysEmitIntoClient public static var belarusian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("be") }
  }
  @_alwaysEmitIntoClient public static var bodo: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("brx") }
  }
  @_alwaysEmitIntoClient public static var bulgarian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("bg") }
  }
  @_alwaysEmitIntoClient public static var burmese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("my") }
  }
  @_alwaysEmitIntoClient public static var cantonese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("yue") }
  }
  @_alwaysEmitIntoClient public static var catalan: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ca") }
  }
  @_alwaysEmitIntoClient public static var cherokee: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("chr") }
  }
  @_alwaysEmitIntoClient public static var chinese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("zh") }
  }
  @_alwaysEmitIntoClient public static var croatian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("hr") }
  }
  @_alwaysEmitIntoClient public static var czech: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("cs") }
  }
  @_alwaysEmitIntoClient public static var danish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("da") }
  }
  @_alwaysEmitIntoClient public static var dhivehi: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("dv") }
  }
  @_alwaysEmitIntoClient public static var dogri: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("doi") }
  }
  @_alwaysEmitIntoClient public static var dutch: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("nl") }
  }
  @_alwaysEmitIntoClient public static var dzongkha: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("dz") }
  }
  @_alwaysEmitIntoClient public static var english: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("en") }
  }
  @_alwaysEmitIntoClient public static var estonian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("et") }
  }
  @_alwaysEmitIntoClient public static var faroese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("fo") }
  }
  @_alwaysEmitIntoClient public static var finnish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("fi") }
  }
  @_alwaysEmitIntoClient public static var french: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("fr") }
  }
  @_alwaysEmitIntoClient public static var fula: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ff") }
  }
  @_alwaysEmitIntoClient public static var georgian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ka") }
  }
  @_alwaysEmitIntoClient public static var german: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("de") }
  }
  @_alwaysEmitIntoClient public static var greek: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("el") }
  }
  @_alwaysEmitIntoClient public static var gujarati: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("gu") }
  }
  @_alwaysEmitIntoClient public static var hawaiian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("haw") }
  }
  @_alwaysEmitIntoClient public static var hebrew: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("he") }
  }
  @_alwaysEmitIntoClient public static var hindi: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("hi") }
  }
  @_alwaysEmitIntoClient public static var hungarian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("hu") }
  }
  @_alwaysEmitIntoClient public static var icelandic: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("is") }
  }
  @_alwaysEmitIntoClient public static var igbo: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ig") }
  }
  @_alwaysEmitIntoClient public static var indonesian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("id") }
  }
  @_alwaysEmitIntoClient public static var irish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ga") }
  }
  @_alwaysEmitIntoClient public static var italian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("it") }
  }
  @_alwaysEmitIntoClient public static var japanese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ja") }
  }
  @_alwaysEmitIntoClient public static var kannada: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("kn") }
  }
  @_alwaysEmitIntoClient public static var kashmiri: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ks") }
  }
  @_alwaysEmitIntoClient public static var kazakh: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("kk") }
  }
  @_alwaysEmitIntoClient public static var khmer: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("km") }
  }
  @_alwaysEmitIntoClient public static var konkani: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("kok") }
  }
  @_alwaysEmitIntoClient public static var korean: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ko") }
  }
  @_alwaysEmitIntoClient public static var kurdish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ku") }
  }
  @_alwaysEmitIntoClient public static var kurdishSorani: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ckb") }
  }
  @_alwaysEmitIntoClient public static var kyrgyz: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ky") }
  }
  @_alwaysEmitIntoClient public static var lao: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("lo") }
  }
  @_alwaysEmitIntoClient public static var latvian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("lv") }
  }
  @_alwaysEmitIntoClient public static var lithuanian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("lt") }
  }
  @_alwaysEmitIntoClient public static var macedonian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("mk") }
  }
  @_alwaysEmitIntoClient public static var maithili: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("mai") }
  }
  @_alwaysEmitIntoClient public static var malay: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ms") }
  }
  @_alwaysEmitIntoClient public static var malayalam: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ml") }
  }
  @_alwaysEmitIntoClient public static var maltese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("mt") }
  }
  @_alwaysEmitIntoClient public static var manipuri: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("mni") }
  }
  @_alwaysEmitIntoClient public static var māori: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("mi") }
  }
  @_alwaysEmitIntoClient public static var marathi: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("mr") }
  }
  @_alwaysEmitIntoClient public static var mongolian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("mn") }
  }
  @_alwaysEmitIntoClient public static var navajo: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("nv") }
  }
  @_alwaysEmitIntoClient public static var nepali: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ne") }
  }
  @_alwaysEmitIntoClient public static var norwegian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("no") }
  }
  @_alwaysEmitIntoClient public static var norwegianBokmål: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("nb") }
  }
  @_alwaysEmitIntoClient public static var norwegianNynorsk: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("nn") }
  }
  @_alwaysEmitIntoClient public static var odia: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("or") }
  }
  @_alwaysEmitIntoClient public static var pashto: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ps") }
  }
  @_alwaysEmitIntoClient public static var persian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("fa") }
  }
  @_alwaysEmitIntoClient public static var polish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("pl") }
  }
  @_alwaysEmitIntoClient public static var portuguese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("pt") }
  }
  @_alwaysEmitIntoClient public static var punjabi: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("pa") }
  }
  @_alwaysEmitIntoClient public static var rohingya: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("rhg") }
  }
  @_alwaysEmitIntoClient public static var romanian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ro") }
  }
  @_alwaysEmitIntoClient public static var russian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ru") }
  }
  @_alwaysEmitIntoClient public static var samoan: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sm") }
  }
  @_alwaysEmitIntoClient public static var sanskrit: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sa") }
  }
  @_alwaysEmitIntoClient public static var santali: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sat") }
  }
  @_alwaysEmitIntoClient public static var serbian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sr") }
  }
  @_alwaysEmitIntoClient public static var sindhi: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sd") }
  }
  @_alwaysEmitIntoClient public static var sinhala: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("si") }
  }
  @_alwaysEmitIntoClient public static var slovak: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sk") }
  }
  @_alwaysEmitIntoClient public static var slovenian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sl") }
  }
  @_alwaysEmitIntoClient public static var spanish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("es") }
  }
  @_alwaysEmitIntoClient public static var swahili: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sw") }
  }
  @_alwaysEmitIntoClient public static var swedish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("sv") }
  }
  @_alwaysEmitIntoClient public static var tagalog: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("tl") }
  }
  @_alwaysEmitIntoClient public static var tajik: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("tg") }
  }
  @_alwaysEmitIntoClient public static var tamil: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ta") }
  }
  @_alwaysEmitIntoClient public static var telugu: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("te") }
  }
  @_alwaysEmitIntoClient public static var thai: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("th") }
  }
  @_alwaysEmitIntoClient public static var tibetan: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("bo") }
  }
  @_alwaysEmitIntoClient public static var tongan: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("to") }
  }
  @_alwaysEmitIntoClient public static var turkish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("tr") }
  }
  @_alwaysEmitIntoClient public static var turkmen: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("tk") }
  }
  @_alwaysEmitIntoClient public static var ukrainian: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("uk") }
  }
  @_alwaysEmitIntoClient public static var urdu: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ur") }
  }
  @_alwaysEmitIntoClient public static var uyghur: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("ug") }
  }
  @_alwaysEmitIntoClient public static var uzbek: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("uz") }
  }
  @_alwaysEmitIntoClient public static var vietnamese: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("vi") }
  }
  @_alwaysEmitIntoClient public static var welsh: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("cy") }
  }
  @_alwaysEmitIntoClient public static var yiddish: Foundation.Locale.LanguageCode {
    get { Locale.LanguageCode("yi") }
  }
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.Region {
  @_alwaysEmitIntoClient public static var afghanistan: Foundation.Locale.Region {
    get { Locale.Region("AF") }
  }
  @_alwaysEmitIntoClient public static var ålandIslands: Foundation.Locale.Region {
    get { Locale.Region("AX") }
  }
  @_alwaysEmitIntoClient public static var albania: Foundation.Locale.Region {
    get { Locale.Region("AL") }
  }
  @_alwaysEmitIntoClient public static var algeria: Foundation.Locale.Region {
    get { Locale.Region("DZ") }
  }
  @_alwaysEmitIntoClient public static var americanSamoa: Foundation.Locale.Region {
    get { Locale.Region("AS") }
  }
  @_alwaysEmitIntoClient public static var andorra: Foundation.Locale.Region {
    get { Locale.Region("AD") }
  }
  @_alwaysEmitIntoClient public static var angola: Foundation.Locale.Region {
    get { Locale.Region("AO") }
  }
  @_alwaysEmitIntoClient public static var anguilla: Foundation.Locale.Region {
    get { Locale.Region("AI") }
  }
  @_alwaysEmitIntoClient public static var antarctica: Foundation.Locale.Region {
    get { Locale.Region("AQ") }
  }
  @_alwaysEmitIntoClient public static var antiguaBarbuda: Foundation.Locale.Region {
    get { Locale.Region("AG") }
  }
  @_alwaysEmitIntoClient public static var argentina: Foundation.Locale.Region {
    get { Locale.Region("AR") }
  }
  @_alwaysEmitIntoClient public static var armenia: Foundation.Locale.Region {
    get { Locale.Region("AM") }
  }
  @_alwaysEmitIntoClient public static var aruba: Foundation.Locale.Region {
    get { Locale.Region("AW") }
  }
  @_alwaysEmitIntoClient public static var ascensionIsland: Foundation.Locale.Region {
    get { Locale.Region("AC") }
  }
  @_alwaysEmitIntoClient public static var australia: Foundation.Locale.Region {
    get { Locale.Region("AU") }
  }
  @_alwaysEmitIntoClient public static var austria: Foundation.Locale.Region {
    get { Locale.Region("AT") }
  }
  @_alwaysEmitIntoClient public static var azerbaijan: Foundation.Locale.Region {
    get { Locale.Region("AZ") }
  }
  @_alwaysEmitIntoClient public static var bahamas: Foundation.Locale.Region {
    get { Locale.Region("BS") }
  }
  @_alwaysEmitIntoClient public static var bahrain: Foundation.Locale.Region {
    get { Locale.Region("BH") }
  }
  @_alwaysEmitIntoClient public static var bangladesh: Foundation.Locale.Region {
    get { Locale.Region("BD") }
  }
  @_alwaysEmitIntoClient public static var barbados: Foundation.Locale.Region {
    get { Locale.Region("BB") }
  }
  @_alwaysEmitIntoClient public static var belarus: Foundation.Locale.Region {
    get { Locale.Region("BY") }
  }
  @_alwaysEmitIntoClient public static var belgium: Foundation.Locale.Region {
    get { Locale.Region("BE") }
  }
  @_alwaysEmitIntoClient public static var belize: Foundation.Locale.Region {
    get { Locale.Region("BZ") }
  }
  @_alwaysEmitIntoClient public static var benin: Foundation.Locale.Region {
    get { Locale.Region("BJ") }
  }
  @_alwaysEmitIntoClient public static var bermuda: Foundation.Locale.Region {
    get { Locale.Region("BM") }
  }
  @_alwaysEmitIntoClient public static var bhutan: Foundation.Locale.Region {
    get { Locale.Region("BT") }
  }
  @_alwaysEmitIntoClient public static var bolivia: Foundation.Locale.Region {
    get { Locale.Region("BO") }
  }
  @_alwaysEmitIntoClient public static var bosniaHerzegovina: Foundation.Locale.Region {
    get { Locale.Region("BA") }
  }
  @_alwaysEmitIntoClient public static var botswana: Foundation.Locale.Region {
    get { Locale.Region("BW") }
  }
  @_alwaysEmitIntoClient public static var bouvetIsland: Foundation.Locale.Region {
    get { Locale.Region("BV") }
  }
  @_alwaysEmitIntoClient public static var brazil: Foundation.Locale.Region {
    get { Locale.Region("BR") }
  }
  @_alwaysEmitIntoClient public static var britishVirginIslands: Foundation.Locale.Region {
    get { Locale.Region("VG") }
  }
  @_alwaysEmitIntoClient public static var brunei: Foundation.Locale.Region {
    get { Locale.Region("BN") }
  }
  @_alwaysEmitIntoClient public static var bulgaria: Foundation.Locale.Region {
    get { Locale.Region("BG") }
  }
  @_alwaysEmitIntoClient public static var burkinaFaso: Foundation.Locale.Region {
    get { Locale.Region("BF") }
  }
  @_alwaysEmitIntoClient public static var burundi: Foundation.Locale.Region {
    get { Locale.Region("BI") }
  }
  @_alwaysEmitIntoClient public static var cambodia: Foundation.Locale.Region {
    get { Locale.Region("KH") }
  }
  @_alwaysEmitIntoClient public static var cameroon: Foundation.Locale.Region {
    get { Locale.Region("CM") }
  }
  @_alwaysEmitIntoClient public static var canada: Foundation.Locale.Region {
    get { Locale.Region("CA") }
  }
  @_alwaysEmitIntoClient public static var canaryIslands: Foundation.Locale.Region {
    get { Locale.Region("IC") }
  }
  @_alwaysEmitIntoClient public static var capeVerde: Foundation.Locale.Region {
    get { Locale.Region("CV") }
  }
  @_alwaysEmitIntoClient public static var caribbeanNetherlands: Foundation.Locale.Region {
    get { Locale.Region("BQ") }
  }
  @_alwaysEmitIntoClient public static var caymanIslands: Foundation.Locale.Region {
    get { Locale.Region("KY") }
  }
  @_alwaysEmitIntoClient public static var centralAfricanRepublic: Foundation.Locale.Region {
    get { Locale.Region("CF") }
  }
  @_alwaysEmitIntoClient public static var ceutaMelilla: Foundation.Locale.Region {
    get { Locale.Region("EA") }
  }
  @_alwaysEmitIntoClient public static var chad: Foundation.Locale.Region {
    get { Locale.Region("TD") }
  }
  @_alwaysEmitIntoClient public static var chagosArchipelago: Foundation.Locale.Region {
    get { Locale.Region("IO") }
  }
  @_alwaysEmitIntoClient public static var chile: Foundation.Locale.Region {
    get { Locale.Region("CL") }
  }
  @_alwaysEmitIntoClient public static var chinaMainland: Foundation.Locale.Region {
    get { Locale.Region("CN") }
  }
  @_alwaysEmitIntoClient public static var christmasIsland: Foundation.Locale.Region {
    get { Locale.Region("CX") }
  }
  @_alwaysEmitIntoClient public static var clippertonIsland: Foundation.Locale.Region {
    get { Locale.Region("CP") }
  }
  @_alwaysEmitIntoClient public static var cocosIslands: Foundation.Locale.Region {
    get { Locale.Region("CC") }
  }
  @_alwaysEmitIntoClient public static var colombia: Foundation.Locale.Region {
    get { Locale.Region("CO") }
  }
  @_alwaysEmitIntoClient public static var comoros: Foundation.Locale.Region {
    get { Locale.Region("KM") }
  }
  @_alwaysEmitIntoClient public static var congoBrazzaville: Foundation.Locale.Region {
    get { Locale.Region("CG") }
  }
  @_alwaysEmitIntoClient public static var congoKinshasa: Foundation.Locale.Region {
    get { Locale.Region("CD") }
  }
  @_alwaysEmitIntoClient public static var cookIslands: Foundation.Locale.Region {
    get { Locale.Region("CK") }
  }
  @_alwaysEmitIntoClient public static var costaRica: Foundation.Locale.Region {
    get { Locale.Region("CR") }
  }
  @_alwaysEmitIntoClient public static var côteDIvoire: Foundation.Locale.Region {
    get { Locale.Region("CI") }
  }
  @_alwaysEmitIntoClient public static var croatia: Foundation.Locale.Region {
    get { Locale.Region("HR") }
  }
  @_alwaysEmitIntoClient public static var cuba: Foundation.Locale.Region {
    get { Locale.Region("CU") }
  }
  @_alwaysEmitIntoClient public static var curaçao: Foundation.Locale.Region {
    get { Locale.Region("CW") }
  }
  @_alwaysEmitIntoClient public static var cyprus: Foundation.Locale.Region {
    get { Locale.Region("CY") }
  }
  @_alwaysEmitIntoClient public static var czechia: Foundation.Locale.Region {
    get { Locale.Region("CZ") }
  }
  @_alwaysEmitIntoClient public static var denmark: Foundation.Locale.Region {
    get { Locale.Region("DK") }
  }
  @_alwaysEmitIntoClient public static var diegoGarcia: Foundation.Locale.Region {
    get { Locale.Region("DG") }
  }
  @_alwaysEmitIntoClient public static var djibouti: Foundation.Locale.Region {
    get { Locale.Region("DJ") }
  }
  @_alwaysEmitIntoClient public static var dominica: Foundation.Locale.Region {
    get { Locale.Region("DM") }
  }
  @_alwaysEmitIntoClient public static var dominicanRepublic: Foundation.Locale.Region {
    get { Locale.Region("DO") }
  }
  @_alwaysEmitIntoClient public static var ecuador: Foundation.Locale.Region {
    get { Locale.Region("EC") }
  }
  @_alwaysEmitIntoClient public static var egypt: Foundation.Locale.Region {
    get { Locale.Region("EG") }
  }
  @_alwaysEmitIntoClient public static var elSalvador: Foundation.Locale.Region {
    get { Locale.Region("SV") }
  }
  @_alwaysEmitIntoClient public static var equatorialGuinea: Foundation.Locale.Region {
    get { Locale.Region("GQ") }
  }
  @_alwaysEmitIntoClient public static var eritrea: Foundation.Locale.Region {
    get { Locale.Region("ER") }
  }
  @_alwaysEmitIntoClient public static var estonia: Foundation.Locale.Region {
    get { Locale.Region("EE") }
  }
  @_alwaysEmitIntoClient public static var eswatini: Foundation.Locale.Region {
    get { Locale.Region("SZ") }
  }
  @_alwaysEmitIntoClient public static var ethiopia: Foundation.Locale.Region {
    get { Locale.Region("ET") }
  }
  @_alwaysEmitIntoClient public static var falklandIslands: Foundation.Locale.Region {
    get { Locale.Region("FK") }
  }
  @_alwaysEmitIntoClient public static var faroeIslands: Foundation.Locale.Region {
    get { Locale.Region("FO") }
  }
  @_alwaysEmitIntoClient public static var fiji: Foundation.Locale.Region {
    get { Locale.Region("FJ") }
  }
  @_alwaysEmitIntoClient public static var finland: Foundation.Locale.Region {
    get { Locale.Region("FI") }
  }
  @_alwaysEmitIntoClient public static var france: Foundation.Locale.Region {
    get { Locale.Region("FR") }
  }
  @_alwaysEmitIntoClient public static var frenchGuiana: Foundation.Locale.Region {
    get { Locale.Region("GF") }
  }
  @_alwaysEmitIntoClient public static var frenchPolynesia: Foundation.Locale.Region {
    get { Locale.Region("PF") }
  }
  @_alwaysEmitIntoClient public static var frenchSouthernTerritories: Foundation.Locale.Region {
    get { Locale.Region("TF") }
  }
  @_alwaysEmitIntoClient public static var gabon: Foundation.Locale.Region {
    get { Locale.Region("GA") }
  }
  @_alwaysEmitIntoClient public static var gambia: Foundation.Locale.Region {
    get { Locale.Region("GM") }
  }
  @_alwaysEmitIntoClient public static var georgia: Foundation.Locale.Region {
    get { Locale.Region("GE") }
  }
  @_alwaysEmitIntoClient public static var germany: Foundation.Locale.Region {
    get { Locale.Region("DE") }
  }
  @_alwaysEmitIntoClient public static var ghana: Foundation.Locale.Region {
    get { Locale.Region("GH") }
  }
  @_alwaysEmitIntoClient public static var gibraltar: Foundation.Locale.Region {
    get { Locale.Region("GI") }
  }
  @_alwaysEmitIntoClient public static var greece: Foundation.Locale.Region {
    get { Locale.Region("GR") }
  }
  @_alwaysEmitIntoClient public static var greenland: Foundation.Locale.Region {
    get { Locale.Region("GL") }
  }
  @_alwaysEmitIntoClient public static var grenada: Foundation.Locale.Region {
    get { Locale.Region("GD") }
  }
  @_alwaysEmitIntoClient public static var guadeloupe: Foundation.Locale.Region {
    get { Locale.Region("GP") }
  }
  @_alwaysEmitIntoClient public static var guam: Foundation.Locale.Region {
    get { Locale.Region("GU") }
  }
  @_alwaysEmitIntoClient public static var guatemala: Foundation.Locale.Region {
    get { Locale.Region("GT") }
  }
  @_alwaysEmitIntoClient public static var guernsey: Foundation.Locale.Region {
    get { Locale.Region("GG") }
  }
  @_alwaysEmitIntoClient public static var guinea: Foundation.Locale.Region {
    get { Locale.Region("GN") }
  }
  @_alwaysEmitIntoClient public static var guineaBissau: Foundation.Locale.Region {
    get { Locale.Region("GW") }
  }
  @_alwaysEmitIntoClient public static var guyana: Foundation.Locale.Region {
    get { Locale.Region("GY") }
  }
  @_alwaysEmitIntoClient public static var haiti: Foundation.Locale.Region {
    get { Locale.Region("HT") }
  }
  @_alwaysEmitIntoClient public static var heardMcdonaldIslands: Foundation.Locale.Region {
    get { Locale.Region("HM") }
  }
  @_alwaysEmitIntoClient public static var honduras: Foundation.Locale.Region {
    get { Locale.Region("HN") }
  }
  @_alwaysEmitIntoClient public static var hongKong: Foundation.Locale.Region {
    get { Locale.Region("HK") }
  }
  @_alwaysEmitIntoClient public static var hungary: Foundation.Locale.Region {
    get { Locale.Region("HU") }
  }
  @_alwaysEmitIntoClient public static var iceland: Foundation.Locale.Region {
    get { Locale.Region("IS") }
  }
  @_alwaysEmitIntoClient public static var india: Foundation.Locale.Region {
    get { Locale.Region("IN") }
  }
  @_alwaysEmitIntoClient public static var indonesia: Foundation.Locale.Region {
    get { Locale.Region("ID") }
  }
  @_alwaysEmitIntoClient public static var iran: Foundation.Locale.Region {
    get { Locale.Region("IR") }
  }
  @_alwaysEmitIntoClient public static var iraq: Foundation.Locale.Region {
    get { Locale.Region("IQ") }
  }
  @_alwaysEmitIntoClient public static var ireland: Foundation.Locale.Region {
    get { Locale.Region("IE") }
  }
  @_alwaysEmitIntoClient public static var isleOfMan: Foundation.Locale.Region {
    get { Locale.Region("IM") }
  }
  @_alwaysEmitIntoClient public static var israel: Foundation.Locale.Region {
    get { Locale.Region("IL") }
  }
  @_alwaysEmitIntoClient public static var italy: Foundation.Locale.Region {
    get { Locale.Region("IT") }
  }
  @_alwaysEmitIntoClient public static var jamaica: Foundation.Locale.Region {
    get { Locale.Region("JM") }
  }
  @_alwaysEmitIntoClient public static var japan: Foundation.Locale.Region {
    get { Locale.Region("JP") }
  }
  @_alwaysEmitIntoClient public static var jersey: Foundation.Locale.Region {
    get { Locale.Region("JE") }
  }
  @_alwaysEmitIntoClient public static var jordan: Foundation.Locale.Region {
    get { Locale.Region("JO") }
  }
  @_alwaysEmitIntoClient public static var kazakhstan: Foundation.Locale.Region {
    get { Locale.Region("KZ") }
  }
  @_alwaysEmitIntoClient public static var kenya: Foundation.Locale.Region {
    get { Locale.Region("KE") }
  }
  @_alwaysEmitIntoClient public static var kiribati: Foundation.Locale.Region {
    get { Locale.Region("KI") }
  }
  @_alwaysEmitIntoClient public static var kosovo: Foundation.Locale.Region {
    get { Locale.Region("XK") }
  }
  @_alwaysEmitIntoClient public static var kuwait: Foundation.Locale.Region {
    get { Locale.Region("KW") }
  }
  @_alwaysEmitIntoClient public static var kyrgyzstan: Foundation.Locale.Region {
    get { Locale.Region("KG") }
  }
  @_alwaysEmitIntoClient public static var laos: Foundation.Locale.Region {
    get { Locale.Region("LA") }
  }
  @_alwaysEmitIntoClient public static var latvia: Foundation.Locale.Region {
    get { Locale.Region("LV") }
  }
  @_alwaysEmitIntoClient public static var lebanon: Foundation.Locale.Region {
    get { Locale.Region("LB") }
  }
  @_alwaysEmitIntoClient public static var lesotho: Foundation.Locale.Region {
    get { Locale.Region("LS") }
  }
  @_alwaysEmitIntoClient public static var liberia: Foundation.Locale.Region {
    get { Locale.Region("LR") }
  }
  @_alwaysEmitIntoClient public static var libya: Foundation.Locale.Region {
    get { Locale.Region("LY") }
  }
  @_alwaysEmitIntoClient public static var liechtenstein: Foundation.Locale.Region {
    get { Locale.Region("LI") }
  }
  @_alwaysEmitIntoClient public static var lithuania: Foundation.Locale.Region {
    get { Locale.Region("LT") }
  }
  @_alwaysEmitIntoClient public static var luxembourg: Foundation.Locale.Region {
    get { Locale.Region("LU") }
  }
  @_alwaysEmitIntoClient public static var macao: Foundation.Locale.Region {
    get { Locale.Region("MO") }
  }
  @_alwaysEmitIntoClient public static var madagascar: Foundation.Locale.Region {
    get { Locale.Region("MG") }
  }
  @_alwaysEmitIntoClient public static var malawi: Foundation.Locale.Region {
    get { Locale.Region("MW") }
  }
  @_alwaysEmitIntoClient public static var malaysia: Foundation.Locale.Region {
    get { Locale.Region("MY") }
  }
  @_alwaysEmitIntoClient public static var maldives: Foundation.Locale.Region {
    get { Locale.Region("MV") }
  }
  @_alwaysEmitIntoClient public static var mali: Foundation.Locale.Region {
    get { Locale.Region("ML") }
  }
  @_alwaysEmitIntoClient public static var malta: Foundation.Locale.Region {
    get { Locale.Region("MT") }
  }
  @_alwaysEmitIntoClient public static var marshallIslands: Foundation.Locale.Region {
    get { Locale.Region("MH") }
  }
  @_alwaysEmitIntoClient public static var martinique: Foundation.Locale.Region {
    get { Locale.Region("MQ") }
  }
  @_alwaysEmitIntoClient public static var mauritania: Foundation.Locale.Region {
    get { Locale.Region("MR") }
  }
  @_alwaysEmitIntoClient public static var mauritius: Foundation.Locale.Region {
    get { Locale.Region("MU") }
  }
  @_alwaysEmitIntoClient public static var mayotte: Foundation.Locale.Region {
    get { Locale.Region("YT") }
  }
  @_alwaysEmitIntoClient public static var mexico: Foundation.Locale.Region {
    get { Locale.Region("MX") }
  }
  @_alwaysEmitIntoClient public static var micronesia: Foundation.Locale.Region {
    get { Locale.Region("FM") }
  }
  @_alwaysEmitIntoClient public static var moldova: Foundation.Locale.Region {
    get { Locale.Region("MD") }
  }
  @_alwaysEmitIntoClient public static var monaco: Foundation.Locale.Region {
    get { Locale.Region("MC") }
  }
  @_alwaysEmitIntoClient public static var mongolia: Foundation.Locale.Region {
    get { Locale.Region("MN") }
  }
  @_alwaysEmitIntoClient public static var montenegro: Foundation.Locale.Region {
    get { Locale.Region("ME") }
  }
  @_alwaysEmitIntoClient public static var montserrat: Foundation.Locale.Region {
    get { Locale.Region("MS") }
  }
  @_alwaysEmitIntoClient public static var morocco: Foundation.Locale.Region {
    get { Locale.Region("MA") }
  }
  @_alwaysEmitIntoClient public static var mozambique: Foundation.Locale.Region {
    get { Locale.Region("MZ") }
  }
  @_alwaysEmitIntoClient public static var myanmar: Foundation.Locale.Region {
    get { Locale.Region("MM") }
  }
  @_alwaysEmitIntoClient public static var namibia: Foundation.Locale.Region {
    get { Locale.Region("NA") }
  }
  @_alwaysEmitIntoClient public static var nauru: Foundation.Locale.Region {
    get { Locale.Region("NR") }
  }
  @_alwaysEmitIntoClient public static var nepal: Foundation.Locale.Region {
    get { Locale.Region("NP") }
  }
  @_alwaysEmitIntoClient public static var netherlands: Foundation.Locale.Region {
    get { Locale.Region("NL") }
  }
  @_alwaysEmitIntoClient public static var newCaledonia: Foundation.Locale.Region {
    get { Locale.Region("NC") }
  }
  @_alwaysEmitIntoClient public static var newZealand: Foundation.Locale.Region {
    get { Locale.Region("NZ") }
  }
  @_alwaysEmitIntoClient public static var nicaragua: Foundation.Locale.Region {
    get { Locale.Region("NI") }
  }
  @_alwaysEmitIntoClient public static var niger: Foundation.Locale.Region {
    get { Locale.Region("NE") }
  }
  @_alwaysEmitIntoClient public static var nigeria: Foundation.Locale.Region {
    get { Locale.Region("NG") }
  }
  @_alwaysEmitIntoClient public static var niue: Foundation.Locale.Region {
    get { Locale.Region("NU") }
  }
  @_alwaysEmitIntoClient public static var norfolkIsland: Foundation.Locale.Region {
    get { Locale.Region("NF") }
  }
  @_alwaysEmitIntoClient public static var northernMarianaIslands: Foundation.Locale.Region {
    get { Locale.Region("MP") }
  }
  @_alwaysEmitIntoClient public static var northMacedonia: Foundation.Locale.Region {
    get { Locale.Region("MK") }
  }
  @_alwaysEmitIntoClient public static var norway: Foundation.Locale.Region {
    get { Locale.Region("NO") }
  }
  @_alwaysEmitIntoClient public static var oman: Foundation.Locale.Region {
    get { Locale.Region("OM") }
  }
  @_alwaysEmitIntoClient public static var pakistan: Foundation.Locale.Region {
    get { Locale.Region("PK") }
  }
  @_alwaysEmitIntoClient public static var palau: Foundation.Locale.Region {
    get { Locale.Region("PW") }
  }
  @_alwaysEmitIntoClient public static var palestinianTerritories: Foundation.Locale.Region {
    get { Locale.Region("PS") }
  }
  @_alwaysEmitIntoClient public static var panama: Foundation.Locale.Region {
    get { Locale.Region("PA") }
  }
  @_alwaysEmitIntoClient public static var papuaNewGuinea: Foundation.Locale.Region {
    get { Locale.Region("PG") }
  }
  @_alwaysEmitIntoClient public static var paraguay: Foundation.Locale.Region {
    get { Locale.Region("PY") }
  }
  @_alwaysEmitIntoClient public static var peru: Foundation.Locale.Region {
    get { Locale.Region("PE") }
  }
  @_alwaysEmitIntoClient public static var philippines: Foundation.Locale.Region {
    get { Locale.Region("PH") }
  }
  @_alwaysEmitIntoClient public static var pitcairnIslands: Foundation.Locale.Region {
    get { Locale.Region("PN") }
  }
  @_alwaysEmitIntoClient public static var poland: Foundation.Locale.Region {
    get { Locale.Region("PL") }
  }
  @_alwaysEmitIntoClient public static var portugal: Foundation.Locale.Region {
    get { Locale.Region("PT") }
  }
  @_alwaysEmitIntoClient public static var puertoRico: Foundation.Locale.Region {
    get { Locale.Region("PR") }
  }
  @_alwaysEmitIntoClient public static var qatar: Foundation.Locale.Region {
    get { Locale.Region("QA") }
  }
  @_alwaysEmitIntoClient public static var réunion: Foundation.Locale.Region {
    get { Locale.Region("RE") }
  }
  @_alwaysEmitIntoClient public static var romania: Foundation.Locale.Region {
    get { Locale.Region("RO") }
  }
  @_alwaysEmitIntoClient public static var russia: Foundation.Locale.Region {
    get { Locale.Region("RU") }
  }
  @_alwaysEmitIntoClient public static var rwanda: Foundation.Locale.Region {
    get { Locale.Region("RW") }
  }
  @_alwaysEmitIntoClient public static var saintBarthélemy: Foundation.Locale.Region {
    get { Locale.Region("BL") }
  }
  @_alwaysEmitIntoClient public static var saintHelena: Foundation.Locale.Region {
    get { Locale.Region("SH") }
  }
  @_alwaysEmitIntoClient public static var saintKittsNevis: Foundation.Locale.Region {
    get { Locale.Region("KN") }
  }
  @_alwaysEmitIntoClient public static var saintLucia: Foundation.Locale.Region {
    get { Locale.Region("LC") }
  }
  @_alwaysEmitIntoClient public static var saintMartin: Foundation.Locale.Region {
    get { Locale.Region("MF") }
  }
  @_alwaysEmitIntoClient public static var saintPierreMiquelon: Foundation.Locale.Region {
    get { Locale.Region("PM") }
  }
  @_alwaysEmitIntoClient public static var saintVincentGrenadines: Foundation.Locale.Region {
    get { Locale.Region("VC") }
  }
  @_alwaysEmitIntoClient public static var samoa: Foundation.Locale.Region {
    get { Locale.Region("WS") }
  }
  @_alwaysEmitIntoClient public static var sanMarino: Foundation.Locale.Region {
    get { Locale.Region("SM") }
  }
  @_alwaysEmitIntoClient public static var sãoToméPríncipe: Foundation.Locale.Region {
    get { Locale.Region("ST") }
  }
  @_alwaysEmitIntoClient public static var saudiArabia: Foundation.Locale.Region {
    get { Locale.Region("SA") }
  }
  @_alwaysEmitIntoClient public static var senegal: Foundation.Locale.Region {
    get { Locale.Region("SN") }
  }
  @_alwaysEmitIntoClient public static var serbia: Foundation.Locale.Region {
    get { Locale.Region("RS") }
  }
  @_alwaysEmitIntoClient public static var seychelles: Foundation.Locale.Region {
    get { Locale.Region("SC") }
  }
  @_alwaysEmitIntoClient public static var sierraLeone: Foundation.Locale.Region {
    get { Locale.Region("SL") }
  }
  @_alwaysEmitIntoClient public static var singapore: Foundation.Locale.Region {
    get { Locale.Region("SG") }
  }
  @_alwaysEmitIntoClient public static var sintMaarten: Foundation.Locale.Region {
    get { Locale.Region("SX") }
  }
  @_alwaysEmitIntoClient public static var slovakia: Foundation.Locale.Region {
    get { Locale.Region("SK") }
  }
  @_alwaysEmitIntoClient public static var slovenia: Foundation.Locale.Region {
    get { Locale.Region("SI") }
  }
  @_alwaysEmitIntoClient public static var solomonIslands: Foundation.Locale.Region {
    get { Locale.Region("SB") }
  }
  @_alwaysEmitIntoClient public static var somalia: Foundation.Locale.Region {
    get { Locale.Region("SO") }
  }
  @_alwaysEmitIntoClient public static var southAfrica: Foundation.Locale.Region {
    get { Locale.Region("ZA") }
  }
  @_alwaysEmitIntoClient public static var southGeorgiaSouthSandwichIslands: Foundation.Locale.Region {
    get { Locale.Region("GS") }
  }
  @_alwaysEmitIntoClient public static var southKorea: Foundation.Locale.Region {
    get { Locale.Region("KR") }
  }
  @_alwaysEmitIntoClient public static var southSudan: Foundation.Locale.Region {
    get { Locale.Region("SS") }
  }
  @_alwaysEmitIntoClient public static var spain: Foundation.Locale.Region {
    get { Locale.Region("ES") }
  }
  @_alwaysEmitIntoClient public static var sriLanka: Foundation.Locale.Region {
    get { Locale.Region("LK") }
  }
  @_alwaysEmitIntoClient public static var suriname: Foundation.Locale.Region {
    get { Locale.Region("SR") }
  }
  @_alwaysEmitIntoClient public static var svalbardJanMayen: Foundation.Locale.Region {
    get { Locale.Region("SJ") }
  }
  @_alwaysEmitIntoClient public static var sweden: Foundation.Locale.Region {
    get { Locale.Region("SE") }
  }
  @_alwaysEmitIntoClient public static var switzerland: Foundation.Locale.Region {
    get { Locale.Region("CH") }
  }
  @_alwaysEmitIntoClient public static var taiwan: Foundation.Locale.Region {
    get { Locale.Region("TW") }
  }
  @_alwaysEmitIntoClient public static var tajikistan: Foundation.Locale.Region {
    get { Locale.Region("TJ") }
  }
  @_alwaysEmitIntoClient public static var tanzania: Foundation.Locale.Region {
    get { Locale.Region("TZ") }
  }
  @_alwaysEmitIntoClient public static var thailand: Foundation.Locale.Region {
    get { Locale.Region("TH") }
  }
  @_alwaysEmitIntoClient public static var timorLeste: Foundation.Locale.Region {
    get { Locale.Region("TL") }
  }
  @_alwaysEmitIntoClient public static var togo: Foundation.Locale.Region {
    get { Locale.Region("TG") }
  }
  @_alwaysEmitIntoClient public static var tokelau: Foundation.Locale.Region {
    get { Locale.Region("TK") }
  }
  @_alwaysEmitIntoClient public static var tonga: Foundation.Locale.Region {
    get { Locale.Region("TO") }
  }
  @_alwaysEmitIntoClient public static var trinidadTobago: Foundation.Locale.Region {
    get { Locale.Region("TT") }
  }
  @_alwaysEmitIntoClient public static var tristanDaCunha: Foundation.Locale.Region {
    get { Locale.Region("TA") }
  }
  @_alwaysEmitIntoClient public static var tunisia: Foundation.Locale.Region {
    get { Locale.Region("TN") }
  }
  @_alwaysEmitIntoClient public static var turkey: Foundation.Locale.Region {
    get { Locale.Region("TR") }
  }
  @_alwaysEmitIntoClient public static var turkmenistan: Foundation.Locale.Region {
    get { Locale.Region("TM") }
  }
  @_alwaysEmitIntoClient public static var turksCaicosIslands: Foundation.Locale.Region {
    get { Locale.Region("TC") }
  }
  @_alwaysEmitIntoClient public static var tuvalu: Foundation.Locale.Region {
    get { Locale.Region("TV") }
  }
  @_alwaysEmitIntoClient public static var uganda: Foundation.Locale.Region {
    get { Locale.Region("UG") }
  }
  @_alwaysEmitIntoClient public static var ukraine: Foundation.Locale.Region {
    get { Locale.Region("UA") }
  }
  @_alwaysEmitIntoClient public static var unitedArabEmirates: Foundation.Locale.Region {
    get { Locale.Region("AE") }
  }
  @_alwaysEmitIntoClient public static var unitedKingdom: Foundation.Locale.Region {
    get { Locale.Region("GB") }
  }
  @_alwaysEmitIntoClient public static var unitedStates: Foundation.Locale.Region {
    get { Locale.Region("US") }
  }
  @_alwaysEmitIntoClient public static var unitedStatesOutlyingIslands: Foundation.Locale.Region {
    get { Locale.Region("UM") }
  }
  @_alwaysEmitIntoClient public static var unitedStatesVirginIslands: Foundation.Locale.Region {
    get { Locale.Region("VI") }
  }
  @_alwaysEmitIntoClient public static var uruguay: Foundation.Locale.Region {
    get { Locale.Region("UY") }
  }
  @_alwaysEmitIntoClient public static var uzbekistan: Foundation.Locale.Region {
    get { Locale.Region("UZ") }
  }
  @_alwaysEmitIntoClient public static var vanuatu: Foundation.Locale.Region {
    get { Locale.Region("VU") }
  }
  @_alwaysEmitIntoClient public static var vaticanCity: Foundation.Locale.Region {
    get { Locale.Region("VA") }
  }
  @_alwaysEmitIntoClient public static var venezuela: Foundation.Locale.Region {
    get { Locale.Region("VE") }
  }
  @_alwaysEmitIntoClient public static var vietnam: Foundation.Locale.Region {
    get { Locale.Region("VN") }
  }
  @_alwaysEmitIntoClient public static var wallisFutuna: Foundation.Locale.Region {
    get { Locale.Region("WF") }
  }
  @_alwaysEmitIntoClient public static var westernSahara: Foundation.Locale.Region {
    get { Locale.Region("EH") }
  }
  @_alwaysEmitIntoClient public static var yemen: Foundation.Locale.Region {
    get { Locale.Region("YE") }
  }
  @_alwaysEmitIntoClient public static var zambia: Foundation.Locale.Region {
    get { Locale.Region("ZM") }
  }
  @_alwaysEmitIntoClient public static var zimbabwe: Foundation.Locale.Region {
    get { Locale.Region("ZW") }
  }
  @_alwaysEmitIntoClient public static var world: Foundation.Locale.Region {
    get { Locale.Region("001") }
  }
  @_alwaysEmitIntoClient public static var latinAmerica: Foundation.Locale.Region {
    get { Locale.Region("419") }
  }
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.Script {
  @_alwaysEmitIntoClient public static var adlam: Foundation.Locale.Script {
    get { Locale.Script("Adlm") }
  }
  @_alwaysEmitIntoClient public static var arabic: Foundation.Locale.Script {
    get { Locale.Script("Arab") }
  }
  @_alwaysEmitIntoClient public static var arabicNastaliq: Foundation.Locale.Script {
    get { Locale.Script("Aran") }
  }
  @_alwaysEmitIntoClient public static var armenian: Foundation.Locale.Script {
    get { Locale.Script("Armn") }
  }
  @_alwaysEmitIntoClient public static var bangla: Foundation.Locale.Script {
    get { Locale.Script("Beng") }
  }
  @_alwaysEmitIntoClient public static var cherokee: Foundation.Locale.Script {
    get { Locale.Script("Cher") }
  }
  @_alwaysEmitIntoClient public static var cyrillic: Foundation.Locale.Script {
    get { Locale.Script("Cyrl") }
  }
  @_alwaysEmitIntoClient public static var devanagari: Foundation.Locale.Script {
    get { Locale.Script("Deva") }
  }
  @_alwaysEmitIntoClient public static var ethiopic: Foundation.Locale.Script {
    get { Locale.Script("Ethi") }
  }
  @_alwaysEmitIntoClient public static var georgian: Foundation.Locale.Script {
    get { Locale.Script("Geor") }
  }
  @_alwaysEmitIntoClient public static var greek: Foundation.Locale.Script {
    get { Locale.Script("Grek") }
  }
  @_alwaysEmitIntoClient public static var gujarati: Foundation.Locale.Script {
    get { Locale.Script("Gujr") }
  }
  @_alwaysEmitIntoClient public static var gurmukhi: Foundation.Locale.Script {
    get { Locale.Script("Guru") }
  }
  @_alwaysEmitIntoClient public static var hanifiRohingya: Foundation.Locale.Script {
    get { Locale.Script("Rohg") }
  }
  @_alwaysEmitIntoClient public static var hanSimplified: Foundation.Locale.Script {
    get { Locale.Script("Hans") }
  }
  @_alwaysEmitIntoClient public static var hanTraditional: Foundation.Locale.Script {
    get { Locale.Script("Hant") }
  }
  @_alwaysEmitIntoClient public static var hebrew: Foundation.Locale.Script {
    get { Locale.Script("Hebr") }
  }
  @_alwaysEmitIntoClient public static var hiragana: Foundation.Locale.Script {
    get { Locale.Script("Hira") }
  }
  @_alwaysEmitIntoClient public static var japanese: Foundation.Locale.Script {
    get { Locale.Script("Jpan") }
  }
  @_alwaysEmitIntoClient public static var kannada: Foundation.Locale.Script {
    get { Locale.Script("Knda") }
  }
  @_alwaysEmitIntoClient public static var katakana: Foundation.Locale.Script {
    get { Locale.Script("Kana") }
  }
  @_alwaysEmitIntoClient public static var khmer: Foundation.Locale.Script {
    get { Locale.Script("Khmr") }
  }
  @_alwaysEmitIntoClient public static var korean: Foundation.Locale.Script {
    get { Locale.Script("Kore") }
  }
  @_alwaysEmitIntoClient public static var lao: Foundation.Locale.Script {
    get { Locale.Script("Laoo") }
  }
  @_alwaysEmitIntoClient public static var latin: Foundation.Locale.Script {
    get { Locale.Script("Latn") }
  }
  @_alwaysEmitIntoClient public static var malayalam: Foundation.Locale.Script {
    get { Locale.Script("Mlym") }
  }
  @_alwaysEmitIntoClient public static var meiteiMayek: Foundation.Locale.Script {
    get { Locale.Script("Mtei") }
  }
  @_alwaysEmitIntoClient public static var myanmar: Foundation.Locale.Script {
    get { Locale.Script("Mymr") }
  }
  @_alwaysEmitIntoClient public static var odia: Foundation.Locale.Script {
    get { Locale.Script("Orya") }
  }
  @_alwaysEmitIntoClient public static var olChiki: Foundation.Locale.Script {
    get { Locale.Script("Olck") }
  }
  @_alwaysEmitIntoClient public static var sinhala: Foundation.Locale.Script {
    get { Locale.Script("Sinh") }
  }
  @_alwaysEmitIntoClient public static var syriac: Foundation.Locale.Script {
    get { Locale.Script("Syrc") }
  }
  @_alwaysEmitIntoClient public static var tamil: Foundation.Locale.Script {
    get { Locale.Script("Taml") }
  }
  @_alwaysEmitIntoClient public static var telugu: Foundation.Locale.Script {
    get { Locale.Script("Telu") }
  }
  @_alwaysEmitIntoClient public static var thaana: Foundation.Locale.Script {
    get { Locale.Script("Thaa") }
  }
  @_alwaysEmitIntoClient public static var thai: Foundation.Locale.Script {
    get { Locale.Script("Thai") }
  }
  @_alwaysEmitIntoClient public static var tibetan: Foundation.Locale.Script {
    get { Locale.Script("Tibt") }
  }
}
extension Foundation.Locale {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct Language : Swift.Hashable, Swift.Codable, Swift.Sendable {
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct Components : Swift.Hashable, Swift.Codable, Swift.Sendable {
      public var languageCode: Foundation.Locale.LanguageCode?
      public var script: Foundation.Locale.Script?
      public var region: Foundation.Locale.Region?
      public init(languageCode: Foundation.Locale.LanguageCode? = nil, script: Foundation.Locale.Script? = nil, region: Foundation.Locale.Region? = nil)
      public static func == (a: Foundation.Locale.Language.Components, b: Foundation.Locale.Language.Components) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public init(components: Foundation.Locale.Language.Components)
    public init(languageCode: Foundation.Locale.LanguageCode? = nil, script: Foundation.Locale.Script? = nil, region: Foundation.Locale.Region? = nil)
    public static var systemLanguages: [Foundation.Locale.Language] {
      get
    }
    public static func == (a: Foundation.Locale.Language, b: Foundation.Locale.Language) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Swift.KeyedEncodingContainer {
  public mutating func encodePredicateExpression<T, each Input>(_ expression: T, forKey key: Swift.KeyedEncodingContainer<K>.Key, variable: repeat Foundation.PredicateExpressions.Variable<each Input>, predicateConfiguration: Foundation.PredicateCodableConfiguration) throws where T : Foundation.PredicateExpression, T : Swift.Encodable, T.Output == Swift.Bool
  public mutating func encodePredicateExpressionIfPresent<T, each Input>(_ expression: T?, forKey key: Swift.KeyedEncodingContainer<K>.Key, variable: repeat Foundation.PredicateExpressions.Variable<each Input>, predicateConfiguration: Foundation.PredicateCodableConfiguration) throws where T : Foundation.PredicateExpression, T : Swift.Encodable, T.Output == Swift.Bool
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Swift.KeyedDecodingContainer {
  @_optimize(none) public mutating func decodePredicateExpression<each Input>(forKey key: Swift.KeyedDecodingContainer<K>.Key, input: repeat (each Input).Type, predicateConfiguration: Foundation.PredicateCodableConfiguration) throws -> (expression: any Foundation.PredicateExpression<Swift.Bool>, variable: (repeat Foundation.PredicateExpressions.Variable<each Input>))
  public mutating func decodePredicateExpressionIfPresent<each Input>(forKey key: Swift.KeyedDecodingContainer<K>.Key, input: repeat (each Input).Type, predicateConfiguration: Foundation.PredicateCodableConfiguration) throws -> (expression: any Foundation.PredicateExpression<Swift.Bool>, variable: (repeat Foundation.PredicateExpressions.Variable<each Input>))?
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Swift.UnkeyedEncodingContainer {
  public mutating func encodePredicateExpression<T, each Input>(_ expression: T, variable: repeat Foundation.PredicateExpressions.Variable<each Input>, predicateConfiguration: Foundation.PredicateCodableConfiguration) throws where T : Foundation.PredicateExpression, T : Swift.Encodable, T.Output == Swift.Bool
  public mutating func encodePredicateExpressionIfPresent<T, each Input>(_ expression: T?, variable: repeat Foundation.PredicateExpressions.Variable<each Input>, predicateConfiguration: Foundation.PredicateCodableConfiguration) throws where T : Foundation.PredicateExpression, T : Swift.Encodable, T.Output == Swift.Bool
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Swift.UnkeyedDecodingContainer {
  @_optimize(none) public mutating func decodePredicateExpression<each Input>(input: repeat (each Input).Type, predicateConfiguration: Foundation.PredicateCodableConfiguration) throws -> (expression: any Foundation.PredicateExpression<Swift.Bool>, variable: (repeat Foundation.PredicateExpressions.Variable<each Input>))
  public mutating func decodePredicateExpressionIfPresent<each Input>(input: repeat (each Input).Type, predicateConfiguration: Foundation.PredicateCodableConfiguration) throws -> (expression: any Foundation.PredicateExpression<Swift.Bool>, variable: (repeat Foundation.PredicateExpressions.Variable<each Input>))?
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Swift.KeyedEncodingContainer {
  @_disfavoredOverload public mutating func encodePredicateExpression<T, each Input>(_ expression: T, forKey key: Swift.KeyedEncodingContainer<K>.Key, variable: repeat Foundation.PredicateExpressions.Variable<each Input>, predicateConfiguration: Foundation.PredicateCodableConfiguration) throws where T : Foundation.PredicateExpression, T : Swift.Encodable
  @_disfavoredOverload public mutating func encodePredicateExpressionIfPresent<T, each Input>(_ expression: T?, forKey key: Swift.KeyedEncodingContainer<K>.Key, variable: repeat Foundation.PredicateExpressions.Variable<each Input>, predicateConfiguration: Foundation.PredicateCodableConfiguration) throws where T : Foundation.PredicateExpression, T : Swift.Encodable
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Swift.KeyedDecodingContainer {
  public mutating func decodePredicateExpression<each Input, Output>(forKey key: Swift.KeyedDecodingContainer<K>.Key, input: repeat (each Input).Type, output: Output.Type, predicateConfiguration: Foundation.PredicateCodableConfiguration) throws -> (expression: any Foundation.PredicateExpression<Output>, variable: (repeat Foundation.PredicateExpressions.Variable<each Input>))
  public mutating func decodePredicateExpressionIfPresent<each Input, Output>(forKey key: Swift.KeyedDecodingContainer<K>.Key, input: repeat (each Input).Type, output: Output.Type, predicateConfiguration: Foundation.PredicateCodableConfiguration) throws -> (expression: any Foundation.PredicateExpression<Output>, variable: (repeat Foundation.PredicateExpressions.Variable<each Input>))?
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Swift.UnkeyedEncodingContainer {
  @_disfavoredOverload public mutating func encodePredicateExpression<T, each Input>(_ expression: T, variable: repeat Foundation.PredicateExpressions.Variable<each Input>, predicateConfiguration: Foundation.PredicateCodableConfiguration) throws where T : Foundation.PredicateExpression, T : Swift.Encodable
  @_disfavoredOverload public mutating func encodePredicateExpressionIfPresent<T, each Input>(_ expression: T?, variable: repeat Foundation.PredicateExpressions.Variable<each Input>, predicateConfiguration: Foundation.PredicateCodableConfiguration) throws where T : Foundation.PredicateExpression, T : Swift.Encodable
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Swift.UnkeyedDecodingContainer {
  public mutating func decodePredicateExpression<each Input, Output>(input: repeat (each Input).Type, output: Output.Type, predicateConfiguration: Foundation.PredicateCodableConfiguration) throws -> (expression: any Foundation.PredicateExpression<Output>, variable: (repeat Foundation.PredicateExpressions.Variable<each Input>))
  public mutating func decodePredicateExpressionIfPresent<each Input, Output>(input: repeat (each Input).Type, output: Output.Type, predicateConfiguration: Foundation.PredicateCodableConfiguration) throws -> (expression: any Foundation.PredicateExpression<Output>, variable: (repeat Foundation.PredicateExpressions.Variable<each Input>))?
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Predicate : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Expression : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Predicate : Foundation.CodableWithConfiguration {
  public typealias EncodingConfiguration = Foundation.PredicateCodableConfiguration
  public typealias DecodingConfiguration = Foundation.PredicateCodableConfiguration
  public func encode(to encoder: any Swift.Encoder, configuration: Foundation.Predicate<repeat each Input>.EncodingConfiguration) throws
  public init(from decoder: any Swift.Decoder, configuration: Foundation.Predicate<repeat each Input>.DecodingConfiguration) throws
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Expression : Foundation.CodableWithConfiguration {
  public typealias EncodingConfiguration = Foundation.PredicateCodableConfiguration
  public typealias DecodingConfiguration = Foundation.PredicateCodableConfiguration
  public func encode(to encoder: any Swift.Encoder, configuration: Foundation.Expression<repeat each Input, Output>.EncodingConfiguration) throws
  public init(from decoder: any Swift.Decoder, configuration: Foundation.Expression<repeat each Input, Output>.DecodingConfiguration) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol PredicateCodableKeyPathProviding {
  @preconcurrency static var predicateCodableKeyPaths: [Swift.String : any Swift.PartialKeyPath<Self> & Swift.Sendable] { get }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public struct PredicateCodableConfiguration : Swift.Sendable, Swift.CustomDebugStringConvertible {
  public init()
  public var debugDescription: Swift.String {
    get
  }
  public mutating func allowType(_ type: any Any.Type, identifier: Swift.String? = nil)
  public mutating func disallowType(_ type: any Any.Type)
  public mutating func allowPartialType(_ type: any Any.Type, identifier: Swift.String)
  public mutating func disallowPartialType(_ type: any Any.Type)
  @_alwaysEmitIntoClient public mutating func allowKeyPath(_ keyPath: any Swift.AnyKeyPath & Swift.Sendable, identifier: Swift.String) {
        self.allowKeyPath(keyPath as AnyKeyPath, identifier: identifier)
    }
  @_alwaysEmitIntoClient public mutating func disallowKeyPath(_ keyPath: any Swift.AnyKeyPath & Swift.Sendable) {
        self.disallowKeyPath(keyPath as AnyKeyPath)
    }
  @usableFromInline
  internal mutating func allowKeyPath(_ keyPath: Swift.AnyKeyPath, identifier: Swift.String)
  @usableFromInline
  internal mutating func disallowKeyPath(_ keyPath: Swift.AnyKeyPath)
  public mutating func allowKeyPathsForPropertiesProvided<T>(by type: T.Type, recursive: Swift.Bool = false) where T : Foundation.PredicateCodableKeyPathProviding
  public mutating func disallowKeyPathsForPropertiesProvided<T>(by type: T.Type, recursive: Swift.Bool = false) where T : Foundation.PredicateCodableKeyPathProviding
  public mutating func allow(_ other: Foundation.PredicateCodableConfiguration)
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateCodableConfiguration {
  public static let standardConfiguration: Foundation.PredicateCodableConfiguration
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct SequenceMaximum<Elements> : Foundation.PredicateExpression where Elements : Foundation.PredicateExpression, Elements.Output : Swift.Sequence, Elements.Output.Element : Swift.Comparable {
    public typealias Output = Swift.Optional<Elements.Output.Element>
    public let elements: Elements
    public init(elements: Elements)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.SequenceMaximum<Elements>.Output
  }
  public static func build_max<Elements>(_ elements: Elements) -> Foundation.PredicateExpressions.SequenceMaximum<Elements> where Elements : Foundation.PredicateExpression, Elements.Output : Swift.Sequence, Elements.Output.Element : Swift.Comparable
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceMaximum : Foundation.StandardPredicateExpression where Elements : Foundation.StandardPredicateExpression {
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.SequenceMaximum : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceMaximum : Swift.Codable where Elements : Swift.Decodable, Elements : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceMaximum : Swift.Sendable where Elements : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct SequenceMinimum<Elements> : Foundation.PredicateExpression where Elements : Foundation.PredicateExpression, Elements.Output : Swift.Sequence, Elements.Output.Element : Swift.Comparable {
    public typealias Output = Swift.Optional<Elements.Output.Element>
    public let elements: Elements
    public init(elements: Elements)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.SequenceMinimum<Elements>.Output
  }
  public static func build_min<Elements>(_ elements: Elements) -> Foundation.PredicateExpressions.SequenceMinimum<Elements> where Elements : Foundation.PredicateExpression, Elements.Output : Swift.Sequence, Elements.Output.Element : Swift.Comparable
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceMinimum : Foundation.StandardPredicateExpression where Elements : Foundation.StandardPredicateExpression {
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.SequenceMinimum : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceMinimum : Swift.Codable where Elements : Swift.Decodable, Elements : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceMinimum : Swift.Sendable where Elements : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public enum ArithmeticOperator : Swift.Codable, Swift.Sendable {
    case add, subtract, multiply
    public static func == (a: Foundation.PredicateExpressions.ArithmeticOperator, b: Foundation.PredicateExpressions.ArithmeticOperator) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Arithmetic<LHS, RHS> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Numeric, LHS.Output == RHS.Output {
    public typealias Output = LHS.Output
    public let op: Foundation.PredicateExpressions.ArithmeticOperator
    public let lhs: LHS
    public let rhs: RHS
    public init(lhs: LHS, rhs: RHS, op: Foundation.PredicateExpressions.ArithmeticOperator)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.Arithmetic<LHS, RHS>.Output
  }
  public static func build_Arithmetic<LHS, RHS>(lhs: LHS, rhs: RHS, op: Foundation.PredicateExpressions.ArithmeticOperator) -> Foundation.PredicateExpressions.Arithmetic<LHS, RHS> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Numeric, LHS.Output == RHS.Output
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Arithmetic : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.Arithmetic : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Arithmetic : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Arithmetic : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct CollectionIndexSubscript<Wrapped, Index> : Foundation.PredicateExpression where Wrapped : Foundation.PredicateExpression, Index : Foundation.PredicateExpression, Wrapped.Output : Swift.Collection, Index.Output == Wrapped.Output.Index {
    public typealias Output = Wrapped.Output.Element
    public let wrapped: Wrapped
    public let index: Index
    public init(wrapped: Wrapped, index: Index)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.CollectionIndexSubscript<Wrapped, Index>.Output
  }
  public static func build_subscript<Wrapped, Index>(_ wrapped: Wrapped, _ index: Index) -> Foundation.PredicateExpressions.CollectionIndexSubscript<Wrapped, Index> where Wrapped : Foundation.PredicateExpression, Index : Foundation.PredicateExpression, Wrapped.Output : Swift.Collection, Index.Output == Wrapped.Output.Index
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.CollectionIndexSubscript : Swift.Sendable where Wrapped : Swift.Sendable, Index : Swift.Sendable {
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.CollectionIndexSubscript : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.CollectionIndexSubscript : Swift.Codable where Wrapped : Swift.Decodable, Wrapped : Swift.Encodable, Index : Swift.Decodable, Index : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.CollectionIndexSubscript : Foundation.StandardPredicateExpression where Wrapped : Foundation.StandardPredicateExpression, Index : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct CollectionRangeSubscript<Wrapped, Range> : Foundation.PredicateExpression where Wrapped : Foundation.PredicateExpression, Range : Foundation.PredicateExpression, Wrapped.Output : Swift.Collection, Range.Output == Swift.Range<Wrapped.Output.Index> {
    public typealias Output = Wrapped.Output.SubSequence
    public let wrapped: Wrapped
    public let range: Range
    public init(wrapped: Wrapped, range: Range)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.CollectionRangeSubscript<Wrapped, Range>.Output
  }
  public static func build_subscript<Wrapped, Range>(_ wrapped: Wrapped, _ range: Range) -> Foundation.PredicateExpressions.CollectionRangeSubscript<Wrapped, Range> where Wrapped : Foundation.PredicateExpression, Range : Foundation.PredicateExpression, Wrapped.Output : Swift.Collection, Range.Output == Swift.Range<Wrapped.Output.Index>
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.CollectionRangeSubscript : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.CollectionRangeSubscript : Swift.Sendable where Wrapped : Swift.Sendable, Range : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.CollectionRangeSubscript : Swift.Codable where Wrapped : Swift.Decodable, Wrapped : Swift.Encodable, Range : Swift.Decodable, Range : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.CollectionRangeSubscript : Foundation.StandardPredicateExpression where Wrapped : Foundation.StandardPredicateExpression, Range : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct CollectionContainsCollection<Base, Other> : Foundation.PredicateExpression where Base : Foundation.PredicateExpression, Other : Foundation.PredicateExpression, Base.Output : Swift.Collection, Other.Output : Swift.Collection, Base.Output.Element : Swift.Equatable, Base.Output.Element == Other.Output.Element {
    public typealias Output = Swift.Bool
    public let base: Base
    public let other: Other
    public init(base: Base, other: Other)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Swift.Bool
  }
  public static func build_contains<Base, Other>(_ base: Base, _ other: Other) -> Foundation.PredicateExpressions.CollectionContainsCollection<Base, Other> where Base : Foundation.PredicateExpression, Other : Foundation.PredicateExpression, Base.Output : Swift.Collection, Other.Output : Swift.Collection, Base.Output.Element : Swift.Equatable, Base.Output.Element == Other.Output.Element
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.CollectionContainsCollection : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.CollectionContainsCollection : Swift.Sendable where Base : Swift.Sendable, Other : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.CollectionContainsCollection : Swift.Codable where Base : Swift.Decodable, Base : Swift.Encodable, Other : Swift.Decodable, Other : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.CollectionContainsCollection : Foundation.StandardPredicateExpression where Base : Foundation.StandardPredicateExpression, Other : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public enum ComparisonOperator : Swift.Codable, Swift.Sendable {
    case lessThan, lessThanOrEqual, greaterThan, greaterThanOrEqual
    public static func == (a: Foundation.PredicateExpressions.ComparisonOperator, b: Foundation.PredicateExpressions.ComparisonOperator) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Comparison<LHS, RHS> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Comparable, LHS.Output == RHS.Output {
    public typealias Output = Swift.Bool
    public let op: Foundation.PredicateExpressions.ComparisonOperator
    public let lhs: LHS
    public let rhs: RHS
    public init(lhs: LHS, rhs: RHS, op: Foundation.PredicateExpressions.ComparisonOperator)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Swift.Bool
  }
  public static func build_Comparison<LHS, RHS>(lhs: LHS, rhs: RHS, op: Foundation.PredicateExpressions.ComparisonOperator) -> Foundation.PredicateExpressions.Comparison<LHS, RHS> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Comparable, LHS.Output == RHS.Output
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.Comparison : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Comparison : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Comparison : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Comparison : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct Conditional<Test, If, Else> : Foundation.PredicateExpression where Test : Foundation.PredicateExpression, If : Foundation.PredicateExpression, Else : Foundation.PredicateExpression, Test.Output == Swift.Bool, If.Output == Else.Output {
    public typealias Output = If.Output
    public let test: Test
    public let trueBranch: If
    public let falseBranch: Else
    public init(test: Test, trueBranch: If, falseBranch: Else)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> If.Output
  }
  public static func build_Conditional<Test, If, Else>(_ test: Test, _ trueBranch: If, _ falseBranch: Else) -> Foundation.PredicateExpressions.Conditional<Test, If, Else> where Test : Foundation.PredicateExpression, If : Foundation.PredicateExpression, Else : Foundation.PredicateExpression, Test.Output == Swift.Bool, If.Output == Else.Output
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.Conditional : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Conditional : Foundation.StandardPredicateExpression where Test : Foundation.StandardPredicateExpression, If : Foundation.StandardPredicateExpression, Else : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Conditional : Swift.Codable where Test : Swift.Decodable, Test : Swift.Encodable, If : Swift.Decodable, If : Swift.Encodable, Else : Swift.Decodable, Else : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Conditional : Swift.Sendable where Test : Swift.Sendable, If : Swift.Sendable, Else : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct Conjunction<LHS, RHS> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output == Swift.Bool, RHS.Output == Swift.Bool {
    public typealias Output = Swift.Bool
    public let lhs: LHS
    public let rhs: RHS
    public init(lhs: LHS, rhs: RHS)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Swift.Bool
  }
  public static func build_Conjunction<LHS, RHS>(lhs: LHS, rhs: RHS) -> Foundation.PredicateExpressions.Conjunction<LHS, RHS> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output == Swift.Bool, RHS.Output == Swift.Bool
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.Conjunction : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Conjunction : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Conjunction : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Conjunction : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct DictionaryKeySubscript<Wrapped, Key, Value> : Foundation.PredicateExpression where Wrapped : Foundation.PredicateExpression, Key : Foundation.PredicateExpression, Wrapped.Output == [Key.Output : Value], Key.Output : Swift.Hashable {
    public typealias Output = Swift.Optional<Value>
    public let wrapped: Wrapped
    public let key: Key
    public init(wrapped: Wrapped, key: Key)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.DictionaryKeySubscript<Wrapped, Key, Value>.Output
  }
  public static func build_subscript<Wrapped, Key, Value>(_ wrapped: Wrapped, _ key: Key) -> Foundation.PredicateExpressions.DictionaryKeySubscript<Wrapped, Key, Value> where Wrapped : Foundation.PredicateExpression, Key : Foundation.PredicateExpression, Wrapped.Output == [Key.Output : Value], Key.Output : Swift.Hashable
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.DictionaryKeySubscript : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.DictionaryKeySubscript : Swift.Sendable where Wrapped : Swift.Sendable, Key : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.DictionaryKeySubscript : Swift.Codable where Wrapped : Swift.Decodable, Wrapped : Swift.Encodable, Key : Swift.Decodable, Key : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.DictionaryKeySubscript : Foundation.StandardPredicateExpression where Wrapped : Foundation.StandardPredicateExpression, Key : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct DictionaryKeyDefaultValueSubscript<Wrapped, Key, Default> : Foundation.PredicateExpression where Wrapped : Foundation.PredicateExpression, Key : Foundation.PredicateExpression, Default : Foundation.PredicateExpression, Wrapped.Output == [Key.Output : Default.Output], Key.Output : Swift.Hashable {
    public typealias Output = Default.Output
    public let wrapped: Wrapped
    public let key: Key
    public let `default`: Default
    public init(wrapped: Wrapped, key: Key, default: Default)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.DictionaryKeyDefaultValueSubscript<Wrapped, Key, Default>.Output
  }
  public static func build_subscript<Wrapped, Key, Default>(_ wrapped: Wrapped, _ key: Key, default: Default) -> Foundation.PredicateExpressions.DictionaryKeyDefaultValueSubscript<Wrapped, Key, Default> where Wrapped : Foundation.PredicateExpression, Key : Foundation.PredicateExpression, Default : Foundation.PredicateExpression, Wrapped.Output == [Key.Output : Default.Output], Key.Output : Swift.Hashable
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.DictionaryKeyDefaultValueSubscript : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.DictionaryKeyDefaultValueSubscript : Swift.Sendable where Wrapped : Swift.Sendable, Key : Swift.Sendable, Default : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.DictionaryKeyDefaultValueSubscript : Swift.Codable where Wrapped : Swift.Decodable, Wrapped : Swift.Encodable, Key : Swift.Decodable, Key : Swift.Encodable, Default : Swift.Decodable, Default : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.DictionaryKeyDefaultValueSubscript : Foundation.StandardPredicateExpression where Wrapped : Foundation.StandardPredicateExpression, Key : Foundation.StandardPredicateExpression, Default : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct Disjunction<LHS, RHS> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output == Swift.Bool, RHS.Output == Swift.Bool {
    public typealias Output = Swift.Bool
    public let lhs: LHS
    public let rhs: RHS
    public init(lhs: LHS, rhs: RHS)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Swift.Bool
  }
  public static func build_Disjunction<LHS, RHS>(lhs: LHS, rhs: RHS) -> Foundation.PredicateExpressions.Disjunction<LHS, RHS> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output == Swift.Bool, RHS.Output == Swift.Bool
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.Disjunction : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Disjunction : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Disjunction : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Disjunction : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct IntDivision<LHS, RHS> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.BinaryInteger, LHS.Output == RHS.Output {
    public typealias Output = LHS.Output
    public let lhs: LHS
    public let rhs: RHS
    public init(lhs: LHS, rhs: RHS)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.IntDivision<LHS, RHS>.Output
  }
  public struct IntRemainder<LHS, RHS> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.BinaryInteger, LHS.Output == RHS.Output {
    public typealias Output = LHS.Output
    public let lhs: LHS
    public let rhs: RHS
    public init(lhs: LHS, rhs: RHS)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.IntRemainder<LHS, RHS>.Output
  }
  public struct FloatDivision<LHS, RHS> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.FloatingPoint, LHS.Output == RHS.Output {
    public typealias Output = LHS.Output
    public let lhs: LHS
    public let rhs: RHS
    public init(lhs: LHS, rhs: RHS)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.FloatDivision<LHS, RHS>.Output
  }
  public static func build_Division<LHS, RHS>(lhs: LHS, rhs: RHS) -> Foundation.PredicateExpressions.IntDivision<LHS, RHS> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.BinaryInteger, LHS.Output == RHS.Output
  public static func build_Division<LHS, RHS>(lhs: LHS, rhs: RHS) -> Foundation.PredicateExpressions.FloatDivision<LHS, RHS> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.FloatingPoint, LHS.Output == RHS.Output
  public static func build_Remainder<LHS, RHS>(lhs: LHS, rhs: RHS) -> Foundation.PredicateExpressions.IntRemainder<LHS, RHS> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.BinaryInteger, LHS.Output == RHS.Output
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.FloatDivision : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.IntDivision : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.IntRemainder : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.FloatDivision : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.IntRemainder : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.IntDivision : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.FloatDivision : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.IntRemainder : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.IntDivision : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.FloatDivision : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.IntRemainder : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.IntDivision : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct Equal<LHS, RHS> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Equatable, LHS.Output == RHS.Output {
    public typealias Output = Swift.Bool
    public let lhs: LHS
    public let rhs: RHS
    public init(lhs: LHS, rhs: RHS)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Swift.Bool
  }
  public static func build_Equal<LHS, RHS>(lhs: LHS, rhs: RHS) -> Foundation.PredicateExpressions.Equal<LHS, RHS> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Equatable, LHS.Output == RHS.Output
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.Equal : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Equal : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Equal : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Equal : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
  public struct ExpressionEvaluate<Transformation, each Input, Output> : Foundation.PredicateExpression where Transformation : Foundation.PredicateExpression, repeat each Input : Foundation.PredicateExpression, Transformation.Output == Foundation.Expression<repeat (each Input).Output, Output> {
    public let expression: Transformation
    public let input: (repeat each Input)
    public init(expression: Transformation, input: repeat each Input)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Output
  }
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
  public static func build_evaluate<Transformation, each Input, Output>(_ expression: Transformation, _ input: repeat each Input) -> Foundation.PredicateExpressions.ExpressionEvaluate<Transformation, repeat each Input, Output> where Transformation : Foundation.PredicateExpression, repeat each Input : Foundation.PredicateExpression, Transformation.Output == Foundation.Expression<repeat (each Input).Output, Output>
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.PredicateExpressions.ExpressionEvaluate : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.PredicateExpressions.ExpressionEvaluate : Foundation.StandardPredicateExpression where Transformation : Foundation.StandardPredicateExpression, repeat each Input : Foundation.StandardPredicateExpression {
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.PredicateExpressions.ExpressionEvaluate : Swift.Codable where Transformation : Swift.Decodable, Transformation : Swift.Encodable, repeat each Input : Swift.Decodable, repeat each Input : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.PredicateExpressions.ExpressionEvaluate : Swift.Sendable where Transformation : Swift.Sendable, repeat each Input : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct Filter<LHS, RHS> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Sequence, RHS.Output == Swift.Bool {
    public typealias Element = LHS.Output.Element
    public typealias Output = [Foundation.PredicateExpressions.Filter<LHS, RHS>.Element]
    public let sequence: LHS
    public let filter: RHS
    public let variable: Foundation.PredicateExpressions.Variable<Foundation.PredicateExpressions.Filter<LHS, RHS>.Element>
    public init(_ sequence: LHS, _ builder: (Foundation.PredicateExpressions.Variable<Foundation.PredicateExpressions.Filter<LHS, RHS>.Element>) -> RHS)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.Filter<LHS, RHS>.Output
  }
  public static func build_filter<LHS, RHS>(_ lhs: LHS, _ builder: (Foundation.PredicateExpressions.Variable<LHS.Output.Element>) -> RHS) -> Foundation.PredicateExpressions.Filter<LHS, RHS> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Sequence, RHS.Output == Swift.Bool
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.Filter : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Filter : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Filter : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Filter : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct NotEqual<LHS, RHS> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Equatable, LHS.Output == RHS.Output {
    public typealias Output = Swift.Bool
    public let lhs: LHS
    public let rhs: RHS
    public init(lhs: LHS, rhs: RHS)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Swift.Bool
  }
  public static func build_NotEqual<LHS, RHS>(lhs: LHS, rhs: RHS) -> Foundation.PredicateExpressions.NotEqual<LHS, RHS> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Equatable, LHS.Output == RHS.Output
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.NotEqual : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.NotEqual : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.NotEqual : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.NotEqual : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct Negation<Wrapped> : Foundation.PredicateExpression where Wrapped : Foundation.PredicateExpression, Wrapped.Output == Swift.Bool {
    public typealias Output = Swift.Bool
    public let wrapped: Wrapped
    public init(_ wrapped: Wrapped)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Swift.Bool
  }
  public static func build_Negation<T>(_ wrapped: T) -> Foundation.PredicateExpressions.Negation<T> where T : Foundation.PredicateExpression, T.Output == Swift.Bool
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.Negation : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Negation : Foundation.StandardPredicateExpression where Wrapped : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Negation : Swift.Codable where Wrapped : Swift.Decodable, Wrapped : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Negation : Swift.Sendable where Wrapped : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct OptionalFlatMap<LHS, Wrapped, RHS, Result> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output == Wrapped? {
    public typealias Output = Swift.Optional<Result>
    public let wrapped: LHS
    public let transform: RHS
    public let variable: Foundation.PredicateExpressions.Variable<Wrapped>
    public init(_ wrapped: LHS, _ builder: (Foundation.PredicateExpressions.Variable<Wrapped>) -> RHS) where Result == RHS.Output
    public init(_ wrapped: LHS, _ builder: (Foundation.PredicateExpressions.Variable<Wrapped>) -> RHS) where RHS.Output == Result?
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.OptionalFlatMap<LHS, Wrapped, RHS, Result>.Output
  }
  public static func build_flatMap<LHS, RHS, Wrapped, Result>(_ wrapped: LHS, _ builder: (Foundation.PredicateExpressions.Variable<Wrapped>) -> RHS) -> Foundation.PredicateExpressions.OptionalFlatMap<LHS, Wrapped, RHS, Result> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, Result == RHS.Output, LHS.Output == Wrapped?
  public static func build_flatMap<LHS, RHS, Wrapped, Result>(_ wrapped: LHS, _ builder: (Foundation.PredicateExpressions.Variable<Wrapped>) -> RHS) -> Foundation.PredicateExpressions.OptionalFlatMap<LHS, Wrapped, RHS, Result> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output == Wrapped?, RHS.Output == Result?
  public struct NilCoalesce<LHS, RHS> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output == RHS.Output? {
    public typealias Output = RHS.Output
    public let lhs: LHS
    public let rhs: RHS
    public init(lhs: LHS, rhs: RHS)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.NilCoalesce<LHS, RHS>.Output
  }
  public static func build_NilCoalesce<LHS, RHS>(lhs: LHS, rhs: RHS) -> Foundation.PredicateExpressions.NilCoalesce<LHS, RHS> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output == RHS.Output?
  public struct ForcedUnwrap<Inner, Wrapped> : Foundation.PredicateExpression where Inner : Foundation.PredicateExpression, Inner.Output == Wrapped? {
    public typealias Output = Wrapped
    public let inner: Inner
    public init(_ inner: Inner)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Wrapped
  }
  public static func build_ForcedUnwrap<Inner, Wrapped>(_ inner: Inner) -> Foundation.PredicateExpressions.ForcedUnwrap<Inner, Wrapped> where Inner : Foundation.PredicateExpression, Inner.Output == Wrapped?
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.OptionalFlatMap : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.NilCoalesce : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.ForcedUnwrap : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.OptionalFlatMap : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.NilCoalesce : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.ForcedUnwrap : Foundation.StandardPredicateExpression where Inner : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.OptionalFlatMap : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.NilCoalesce : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.ForcedUnwrap : Swift.Codable where Inner : Swift.Decodable, Inner : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.OptionalFlatMap : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.NilCoalesce : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.ForcedUnwrap : Swift.Sendable where Inner : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct NilLiteral<Wrapped> : Foundation.StandardPredicateExpression, Swift.Codable, Swift.Sendable {
    public typealias Output = Swift.Optional<Wrapped>
    public init()
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.NilLiteral<Wrapped>.Output
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public static func build_NilLiteral<Wrapped>() -> Foundation.PredicateExpressions.NilLiteral<Wrapped>
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  @available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
  public struct PredicateEvaluate<Condition, each Input> : Foundation.PredicateExpression where Condition : Foundation.PredicateExpression, repeat each Input : Foundation.PredicateExpression, Condition.Output == Foundation.Predicate<repeat (each Input).Output> {
    public typealias Output = Swift.Bool
    public let predicate: Condition
    public let input: (repeat each Input)
    public init(predicate: Condition, input: repeat each Input)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.PredicateEvaluate<Condition, repeat each Input>.Output
  }
  @available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
  public static func build_evaluate<Condition, each Input>(_ predicate: Condition, _ input: repeat each Input) -> Foundation.PredicateExpressions.PredicateEvaluate<Condition, repeat each Input> where Condition : Foundation.PredicateExpression, repeat each Input : Foundation.PredicateExpression, Condition.Output == Foundation.Predicate<repeat (each Input).Output>
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.PredicateEvaluate : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.PredicateEvaluate : Foundation.StandardPredicateExpression where Condition : Foundation.StandardPredicateExpression, repeat each Input : Foundation.StandardPredicateExpression {
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.PredicateEvaluate : Swift.Codable where Condition : Swift.Decodable, Condition : Swift.Encodable, repeat each Input : Swift.Decodable, repeat each Input : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.PredicateEvaluate : Swift.Sendable where Condition : Swift.Sendable, repeat each Input : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct Range<LHS, RHS> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Comparable, LHS.Output == RHS.Output {
    public typealias Output = Swift.Range<LHS.Output>
    public let lower: LHS
    public let upper: RHS
    public init(lower: LHS, upper: RHS)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Swift.Range<LHS.Output>
  }
  public static func build_Range<LHS, RHS>(lower: LHS, upper: RHS) -> Foundation.PredicateExpressions.Range<LHS, RHS> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Comparable, LHS.Output == RHS.Output
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.Range : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Range : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Range : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Range : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct ClosedRange<LHS, RHS> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Comparable, LHS.Output == RHS.Output {
    public typealias Output = Swift.ClosedRange<LHS.Output>
    public let lower: LHS
    public let upper: RHS
    public init(lower: LHS, upper: RHS)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Swift.ClosedRange<LHS.Output>
  }
  public static func build_ClosedRange<LHS, RHS>(lower: LHS, upper: RHS) -> Foundation.PredicateExpressions.ClosedRange<LHS, RHS> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Comparable, LHS.Output == RHS.Output
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.ClosedRange : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.ClosedRange : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.ClosedRange : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.ClosedRange : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct RangeExpressionContains<RangeExpression, Element> : Foundation.PredicateExpression where RangeExpression : Foundation.PredicateExpression, Element : Foundation.PredicateExpression, RangeExpression.Output : Swift.RangeExpression, Element.Output == RangeExpression.Output.Bound {
    public typealias Output = Swift.Bool
    public let range: RangeExpression
    public let element: Element
    public init(range: RangeExpression, element: Element)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.RangeExpressionContains<RangeExpression, Element>.Output
  }
  public static func build_contains<RangeExpression, Element>(_ range: RangeExpression, _ element: Element) -> Foundation.PredicateExpressions.RangeExpressionContains<RangeExpression, Element> where RangeExpression : Foundation.PredicateExpression, Element : Foundation.PredicateExpression, RangeExpression.Output : Swift.RangeExpression, Element.Output == RangeExpression.Output.Bound
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.RangeExpressionContains : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.RangeExpressionContains : Foundation.StandardPredicateExpression where RangeExpression : Foundation.StandardPredicateExpression, Element : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.RangeExpressionContains : Swift.Codable where RangeExpression : Swift.Decodable, RangeExpression : Swift.Encodable, Element : Swift.Decodable, Element : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.RangeExpressionContains : Swift.Sendable where RangeExpression : Swift.Sendable, Element : Swift.Sendable {
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.PredicateExpressions {
  public struct StringContainsRegex<Subject, Regex> : Foundation.PredicateExpression, Swift.CustomStringConvertible where Subject : Foundation.PredicateExpression, Regex : Foundation.PredicateExpression, Subject.Output : Swift.BidirectionalCollection, Regex.Output : _StringProcessing.RegexComponent, Subject.Output.SubSequence == Swift.Substring {
    public typealias Output = Swift.Bool
    public let subject: Subject
    public let regex: Regex
    public init(subject: Subject, regex: Regex)
    public var description: Swift.String {
      get
    }
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Swift.Bool
  }
  @_disfavoredOverload public static func build_contains<Subject, Regex>(_ subject: Subject, _ regex: Regex) -> Foundation.PredicateExpressions.StringContainsRegex<Subject, Regex> where Subject : Foundation.PredicateExpression, Regex : Foundation.PredicateExpression, Subject.Output : Swift.BidirectionalCollection, Regex.Output : _StringProcessing.RegexComponent, Subject.Output.SubSequence == Swift.Substring
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.PredicateExpressions {
  public struct PredicateRegex : Swift.Sendable, Swift.Codable, _StringProcessing.RegexComponent, Swift.CustomStringConvertible {
    public let stringRepresentation: Swift.String
    public var regex: _StringProcessing.Regex<_StringProcessing.AnyRegexOutput> {
      get
    }
    public var description: Swift.String {
      get
    }
    public init?(_ component: some RegexComponent)
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    @available(iOS 18, tvOS 18, watchOS 11, macOS 15, *)
    public typealias RegexOutput = _StringProcessing.AnyRegexOutput
  }
  public static func build_Arg(_ component: some RegexComponent) -> Foundation.PredicateExpressions.Value<Foundation.PredicateExpressions.PredicateRegex>
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.PredicateExpressions.StringContainsRegex : Swift.Sendable where Subject : Swift.Sendable, Regex : Swift.Sendable {
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.PredicateExpressions.StringContainsRegex : Swift.Codable where Subject : Swift.Decodable, Subject : Swift.Encodable, Regex : Swift.Decodable, Regex : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.PredicateExpressions.StringContainsRegex : Foundation.StandardPredicateExpression where Subject : Foundation.StandardPredicateExpression, Regex : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct SequenceContains<LHS, RHS> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Sequence, RHS.Output : Swift.Equatable, RHS.Output == LHS.Output.Element {
    public typealias Output = Swift.Bool
    public let sequence: LHS
    public let element: RHS
    public init(sequence: LHS, element: RHS)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Swift.Bool
  }
  public struct SequenceContainsWhere<LHS, RHS> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Sequence, RHS.Output == Swift.Bool {
    public typealias Element = LHS.Output.Element
    public typealias Output = Swift.Bool
    public let sequence: LHS
    public let test: RHS
    public let variable: Foundation.PredicateExpressions.Variable<Foundation.PredicateExpressions.SequenceContainsWhere<LHS, RHS>.Element>
    public init(_ sequence: LHS, builder: (Foundation.PredicateExpressions.Variable<Foundation.PredicateExpressions.SequenceContainsWhere<LHS, RHS>.Element>) -> RHS)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.SequenceContainsWhere<LHS, RHS>.Output
  }
  public struct SequenceAllSatisfy<LHS, RHS> : Foundation.PredicateExpression where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Sequence, RHS.Output == Swift.Bool {
    public typealias Element = LHS.Output.Element
    public typealias Output = Swift.Bool
    public let sequence: LHS
    public let test: RHS
    public let variable: Foundation.PredicateExpressions.Variable<Foundation.PredicateExpressions.SequenceAllSatisfy<LHS, RHS>.Element>
    public init(_ sequence: LHS, builder: (Foundation.PredicateExpressions.Variable<Foundation.PredicateExpressions.SequenceAllSatisfy<LHS, RHS>.Element>) -> RHS)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.SequenceAllSatisfy<LHS, RHS>.Output
  }
  public struct SequenceStartsWith<Base, Prefix> : Foundation.PredicateExpression where Base : Foundation.PredicateExpression, Prefix : Foundation.PredicateExpression, Base.Output : Swift.Sequence, Prefix.Output : Swift.Sequence, Base.Output.Element : Swift.Equatable, Base.Output.Element == Prefix.Output.Element {
    public typealias Output = Swift.Bool
    public let base: Base
    public let prefix: Prefix
    public init(base: Base, prefix: Prefix)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Swift.Bool
  }
  @_disfavoredOverload public static func build_contains<LHS, RHS>(_ lhs: LHS, _ rhs: RHS) -> Foundation.PredicateExpressions.SequenceContains<LHS, RHS> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Sequence, RHS.Output : Swift.Equatable, RHS.Output == LHS.Output.Element
  public static func build_contains<LHS, RHS>(_ lhs: LHS, where builder: (Foundation.PredicateExpressions.Variable<LHS.Output.Element>) -> RHS) -> Foundation.PredicateExpressions.SequenceContainsWhere<LHS, RHS> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Sequence, RHS.Output == Swift.Bool
  public static func build_allSatisfy<LHS, RHS>(_ lhs: LHS, _ builder: (Foundation.PredicateExpressions.Variable<LHS.Output.Element>) -> RHS) -> Foundation.PredicateExpressions.SequenceAllSatisfy<LHS, RHS> where LHS : Foundation.PredicateExpression, RHS : Foundation.PredicateExpression, LHS.Output : Swift.Sequence, RHS.Output == Swift.Bool
  public static func build_starts<Base, Prefix>(_ base: Base, with prefix: Prefix) -> Foundation.PredicateExpressions.SequenceStartsWith<Base, Prefix> where Base : Foundation.PredicateExpression, Prefix : Foundation.PredicateExpression, Base.Output : Swift.Sequence, Prefix.Output : Swift.Sequence, Base.Output.Element : Swift.Equatable, Base.Output.Element == Prefix.Output.Element
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.SequenceContains : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.SequenceContainsWhere : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.SequenceAllSatisfy : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceContains : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceContainsWhere : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceAllSatisfy : Foundation.StandardPredicateExpression where LHS : Foundation.StandardPredicateExpression, RHS : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceStartsWith : Foundation.StandardPredicateExpression where Base : Foundation.StandardPredicateExpression, Prefix : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceContains : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceContainsWhere : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceAllSatisfy : Swift.Codable where LHS : Swift.Decodable, LHS : Swift.Encodable, RHS : Swift.Decodable, RHS : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceStartsWith : Swift.Codable where Base : Swift.Decodable, Base : Swift.Encodable, Prefix : Swift.Decodable, Prefix : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceContains : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceContainsWhere : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceAllSatisfy : Swift.Sendable where LHS : Swift.Sendable, RHS : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.SequenceStartsWith : Swift.Sendable where Base : Swift.Sendable, Prefix : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct StringCaseInsensitiveCompare<Root, Other> : Foundation.PredicateExpression where Root : Foundation.PredicateExpression, Other : Foundation.PredicateExpression, Root.Output : Swift.StringProtocol, Other.Output : Swift.StringProtocol {
    public typealias Output = Foundation.ComparisonResult
    public let root: Root
    public let other: Other
    public init(root: Root, other: Other)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.StringCaseInsensitiveCompare<Root, Other>.Output
  }
  public static func build_caseInsensitiveCompare<Root, Other>(_ root: Root, _ other: Other) -> Foundation.PredicateExpressions.StringCaseInsensitiveCompare<Root, Other> where Root : Foundation.PredicateExpression, Other : Foundation.PredicateExpression, Root.Output : Swift.StringProtocol, Other.Output : Swift.StringProtocol
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.StringCaseInsensitiveCompare : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.StringCaseInsensitiveCompare : Foundation.StandardPredicateExpression where Root : Foundation.StandardPredicateExpression, Other : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.StringCaseInsensitiveCompare : Swift.Codable where Root : Swift.Decodable, Root : Swift.Encodable, Other : Swift.Decodable, Other : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.StringCaseInsensitiveCompare : Swift.Sendable where Root : Swift.Sendable, Other : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct ConditionalCast<Input, Desired> : Foundation.PredicateExpression where Input : Foundation.PredicateExpression {
    public typealias Output = Swift.Optional<Desired>
    public let input: Input
    public init(_ input: Input)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.ConditionalCast<Input, Desired>.Output
  }
  public struct ForceCast<Input, Desired> : Foundation.PredicateExpression where Input : Foundation.PredicateExpression {
    public typealias Output = Desired
    public let input: Input
    public init(_ input: Input)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.ForceCast<Input, Desired>.Output
  }
  public struct TypeCheck<Input, Desired> : Foundation.PredicateExpression where Input : Foundation.PredicateExpression {
    public typealias Output = Swift.Bool
    public let input: Input
    public init(_ input: Input)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.TypeCheck<Input, Desired>.Output
  }
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.ConditionalCast : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.ForceCast : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.TypeCheck : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.ConditionalCast : Foundation.StandardPredicateExpression where Input : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.ForceCast : Foundation.StandardPredicateExpression where Input : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.TypeCheck : Foundation.StandardPredicateExpression where Input : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.ConditionalCast : Swift.Codable where Input : Swift.Decodable, Input : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.ForceCast : Swift.Codable where Input : Swift.Decodable, Input : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.TypeCheck : Swift.Codable where Input : Swift.Decodable, Input : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.ConditionalCast : Swift.Sendable where Input : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.ForceCast : Swift.Sendable where Input : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.TypeCheck : Swift.Sendable where Input : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct UnaryMinus<Wrapped> : Foundation.PredicateExpression where Wrapped : Foundation.PredicateExpression, Wrapped.Output : Swift.SignedNumeric {
    public typealias Output = Wrapped.Output
    public let wrapped: Wrapped
    public init(_ wrapped: Wrapped)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Foundation.PredicateExpressions.UnaryMinus<Wrapped>.Output
  }
  public static func build_UnaryMinus<T>(_ inner: T) -> Foundation.PredicateExpressions.UnaryMinus<T> where T : Foundation.PredicateExpression, T.Output : Swift.SignedNumeric
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.UnaryMinus : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.UnaryMinus : Foundation.StandardPredicateExpression where Wrapped : Foundation.StandardPredicateExpression {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.UnaryMinus : Swift.Codable where Wrapped : Swift.Decodable, Wrapped : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.UnaryMinus : Swift.Sendable where Wrapped : Swift.Sendable {
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
public struct Expression<each Input, Output> : Swift.Sendable {
  public let expression: any Foundation.StandardPredicateExpression<Output>
  public let variable: (repeat Foundation.PredicateExpressions.Variable<each Input>)
  public init(_ builder: (repeat Foundation.PredicateExpressions.Variable<each Input>) -> any Foundation.StandardPredicateExpression<Output>)
  public func evaluate(_ input: repeat each Input) throws -> Output
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
@freestanding(expression) public macro Expression<each Input, Output>(_ body: (repeat each Input) -> Output) -> Foundation.Expression<repeat each Input, Output> = #externalMacro(module: "FoundationMacros", type: "ExpressionMacro")
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.NSPredicate {
  convenience public init?<Input>(_ predicate: Foundation.Predicate<Input>) where Input : ObjectiveC.NSObject
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.NSExpression {
  convenience public init?<Input, Output>(_ expression: Foundation.Expression<Input, Output>) where Input : ObjectiveC.NSObject
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public struct Predicate<each Input> : Swift.Sendable {
  public let expression: any Foundation.StandardPredicateExpression<Swift.Bool>
  public let variable: (repeat Foundation.PredicateExpressions.Variable<each Input>)
  public init(_ builder: (repeat Foundation.PredicateExpressions.Variable<each Input>) -> any Foundation.StandardPredicateExpression<Swift.Bool>)
  public func evaluate(_ input: repeat each Input) throws -> Swift.Bool
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
@freestanding(expression) public macro Predicate<each Input>(_ body: (repeat each Input) -> Swift.Bool) -> Foundation.Predicate<repeat each Input> = #externalMacro(module: "FoundationMacros", type: "PredicateMacro")
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Predicate {
  public static var `true`: Foundation.Predicate<repeat each Input> {
    get
  }
  public static var `false`: Foundation.Predicate<repeat each Input> {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
@frozen public enum PredicateExpressions {
}
@available(macOS, unavailable, introduced: 14.0)
@available(iOS, unavailable, introduced: 17.0)
@available(tvOS, unavailable, introduced: 17.0)
@available(watchOS, unavailable, introduced: 10.0)
@available(*, unavailable)
extension Foundation.PredicateExpressions : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Swift.Sequence {
  public func filter(_ predicate: Foundation.Predicate<Self.Element>) throws -> [Self.Element]
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.Predicate : Swift.CustomStringConvertible {
  @_optimize(none) public var description: Swift.String {
    get
  }
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Expression : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.Predicate : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Expression : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public struct PredicateBindings {
  public init<each T>(_ value: repeat (Foundation.PredicateExpressions.Variable<each T>, each T))
  public subscript<T>(variable: Foundation.PredicateExpressions.Variable<T>) -> T? {
    get
    set
  }
  public func binding<T>(_ variable: Foundation.PredicateExpressions.Variable<T>, to value: T) -> Foundation.PredicateBindings
}
@available(macOS, unavailable, introduced: 14.0)
@available(iOS, unavailable, introduced: 17.0)
@available(tvOS, unavailable, introduced: 17.0)
@available(watchOS, unavailable, introduced: 10.0)
@available(*, unavailable)
extension Foundation.PredicateBindings : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol PredicateExpression<Output> {
  associatedtype Output
  func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Self.Output
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol StandardPredicateExpression<Output> : Foundation.PredicateExpression, Swift.Decodable, Swift.Encodable, Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public struct PredicateError : Swift.Error, Swift.Hashable, Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
  public static func == (lhs: Foundation.PredicateError, rhs: Foundation.PredicateError) -> Swift.Bool
  public static let undefinedVariable: Foundation.PredicateError
  public static let forceUnwrapFailure: Foundation.PredicateError
  public static let forceCastFailure: Foundation.PredicateError
  public static let invalidInput: Foundation.PredicateError
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions {
  public struct VariableID : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func == (a: Foundation.PredicateExpressions.VariableID, b: Foundation.PredicateExpressions.VariableID) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Variable<Output> : Foundation.StandardPredicateExpression {
    public let key: Foundation.PredicateExpressions.VariableID
    public init()
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Output
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct KeyPath<Root, Output> : Foundation.PredicateExpression where Root : Foundation.PredicateExpression {
    public let root: Root
    public let keyPath: any Swift.KeyPath<Root.Output, Output> & Swift.Sendable
    public init(root: Root, keyPath: any Swift.KeyPath<Root.Output, Output> & Swift.Sendable)
    public func evaluate(_ bindings: Foundation.PredicateBindings) throws -> Output
  }
  public struct Value<Output> : Foundation.PredicateExpression {
    public let value: Output
    public init(_ value: Output)
    public func evaluate(_ bindings: Foundation.PredicateBindings) -> Output
  }
  public static func build_Arg<T>(_ arg: T) -> Foundation.PredicateExpressions.Value<T>
  public static func build_Arg<T>(_ arg: T) -> T where T : Foundation.PredicateExpression
  @usableFromInline
  internal static func build_KeyPath<Root, Value>(root: Root, keyPath: Swift.KeyPath<Root.Output, Value>) -> Foundation.PredicateExpressions.KeyPath<Root, Value> where Root : Foundation.PredicateExpression
  @_alwaysEmitIntoClient public static func build_KeyPath<Root, Value>(root: Root, keyPath: any Swift.KeyPath<Root.Output, Value> & Swift.Sendable) -> Foundation.PredicateExpressions.KeyPath<Root, Value> where Root : Foundation.PredicateExpression {
        PredicateExpressions.build_KeyPath(root: root, keyPath: keyPath as Swift.KeyPath<Root.Output, Value>)
    }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.KeyPath : Swift.Codable where Root : Swift.Decodable, Root : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.KeyPath : Swift.Sendable where Root : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.KeyPath : Foundation.StandardPredicateExpression where Root : Foundation.StandardPredicateExpression {
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.KeyPath : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Value : Swift.Codable where Output : Swift.Decodable, Output : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Value : Swift.Sendable where Output : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.Value : Foundation.StandardPredicateExpression where Output : Swift.Decodable, Output : Swift.Encodable {
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.Value : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Foundation.PredicateExpressions.Variable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.KeyPath {
  public enum CommonKeyPathKind : Swift.Hashable, Swift.Sendable {
    case collectionCount
    case collectionIsEmpty
    case collectionFirst
    case bidirectionalCollectionLast
    public static func == (a: Foundation.PredicateExpressions.KeyPath<Root, Output>.CommonKeyPathKind, b: Foundation.PredicateExpressions.KeyPath<Root, Output>.CommonKeyPathKind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var kind: Foundation.PredicateExpressions.KeyPath<Root, Output>.CommonKeyPathKind? {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@_objcRuntimeName(_TtC10Foundation20_PropertyListDecoder) open class PropertyListDecoder {
  public typealias PropertyListFormat = Foundation.PropertyListSerialization.PropertyListFormat
  @preconcurrency open var userInfo: [Swift.CodingUserInfoKey : any Swift.Sendable] {
    get
    set
    _modify
  }
  public init()
  open func decode<T>(_ type: T.Type, from data: Foundation.Data) throws -> T where T : Swift.Decodable
  open func decode<T>(_ type: T.Type, from data: Foundation.Data, format: inout Foundation.PropertyListDecoder.PropertyListFormat) throws -> T where T : Swift.Decodable
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  open func decode<T>(_ type: T.Type, from data: Foundation.Data, configuration: T.DecodingConfiguration) throws -> T where T : Foundation.DecodableWithConfiguration
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  open func decode<T, C>(_ type: T.Type, from data: Foundation.Data, configuration: C.Type) throws -> T where T : Foundation.DecodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  open func decode<T, C>(_ type: T.Type, from data: Foundation.Data, format: inout Foundation.PropertyListDecoder.PropertyListFormat, configuration: C.Type) throws -> T where T : Foundation.DecodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  open func decode<T>(_ type: T.Type, from data: Foundation.Data, format: inout Foundation.PropertyListDecoder.PropertyListFormat, configuration: T.DecodingConfiguration) throws -> T where T : Foundation.DecodableWithConfiguration
  @objc deinit
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.PropertyListDecoder : @unchecked Swift.Sendable {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@_objcRuntimeName(_TtC10Foundation20_PropertyListEncoder) open class PropertyListEncoder {
  open var outputFormat: Foundation.PropertyListDecoder.PropertyListFormat {
    get
    set
    _modify
  }
  @preconcurrency open var userInfo: [Swift.CodingUserInfoKey : any Swift.Sendable] {
    get
    set
    _modify
  }
  public init()
  open func encode<Value>(_ value: Value) throws -> Foundation.Data where Value : Swift.Encodable
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  open func encode<T>(_ value: T, configuration: T.EncodingConfiguration) throws -> Foundation.Data where T : Foundation.EncodableWithConfiguration
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  open func encode<T, C>(_ value: T, configuration: C.Type) throws -> Foundation.Data where T : Foundation.EncodableWithConfiguration, C : Foundation.EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration
  @objc deinit
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.PropertyListEncoder : @unchecked Swift.Sendable {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public var kCFStringEncodingASCII: CoreFoundation.CFStringEncoding {
  get
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.String {
  public struct Encoding : Swift.RawRepresentable, Swift.Sendable, Swift.Equatable {
    public var rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let ascii: Swift.String.Encoding
    public static let nextstep: Swift.String.Encoding
    public static let japaneseEUC: Swift.String.Encoding
    public static let utf8: Swift.String.Encoding
    public static let isoLatin1: Swift.String.Encoding
    public static let symbol: Swift.String.Encoding
    public static let nonLossyASCII: Swift.String.Encoding
    public static let shiftJIS: Swift.String.Encoding
    public static let isoLatin2: Swift.String.Encoding
    public static let unicode: Swift.String.Encoding
    public static let windowsCP1251: Swift.String.Encoding
    public static let windowsCP1252: Swift.String.Encoding
    public static let windowsCP1253: Swift.String.Encoding
    public static let windowsCP1254: Swift.String.Encoding
    public static let windowsCP1250: Swift.String.Encoding
    public static let iso2022JP: Swift.String.Encoding
    public static let macOSRoman: Swift.String.Encoding
    public static let utf16: Swift.String.Encoding
    public static let utf16BigEndian: Swift.String.Encoding
    public static let utf16LittleEndian: Swift.String.Encoding
    public static let utf32: Swift.String.Encoding
    public static let utf32BigEndian: Swift.String.Encoding
    public static let utf32LittleEndian: Swift.String.Encoding
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias RawValue = Swift.UInt
  }
  public typealias EncodingConversionOptions = Foundation.NSString.EncodingConversionOptions
  public typealias EnumerationOptions = Foundation.NSString.EnumerationOptions
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.String.Encoding : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  @_alwaysEmitIntoClient public func hash(into hasher: inout Swift.Hasher) {
         
         
         
         
         
         
         
         
         
        hasher.combine(rawValue)
    }
  public static func == (lhs: Swift.String.Encoding, rhs: Swift.String.Encoding) -> Swift.Bool
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.String.Encoding : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.String {
  public typealias CompareOptions = Foundation.NSString.CompareOptions
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.String {
  public init?(data: __shared Foundation.Data, encoding: Swift.String.Encoding)
  public init?<S>(bytes: __shared S, encoding: Swift.String.Encoding) where S : Swift.Sequence, S.Element == Swift.UInt8
  public init(contentsOfFile path: __shared Swift.String, encoding enc: Swift.String.Encoding) throws
  public init(contentsOf url: __shared Foundation.URL, encoding enc: Swift.String.Encoding) throws
  public init(contentsOfFile path: __shared Swift.String, usedEncoding: inout Swift.String.Encoding) throws
  public init(contentsOf url: __shared Foundation.URL, usedEncoding: inout Swift.String.Encoding) throws
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.StringProtocol {
  public func write<T>(toFile path: T, atomically useAuxiliaryFile: Swift.Bool, encoding enc: Swift.String.Encoding) throws where T : Swift.StringProtocol
  public func write(to url: Foundation.URL, atomically useAuxiliaryFile: Swift.Bool, encoding enc: Swift.String.Encoding) throws
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Swift.String {
  public func data(using encoding: Swift.String.Encoding, allowLossyConversion: Swift.Bool = false) -> Foundation.Data?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.StringProtocol {
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public var capitalized: Swift.String {
    get
  }
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public func rangeOfCharacter(from aSet: Foundation.CharacterSet, options mask: Swift.String.CompareOptions = [], range aRange: Swift.Range<Self.Index>? = nil) -> Swift.Range<Self.Index>?
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public func data(using encoding: Swift.String.Encoding, allowLossyConversion: Swift.Bool = false) -> Foundation.Data?
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public func components<T>(separatedBy separator: T) -> [Swift.String] where T : Swift.StringProtocol
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public func lineRange(for range: some RangeExpression<Index>) -> Swift.Range<Self.Index>
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public func paragraphRange(for range: some RangeExpression<Index>) -> Swift.Range<Self.Index>
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct TimeZone : Swift.Hashable, Swift.Equatable, Swift.Sendable {
  public init?(identifier: __shared Swift.String)
  public init?(secondsFromGMT seconds: Swift.Int)
  public init?(abbreviation: __shared Swift.String)
  public static var current: Foundation.TimeZone {
    get
  }
  public static var autoupdatingCurrent: Foundation.TimeZone {
    get
  }
  public var identifier: Swift.String {
    get
  }
  public func secondsFromGMT(for date: Foundation.Date = Date()) -> Swift.Int
  public func abbreviation(for date: Foundation.Date = Date()) -> Swift.String?
  public func isDaylightSavingTime(for date: Foundation.Date = Date()) -> Swift.Bool
  public func daylightSavingTimeOffset(for date: Foundation.Date = Date()) -> Foundation.TimeInterval
  public func nextDaylightSavingTimeTransition(after date: Foundation.Date) -> Foundation.Date?
  public static var abbreviationDictionary: [Swift.String : Swift.String] {
    get
    set
  }
  public var nextDaylightSavingTimeTransition: Foundation.Date? {
    get
  }
  public func localizedName(for style: Foundation.TimeZone.NameStyle, locale: Foundation.Locale?) -> Swift.String?
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_alwaysEmitIntoClient @_disfavoredOverload public static var gmt: Foundation.TimeZone {
    get { TimeZone(secondsFromGMT: 0)! }
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.TimeZone, rhs: Foundation.TimeZone) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.TimeZone {
  public typealias NameStyle = Foundation.NSTimeZone.NameStyle
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.TimeZone : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.TimeZone : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.TimeZone : Foundation.ReferenceConvertible, Swift._ObjectiveCBridgeable {
  public typealias ReferenceType = Foundation.NSTimeZone
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSTimeZone
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSTimeZone, result: inout Foundation.TimeZone?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSTimeZone, result: inout Foundation.TimeZone?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSTimeZone?) -> Foundation.TimeZone
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSTimeZone
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSTimeZone : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct URLResourceValues {
  public init()
  public var allValues: [Foundation.URLResourceKey : Any] {
    get
  }
  public var name: Swift.String? {
    get
    set
  }
  public var localizedName: Swift.String? {
    get
  }
  public var isRegularFile: Swift.Bool? {
    get
  }
  public var isDirectory: Swift.Bool? {
    get
  }
  public var isSymbolicLink: Swift.Bool? {
    get
  }
  public var isVolume: Swift.Bool? {
    get
  }
  public var isPackage: Swift.Bool? {
    get
    set
  }
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public var isApplication: Swift.Bool? {
    get
  }
  @available(macOS 10.11, *)
  public var applicationIsScriptable: Swift.Bool? {
    get
  }
  public var isSystemImmutable: Swift.Bool? {
    get
  }
  public var isUserImmutable: Swift.Bool? {
    get
    set
  }
  public var isHidden: Swift.Bool? {
    get
    set
  }
  public var hasHiddenExtension: Swift.Bool? {
    get
    set
  }
  public var creationDate: Foundation.Date? {
    get
    set
  }
  public var contentAccessDate: Foundation.Date? {
    get
    set
  }
  public var contentModificationDate: Foundation.Date? {
    get
    set
  }
  public var attributeModificationDate: Foundation.Date? {
    get
  }
  public var linkCount: Swift.Int? {
    get
  }
  public var parentDirectory: Foundation.URL? {
    get
  }
  public var volume: Foundation.URL? {
    get
  }
  @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use .contentType instead")
  @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use .contentType instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use .contentType instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use .contentType instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use .contentType instead")
  public var typeIdentifier: Swift.String? {
    get
  }
  public var localizedTypeDescription: Swift.String? {
    get
  }
  public var labelNumber: Swift.Int? {
    get
    set
  }
  public var localizedLabel: Swift.String? {
    get
  }
  public var fileResourceIdentifier: (any Foundation.NSCopying & Foundation.NSSecureCoding & ObjectiveC.NSObjectProtocol)? {
    get
  }
  public var volumeIdentifier: (any Foundation.NSCopying & Foundation.NSSecureCoding & ObjectiveC.NSObjectProtocol)? {
    get
  }
  @available(macOS 13.3, iOS 16.4, tvOS 16.4, watchOS 9.4, *)
  public var fileIdentifier: Swift.UInt64? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var fileContentIdentifier: Swift.Int64? {
    get
  }
  public var preferredIOBlockSize: Swift.Int? {
    get
  }
  public var isReadable: Swift.Bool? {
    get
  }
  public var isWritable: Swift.Bool? {
    get
  }
  public var isExecutable: Swift.Bool? {
    get
  }
  public var fileSecurity: Foundation.NSFileSecurity? {
    get
    set
  }
  public var isExcludedFromBackup: Swift.Bool? {
    get
    set
  }
  public var tagNames: [Swift.String]? {
    get
  }
  public var path: Swift.String? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var canonicalPath: Swift.String? {
    get
  }
  public var isMountTrigger: Swift.Bool? {
    get
  }
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public var generationIdentifier: (any Foundation.NSCopying & Foundation.NSSecureCoding & ObjectiveC.NSObjectProtocol)? {
    get
  }
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public var documentIdentifier: Swift.Int? {
    get
  }
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public var addedToDirectoryDate: Foundation.Date? {
    get
  }
  @available(macOS 10.10, *)
  public var quarantineProperties: [Swift.String : Any]? {
    get
    set
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var mayHaveExtendedAttributes: Swift.Bool? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var isPurgeable: Swift.Bool? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var isSparse: Swift.Bool? {
    get
  }
  @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
  public var mayShareFileContent: Swift.Bool? {
    get
  }
  public var fileResourceType: Foundation.URLFileResourceType? {
    get
  }
  @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
  public var directoryEntryCount: Swift.Int? {
    get
  }
  public var volumeLocalizedFormatDescription: Swift.String? {
    get
  }
  public var volumeTotalCapacity: Swift.Int? {
    get
  }
  public var volumeAvailableCapacity: Swift.Int? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var volumeAvailableCapacityForImportantUsage: Swift.Int64? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var volumeAvailableCapacityForOpportunisticUsage: Swift.Int64? {
    get
  }
  public var volumeResourceCount: Swift.Int? {
    get
  }
  public var volumeSupportsPersistentIDs: Swift.Bool? {
    get
  }
  public var volumeSupportsSymbolicLinks: Swift.Bool? {
    get
  }
  public var volumeSupportsHardLinks: Swift.Bool? {
    get
  }
  public var volumeSupportsJournaling: Swift.Bool? {
    get
  }
  public var volumeIsJournaling: Swift.Bool? {
    get
  }
  public var volumeSupportsSparseFiles: Swift.Bool? {
    get
  }
  public var volumeSupportsZeroRuns: Swift.Bool? {
    get
  }
  public var volumeSupportsCaseSensitiveNames: Swift.Bool? {
    get
  }
  public var volumeSupportsCasePreservedNames: Swift.Bool? {
    get
  }
  public var volumeSupportsRootDirectoryDates: Swift.Bool? {
    get
  }
  public var volumeSupportsVolumeSizes: Swift.Bool? {
    get
  }
  public var volumeSupportsRenaming: Swift.Bool? {
    get
  }
  public var volumeSupportsAdvisoryFileLocking: Swift.Bool? {
    get
  }
  public var volumeSupportsExtendedSecurity: Swift.Bool? {
    get
  }
  public var volumeIsBrowsable: Swift.Bool? {
    get
  }
  public var volumeMaximumFileSize: Swift.Int? {
    get
  }
  public var volumeIsEjectable: Swift.Bool? {
    get
  }
  public var volumeIsRemovable: Swift.Bool? {
    get
  }
  public var volumeIsInternal: Swift.Bool? {
    get
  }
  public var volumeIsAutomounted: Swift.Bool? {
    get
  }
  public var volumeIsLocal: Swift.Bool? {
    get
  }
  public var volumeIsReadOnly: Swift.Bool? {
    get
  }
  public var volumeCreationDate: Foundation.Date? {
    get
  }
  public var volumeURLForRemounting: Foundation.URL? {
    get
  }
  public var volumeUUIDString: Swift.String? {
    get
  }
  public var volumeName: Swift.String? {
    get
    set
  }
  public var volumeLocalizedName: Swift.String? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeIsEncrypted: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeIsRootFileSystem: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsCompression: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsFileCloning: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsSwapRenaming: Swift.Bool? {
    get
  }
  @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
  public var volumeSupportsExclusiveRenaming: Swift.Bool? {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public var volumeSupportsImmutableFiles: Swift.Bool? {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public var volumeSupportsAccessPermissions: Swift.Bool? {
    get
  }
  @available(macOS 13.3, iOS 16.4, tvOS 16.4, watchOS 9.4, *)
  public var volumeTypeName: Swift.String? {
    get
  }
  @available(macOS 13.3, iOS 16.4, tvOS 16.4, watchOS 9.4, *)
  public var volumeSubtype: Swift.Int? {
    get
  }
  @available(macOS 13.3, iOS 16.4, tvOS 16.4, watchOS 9.4, *)
  public var volumeMountFromLocation: Swift.String? {
    get
  }
  public var isUbiquitousItem: Swift.Bool? {
    get
  }
  public var ubiquitousItemHasUnresolvedConflicts: Swift.Bool? {
    get
  }
  public var ubiquitousItemIsDownloading: Swift.Bool? {
    get
  }
  public var ubiquitousItemIsUploaded: Swift.Bool? {
    get
  }
  public var ubiquitousItemIsUploading: Swift.Bool? {
    get
  }
  public var ubiquitousItemDownloadingStatus: Foundation.URLUbiquitousItemDownloadingStatus? {
    get
  }
  public var ubiquitousItemDownloadingError: Foundation.NSError? {
    get
  }
  public var ubiquitousItemUploadingError: Foundation.NSError? {
    get
  }
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public var ubiquitousItemDownloadRequested: Swift.Bool? {
    get
  }
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public var ubiquitousItemContainerDisplayName: Swift.String? {
    get
  }
  @available(macOS 11.3, iOS 14.5, watchOS 7.4, tvOS 14.5, *)
  public var ubiquitousItemIsExcludedFromSync: Swift.Bool? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousItemIsShared: Swift.Bool? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemCurrentUserRole: Foundation.URLUbiquitousSharedItemRole? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemCurrentUserPermissions: Foundation.URLUbiquitousSharedItemPermissions? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemOwnerNameComponents: Foundation.PersonNameComponents? {
    get
  }
  @available(macOS 10.13, iOS 11.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public var ubiquitousSharedItemMostRecentEditorNameComponents: Foundation.PersonNameComponents? {
    get
  }
  @available(macOS 11.0, iOS 9.0, *)
  public var fileProtection: Foundation.URLFileProtection? {
    get
  }
  public var fileSize: Swift.Int? {
    get
  }
  public var fileAllocatedSize: Swift.Int? {
    get
  }
  public var totalFileSize: Swift.Int? {
    get
  }
  public var totalFileAllocatedSize: Swift.Int? {
    get
  }
  public var isAliasFile: Swift.Bool? {
    get
  }
}
@available(macOS, unavailable, introduced: 10.10)
@available(iOS, unavailable, introduced: 8.0)
@available(tvOS, unavailable, introduced: 9.0)
@available(watchOS, unavailable, introduced: 2.0)
@available(*, unavailable)
extension Foundation.URLResourceValues : Swift.Sendable {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct URL : Swift.Equatable, Swift.Sendable, Swift.Hashable {
  public typealias BookmarkResolutionOptions = Foundation.NSURL.BookmarkResolutionOptions
  public typealias BookmarkCreationOptions = Foundation.NSURL.BookmarkCreationOptions
  public init?(string: __shared Swift.String)
  public init?(string: __shared Swift.String, relativeTo url: __shared Foundation.URL?)
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public init?(string: __shared Swift.String, encodingInvalidCharacters: Swift.Bool)
  @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  public init(fileURLWithPath path: __shared Swift.String, isDirectory: Swift.Bool, relativeTo base: __shared Foundation.URL?)
  @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  public init(fileURLWithPath path: __shared Swift.String, relativeTo base: __shared Foundation.URL?)
  @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  public init(fileURLWithPath path: __shared Swift.String, isDirectory: Swift.Bool)
  @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
  public init(fileURLWithPath path: __shared Swift.String)
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public init?(dataRepresentation: __shared Foundation.Data, relativeTo base: __shared Foundation.URL?, isAbsolute: Swift.Bool = false)
  @available(swift, obsoleted: 4.2)
  public init?(resolvingBookmarkData data: __shared Foundation.Data, options: Foundation.URL.BookmarkResolutionOptions = [], relativeTo url: __shared Foundation.URL? = nil, bookmarkDataIsStale: inout Swift.Bool) throws
  @available(swift 4.2)
  public init(resolvingBookmarkData data: __shared Foundation.Data, options: Foundation.URL.BookmarkResolutionOptions = [], relativeTo url: __shared Foundation.URL? = nil, bookmarkDataIsStale: inout Swift.Bool) throws
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public init(resolvingAliasFileAt url: __shared Foundation.URL, options: Foundation.URL.BookmarkResolutionOptions = []) throws
  public init(fileURLWithFileSystemRepresentation path: Swift.UnsafePointer<Swift.Int8>, isDirectory: Swift.Bool, relativeTo baseURL: __shared Foundation.URL?)
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public var dataRepresentation: Foundation.Data {
    get
  }
  public var absoluteString: Swift.String {
    get
  }
  public var relativeString: Swift.String {
    get
  }
  public var baseURL: Foundation.URL? {
    get
  }
  public var absoluteURL: Foundation.URL {
    get
  }
  public var scheme: Swift.String? {
    get
  }
  public var isFileURL: Swift.Bool {
    get
  }
  @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use host(percentEncoded:) instead")
  @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use host(percentEncoded:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use host(percentEncoded:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use host(percentEncoded:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use host(percentEncoded:) instead")
  public var host: Swift.String? {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func host(percentEncoded: Swift.Bool = true) -> Swift.String?
  public var port: Swift.Int? {
    get
  }
  @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use user(percentEncoded:) instead")
  @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use user(percentEncoded:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use user(percentEncoded:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use user(percentEncoded:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use user(percentEncoded:) instead")
  public var user: Swift.String? {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func user(percentEncoded: Swift.Bool = true) -> Swift.String?
  @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use password(percentEncoded:) instead")
  @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use password(percentEncoded:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use password(percentEncoded:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use password(percentEncoded:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use password(percentEncoded:) instead")
  public var password: Swift.String? {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func password(percentEncoded: Swift.Bool = true) -> Swift.String?
  @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use path(percentEncoded:) instead")
  @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use path(percentEncoded:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use path(percentEncoded:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use path(percentEncoded:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use path(percentEncoded:) instead")
  public var path: Swift.String {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func path(percentEncoded: Swift.Bool = true) -> Swift.String
  public var relativePath: Swift.String {
    get
  }
  @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use query(percentEncoded:) instead")
  @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use query(percentEncoded:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use query(percentEncoded:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use query(percentEncoded:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use query(percentEncoded:) instead")
  public var query: Swift.String? {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func query(percentEncoded: Swift.Bool = true) -> Swift.String?
  @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use fragment(percentEncoded:) instead")
  @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use fragment(percentEncoded:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use fragment(percentEncoded:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use fragment(percentEncoded:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use fragment(percentEncoded:) instead")
  public var fragment: Swift.String? {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func fragment(percentEncoded: Swift.Bool = true) -> Swift.String?
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public func withUnsafeFileSystemRepresentation<ResultType>(_ block: (Swift.UnsafePointer<Swift.Int8>?) throws -> ResultType) rethrows -> ResultType
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public var hasDirectoryPath: Swift.Bool {
    get
  }
  public var pathComponents: [Swift.String] {
    get
  }
  public var lastPathComponent: Swift.String {
    get
  }
  public var pathExtension: Swift.String {
    get
  }
  @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  public func appendingPathComponent(_ pathComponent: Swift.String, isDirectory: Swift.Bool) -> Foundation.URL
  @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
  public func appendingPathComponent(_ pathComponent: Swift.String) -> Foundation.URL
  public func deletingLastPathComponent() -> Foundation.URL
  public func appendingPathExtension(_ pathExtension: Swift.String) -> Foundation.URL
  public func deletingPathExtension() -> Foundation.URL
  @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  public mutating func appendPathComponent(_ pathComponent: Swift.String, isDirectory: Swift.Bool)
  @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
  public mutating func appendPathComponent(_ pathComponent: Swift.String)
  public mutating func appendPathExtension(_ pathExtension: Swift.String)
  public mutating func deleteLastPathComponent()
  public mutating func deletePathExtension()
  public var standardized: Foundation.URL {
    get
  }
  public mutating func standardize()
  public var standardizedFileURL: Foundation.URL {
    get
  }
  public func resolvingSymlinksInPath() -> Foundation.URL
  public mutating func resolveSymlinksInPath()
  public func checkResourceIsReachable() throws -> Swift.Bool
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public func checkPromisedItemIsReachable() throws -> Swift.Bool
  public mutating func setResourceValues(_ values: Foundation.URLResourceValues) throws
  public func resourceValues(forKeys keys: Swift.Set<Foundation.URLResourceKey>) throws -> Foundation.URLResourceValues
  @preconcurrency public mutating func setTemporaryResourceValue(_ value: any Swift.Sendable, forKey key: Foundation.URLResourceKey)
  public mutating func removeAllCachedResourceValues()
  public mutating func removeCachedResourceValue(forKey key: Foundation.URLResourceKey)
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public func promisedItemResourceValues(forKeys keys: Swift.Set<Foundation.URLResourceKey>) throws -> Foundation.URLResourceValues
  public func bookmarkData(options: Foundation.URL.BookmarkCreationOptions = [], includingResourceValuesForKeys keys: Swift.Set<Foundation.URLResourceKey>? = nil, relativeTo url: Foundation.URL? = nil) throws -> Foundation.Data
  public static func resourceValues(forKeys keys: Swift.Set<Foundation.URLResourceKey>, fromBookmarkData data: Foundation.Data) -> Foundation.URLResourceValues?
  public static func writeBookmarkData(_ data: Foundation.Data, to url: Foundation.URL) throws
  public static func bookmarkData(withContentsOf url: Foundation.URL) throws -> Foundation.Data
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public func startAccessingSecurityScopedResource() -> Swift.Bool
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public func stopAccessingSecurityScopedResource()
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.URL, rhs: Foundation.URL) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.URL {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public init(filePath path: Swift.String, directoryHint: Foundation.URL.DirectoryHint = .inferFromPath, relativeTo base: Foundation.URL? = nil)
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func appending<S>(path: S, directoryHint: Foundation.URL.DirectoryHint = .inferFromPath) -> Foundation.URL where S : Swift.StringProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public mutating func append<S>(path: S, directoryHint: Foundation.URL.DirectoryHint = .inferFromPath) where S : Swift.StringProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func appending<S>(component: S, directoryHint: Foundation.URL.DirectoryHint = .inferFromPath) -> Foundation.URL where S : Swift.StringProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public mutating func append<S>(component: S, directoryHint: Foundation.URL.DirectoryHint = .inferFromPath) where S : Swift.StringProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func appending(queryItems: [Foundation.URLQueryItem]) -> Foundation.URL
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public mutating func append(queryItems: [Foundation.URLQueryItem])
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public func appending<S>(components: S..., directoryHint: Foundation.URL.DirectoryHint = .inferFromPath) -> Foundation.URL where S : Swift.StringProtocol
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public mutating func append<S>(components: S..., directoryHint: Foundation.URL.DirectoryHint = .inferFromPath) where S : Swift.StringProtocol
}
extension Foundation.URL {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static func currentDirectory() -> Foundation.URL
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var homeDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static func homeDirectory(forUser user: Swift.String) -> Foundation.URL?
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var temporaryDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var cachesDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var applicationDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var libraryDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var userDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var documentsDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var desktopDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var applicationSupportDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var downloadsDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var moviesDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var musicDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var picturesDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public static var sharedPublicDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, *)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  public static var trashDirectory: Foundation.URL {
    get
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public init(for directory: Foundation.FileManager.SearchPathDirectory, in domain: Foundation.FileManager.SearchPathDomainMask, appropriateFor url: Foundation.URL? = nil, create shouldCreate: Swift.Bool = false) throws
}
extension Foundation.URL {
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public enum DirectoryHint : Swift.Sendable {
    case isDirectory
    case notDirectory
    case checkFileSystem
    case inferFromPath
    public static func == (a: Foundation.URL.DirectoryHint, b: Foundation.URL.DirectoryHint) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.URL : Foundation.ReferenceConvertible, Swift._ObjectiveCBridgeable {
  public typealias ReferenceType = Foundation.NSURL
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSURL
  public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSURL, result: inout Foundation.URL?)
  public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSURL, result: inout Foundation.URL?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSURL?) -> Foundation.URL
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSURL
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.URL : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSURL : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.URL : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "URL.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.URL : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.URL : Swift._ExpressibleByFileReferenceLiteral {
  public init(fileReferenceLiteralResourceName name: Swift.String)
}
public typealias _FileReferenceLiteralType = Foundation.URL
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct URLComponents : Swift.Hashable, Swift.Equatable, Swift.Sendable {
  public init()
  public init?(url: __shared Foundation.URL, resolvingAgainstBaseURL resolve: Swift.Bool)
  public init?(string: __shared Swift.String)
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public init?(string: __shared Swift.String, encodingInvalidCharacters: Swift.Bool)
  public var url: Foundation.URL? {
    get
  }
  public func url(relativeTo base: Foundation.URL?) -> Foundation.URL?
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public var string: Swift.String? {
    get
  }
  public var scheme: Swift.String? {
    get
    set
  }
  public var user: Swift.String? {
    get
    set
  }
  public var password: Swift.String? {
    get
    set
  }
  public var host: Swift.String? {
    get
    set
  }
  public var port: Swift.Int? {
    get
    set
  }
  public var path: Swift.String {
    get
    set
  }
  public var query: Swift.String? {
    get
    set
  }
  public var fragment: Swift.String? {
    get
    set
  }
  public var percentEncodedUser: Swift.String? {
    get
    set
  }
  public var percentEncodedPassword: Swift.String? {
    get
    set
  }
  @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use encodedHost instead")
  @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use encodedHost instead")
  @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use encodedHost instead")
  @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use encodedHost instead")
  @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use encodedHost instead")
  public var percentEncodedHost: Swift.String? {
    get
    set
  }
  @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
  public var encodedHost: Swift.String? {
    get
    set
  }
  public var percentEncodedPath: Swift.String {
    get
    set
  }
  public var percentEncodedQuery: Swift.String? {
    get
    set
  }
  public var percentEncodedFragment: Swift.String? {
    get
    set
  }
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public var rangeOfScheme: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public var rangeOfUser: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public var rangeOfPassword: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public var rangeOfHost: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public var rangeOfPort: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public var rangeOfPath: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public var rangeOfQuery: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public var rangeOfFragment: Swift.Range<Swift.String.Index>? {
    get
  }
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public var queryItems: [Foundation.URLQueryItem]? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public var percentEncodedQueryItems: [Foundation.URLQueryItem]? {
    get
    set
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.URLComponents, rhs: Foundation.URLComponents) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.URLComponents : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.URLComponents : Foundation.ReferenceConvertible, Swift._ObjectiveCBridgeable {
  public typealias ReferenceType = Foundation.NSURLComponents
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSURLComponents
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSURLComponents, result: inout Foundation.URLComponents?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSURLComponents, result: inout Foundation.URLComponents?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSURLComponents?) -> Foundation.URLComponents
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSURLComponents
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSURLComponents : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct URLQueryItem : Swift.Hashable, Swift.Equatable, Swift.Sendable {
  public var name: Swift.String
  public var value: Swift.String?
  public init(name: __shared Swift.String, value: __shared Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public static func == (lhs: Foundation.URLQueryItem, rhs: Foundation.URLQueryItem) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.URLQueryItem : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.URLQueryItem : Foundation.ReferenceConvertible, Swift._ObjectiveCBridgeable {
  public typealias ReferenceType = Foundation.NSURLQueryItem
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSURLQueryItem
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSURLQueryItem, result: inout Foundation.URLQueryItem?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSURLQueryItem, result: inout Foundation.URLQueryItem?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSURLQueryItem?) -> Foundation.URLQueryItem
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSURLQueryItem
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSURLQueryItem : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.URLComponents : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.EncodingError : Foundation.LocalizedError {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.DecodingError : Foundation.LocalizedError {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.JSONEncoder : Combine.TopLevelEncoder {
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Output = Foundation.Data
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.PropertyListEncoder : Combine.TopLevelEncoder {
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Output = Foundation.Data
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.JSONDecoder : Combine.TopLevelDecoder {
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Input = Foundation.Data
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.PropertyListDecoder : Combine.TopLevelDecoder {
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Input = Foundation.Data
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol EncodingConfigurationProviding {
  associatedtype EncodingConfiguration
  static var encodingConfiguration: Self.EncodingConfiguration { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol EncodableWithConfiguration {
  associatedtype EncodingConfiguration
  func encode(to encoder: any Swift.Encoder, configuration: Self.EncodingConfiguration) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol DecodingConfigurationProviding {
  associatedtype DecodingConfiguration
  static var decodingConfiguration: Self.DecodingConfiguration { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol DecodableWithConfiguration {
  associatedtype DecodingConfiguration
  init(from decoder: any Swift.Decoder, configuration: Self.DecodingConfiguration) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public typealias CodableWithConfiguration = Foundation.DecodableWithConfiguration & Foundation.EncodableWithConfiguration
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.KeyedEncodingContainer {
  public mutating func encode<T, C>(_ wrapper: Foundation.CodableConfiguration<T?, C>, forKey key: Swift.KeyedEncodingContainer<K>.Key) throws where T : Foundation.DecodableWithConfiguration, T : Foundation.EncodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, C : Foundation.EncodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration, T.EncodingConfiguration == C.EncodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.KeyedDecodingContainer {
  public func decode<T, C>(_: Foundation.CodableConfiguration<T?, C>.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> Foundation.CodableConfiguration<T?, C> where T : Foundation.DecodableWithConfiguration, T : Foundation.EncodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, C : Foundation.EncodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration, T.EncodingConfiguration == C.EncodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.KeyedEncodingContainer {
  public mutating func encode<T, C>(_ t: T, forKey key: Swift.KeyedEncodingContainer<K>.Key, configuration: C.Type) throws where T : Foundation.EncodableWithConfiguration, C : Foundation.EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration
  public mutating func encodeIfPresent<T, C>(_ t: T?, forKey key: Swift.KeyedEncodingContainer<K>.Key, configuration: C.Type) throws where T : Foundation.EncodableWithConfiguration, C : Foundation.EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration
  public mutating func encode<T>(_ t: T, forKey key: Swift.KeyedEncodingContainer<K>.Key, configuration: T.EncodingConfiguration) throws where T : Foundation.EncodableWithConfiguration
  public mutating func encodeIfPresent<T>(_ t: T?, forKey key: Swift.KeyedEncodingContainer<K>.Key, configuration: T.EncodingConfiguration) throws where T : Foundation.EncodableWithConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.KeyedDecodingContainer {
  public func decode<T, C>(_: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key, configuration: C.Type) throws -> T where T : Foundation.DecodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  public func decodeIfPresent<T, C>(_: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key, configuration: C.Type) throws -> T? where T : Foundation.DecodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  public func decode<T>(_: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key, configuration: T.DecodingConfiguration) throws -> T where T : Foundation.DecodableWithConfiguration
  public func decodeIfPresent<T>(_: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key, configuration: T.DecodingConfiguration) throws -> T? where T : Foundation.DecodableWithConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UnkeyedEncodingContainer {
  public mutating func encode<T, C>(_ t: T, configuration: C.Type) throws where T : Foundation.EncodableWithConfiguration, C : Foundation.EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration
  public mutating func encode<T>(_ t: T, configuration: T.EncodingConfiguration) throws where T : Foundation.EncodableWithConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UnkeyedDecodingContainer {
  public mutating func decode<T, C>(_: T.Type, configuration: C.Type) throws -> T where T : Foundation.DecodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  public mutating func decodeIfPresent<T, C>(_: T.Type, configuration: C.Type) throws -> T? where T : Foundation.DecodableWithConfiguration, C : Foundation.DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration
  public mutating func decode<T>(_: T.Type, configuration: T.DecodingConfiguration) throws -> T where T : Foundation.DecodableWithConfiguration
  public mutating func decodeIfPresent<T>(_: T.Type, configuration: T.DecodingConfiguration) throws -> T? where T : Foundation.DecodableWithConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@propertyWrapper public struct CodableConfiguration<T, ConfigurationProvider> : Swift.Codable where T : Foundation.DecodableWithConfiguration, T : Foundation.EncodableWithConfiguration, ConfigurationProvider : Foundation.DecodingConfigurationProviding, ConfigurationProvider : Foundation.EncodingConfigurationProviding, T.DecodingConfiguration == ConfigurationProvider.DecodingConfiguration, T.EncodingConfiguration == ConfigurationProvider.EncodingConfiguration {
  public var wrappedValue: T
  public init(wrappedValue: T)
  public init(wrappedValue: T, from configurationProvider: ConfigurationProvider.Type)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.CodableConfiguration : Swift.Sendable where T : Swift.Sendable {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.CodableConfiguration : Swift.Equatable where T : Swift.Equatable {
  public static func == (a: Foundation.CodableConfiguration<T, ConfigurationProvider>, b: Foundation.CodableConfiguration<T, ConfigurationProvider>) -> Swift.Bool
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.CodableConfiguration : Swift.Hashable where T : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Optional : Foundation.EncodableWithConfiguration where Wrapped : Foundation.EncodableWithConfiguration {
  public func encode(to encoder: any Swift.Encoder, configuration: Wrapped.EncodingConfiguration) throws
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias EncodingConfiguration = Wrapped.EncodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Optional : Foundation.DecodableWithConfiguration where Wrapped : Foundation.DecodableWithConfiguration {
  public init(from decoder: any Swift.Decoder, configuration: Wrapped.DecodingConfiguration) throws
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias DecodingConfiguration = Wrapped.DecodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Array : Foundation.EncodableWithConfiguration where Element : Foundation.EncodableWithConfiguration {
  public func encode(to encoder: any Swift.Encoder, configuration: Element.EncodingConfiguration) throws
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias EncodingConfiguration = Element.EncodingConfiguration
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Array : Foundation.DecodableWithConfiguration where Element : Foundation.DecodableWithConfiguration {
  public init(from decoder: any Swift.Decoder, configuration: Element.DecodingConfiguration) throws
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias DecodingConfiguration = Element.DecodingConfiguration
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.ComparisonResult : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct Date : Swift.Comparable, Swift.Hashable, Swift.Equatable, Swift.Sendable {
  public static let timeIntervalBetween1970AndReferenceDate: Swift.Double
  public static var timeIntervalSinceReferenceDate: Foundation.TimeInterval {
    get
  }
  public init()
  public init(timeIntervalSinceNow: Foundation.TimeInterval)
  public init(timeIntervalSince1970: Foundation.TimeInterval)
  public init(timeInterval: Foundation.TimeInterval, since date: Foundation.Date)
  public init(timeIntervalSinceReferenceDate ti: Foundation.TimeInterval)
  public var timeIntervalSinceReferenceDate: Foundation.TimeInterval {
    get
  }
  public func timeIntervalSince(_ date: Foundation.Date) -> Foundation.TimeInterval
  public var timeIntervalSinceNow: Foundation.TimeInterval {
    get
  }
  public var timeIntervalSince1970: Foundation.TimeInterval {
    get
  }
  public func addingTimeInterval(_ timeInterval: Foundation.TimeInterval) -> Foundation.Date
  public mutating func addTimeInterval(_ timeInterval: Foundation.TimeInterval)
  public static let distantFuture: Foundation.Date
  public static let distantPast: Foundation.Date
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public static var now: Foundation.Date {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public func compare(_ other: Foundation.Date) -> Foundation.ComparisonResult
  public static func == (lhs: Foundation.Date, rhs: Foundation.Date) -> Swift.Bool
  public static func < (lhs: Foundation.Date, rhs: Foundation.Date) -> Swift.Bool
  public static func > (lhs: Foundation.Date, rhs: Foundation.Date) -> Swift.Bool
  public static func + (lhs: Foundation.Date, rhs: Foundation.TimeInterval) -> Foundation.Date
  public static func - (lhs: Foundation.Date, rhs: Foundation.TimeInterval) -> Foundation.Date
  public static func += (lhs: inout Foundation.Date, rhs: Foundation.TimeInterval)
  public static func -= (lhs: inout Foundation.Date, rhs: Foundation.TimeInterval)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Date : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible, Swift.CustomReflectable {
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Date : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Date : Foundation.ReferenceConvertible, Swift._ObjectiveCBridgeable {
  public typealias ReferenceType = Foundation.NSDate
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDate
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSDate, result: inout Foundation.Date?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSDate, result: inout Foundation.Date?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSDate?) -> Foundation.Date
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSDate
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSDate : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Date : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "Date.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.Date {
  public typealias Stride = Foundation.TimeInterval
  public func distance(to other: Foundation.Date) -> Foundation.TimeInterval
  public func advanced(by n: Foundation.TimeInterval) -> Foundation.Date
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Date : Swift.Strideable {
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
public struct DateInterval : Swift.Comparable, Swift.Hashable, Swift.Codable, Swift.Sendable {
  public var start: Foundation.Date
  public var end: Foundation.Date {
    get
    set
  }
  public var duration: Foundation.TimeInterval {
    get
    set
  }
  public init()
  public init(start: Foundation.Date, end: Foundation.Date)
  public init(start: Foundation.Date, duration: Foundation.TimeInterval)
  public func compare(_ dateInterval: Foundation.DateInterval) -> Foundation.ComparisonResult
  public func intersects(_ dateInterval: Foundation.DateInterval) -> Swift.Bool
  public func intersection(with dateInterval: Foundation.DateInterval) -> Foundation.DateInterval?
  public func contains(_ date: Foundation.Date) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static func == (lhs: Foundation.DateInterval, rhs: Foundation.DateInterval) -> Swift.Bool
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static func < (lhs: Foundation.DateInterval, rhs: Foundation.DateInterval) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.DateInterval : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.DateInterval : Foundation.ReferenceConvertible, Swift._ObjectiveCBridgeable {
  public typealias ReferenceType = Foundation.NSDateInterval
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDateInterval
  public static func _forceBridgeFromObjectiveC(_ dateInterval: Foundation.NSDateInterval, result: inout Foundation.DateInterval?)
  public static func _conditionallyBridgeFromObjectiveC(_ dateInterval: Foundation.NSDateInterval, result: inout Foundation.DateInterval?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSDateInterval?) -> Foundation.DateInterval
  @available(iOS 10.0, tvOS 10.0, watchOS 3.0, macOS 10.12, *)
  public typealias _ObjectiveCType = Foundation.NSDateInterval
}
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Foundation.NSDateInterval : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct IndexPath : Swift.Equatable, Swift.Hashable, Swift.MutableCollection, Swift.RandomAccessCollection, Swift.Comparable, Swift.ExpressibleByArrayLiteral, Swift.Sendable {
  public typealias Element = Swift.Int
  public typealias Index = Swift.Array<Swift.Int>.Index
  public typealias Indices = Swift.DefaultIndices<Foundation.IndexPath>
  public init()
  public init<ElementSequence>(indexes: ElementSequence) where ElementSequence : Swift.Sequence, ElementSequence.Element == Swift.Int
  public init(arrayLiteral indexes: Foundation.IndexPath.Element...)
  public init(indexes: Swift.Array<Foundation.IndexPath.Element>)
  public init(index: Foundation.IndexPath.Element)
  public func dropLast() -> Foundation.IndexPath
  public mutating func append(_ other: Foundation.IndexPath)
  public mutating func append(_ other: Foundation.IndexPath.Element)
  public mutating func append(_ other: Swift.Array<Foundation.IndexPath.Element>)
  public func appending(_ other: Foundation.IndexPath.Element) -> Foundation.IndexPath
  public func appending(_ other: Foundation.IndexPath) -> Foundation.IndexPath
  public func appending(_ other: Swift.Array<Foundation.IndexPath.Element>) -> Foundation.IndexPath
  public subscript(index: Foundation.IndexPath.Index) -> Foundation.IndexPath.Element {
    get
    set
  }
  public subscript(range: Swift.Range<Foundation.IndexPath.Index>) -> Foundation.IndexPath {
    get
    set
  }
  public func makeIterator() -> Swift.IndexingIterator<Foundation.IndexPath>
  public var count: Swift.Int {
    get
  }
  public var startIndex: Foundation.IndexPath.Index {
    get
  }
  public var endIndex: Foundation.IndexPath.Index {
    get
  }
  public func index(before i: Foundation.IndexPath.Index) -> Foundation.IndexPath.Index
  public func index(after i: Foundation.IndexPath.Index) -> Foundation.IndexPath.Index
  public func compare(_ other: Foundation.IndexPath) -> Foundation.ComparisonResult
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public static func + (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Foundation.IndexPath
  public static func += (lhs: inout Foundation.IndexPath, rhs: Foundation.IndexPath)
  public static func < (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public static func <= (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public static func > (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  public static func >= (lhs: Foundation.IndexPath, rhs: Foundation.IndexPath) -> Swift.Bool
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias ArrayLiteralElement = Foundation.IndexPath.Element
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Iterator = Swift.IndexingIterator<Foundation.IndexPath>
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias SubSequence = Foundation.IndexPath
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.IndexPath : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.IndexPath : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.IndexPath : Foundation.ReferenceConvertible {
  public typealias ReferenceType = Foundation.NSIndexPath
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSIndexPath : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.IndexPath : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSIndexPath
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSIndexPath, result: inout Foundation.IndexPath?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSIndexPath, result: inout Foundation.IndexPath?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSIndexPath?) -> Foundation.IndexPath
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSIndexPath
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@preconcurrency public protocol SortComparator<Compared> : Swift.Hashable, Swift.Sendable {
  associatedtype Compared
  func compare(_ lhs: Self.Compared, _ rhs: Self.Compared) -> Foundation.ComparisonResult
  var order: Foundation.SortOrder { get set }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@frozen public enum SortOrder : Swift.Hashable, Swift.Codable, Swift.Sendable {
  case forward
  case reverse
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: Foundation.SortOrder, b: Foundation.SortOrder) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct ComparableComparator<Compared> : Foundation.SortComparator, Swift.Sendable where Compared : Swift.Comparable {
  public var order: Foundation.SortOrder
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public init(order: Foundation.SortOrder = .forward)
  public func compare(_ lhs: Compared, _ rhs: Compared) -> Foundation.ComparisonResult
  public static func == (a: Foundation.ComparableComparator<Compared>, b: Foundation.ComparableComparator<Compared>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Never : Foundation.SortComparator {
  public typealias Compared = Swift.Never
  public func compare(_ lhs: Swift.Never, _ rhs: Swift.Never) -> Foundation.ComparisonResult
  public var order: Foundation.SortOrder {
    get
    set
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Sequence {
  public func sorted<Comparator>(using comparator: Comparator) -> [Self.Element] where Comparator : Foundation.SortComparator, Self.Element == Comparator.Compared
  public func sorted<S, Comparator>(using comparators: S) -> [Self.Element] where S : Swift.Sequence, Comparator : Foundation.SortComparator, Comparator == S.Element, Self.Element == Comparator.Compared
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.Sequence {
  public func compare<Comparator>(_ lhs: Comparator.Compared, _ rhs: Comparator.Compared) -> Foundation.ComparisonResult where Comparator : Foundation.SortComparator, Comparator == Self.Element
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Swift.MutableCollection where Self : Swift.RandomAccessCollection {
  public mutating func sort<Comparator>(using comparator: Comparator) where Comparator : Foundation.SortComparator, Self.Element == Comparator.Compared
  public mutating func sort<S, Comparator>(using comparators: S) where S : Swift.Sequence, Comparator : Foundation.SortComparator, Comparator == S.Element, Self.Element == Comparator.Compared
}
public typealias uuid_t = (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8)
public typealias uuid_string_t = (Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8, Swift.Int8)
@available(macOS 10.8, iOS 6.0, tvOS 9.0, watchOS 2.0, *)
public struct UUID : Swift.Hashable, Swift.Equatable, Swift.CustomStringConvertible, Swift.Sendable {
  public var uuid: (Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8, Swift.UInt8) {
    get
  }
  public init()
  public init?(uuidString string: __shared Swift.String)
  public init(uuid: Foundation.uuid_t)
  public var uuidString: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public static func == (lhs: Foundation.UUID, rhs: Foundation.UUID) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.8, iOS 6.0, tvOS 9.0, watchOS 2.0, *)
extension Foundation.UUID : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.8, iOS 6.0, tvOS 9.0, watchOS 2.0, *)
extension Foundation.UUID : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.UUID : Swift.Comparable {
  @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
  public static func < (lhs: Foundation.UUID, rhs: Foundation.UUID) -> Swift.Bool
}
@available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *)
extension Foundation.UUID : Foundation.ReferenceConvertible {
  public typealias ReferenceType = Foundation.NSUUID
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSUUID
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSUUID, result: inout Foundation.UUID?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSUUID, result: inout Foundation.UUID?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSUUID?) -> Foundation.UUID
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSUUID
}
@available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *)
extension Foundation.NSUUID : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
public typealias NSErrorPointer = Swift.AutoreleasingUnsafeMutablePointer<Foundation.NSError?>?
public typealias ErrorPointer = Foundation.NSErrorPointer
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func _convertNSErrorToError(_ error: Foundation.NSError?) -> any Swift.Error
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func _convertErrorToNSError(_ error: any Swift.Error) -> Foundation.NSError
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol RecoverableError : Swift.Error {
  var recoveryOptions: [Swift.String] { get }
  func attemptRecovery(optionIndex recoveryOptionIndex: Swift.Int, resultHandler handler: @escaping (_ recovered: Swift.Bool) -> Swift.Void)
  func attemptRecovery(optionIndex recoveryOptionIndex: Swift.Int) -> Swift.Bool
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.RecoverableError {
  public func attemptRecovery(optionIndex recoveryOptionIndex: Swift.Int, resultHandler handler: @escaping (_ recovered: Swift.Bool) -> Swift.Void)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.CustomNSError where Self : Swift.RawRepresentable, Self.RawValue : Swift.FixedWidthInteger {
  public var errorCode: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func _getErrorDefaultUserInfo<T>(_ error: T) -> Swift.AnyObject? where T : Swift.Error
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSError : Swift.Error {
  @nonobjc public var _domain: Swift.String {
    get
  }
  @nonobjc public var _code: Swift.Int {
    get
  }
  @nonobjc public var _userInfo: Swift.AnyObject? {
    get
  }
  @nonobjc public func _getEmbeddedNSError() -> Swift.AnyObject?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CoreFoundation.CFError : Swift.Error, @unchecked Swift.Sendable {
  public var _domain: Swift.String {
    get
  }
  public var _code: Swift.Int {
    get
  }
  public var _userInfo: Swift.AnyObject? {
    get
  }
  public func _getEmbeddedNSError() -> Swift.AnyObject?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol _ObjectiveCBridgeableError : Swift.Error {
  init?(_bridgedNSError: __shared Foundation.NSError)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func _bridgeNSErrorToError<T>(_ error: Foundation.NSError, out: Swift.UnsafeMutablePointer<T>) -> Swift.Bool where T : Foundation._ObjectiveCBridgeableError
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol _BridgedNSError : Foundation._ObjectiveCBridgeableError, Swift.Hashable, Swift.RawRepresentable where Self.RawValue : Swift.FixedWidthInteger {
  static var _nsErrorDomain: Swift.String { get }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._BridgedNSError {
  public var _domain: Swift.String {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._BridgedNSError {
  public var _code: Swift.Int {
    get
  }
  public init?(_bridgedNSError: __shared Foundation.NSError)
  public func hash(into hasher: inout Swift.Hasher)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol _BridgedStoredNSError : Foundation.CustomNSError, Foundation._ObjectiveCBridgeableError, Swift.Hashable {
  associatedtype Code : Foundation._ErrorCodeProtocol, Swift.RawRepresentable where Self.Code.RawValue : Swift.FixedWidthInteger
  var _nsError: Foundation.NSError { get }
  init(_nsError error: Foundation.NSError)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._BridgedStoredNSError {
  public var code: Self.Code {
    get
  }
  public init(_ code: Self.Code, userInfo: [Swift.String : Any] = [:])
  public var userInfo: [Swift.String : Any] {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._BridgedStoredNSError {
  public init?(_bridgedNSError error: Foundation.NSError)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._BridgedStoredNSError {
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._BridgedStoredNSError {
  public func hash(into hasher: inout Swift.Hasher)
  @_alwaysEmitIntoClient public var hashValue: Swift.Int {
    get {
        return _nsError.hashValue
    }
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._BridgedStoredNSError {
  public func _getEmbeddedNSError() -> Swift.AnyObject?
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift._SwiftNewtypeWrapper where Self.RawValue == any Swift.Error {
  @inlinable public func _bridgeToObjectiveC() -> Foundation.NSError {
        return rawValue as NSError
    }
  @inlinable public static func _forceBridgeFromObjectiveC(_ source: Foundation.NSError, result: inout Self?) {
        result = Self(rawValue: source)
    }
  @inlinable public static func _conditionallyBridgeFromObjectiveC(_ source: Foundation.NSError, result: inout Self?) -> Swift.Bool {
        result = Self(rawValue: source)
        return result != nil
    }
  @inlinable @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSError?) -> Self {
        return Self(rawValue: _convertNSErrorToError(source))!
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct ErrorUserInfoKey : Swift.RawRepresentable, Swift._SwiftNewtypeWrapper, Swift.Equatable, Swift.Hashable, Swift._ObjectiveCBridgeable, Swift.Sendable {
  public typealias _ObjectiveCType = Foundation.NSString
  public init(rawValue: Swift.String)
  public var rawValue: Swift.String
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias RawValue = Swift.String
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.ErrorUserInfoKey {
  @available(*, deprecated, renamed: "NSUnderlyingErrorKey")
  public static let underlyingErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedDescriptionKey")
  public static let localizedDescriptionKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedFailureReasonErrorKey")
  public static let localizedFailureReasonErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedRecoverySuggestionErrorKey")
  public static let localizedRecoverySuggestionErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSLocalizedRecoveryOptionsErrorKey")
  public static let localizedRecoveryOptionsErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSRecoveryAttempterErrorKey")
  public static let recoveryAttempterErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSHelpAnchorErrorKey")
  public static let helpAnchorErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSStringEncodingErrorKey")
  public static let stringEncodingErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSURLErrorKey")
  public static let NSURLErrorKey: Foundation.ErrorUserInfoKey
  @available(*, deprecated, renamed: "NSFilePathErrorKey")
  public static let filePathErrorKey: Foundation.ErrorUserInfoKey
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.NotificationCenter {
  public func publisher(for name: Foundation.Notification.Name, object: Swift.AnyObject? = nil) -> Foundation.NotificationCenter.Publisher
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.NotificationCenter {
  public struct Publisher : Combine.Publisher {
    public typealias Output = Foundation.Notification
    public typealias Failure = Swift.Never
    public let center: Foundation.NotificationCenter
    public let name: Foundation.Notification.Name
    public let object: Swift.AnyObject?
    public init(center: Foundation.NotificationCenter, name: Foundation.Notification.Name, object: Swift.AnyObject? = nil)
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == Foundation.Notification
  }
}
@available(macOS, unavailable, introduced: 10.15)
@available(iOS, unavailable, introduced: 13.0)
@available(tvOS, unavailable, introduced: 13.0)
@available(watchOS, unavailable, introduced: 6.0)
@available(*, unavailable)
extension Foundation.NotificationCenter.Publisher : Swift.Sendable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.NotificationCenter.Publisher : Swift.Equatable {
  public static func == (lhs: Foundation.NotificationCenter.Publisher, rhs: Foundation.NotificationCenter.Publisher) -> Swift.Bool
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct MeasurementFormatUnitUsage<UnitType> : Swift.Codable, Swift.Hashable, Swift.Sendable where UnitType : Foundation.Dimension {
  public static var general: Foundation.MeasurementFormatUnitUsage<UnitType> {
    get
  }
  public static var asProvided: Foundation.MeasurementFormatUnitUsage<UnitType> {
    get
  }
  public static func == (a: Foundation.MeasurementFormatUnitUsage<UnitType>, b: Foundation.MeasurementFormatUnitUsage<UnitType>) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitTemperature {
  public static var weather: Foundation.MeasurementFormatUnitUsage<Foundation.UnitTemperature> {
    get
  }
  public static var person: Foundation.MeasurementFormatUnitUsage<Foundation.UnitTemperature> {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitLength {
  public static var person: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> {
    get
  }
  public static var road: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> {
    get
  }
  public static var personHeight: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> {
    get
  }
  @available(macOS 14, iOS 16, tvOS 17, watchOS 9, *)
  public static var visibility: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitLength {
  public static var focalLength: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> {
    get
  }
  public static var rainfall: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> {
    get
  }
  public static var snowfall: Foundation.MeasurementFormatUnitUsage<Foundation.UnitLength> {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitEnergy {
  public static var food: Foundation.MeasurementFormatUnitUsage<Foundation.UnitEnergy> {
    get
  }
  public static var workout: Foundation.MeasurementFormatUnitUsage<Foundation.UnitEnergy> {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitMass {
  public static var personWeight: Foundation.MeasurementFormatUnitUsage<Foundation.UnitMass> {
    get
  }
}
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitSpeed {
  @available(macOS 14, iOS 16, tvOS 17, watchOS 9, *)
  public static var wind: Foundation.MeasurementFormatUnitUsage<Foundation.UnitSpeed> {
    get
  }
}
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitPressure {
  @available(macOS 14, iOS 16, tvOS 17, watchOS 9, *)
  public static var barometric: Foundation.MeasurementFormatUnitUsage<Foundation.UnitPressure> {
    get
  }
}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.MeasurementFormatUnitUsage where UnitType == Foundation.UnitVolume {
  public static var liquid: Foundation.MeasurementFormatUnitUsage<Foundation.UnitVolume> {
    get
  }
}
@available(*, deprecated, message: "Please use the struct type URLRequest")
public typealias MutableURLRequest = Foundation.NSMutableURLRequest
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct URLRequest : Foundation.ReferenceConvertible, Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public typealias ReferenceType = Foundation.NSURLRequest
  public typealias CachePolicy = Foundation.NSURLRequest.CachePolicy
  public typealias NetworkServiceType = Foundation.NSURLRequest.NetworkServiceType
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public typealias Attribution = Foundation.NSURLRequest.Attribution
  public init(url: Foundation.URL, cachePolicy: Foundation.URLRequest.CachePolicy = .useProtocolCachePolicy, timeoutInterval: Foundation.TimeInterval = 60.0)
  public var url: Foundation.URL? {
    get
    set
  }
  public var cachePolicy: Foundation.URLRequest.CachePolicy {
    get
    set
  }
  public var timeoutInterval: Foundation.TimeInterval {
    get
    set
  }
  public var mainDocumentURL: Foundation.URL? {
    get
    set
  }
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public var networkServiceType: Foundation.URLRequest.NetworkServiceType {
    get
    set
  }
  @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
  public var allowsCellularAccess: Swift.Bool {
    get
    set
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var allowsExpensiveNetworkAccess: Swift.Bool {
    get
    set
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var allowsConstrainedNetworkAccess: Swift.Bool {
    get
    set
  }
  @available(macOS 11.3, iOS 14.5, watchOS 7.4, tvOS 14.5, *)
  public var assumesHTTP3Capable: Swift.Bool {
    get
    set
  }
  @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
  public var attribution: Foundation.URLRequest.Attribution {
    get
    set
  }
  @available(macOS 13.0, iOS 16.1, watchOS 9.1, tvOS 16.1, *)
  public var requiresDNSSECValidation: Swift.Bool {
    get
    set
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public var allowsPersistentDNS: Swift.Bool {
    get
    set
  }
  public var httpMethod: Swift.String? {
    get
    set
  }
  public var allHTTPHeaderFields: [Swift.String : Swift.String]? {
    get
    set
  }
  public func value(forHTTPHeaderField field: Swift.String) -> Swift.String?
  public mutating func setValue(_ value: Swift.String?, forHTTPHeaderField field: Swift.String)
  public mutating func addValue(_ value: Swift.String, forHTTPHeaderField field: Swift.String)
  public var httpBody: Foundation.Data? {
    get
    set
  }
  public var httpBodyStream: Foundation.InputStream? {
    get
    set
  }
  public var httpShouldHandleCookies: Swift.Bool {
    get
    set
  }
  @available(macOS 15.2, iOS 18.2, watchOS 11.2, tvOS 18.2, visionOS 2.2, *)
  public var cookiePartitionIdentifier: Swift.String? {
    get
    set
  }
  @available(macOS, introduced: 10.10, deprecated: 15.4, message: "Only supported in the classic loading mode, please adopt HTTP/2 and HTTP/3 instead")
  @available(iOS, introduced: 8.0, deprecated: 18.4, message: "Only supported in the classic loading mode, please adopt HTTP/2 and HTTP/3 instead")
  @available(watchOS, introduced: 2.0, deprecated: 11.4, message: "Only supported in the classic loading mode, please adopt HTTP/2 and HTTP/3 instead")
  @available(tvOS, introduced: 9.0, deprecated: 18.4, message: "Only supported in the classic loading mode, please adopt HTTP/2 and HTTP/3 instead")
  @available(visionOS, introduced: 1.0, deprecated: 2.4, message: "Only supported in the classic loading mode, please adopt HTTP/2 and HTTP/3 instead")
  public var httpShouldUsePipelining: Swift.Bool {
    get
    set
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Foundation.URLRequest, rhs: Foundation.URLRequest) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.URLRequest : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, Swift.CustomReflectable {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.URLRequest : Swift._ObjectiveCBridgeable {
  public static func _getObjectiveCType() -> any Any.Type
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSURLRequest
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSURLRequest, result: inout Foundation.URLRequest?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSURLRequest, result: inout Foundation.URLRequest?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSURLRequest?) -> Foundation.URLRequest
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSURLRequest
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSURLRequest : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
@usableFromInline
@frozen internal struct _AsyncBytesBuffer : @unchecked Swift.Sendable {
  internal var storage: Swift.AnyObject? = nil
  @usableFromInline
  internal var nextPointer: Swift.UnsafeMutableRawPointer
  @usableFromInline
  internal var endPointer: Swift.UnsafeMutableRawPointer
  @usableFromInline
  internal init(capacity: Swift.Int)
  @usableFromInline
  @inline(never) internal mutating func reloadBufferAndNext() async throws -> Swift.UInt8?
  @inlinable @inline(__always) internal mutating func next() async throws -> Swift.UInt8? {
        if _fastPath(nextPointer != endPointer) {
            let byte = nextPointer.load(fromByteOffset: 0, as: UInt8.self)
            nextPointer = nextPointer + 1
            return byte
        }
        return try await reloadBufferAndNext()
    }
}
extension Foundation.FileHandle {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct AsyncBytes : _Concurrency.AsyncSequence, Swift.Sendable {
    public typealias Element = Swift.UInt8
    public typealias AsyncIterator = Foundation.FileHandle.AsyncBytes.Iterator
    public func makeAsyncIterator() -> Foundation.FileHandle.AsyncBytes.Iterator
    @frozen public struct Iterator : _Concurrency.AsyncIteratorProtocol, Swift.Sendable {
      public typealias Element = Swift.UInt8
      @usableFromInline
      internal var buffer: Foundation._AsyncBytesBuffer
      @inlinable @inline(__always) public mutating func next() async throws -> Swift.UInt8? {
                return try await buffer.next()
            }
      @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
      @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    }
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var bytes: Foundation.FileHandle.AsyncBytes {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(*, noasync)
public struct NSFastEnumerationIterator : Swift.IteratorProtocol {
  public init(_ enumerable: any Foundation.NSFastEnumeration)
  public mutating func next() -> Any?
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  @available(*, noasync)
  public typealias Element = Any
}
@available(macOS, unavailable, introduced: 10.10)
@available(iOS, unavailable, introduced: 8.0)
@available(tvOS, unavailable, introduced: 9.0)
@available(watchOS, unavailable, introduced: 2.0)
@available(*, unavailable)
extension Foundation.NSFastEnumerationIterator : Swift.Sendable {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSEnumerator : Swift.Sequence {
  @available(*, noasync)
  public func makeIterator() -> Foundation.NSFastEnumerationIterator
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Element = Any
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Iterator = Foundation.NSFastEnumerationIterator
}
@available(macOS 10.0, iOS 2.0, watchOS 1.0, tvOS 9.0, *)
extension Dispatch.DispatchData : Foundation.DataProtocol {
  public struct Region : Foundation.DataProtocol, Foundation.ContiguousBytes, Swift.Sendable {
    public var regions: Swift.CollectionOfOne<Dispatch.DispatchData.Region> {
      get
    }
    public subscript(position: Dispatch.DispatchData.Index) -> Swift.UInt8 {
      get
    }
    public var startIndex: Dispatch.DispatchData.Index {
      get
    }
    public var endIndex: Dispatch.DispatchData.Index {
      get
    }
    public func withUnsafeBytes<ResultType>(_ body: (Swift.UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType
    @available(iOS 2.0, tvOS 9.0, watchOS 1.0, macOS 10.0, *)
    public typealias Element = Swift.UInt8
    @available(iOS 2.0, tvOS 9.0, watchOS 1.0, macOS 10.0, *)
    public typealias Index = Dispatch.DispatchData.Index
    @available(iOS 2.0, tvOS 9.0, watchOS 1.0, macOS 10.0, *)
    public typealias Indices = Swift.Range<Dispatch.DispatchData.Index>
    @available(iOS 2.0, tvOS 9.0, watchOS 1.0, macOS 10.0, *)
    public typealias Iterator = Swift.IndexingIterator<Dispatch.DispatchData.Region>
    @available(iOS 2.0, tvOS 9.0, watchOS 1.0, macOS 10.0, *)
    public typealias Regions = Swift.CollectionOfOne<Dispatch.DispatchData.Region>
    @available(iOS 2.0, tvOS 9.0, watchOS 1.0, macOS 10.0, *)
    public typealias SubSequence = Swift.Slice<Dispatch.DispatchData.Region>
  }
  public var regions: [Dispatch.DispatchData.Region] {
    get
  }
  @available(iOS 2.0, tvOS 9.0, watchOS 1.0, macOS 10.0, *)
  public typealias Regions = [Dispatch.DispatchData.Region]
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.CocoaError.Code {
  @available(*, deprecated, renamed: "fileNoSuchFile")
  public static var fileNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileLocking")
  public static var fileLockingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnknown")
  public static var fileReadUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoPermission")
  public static var fileReadNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInvalidFileName")
  public static var fileReadInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadCorruptFile")
  public static var fileReadCorruptFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoSuchFile")
  public static var fileReadNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInapplicableStringEncoding")
  public static var fileReadInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnsupportedScheme")
  public static var fileReadUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "fileReadTooLarge")
  public static var fileReadTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "fileReadUnknownStringEncoding")
  public static var fileReadUnknownStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnknown")
  public static var fileWriteUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteNoPermission")
  public static var fileWriteNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInvalidFileName")
  public static var fileWriteInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "fileWriteFileExists")
  public static var fileWriteFileExistsError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInapplicableStringEncoding")
  public static var fileWriteInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnsupportedScheme")
  public static var fileWriteUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteOutOfSpace")
  public static var fileWriteOutOfSpaceError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "fileWriteVolumeReadOnly")
  public static var fileWriteVolumeReadOnlyError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountUnknown")
  public static var fileManagerUnmountUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountBusy")
  public static var fileManagerUnmountBusyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "keyValueValidation")
  public static var keyValueValidationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "formatting")
  public static var formattingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "userCancelled")
  public static var userCancelledError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "featureUnsupported")
  public static var featureUnsupportedError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "executableNotLoadable")
  public static var executableNotLoadableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "executableArchitectureMismatch")
  public static var executableArchitectureMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "executableRuntimeMismatch")
  public static var executableRuntimeMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "executableLoad")
  public static var executableLoadError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "executableLink")
  public static var executableLinkError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListReadCorrupt")
  public static var propertyListReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListReadUnknownVersion")
  public static var propertyListReadUnknownVersionError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListReadStream")
  public static var propertyListReadStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListWriteStream")
  public static var propertyListWriteStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListWriteInvalid")
  public static var propertyListWriteInvalidError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileUnavailable")
  public static var ubiquitousFileUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileNotUploadedDueToQuota")
  public static var ubiquitousFileNotUploadedDueToQuotaError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffFailed")
  public static var userActivityHandoffFailedError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityConnectionUnavailable")
  public static var userActivityConnectionUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityRemoteApplicationTimedOut")
  public static var userActivityRemoteApplicationTimedOutError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffUserInfoTooLarge")
  public static var userActivityHandoffUserInfoTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderReadCorrupt")
  public static var coderReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderValueNotFound")
  public static var coderValueNotFoundError: Foundation.CocoaError.Code {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.CocoaError {
  @available(*, deprecated, renamed: "fileNoSuchFile")
  public static var fileNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileLocking")
  public static var fileLockingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnknown")
  public static var fileReadUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoPermission")
  public static var fileReadNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInvalidFileName")
  public static var fileReadInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadCorruptFile")
  public static var fileReadCorruptFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadNoSuchFile")
  public static var fileReadNoSuchFileError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadInapplicableStringEncoding")
  public static var fileReadInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileReadUnsupportedScheme")
  public static var fileReadUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "fileReadTooLarge")
  public static var fileReadTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "fileReadUnknownStringEncoding")
  public static var fileReadUnknownStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnknown")
  public static var fileWriteUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteNoPermission")
  public static var fileWriteNoPermissionError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInvalidFileName")
  public static var fileWriteInvalidFileNameError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "fileWriteFileExists")
  public static var fileWriteFileExistsError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteInapplicableStringEncoding")
  public static var fileWriteInapplicableStringEncodingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteUnsupportedScheme")
  public static var fileWriteUnsupportedSchemeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "fileWriteOutOfSpace")
  public static var fileWriteOutOfSpaceError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "fileWriteVolumeReadOnly")
  public static var fileWriteVolumeReadOnlyError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountUnknown")
  public static var fileManagerUnmountUnknownError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, *)
  @available(iOS, unavailable)
  @available(*, deprecated, renamed: "fileManagerUnmountBusy")
  public static var fileManagerUnmountBusyError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "keyValueValidation")
  public static var keyValueValidationError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "formatting")
  public static var formattingError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "userCancelled")
  public static var userCancelledError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "featureUnsupported")
  public static var featureUnsupportedError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "executableNotLoadable")
  public static var executableNotLoadableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "executableArchitectureMismatch")
  public static var executableArchitectureMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "executableRuntimeMismatch")
  public static var executableRuntimeMismatchError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "executableLoad")
  public static var executableLoadError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "executableLink")
  public static var executableLinkError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListReadCorrupt")
  public static var propertyListReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListReadUnknownVersion")
  public static var propertyListReadUnknownVersionError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListReadStream")
  public static var propertyListReadStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListWriteStream")
  public static var propertyListWriteStreamError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "propertyListWriteInvalid")
  public static var propertyListWriteInvalidError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileUnavailable")
  public static var ubiquitousFileUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "ubiquitousFileNotUploadedDueToQuota")
  public static var ubiquitousFileNotUploadedDueToQuotaError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffFailed")
  public static var userActivityHandoffFailedError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityConnectionUnavailable")
  public static var userActivityConnectionUnavailableError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityRemoteApplicationTimedOut")
  public static var userActivityRemoteApplicationTimedOutError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  @available(*, deprecated, renamed: "userActivityHandoffUserInfoTooLarge")
  public static var userActivityHandoffUserInfoTooLargeError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderReadCorrupt")
  public static var coderReadCorruptError: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  @available(*, deprecated, renamed: "coderValueNotFound")
  public static var coderValueNotFoundError: Foundation.CocoaError.Code {
    get
  }
}
extension Foundation.UndoManager {
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  @preconcurrency public func registerUndo<TargetType>(withTarget target: TargetType, handler: @escaping @Sendable (TargetType) -> Swift.Void) where TargetType : AnyObject
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.__DataStorage {
  @usableFromInline
  convenience internal init(immutableReference: Foundation.NSData, offset: Swift.Int)
  @usableFromInline
  convenience internal init(mutableReference: Foundation.NSMutableData, offset: Swift.Int)
  @usableFromInline
  convenience internal init(customReference: Foundation.NSData, offset: Swift.Int)
  @usableFromInline
  convenience internal init(customMutableReference: Foundation.NSMutableData, offset: Swift.Int)
  @usableFromInline
  @inline(never) final internal func bridgedReference(_ range: Swift.Range<Swift.Int>) -> Foundation.NSData
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Data : Foundation.ReferenceConvertible {
  public typealias ReferenceType = Foundation.NSData
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSData
  public static func _forceBridgeFromObjectiveC(_ input: Foundation.NSData, result: inout Foundation.Data?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: Foundation.NSData, result: inout Foundation.Data?) -> Swift.Bool
  public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSData?) -> Foundation.Data
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSData
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Data.InlineSlice {
  @inlinable internal func bridgedReference() -> Foundation.NSData {
        return storage.bridgedReference(self.range)
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Data.LargeSlice {
  @inlinable internal func bridgedReference() -> Foundation.NSData {
        return storage.bridgedReference(self.range)
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Data._Representation {
  @inlinable internal func bridgedReference() -> Foundation.NSData {
        switch self {
        case .empty: return NSData()
        case .inline(let inline):
            return inline.withUnsafeBytes {
                return NSData(bytes: $0.baseAddress, length: $0.count)
            }
        case .slice(let slice):
            return slice.bridgedReference()
        case .large(let slice):
            return slice.bridgedReference()
        }
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSData : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Data {
  public init(referencing reference: __shared Foundation.NSData)
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct AsyncCharacterSequence<Base> : _Concurrency.AsyncSequence where Base : _Concurrency.AsyncSequence, Base.Element == Swift.UInt8 {
  public typealias Element = Swift.Character
  @frozen public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var remaining: Foundation.AsyncUnicodeScalarSequence<Base>.AsyncIterator
    @usableFromInline
    internal var accumulator: Swift.String = ""
    @inlinable @inline(__always) public mutating func next() async rethrows -> Swift.Character? {
            while let scalar = try await remaining.next() {
                accumulator.unicodeScalars.append(scalar)
                if accumulator.count > 1 {
                    return accumulator.removeFirst()
                }
            }
            return accumulator.count > 0 ? accumulator.removeFirst() : nil
        }
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Element = Swift.Character
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Base.Failure
  }
  public func makeAsyncIterator() -> Foundation.AsyncCharacterSequence<Base>.AsyncIterator
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Base.Failure
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.AsyncCharacterSequence : Swift.Sendable where Base : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.AsyncCharacterSequence.AsyncIterator : Swift.Sendable where Base.AsyncIterator : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension _Concurrency.AsyncSequence where Self.Element == Swift.UInt8 {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var characters: Foundation.AsyncCharacterSequence<Self> {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Progress {
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var estimatedTimeRemaining: Foundation.TimeInterval? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var throughput: Swift.Int? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var fileTotalCount: Swift.Int? {
    get
    set
  }
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public var fileCompletedCount: Swift.Int? {
    get
    set
  }
  public func performAsCurrent<ReturnType>(withPendingUnitCount unitCount: Swift.Int64, using work: () throws -> ReturnType) rethrows -> ReturnType
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSDictionary : Swift.ExpressibleByDictionaryLiteral {
  required convenience public init(dictionaryLiteral elements: (Any, Any)...)
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Key = Any
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Value = Any
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Dictionary : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSDictionary
  @_specialize(exported: false, kind: full, where Key == Swift.String, Value == Any)
  public static func _forceBridgeFromObjectiveC(_ d: Foundation.NSDictionary, result: inout Swift.Dictionary<Key, Value>?)
  @_specialize(exported: false, kind: full, where Key == Swift.String, Value == Any)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSDictionary, result: inout Swift.Dictionary<Key, Value>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ d: Foundation.NSDictionary?) -> Swift.Dictionary<Key, Value>
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSDictionary
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSDictionary : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSDictionary : Swift.Sequence {
  @_hasMissingDesignatedInitializers @_objcRuntimeName(_TtCE10FoundationCSo12NSDictionary9_Iterator) final public class Iterator : Swift.IteratorProtocol {
    final public func next() -> (key: Any, value: Any)?
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Element = (key: Any, value: Any)
    @objc deinit
  }
  @objc dynamic public subscript(key: Any) -> Any? {
    @objc(__swift_objectForKeyedSubscript:) get
  }
  public func makeIterator() -> Foundation.NSDictionary.Iterator
  @_alwaysEmitIntoClient @nonobjc public var underestimatedCount: Swift.Int {
    get { count }
  }
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Element = (key: Any, value: Any)
}
@available(macOS, unavailable, introduced: 10.10)
@available(iOS, unavailable, introduced: 8.0)
@available(tvOS, unavailable, introduced: 9.0)
@available(watchOS, unavailable, introduced: 2.0)
@available(*, unavailable)
extension Foundation.NSDictionary.Iterator : Swift.Sendable {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSMutableDictionary {
  @objc override dynamic public subscript(key: Any) -> Any? {
    @objc(__swift_objectForKeyedSubscript:) get
    @objc(__swift_setObject:forKeyedSubscript:) set
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSDictionary {
  @objc(__swiftInitWithDictionary_NSDictionary:) convenience dynamic public init(dictionary otherDictionary: __shared Foundation.NSDictionary)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSDictionary : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Dictionary : Swift.CVarArg {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct URLError : Foundation._BridgedStoredNSError {
  public let _nsError: Foundation.NSError
  public init(_nsError error: Foundation.NSError)
  public static var errorDomain: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public struct Code : Swift.RawRepresentable, Swift.Hashable, Foundation._ErrorCodeProtocol, Swift.Sendable {
    public typealias _ErrorType = Foundation.URLError
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias RawValue = Swift.Int
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.URLError.Code {
  public static var unknown: Foundation.URLError.Code {
    get
  }
  public static var cancelled: Foundation.URLError.Code {
    get
  }
  public static var badURL: Foundation.URLError.Code {
    get
  }
  public static var timedOut: Foundation.URLError.Code {
    get
  }
  public static var unsupportedURL: Foundation.URLError.Code {
    get
  }
  public static var cannotFindHost: Foundation.URLError.Code {
    get
  }
  public static var cannotConnectToHost: Foundation.URLError.Code {
    get
  }
  public static var networkConnectionLost: Foundation.URLError.Code {
    get
  }
  public static var dnsLookupFailed: Foundation.URLError.Code {
    get
  }
  public static var httpTooManyRedirects: Foundation.URLError.Code {
    get
  }
  public static var resourceUnavailable: Foundation.URLError.Code {
    get
  }
  public static var notConnectedToInternet: Foundation.URLError.Code {
    get
  }
  public static var redirectToNonExistentLocation: Foundation.URLError.Code {
    get
  }
  public static var badServerResponse: Foundation.URLError.Code {
    get
  }
  public static var userCancelledAuthentication: Foundation.URLError.Code {
    get
  }
  public static var userAuthenticationRequired: Foundation.URLError.Code {
    get
  }
  public static var zeroByteResource: Foundation.URLError.Code {
    get
  }
  public static var cannotDecodeRawData: Foundation.URLError.Code {
    get
  }
  public static var cannotDecodeContentData: Foundation.URLError.Code {
    get
  }
  public static var cannotParseResponse: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var appTransportSecurityRequiresSecureConnection: Foundation.URLError.Code {
    get
  }
  public static var fileDoesNotExist: Foundation.URLError.Code {
    get
  }
  public static var fileIsDirectory: Foundation.URLError.Code {
    get
  }
  public static var noPermissionsToReadFile: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var dataLengthExceedsMaximum: Foundation.URLError.Code {
    get
  }
  public static var secureConnectionFailed: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateHasBadDate: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateUntrusted: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateHasUnknownRoot: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateNotYetValid: Foundation.URLError.Code {
    get
  }
  public static var clientCertificateRejected: Foundation.URLError.Code {
    get
  }
  public static var clientCertificateRequired: Foundation.URLError.Code {
    get
  }
  public static var cannotLoadFromNetwork: Foundation.URLError.Code {
    get
  }
  public static var cannotCreateFile: Foundation.URLError.Code {
    get
  }
  public static var cannotOpenFile: Foundation.URLError.Code {
    get
  }
  public static var cannotCloseFile: Foundation.URLError.Code {
    get
  }
  public static var cannotWriteToFile: Foundation.URLError.Code {
    get
  }
  public static var cannotRemoveFile: Foundation.URLError.Code {
    get
  }
  public static var cannotMoveFile: Foundation.URLError.Code {
    get
  }
  public static var downloadDecodingFailedMidStream: Foundation.URLError.Code {
    get
  }
  public static var downloadDecodingFailedToComplete: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var internationalRoamingOff: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var callIsActive: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var dataNotAllowed: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var requestBodyStreamExhausted: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionRequiresSharedContainer: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionInUseByAnotherProcess: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionWasDisconnected: Foundation.URLError.Code {
    get
  }
}
extension Foundation.URLError {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public enum BackgroundTaskCancelledReason : Swift.Int, Swift.Sendable {
    case userForceQuitApplication
    case backgroundUpdatesDisabled
    case insufficientSystemResources
    public init?(rawValue: Swift.Int)
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension Foundation.URLError {
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public enum NetworkUnavailableReason : Swift.Int, Swift.Sendable {
    case cellular
    case expensive
    case constrained
    public init?(rawValue: Swift.Int)
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.URLError {
  public var failingURL: Foundation.URL? {
    get
  }
  @available(macOS, deprecated: 15.4, message: "Use failingURL instead")
  @available(iOS, deprecated: 18.4, message: "Use failingURL instead")
  @available(watchOS, deprecated: 11.4, message: "Use failingURL instead")
  @available(tvOS, deprecated: 18.4, message: "Use failingURL instead")
  @available(visionOS, deprecated: 2.4, message: "Use failingURL instead")
  public var failureURLString: Swift.String? {
    get
  }
  public var failureURLPeerTrust: Security.SecTrust? {
    get
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var backgroundTaskCancelledReason: Foundation.URLError.BackgroundTaskCancelledReason? {
    get
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var networkUnavailableReason: Foundation.URLError.NetworkUnavailableReason? {
    get
  }
  @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
  public var downloadTaskResumeData: Foundation.Data? {
    get
  }
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public var uploadTaskResumeData: Foundation.Data? {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.URLError {
  public static var unknown: Foundation.URLError.Code {
    get
  }
  public static var cancelled: Foundation.URLError.Code {
    get
  }
  public static var badURL: Foundation.URLError.Code {
    get
  }
  public static var timedOut: Foundation.URLError.Code {
    get
  }
  public static var unsupportedURL: Foundation.URLError.Code {
    get
  }
  public static var cannotFindHost: Foundation.URLError.Code {
    get
  }
  public static var cannotConnectToHost: Foundation.URLError.Code {
    get
  }
  public static var networkConnectionLost: Foundation.URLError.Code {
    get
  }
  public static var dnsLookupFailed: Foundation.URLError.Code {
    get
  }
  public static var httpTooManyRedirects: Foundation.URLError.Code {
    get
  }
  public static var resourceUnavailable: Foundation.URLError.Code {
    get
  }
  public static var notConnectedToInternet: Foundation.URLError.Code {
    get
  }
  public static var redirectToNonExistentLocation: Foundation.URLError.Code {
    get
  }
  public static var badServerResponse: Foundation.URLError.Code {
    get
  }
  public static var userCancelledAuthentication: Foundation.URLError.Code {
    get
  }
  public static var userAuthenticationRequired: Foundation.URLError.Code {
    get
  }
  public static var zeroByteResource: Foundation.URLError.Code {
    get
  }
  public static var cannotDecodeRawData: Foundation.URLError.Code {
    get
  }
  public static var cannotDecodeContentData: Foundation.URLError.Code {
    get
  }
  public static var cannotParseResponse: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.11, iOS 9.0, *)
  public static var appTransportSecurityRequiresSecureConnection: Foundation.URLError.Code {
    get
  }
  public static var fileDoesNotExist: Foundation.URLError.Code {
    get
  }
  public static var fileIsDirectory: Foundation.URLError.Code {
    get
  }
  public static var noPermissionsToReadFile: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var dataLengthExceedsMaximum: Foundation.URLError.Code {
    get
  }
  public static var secureConnectionFailed: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateHasBadDate: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateUntrusted: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateHasUnknownRoot: Foundation.URLError.Code {
    get
  }
  public static var serverCertificateNotYetValid: Foundation.URLError.Code {
    get
  }
  public static var clientCertificateRejected: Foundation.URLError.Code {
    get
  }
  public static var clientCertificateRequired: Foundation.URLError.Code {
    get
  }
  public static var cannotLoadFromNetwork: Foundation.URLError.Code {
    get
  }
  public static var cannotCreateFile: Foundation.URLError.Code {
    get
  }
  public static var cannotOpenFile: Foundation.URLError.Code {
    get
  }
  public static var cannotCloseFile: Foundation.URLError.Code {
    get
  }
  public static var cannotWriteToFile: Foundation.URLError.Code {
    get
  }
  public static var cannotRemoveFile: Foundation.URLError.Code {
    get
  }
  public static var cannotMoveFile: Foundation.URLError.Code {
    get
  }
  public static var downloadDecodingFailedMidStream: Foundation.URLError.Code {
    get
  }
  public static var downloadDecodingFailedToComplete: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var internationalRoamingOff: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var callIsActive: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var dataNotAllowed: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var requestBodyStreamExhausted: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionRequiresSharedContainer: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionInUseByAnotherProcess: Foundation.URLError.Code {
    get
  }
  @available(macOS 10.10, iOS 8.0, *)
  public static var backgroundSessionWasDisconnected: Foundation.URLError.Code {
    get
  }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.String {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct LocalizationOptions {
    public var replacements: [any Swift.CVarArg]?
    public init()
  }
  public struct LocalizationValue : Swift.Equatable, Swift.ExpressibleByStringInterpolation {
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public enum Placeholder : Swift.Codable, Swift.Hashable, Swift.Sendable {
      case int
      case uint
      case float
      case double
      case object
      public static func == (a: Swift.String.LocalizationValue.Placeholder, b: Swift.String.LocalizationValue.Placeholder) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public init(_ value: Swift.String)
    @_semantics("localization_key.init_literal") public init(stringLiteral value: Swift.String)
    @_semantics("localization_key.init_interpolation") public init(stringInterpolation: Swift.String.LocalizationValue.StringInterpolation)
    public struct StringInterpolation : Swift.StringInterpolationProtocol {
      @_semantics("localization.interpolation_init") public init(literalCapacity: Swift.Int, interpolationCount: Swift.Int)
      @_semantics("localization.interpolation.appendLiteral") public mutating func appendLiteral(_ literal: Swift.String)
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation(_ string: Swift.String)
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation<Subject>(_ subject: Subject) where Subject : ObjectiveC.NSObject
      @_transparent public mutating func appendInterpolation<T>(_ value: T) where T : Foundation._FormatSpecifiable {
                appendInterpolation(value, specifier: formatSpecifier(T.self))
            }
      @_semantics("localization.interpolation.appendInterpolation_param_specifier") public mutating func appendInterpolation<T>(_ value: T, specifier: Swift.String) where T : Foundation._FormatSpecifiable
      @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
      @_transparent public mutating func appendInterpolation(placeholder: Swift.String.LocalizationValue.Placeholder) {
                appendInterpolation(placeholder: placeholder, specifier: placeholderFormatSpecifier(placeholder))
            }
      @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
      @_semantics("localization.interpolation.appendInterpolation_param_specifier") public mutating func appendInterpolation(placeholder: Swift.String.LocalizationValue.Placeholder, specifier: Swift.String)
      @preconcurrency @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation<T, F>(_ value: T, format: F) where T : Swift.Sendable, T == F.FormatInput, F : Foundation.FormatStyle, F : Swift.Sendable, F.FormatOutput : Swift.StringProtocol
      @preconcurrency @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation<T, F>(_ value: T, format: F) where T : Swift.Sendable, T == F.FormatInput, F : Foundation.FormatStyle, F : Swift.Sendable, F.FormatOutput : Foundation.AttributedStringProtocol
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation(_ attrStr: Foundation.AttributedString, options: Foundation.AttributedString.InterpolationOptions = [])
      @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation<T>(_ value: T) where T : Foundation.CustomLocalizedStringResourceConvertible
      @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
      @_semantics("localization.interpolation.appendInterpolation_@_specifier") public mutating func appendInterpolation<C>(_ value: C, format: Foundation.ListFormatStyle<Foundation.StringStyle, [Swift.String]>) where C : Swift.Collection, C.Element : Foundation.CustomLocalizedStringResourceConvertible
      @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
      public typealias StringLiteralType = Swift.String
    }
    public static func == (a: Swift.String.LocalizationValue, b: Swift.String.LocalizationValue) -> Swift.Bool
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias StringLiteralType = Swift.String
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias UnicodeScalarLiteralType = Swift.String
  }
  @_semantics("string.init_localized") public init(localized keyAndValue: Swift.String.LocalizationValue, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale = .current, comment: Swift.StaticString? = nil)
  @_semantics("string.init_localized") public init(localized key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale = .current, comment: Swift.StaticString? = nil)
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_semantics("string.init_localized") public init(localized keyAndValue: Swift.String.LocalizationValue, options: Swift.String.LocalizationOptions, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale = .current, comment: Swift.StaticString? = nil)
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_semantics("string.init_localized") public init(localized key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, options: Swift.String.LocalizationOptions, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale = .current, comment: Swift.StaticString? = nil)
}
@available(macOS, unavailable, introduced: 13.0)
@available(iOS, unavailable, introduced: 16.0)
@available(tvOS, unavailable, introduced: 16.0)
@available(watchOS, unavailable, introduced: 9.0)
@available(*, unavailable)
extension Swift.String.LocalizationOptions : Swift.Sendable {
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Swift.String.LocalizationValue : Swift.Sendable {
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Swift.String.LocalizationValue.StringInterpolation : Swift.Sendable {
}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public enum InflectionConcept : Swift.Sendable, Swift.Hashable, Swift.Equatable, Swift.Codable {
  case termsOfAddress([Foundation.TermOfAddress])
  case localizedPhrase(Swift.String)
  public static func == (a: Foundation.InflectionConcept, b: Foundation.InflectionConcept) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct LocalizationOptions {
    public var replacements: [any Swift.CVarArg]?
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var concepts: [Foundation.InflectionConcept]?
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public var inflect: Swift.Bool
    public var applyReplacementIndexAttribute: Swift.Bool
    public init()
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
    public static func termsOfAddressConcept(_ termsOfAddress: [Foundation.TermOfAddress]) -> Foundation.AttributedString.LocalizationOptions
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
    public static func localizedPhraseConcept(_ phrase: Swift.String) -> Foundation.AttributedString.LocalizationOptions
  }
  public struct FormattingOptions : Swift.OptionSet, Swift.Sendable {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let applyReplacementIndexAttribute: Foundation.AttributedString.FormattingOptions
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias ArrayLiteralElement = Foundation.AttributedString.FormattingOptions
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias Element = Foundation.AttributedString.FormattingOptions
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias RawValue = Swift.UInt
  }
  public struct InterpolationOptions : Swift.OptionSet, Swift.Sendable {
    public let rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let insertAttributesWithoutMerging: Foundation.AttributedString.InterpolationOptions
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias ArrayLiteralElement = Foundation.AttributedString.InterpolationOptions
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias Element = Foundation.AttributedString.InterpolationOptions
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias RawValue = Swift.UInt
  }
  @_semantics("attributed_string.init_localized") public init(localized key: Swift.String.LocalizationValue, options: Foundation.AttributedString.FormattingOptions = [], table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil)
  @_semantics("attributed_string.init_localized") public init(localized key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, options: Foundation.AttributedString.FormattingOptions = [], table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil)
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_semantics("attributed_string.init_localized") public init(localized key: Swift.String.LocalizationValue, options: Foundation.AttributedString.LocalizationOptions, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil)
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_semantics("attributed_string.init_localized") public init(localized key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, options: Foundation.AttributedString.LocalizationOptions, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil)
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.String.LocalizationValue, options: Foundation.AttributedString.FormattingOptions = [], table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) where S : Foundation.AttributeScope
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, options: Foundation.AttributedString.FormattingOptions = [], table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) where S : Foundation.AttributeScope
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.String.LocalizationValue, options: Foundation.AttributedString.LocalizationOptions, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) where S : Foundation.AttributeScope
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, options: Foundation.AttributedString.LocalizationOptions, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) where S : Foundation.AttributeScope
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.String.LocalizationValue, options: Foundation.AttributedString.FormattingOptions = [], table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: S.Type) where S : Foundation.AttributeScope
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, options: Foundation.AttributedString.FormattingOptions = [], table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: S.Type) where S : Foundation.AttributeScope
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.String.LocalizationValue, options: Foundation.AttributedString.LocalizationOptions, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: S.Type) where S : Foundation.AttributeScope
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  @_semantics("attributed_string.init_localized") public init<S>(localized key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, options: Foundation.AttributedString.LocalizationOptions, table: Swift.String? = nil, bundle: Foundation.Bundle? = nil, locale: Foundation.Locale? = nil, comment: Swift.StaticString? = nil, including scope: S.Type) where S : Foundation.AttributeScope
}
@available(macOS, unavailable, introduced: 13.0)
@available(iOS, unavailable, introduced: 16.0)
@available(tvOS, unavailable, introduced: 16.0)
@available(watchOS, unavailable, introduced: 9.0)
@available(*, unavailable)
extension Foundation.AttributedString.LocalizationOptions : Swift.Sendable {
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Swift.String.LocalizationValue : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
@_alwaysEmitIntoClient @_semantics("constant_evaluable") internal func placeholderFormatSpecifier(_ placeholder: Swift.String.LocalizationValue.Placeholder) -> Swift.String {
    switch placeholder {
    case .int: return "%lld"
    case .uint: return "%llu"
    case .float: return "%f"
    case .double: return "%lf"
    case .object: return "%@"
    default: return "%@"
    }
}
@_semantics("constant_evaluable") @_alwaysEmitIntoClient internal func formatSpecifier<T>(_ type: T.Type) -> Swift.String {
    switch type {
    case is Int.Type:
        fallthrough
    case is Int64.Type:
        return "%lld"
    case is Int8.Type:
        fallthrough
    case is Int16.Type:
        fallthrough
    case is Int32.Type:
        return "%d"
    case is UInt.Type:
        fallthrough
    case is UInt64.Type:
        return "%llu"
    case is UInt8.Type:
        fallthrough
    case is UInt16.Type:
        fallthrough
    case is UInt32.Type:
        return "%u"
    case is Float.Type:
        return "%f"
    case is CGFloat.Type:
        fallthrough
    case is Double.Type:
        return "%lf"
    default:
        return "%@"
    }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@preconcurrency public protocol _FormatSpecifiable : Swift.Equatable, Swift.Sendable {
  associatedtype _Arg : Swift.CVarArg, Swift.Sendable
  var _arg: Self._Arg { get }
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Int : Foundation._FormatSpecifiable {
  public var _arg: Swift.Int64 {
    get
  }
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _Arg = Swift.Int64
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Int8 : Foundation._FormatSpecifiable {
  public var _arg: Swift.Int32 {
    get
  }
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _Arg = Swift.Int32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Int16 : Foundation._FormatSpecifiable {
  public var _arg: Swift.Int32 {
    get
  }
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _Arg = Swift.Int32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Int32 : Foundation._FormatSpecifiable {
  public var _arg: Swift.Int32 {
    get
  }
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _Arg = Swift.Int32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Int64 : Foundation._FormatSpecifiable {
  public var _arg: Swift.Int64 {
    get
  }
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _Arg = Swift.Int64
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UInt : Foundation._FormatSpecifiable {
  public var _arg: Swift.UInt64 {
    get
  }
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _Arg = Swift.UInt64
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UInt8 : Foundation._FormatSpecifiable {
  public var _arg: Swift.UInt32 {
    get
  }
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _Arg = Swift.UInt32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UInt16 : Foundation._FormatSpecifiable {
  public var _arg: Swift.UInt32 {
    get
  }
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _Arg = Swift.UInt32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UInt32 : Foundation._FormatSpecifiable {
  public var _arg: Swift.UInt32 {
    get
  }
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _Arg = Swift.UInt32
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.UInt64 : Foundation._FormatSpecifiable {
  public var _arg: Swift.UInt64 {
    get
  }
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _Arg = Swift.UInt64
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Float : Foundation._FormatSpecifiable {
  public var _arg: Swift.Float {
    get
  }
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _Arg = Swift.Float
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Swift.Double : Foundation._FormatSpecifiable {
  public var _arg: Swift.Double {
    get
  }
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _Arg = Swift.Double
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension CoreFoundation.CGFloat : Foundation._FormatSpecifiable {
  public var _arg: CoreFoundation.CGFloat {
    get
  }
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _Arg = CoreFoundation.CGFloat
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public struct LocalizedStringResource : Swift.Equatable, Swift.Codable, Foundation.CustomLocalizedStringResourceConvertible, Swift.ExpressibleByStringInterpolation {
  public let key: Swift.String
  public let defaultValue: Swift.String.LocalizationValue
  public let table: Swift.String?
  public var locale: Foundation.Locale
  public var bundle: Foundation.LocalizedStringResource.BundleDescription {
    get
  }
  public enum BundleDescription : Swift.Sendable {
    case main
    case forClass(Swift.AnyClass)
    case atURL(Foundation.URL)
  }
  @_semantics("string.init_localized") public init(_ keyAndValue: Swift.String.LocalizationValue, table: Swift.String? = nil, locale: Foundation.Locale = .current, bundle: Foundation.LocalizedStringResource.BundleDescription = .main, comment: Swift.StaticString? = nil)
  @_semantics("string.init_localized") public init(_ key: Swift.StaticString, defaultValue: Swift.String.LocalizationValue, table: Swift.String? = nil, locale: Foundation.Locale = .current, bundle: Foundation.LocalizedStringResource.BundleDescription = .main, comment: Swift.StaticString? = nil)
  @_semantics("localization_key.init_literal") public init(stringLiteral value: Swift.String)
  @_semantics("localization_key.init_interpolation") public init(stringInterpolation: Swift.String.LocalizationValue.StringInterpolation)
  public var localizedStringResource: Foundation.LocalizedStringResource {
    get
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (lhs: Foundation.LocalizedStringResource, rhs: Foundation.LocalizedStringResource) -> Swift.Bool
  @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
  public typealias StringInterpolation = Swift.String.LocalizationValue.StringInterpolation
  @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
  public typealias StringLiteralType = Swift.String
  @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
  public typealias UnicodeScalarLiteralType = Swift.String
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.LocalizedStringResource : Swift.Sendable {
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Swift.String {
  @_disfavoredOverload public init(localized resource: Foundation.LocalizedStringResource)
  @_disfavoredOverload public init(localized resource: Foundation.LocalizedStringResource, options: Swift.String.LocalizationOptions)
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.AttributedString {
  @_disfavoredOverload public init(localized resource: Foundation.LocalizedStringResource)
  @_disfavoredOverload public init<S>(localized resource: Foundation.LocalizedStringResource, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) where S : Foundation.AttributeScope
  @_disfavoredOverload public init<S>(localized resource: Foundation.LocalizedStringResource, including scope: S.Type) where S : Foundation.AttributeScope
  @_disfavoredOverload public init(localized resource: Foundation.LocalizedStringResource, options: Foundation.AttributedString.LocalizationOptions)
  @_disfavoredOverload public init<S>(localized resource: Foundation.LocalizedStringResource, options: Foundation.AttributedString.LocalizationOptions, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>) where S : Foundation.AttributeScope
  @_disfavoredOverload public init<S>(localized resource: Foundation.LocalizedStringResource, options: Foundation.AttributedString.LocalizationOptions, including scope: S.Type) where S : Foundation.AttributeScope
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public protocol CustomLocalizedStringResourceConvertible {
  var localizedStringResource: Foundation.LocalizedStringResource { get }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension ObjectiveC.NSObject : Swift.CustomStringConvertible {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension ObjectiveC.NSObject : Swift.CustomDebugStringConvertible {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public let NSNotFound: Swift.Int
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func NSLocalizedString(_ key: Swift.String, tableName: Swift.String? = nil, bundle: Foundation.Bundle = Bundle.main, value: Swift.String = "", comment: Swift.String) -> Swift.String
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func NSLog(_ format: Swift.String, _ args: any Swift.CVarArg...)
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.AnyHashable : Swift._ObjectiveCBridgeable {
  public func _bridgeToObjectiveC() -> ObjectiveC.NSObject
  public static func _forceBridgeFromObjectiveC(_ x: ObjectiveC.NSObject, result: inout Swift.AnyHashable?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: ObjectiveC.NSObject, result: inout Swift.AnyHashable?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: ObjectiveC.NSObject?) -> Swift.AnyHashable
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = ObjectiveC.NSObject
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.CVarArg where Self : Swift._ObjectiveCBridgeable {
  public var _cVarArgEncoding: [Swift.Int] {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSLocking {
  @_alwaysEmitIntoClient @_disfavoredOverload public func withLock<R>(_ body: () throws -> R) rethrows -> R {
        self.lock()
        defer { self.unlock() }
        return try body()
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSDate : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSDate.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
extension Foundation.NSItemProvider {
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  @preconcurrency public func registerObject<T>(ofClass: T.Type, visibility: Foundation.NSItemProviderRepresentationVisibility, loadHandler: @escaping @Sendable (@Sendable (T?, (any Swift.Error)?) -> Swift.Void) -> Foundation.Progress?) where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderWriting
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  public func canLoadObject<T>(ofClass: T.Type) -> Swift.Bool where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
  @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  @preconcurrency public func loadObject<T>(ofClass: T.Type, completionHandler: @escaping @Sendable (T?, (any Swift.Error)?) -> Swift.Void) -> Foundation.Progress where T : Swift._ObjectiveCBridgeable, T._ObjectiveCType : Foundation.NSItemProviderReading
}
extension Foundation.URL {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct AsyncBytes : _Concurrency.AsyncSequence, Swift.Sendable {
    public typealias Element = Swift.UInt8
    @frozen public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol, Swift.Sendable {
      @usableFromInline
      internal var buffer: Foundation._AsyncBytesBuffer = _AsyncBytesBuffer(capacity: 0)
      @inlinable @inline(__always) public mutating func next() async throws -> Swift.UInt8? {
                return try await buffer.next()
            }
      @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
      public typealias Element = Swift.UInt8
      @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
      @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    }
    public func makeAsyncIterator() -> Foundation.URL.AsyncBytes.AsyncIterator
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var resourceBytes: Foundation.URL.AsyncBytes {
    get
  }
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var lines: Foundation.AsyncLineSequence<Foundation.URL.AsyncBytes> {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.String {
  public static var availableStringEncodings: [Swift.String.Encoding] {
    get
  }
  public static var defaultCStringEncoding: Swift.String.Encoding {
    get
  }
  public static func localizedName(of encoding: Swift.String.Encoding) -> Swift.String
  public static func localizedStringWithFormat(_ format: Swift.String, _ arguments: any Swift.CVarArg...) -> Swift.String
  public init?(utf8String bytes: Swift.UnsafePointer<Swift.CChar>)
  @_alwaysEmitIntoClient public init?(utf8String bytes: [Swift.CChar]) {
         
        if let str = String(validatingUTF8: bytes) {
            self = str
            return
        }
        guard let nullPosition = bytes.firstIndex(of: 0) else {
            fatalError(
                "input of String.init(utf8String:) must be null-terminated"
            )
        }
        let ns = bytes.withUnsafeBytes {
            NSString(bytes: $0.baseAddress!,
                     length: nullPosition,
                     encoding: Encoding.utf8.rawValue)
        }
        guard let ns = ns else {
            return nil
        }
        self = String._unconditionallyBridgeFromObjectiveC(ns)
    }
  @available(*, deprecated, message: "Use a copy of the String argument")
  @_alwaysEmitIntoClient public init?(utf8String bytes: Swift.String) {
        var decoded = bytes
        decoded.makeContiguousUTF8()
        if let null = decoded.firstIndex(of: "\0") {
            decoded = String(decoded[..<null])
        }
        self = decoded
    }
  @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
  @_alwaysEmitIntoClient public init?(utf8String bytes: inout Swift.CChar) {
         
        guard bytes == 0 else {
            fatalError(
                "input of String.init(utf8String:) must be null-terminated"
            )
        }
        self = ""
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.String {
  @available(macOS, deprecated: 13, message: "String does not support no-copy initialization")
  @available(iOS, deprecated: 16, message: "String does not support no-copy initialization")
  @available(tvOS, deprecated: 16, message: "String does not support no-copy initialization")
  @available(watchOS, deprecated: 9, message: "String does not support no-copy initialization")
  public init?(bytesNoCopy bytes: Swift.UnsafeMutableRawPointer, length: Swift.Int, encoding: Swift.String.Encoding, freeWhenDone flag: Swift.Bool)
  public init(utf16CodeUnits: Swift.UnsafePointer<Foundation.unichar>, count: Swift.Int)
  @available(macOS, deprecated: 13, message: "String does not support no-copy initialization")
  @available(iOS, deprecated: 16, message: "String does not support no-copy initialization")
  @available(tvOS, deprecated: 16, message: "String does not support no-copy initialization")
  @available(watchOS, deprecated: 9, message: "String does not support no-copy initialization")
  public init(utf16CodeUnitsNoCopy: Swift.UnsafePointer<Foundation.unichar>, count: Swift.Int, freeWhenDone flag: Swift.Bool)
  @available(macOS, deprecated: 15, message: "Use `init(contentsOfFile:encoding:)` instead")
  @available(iOS, deprecated: 18, message: "Use `init(contentsOfFile:encoding:)` instead")
  @available(tvOS, deprecated: 18, message: "Use `init(contentsOfFile:encoding:)` instead")
  @available(watchOS, deprecated: 11, message: "Use `init(contentsOfFile:encoding:)` instead")
  public init(contentsOfFile path: __shared Swift.String) throws
  @available(macOS, deprecated: 15, message: "Use `init(contentsOf:encoding:)` instead")
  @available(iOS, deprecated: 18, message: "Use `init(contentsOf:encoding:)` instead")
  @available(tvOS, deprecated: 18, message: "Use `init(contentsOf:encoding:)` instead")
  @available(watchOS, deprecated: 11, message: "Use `init(contentsOf:encoding:)` instead")
  public init(contentsOf url: __shared Foundation.URL) throws
  public init?(cString: Swift.UnsafePointer<Swift.CChar>, encoding enc: Swift.String.Encoding)
  @_alwaysEmitIntoClient public init?(cString: [Swift.CChar], encoding enc: Swift.String.Encoding) {
        if enc == .utf8 || enc == .ascii || enc == .nonLossyASCII  {
             
            if let str = String(validatingUTF8: cString) {
                if enc == .utf8 || str._guts._isContiguousASCII {
                    self = str
                    return
                }
            }
        }
        guard let nullPosition = cString.firstIndex(of: 0) else {
            fatalError(
                "input of String.init(cString:encoding:) must be null-terminated"
            )
        }
        let ns = cString.withUnsafeBytes {
            NSString(bytes: $0.baseAddress!,
                     length: nullPosition,
                     encoding: enc.rawValue)
        }
        guard let ns = ns else {
            return nil
        }
        self = String._unconditionallyBridgeFromObjectiveC(ns)
    }
  @available(*, deprecated, message: "Use a copy of the String argument")
  @_alwaysEmitIntoClient public init?(cString: Swift.String, encoding enc: Swift.String.Encoding) {
        if enc == .utf8 || enc == .ascii || enc == .nonLossyASCII  {
            var decoded = cString
            decoded.makeContiguousUTF8()
            if let null = decoded.firstIndex(of: "\0") {
                decoded = String(decoded[..<null])
            }
            if enc == .utf8 || decoded.utf8.allSatisfy({ $0 < 128 }) {
                self = decoded
                return
            }
        }
        return nil
    }
  @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
  @_alwaysEmitIntoClient public init?(cString: inout Swift.CChar, encoding enc: Swift.String.Encoding) {
         
        guard cString == 0 else {
            fatalError(
                "input of String.init(cString:encoding:) must be null-terminated"
            )
        }
        self = ""
    }
  public init(format: __shared Swift.String, _ arguments: any Swift.CVarArg...)
  public init(format: __shared Swift.String, arguments: __shared [any Swift.CVarArg])
  public init(format: __shared Swift.String, locale: __shared Foundation.Locale?, _ args: any Swift.CVarArg...)
  public init(format: __shared Swift.String, locale: __shared Foundation.Locale?, arguments: __shared [any Swift.CVarArg])
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.StringProtocol {
  @inlinable internal func _toRelativeNSRange(_ r: Swift.Range<Swift.String.Index>) -> Foundation.NSRange {
        return NSRange(self._toUTF16Offsets(r))
    }
  public func canBeConverted(to encoding: Swift.String.Encoding) -> Swift.Bool
  public func caseInsensitiveCompare<T>(_ aString: T) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func commonPrefix<T>(with aString: T, options: Swift.String.CompareOptions = []) -> Swift.String where T : Swift.StringProtocol
  public func compare<T>(_ aString: T, options mask: Swift.String.CompareOptions = [], range: Swift.Range<Self.Index>? = nil, locale: Foundation.Locale? = nil) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func completePath(into outputName: Swift.UnsafeMutablePointer<Swift.String>? = nil, caseSensitive: Swift.Bool, matchesInto outputArray: Swift.UnsafeMutablePointer<[Swift.String]>? = nil, filterTypes: [Swift.String]? = nil) -> Swift.Int
  public func components(separatedBy separator: Foundation.CharacterSet) -> [Swift.String]
  public func cString(using encoding: Swift.String.Encoding) -> [Swift.CChar]?
  public var decomposedStringWithCanonicalMapping: Swift.String {
    get
  }
  public var decomposedStringWithCompatibilityMapping: Swift.String {
    get
  }
  public func enumerateLines(invoking body: @escaping (_ line: Swift.String, _ stop: inout Swift.Bool) -> Swift.Void)
  public var fastestEncoding: Swift.String.Encoding {
    get
  }
  public func getCString(_ buffer: inout [Swift.CChar], maxLength: Swift.Int, encoding: Swift.String.Encoding) -> Swift.Bool
  public var hash: Swift.Int {
    get
  }
  public func lengthOfBytes(using encoding: Swift.String.Encoding) -> Swift.Int
  public func localizedCaseInsensitiveCompare<T>(_ aString: T) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func localizedCompare<T>(_ aString: T) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func localizedStandardCompare<T>(_ string: T) -> Foundation.ComparisonResult where T : Swift.StringProtocol
  public func maximumLengthOfBytes(using encoding: Swift.String.Encoding) -> Swift.Int
  public var precomposedStringWithCanonicalMapping: Swift.String {
    get
  }
  public var precomposedStringWithCompatibilityMapping: Swift.String {
    get
  }
  public func propertyList() -> Any
  public func propertyListFromStringsFileFormat() -> [Swift.String : Swift.String]
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public func localizedStandardContains<T>(_ string: T) -> Swift.Bool where T : Swift.StringProtocol
  public var smallestEncoding: Swift.String.Encoding {
    get
  }
  public func addingPercentEncoding(withAllowedCharacters allowedCharacters: Foundation.CharacterSet) -> Swift.String?
  public func appendingFormat<T>(_ format: T, _ arguments: any Swift.CVarArg...) -> Swift.String where T : Swift.StringProtocol
  @inlinable public func appending(_ other: some StringProtocol) -> Swift.String {
        var result = String(self)
        result.append(contentsOf: other)
        return result
    }
  public func folding(options: Swift.String.CompareOptions = [], locale: Foundation.Locale?) -> Swift.String
  public func padding<T>(toLength newLength: Swift.Int, withPad padString: T, startingAt padIndex: Swift.Int) -> Swift.String where T : Swift.StringProtocol
  public var removingPercentEncoding: Swift.String? {
    get
  }
  @inlinable public func replacingCharacters<T, R>(in range: R, with replacement: T) -> Swift.String where T : Swift.StringProtocol, R : Swift.RangeExpression, R.Bound == Swift.String.Index {
        var new = ""
        let r = range.relative(to: self)
        if Substring(self).isContiguousUTF8, Substring(replacement).isContiguousUTF8 {
          let prefix = self.utf8.distance(from: self.startIndex, to: r.lowerBound)
          let suffix = self.utf8.distance(from: r.upperBound, to: self.endIndex)
          new.reserveCapacity(prefix + replacement.utf8.count + suffix)
        }
        new += self[..<r.lowerBound]
        new += replacement
        new += self[r.upperBound...]
        return new
    }
  public func replacingOccurrences<Target, Replacement>(of target: Target, with replacement: Replacement, options: Swift.String.CompareOptions = [], range searchRange: Swift.Range<Self.Index>? = nil) -> Swift.String where Target : Swift.StringProtocol, Replacement : Swift.StringProtocol
  @available(swift, deprecated: 3.0, obsoleted: 4.0, message: "Use removingPercentEncoding instead, which always uses the recommended UTF-8 encoding.")
  public func replacingPercentEscapes(using encoding: Swift.String.Encoding) -> Swift.String?
  public func trimmingCharacters(in set: Foundation.CharacterSet) -> Swift.String
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public func applyingTransform(_ transform: Foundation.StringTransform, reverse: Swift.Bool) -> Swift.String?
  public func enumerateLinguisticTags<T, R>(in range: R, scheme tagScheme: T, options opts: Foundation.NSLinguisticTagger.Options = [], orthography: Foundation.NSOrthography? = nil, invoking body: (Swift.String, Swift.Range<Self.Index>, Swift.Range<Self.Index>, inout Swift.Bool) -> Swift.Void) where T : Swift.StringProtocol, R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func enumerateSubstrings<R>(in range: R, options opts: Swift.String.EnumerationOptions = [], _ body: @escaping (_ substring: Swift.String?, _ substringRange: Swift.Range<Self.Index>, _ enclosingRange: Swift.Range<Self.Index>, inout Swift.Bool) -> Swift.Void) where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func getBytes<R>(_ buffer: inout [Swift.UInt8], maxLength maxBufferCount: Swift.Int, usedLength usedBufferCount: Swift.UnsafeMutablePointer<Swift.Int>, encoding: Swift.String.Encoding, options: Swift.String.EncodingConversionOptions = [], range: R, remaining leftover: Swift.UnsafeMutablePointer<Swift.Range<Self.Index>>) -> Swift.Bool where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func getLineStart(_ start: Swift.UnsafeMutablePointer<Self.Index>, end: Swift.UnsafeMutablePointer<Self.Index>, contentsEnd: Swift.UnsafeMutablePointer<Self.Index>, for range: some RangeExpression<Index>)
  public func getParagraphStart(_ start: Swift.UnsafeMutablePointer<Self.Index>, end: Swift.UnsafeMutablePointer<Self.Index>, contentsEnd: Swift.UnsafeMutablePointer<Self.Index>, for range: some RangeExpression<Index>)
  public func linguisticTags<T, R>(in range: R, scheme tagScheme: T, options opts: Foundation.NSLinguisticTagger.Options = [], orthography: Foundation.NSOrthography? = nil, tokenRanges: Swift.UnsafeMutablePointer<[Swift.Range<Self.Index>]>? = nil) -> [Swift.String] where T : Swift.StringProtocol, R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func rangeOfComposedCharacterSequence(at anIndex: Self.Index) -> Swift.Range<Self.Index>
  public func rangeOfComposedCharacterSequences<R>(for range: R) -> Swift.Range<Self.Index> where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  public func range<T>(of aString: T, options mask: Swift.String.CompareOptions = [], range searchRange: Swift.Range<Self.Index>? = nil, locale: Foundation.Locale? = nil) -> Swift.Range<Self.Index>? where T : Swift.StringProtocol
  @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
  public func localizedStandardRange<T>(of string: T) -> Swift.Range<Self.Index>? where T : Swift.StringProtocol
  @available(swift, deprecated: 3.0, obsoleted: 4.0, message: "Use addingPercentEncoding(withAllowedCharacters:) instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid.")
  public func addingPercentEscapes(using encoding: Swift.String.Encoding) -> Swift.String?
  public func contains<T>(_ other: T) -> Swift.Bool where T : Swift.StringProtocol
  public func localizedCaseInsensitiveContains<T>(_ other: T) -> Swift.Bool where T : Swift.StringProtocol
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.StringProtocol {
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript with a 'partial range from' operator.")
  public func substring(from index: Self.Index) -> Swift.String
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript with a 'partial range upto' operator.")
  public func substring(to index: Self.Index) -> Swift.String
  @available(swift, deprecated: 4.0, message: "Please use String slicing subscript.")
  public func substring(with aRange: Swift.Range<Self.Index>) -> Swift.String
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct NSIndexSetIterator : Swift.IteratorProtocol {
  public typealias Element = Swift.Int
  public mutating func next() -> Swift.Int?
}
@available(macOS, unavailable, introduced: 10.10)
@available(iOS, unavailable, introduced: 8.0)
@available(tvOS, unavailable, introduced: 9.0)
@available(watchOS, unavailable, introduced: 2.0)
@available(*, unavailable)
extension Foundation.NSIndexSetIterator : Swift.Sendable {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSIndexSet : Swift.Sequence {
  public func makeIterator() -> Foundation.NSIndexSetIterator
  @_alwaysEmitIntoClient @nonobjc public var underestimatedCount: Swift.Int {
    get { count }
  }
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Element = Foundation.NSIndexSetIterator.Element
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias Iterator = Foundation.NSIndexSetIterator
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  public struct MarkdownParsingOptions : Swift.Sendable {
    public enum FailurePolicy : Swift.Int, Swift.Sendable {
      case throwError
      case returnPartiallyParsedIfPossible
      public init?(rawValue: Swift.Int)
      @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
    public enum InterpretedSyntax : Swift.Int, Swift.Sendable {
      case full
      case inlineOnly
      case inlineOnlyPreservingWhitespace
      public init?(rawValue: Swift.Int)
      @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
    public var allowsExtendedAttributes: Swift.Bool
    public var interpretedSyntax: Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax
    public var failurePolicy: Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy
    public var languageCode: Swift.String?
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var appliesSourcePositionAttributes: Swift.Bool
    public init(allowsExtendedAttributes: Swift.Bool = false, interpretedSyntax: Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax = .full, failurePolicy: Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy = .throwError, languageCode: Swift.String? = nil)
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init(allowsExtendedAttributes: Swift.Bool = false, interpretedSyntax: Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax = .full, failurePolicy: Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy = .throwError, languageCode: Swift.String? = nil, appliesSourcePositionAttributes: Swift.Bool = false)
  }
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public struct MarkdownSourcePosition : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public let startLine: Swift.Int
    public let startColumn: Swift.Int
    public let endLine: Swift.Int
    public let endColumn: Swift.Int
    public init(startLine: Swift.Int, startColumn: Swift.Int, endLine: Swift.Int, endColumn: Swift.Int)
    public static func == (a: Foundation.AttributedString.MarkdownSourcePosition, b: Foundation.AttributedString.MarkdownSourcePosition) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public init<S>(markdown: Swift.String, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
  public init(markdown: Swift.String, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
  public init<S>(markdown: Swift.String, including scope: S.Type, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
  public init<S>(markdown: Foundation.Data, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
  public init(markdown: Foundation.Data, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
  public init<S>(markdown: Foundation.Data, including scope: S.Type, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
  public init<S>(contentsOf url: Foundation.URL, including scope: Swift.KeyPath<Foundation.AttributeScopes, S.Type>, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
  public init(contentsOf url: Foundation.URL, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws
  public init<S>(contentsOf url: Foundation.URL, including scope: S.Type, options: Foundation.AttributedString.MarkdownParsingOptions = .init(), baseURL: Foundation.URL? = nil) throws where S : Foundation.AttributeScope
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.InlinePresentationIntent : Swift.Hashable, Swift.Codable {
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.__NSAttributedStringMarkdownParsingOptions
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.__NSAttributedStringMarkdownParsingOptions, result: inout Foundation.AttributedString.MarkdownParsingOptions?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.__NSAttributedStringMarkdownParsingOptions, result: inout Foundation.AttributedString.MarkdownParsingOptions?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.__NSAttributedStringMarkdownParsingOptions?) -> Foundation.AttributedString.MarkdownParsingOptions
  @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
  public typealias _ObjectiveCType = Foundation.__NSAttributedStringMarkdownParsingOptions
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.AttributedString.MarkdownSourcePosition : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.__NSAttributedStringMarkdownSourcePosition
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.__NSAttributedStringMarkdownSourcePosition, result: inout Foundation.AttributedString.MarkdownSourcePosition?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.__NSAttributedStringMarkdownSourcePosition, result: inout Foundation.AttributedString.MarkdownSourcePosition?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.__NSAttributedStringMarkdownSourcePosition?) -> Foundation.AttributedString.MarkdownSourcePosition
  @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
  public typealias _ObjectiveCType = Foundation.__NSAttributedStringMarkdownSourcePosition
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Date {
  public var description: Swift.String {
    get
  }
  public func description(with locale: Foundation.Locale?) -> Swift.String
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Foundation.Timer {
  public static func publish(every interval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval? = nil, on runLoop: Foundation.RunLoop, in mode: Foundation.RunLoop.Mode, options: Foundation.RunLoop.SchedulerOptions? = nil) -> Foundation.Timer.TimerPublisher
  final public class TimerPublisher : Combine.ConnectablePublisher {
    public typealias Output = Foundation.Date
    public typealias Failure = Swift.Never
    final public let interval: Foundation.TimeInterval
    final public let tolerance: Foundation.TimeInterval?
    final public let runLoop: Foundation.RunLoop
    final public let mode: Foundation.RunLoop.Mode
    final public let options: Foundation.RunLoop.SchedulerOptions?
    public init(interval: Foundation.TimeInterval, tolerance: Foundation.TimeInterval? = nil, runLoop: Foundation.RunLoop, mode: Foundation.RunLoop.Mode, options: Foundation.RunLoop.SchedulerOptions? = nil)
    @objc deinit
    final public func connect() -> any Combine.Cancellable
    final public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == Foundation.Date
  }
}
@available(macOS, unavailable, introduced: 10.15)
@available(iOS, unavailable, introduced: 13.0)
@available(tvOS, unavailable, introduced: 13.0)
@available(watchOS, unavailable, introduced: 6.0)
@available(*, unavailable)
extension Foundation.Timer.TimerPublisher : Swift.Sendable {
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSURL : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSURL.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct AsyncUnicodeScalarSequence<Base> : _Concurrency.AsyncSequence where Base : _Concurrency.AsyncSequence, Base.Element == Swift.UInt8 {
  public typealias Element = Swift.UnicodeScalar
  @frozen public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal var _base: Base.AsyncIterator
    @usableFromInline
    internal var _leftover: Swift.UInt8? = nil
    @inlinable @inline(__always) internal func _expectedContinuationCountForByte(_ byte: Swift.UInt8) -> Swift.Int? {
            if byte & 0b11100000 == 0b11000000 {
                return 1
            }
            if byte & 0b11110000 == 0b11100000 {
                return 2
            }
            if byte & 0b11111000 == 0b11110000 {
                return 3
            }
            if byte & 0b10000000 == 0b00000000 {
                return 0
            }
            if byte & 0b11000000 == 0b10000000 {
                 
                return nil
            }
             
            return nil
        }
    @inlinable internal mutating func _nextComplexScalar(_ first: Swift.UInt8) async rethrows -> Swift.UnicodeScalar? {
            guard let expectedContinuationCount = _expectedContinuationCountForByte(first) else {
                 
                return "\u{FFFD}"
            }
            var bytes: (UInt8, UInt8, UInt8, UInt8) = (first, 0, 0, 0)
            var numContinuations = 0
            while numContinuations < expectedContinuationCount, let next = try await _base.next() {
                guard UTF8.isContinuation(next) else {
                     
                    _leftover = next
                    break
                }
                
                numContinuations += 1
                withUnsafeMutableBytes(of: &bytes) {
                    $0[numContinuations] = next
                }
            }
            return withUnsafeBytes(of: &bytes) {
                return String(decoding: $0, as: UTF8.self).unicodeScalars.first
            }
        }
    @inlinable @inline(__always) public mutating func next() async rethrows -> Swift.UnicodeScalar? {
            if let leftover = _leftover {
                self._leftover = nil
                return try await _nextComplexScalar(leftover)
            }
            if let byte = try await _base.next() {
                if UTF8.isASCII(byte) {
                    _onFastPath()
                    return UnicodeScalar(byte)
                }
                return try await _nextComplexScalar(byte)
            }
            
            return nil
        }
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Element = Swift.UnicodeScalar
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Base.Failure
  }
  public func makeAsyncIterator() -> Foundation.AsyncUnicodeScalarSequence<Base>.AsyncIterator
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Base.Failure
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.AsyncUnicodeScalarSequence : Swift.Sendable where Base : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.AsyncUnicodeScalarSequence.AsyncIterator : Swift.Sendable where Base.AsyncIterator : Swift.Sendable {
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension _Concurrency.AsyncSequence where Self.Element == Swift.UInt8 {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public var unicodeScalars: Foundation.AsyncUnicodeScalarSequence<Self> {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._NSRange : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
        hasher.combine(location)
        hasher.combine(length)
    }
  @inlinable public static func == (lhs: Foundation.NSRange, rhs: Foundation.NSRange) -> Swift.Bool {
        return lhs.location == rhs.location && lhs.length == rhs.length
    }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._NSRange : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._NSRange {
  public init?(_ string: __shared Swift.String)
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._NSRange {
  @inlinable public var lowerBound: Swift.Int {
    get { location }
  }
  @inlinable public var upperBound: Swift.Int {
    get { location + length }
  }
  @inlinable public func contains(_ index: Swift.Int) -> Swift.Bool {
        !(index < location) && (index - location) < length
    }
  @inlinable public mutating func formUnion(_ other: Foundation.NSRange) {
        self = union(other)
    }
  @inlinable public func union(_ other: Foundation.NSRange) -> Foundation.NSRange {
        let max1 = location + length
        let max2 = other.location + other.length
        let maxend = (max1 < max2) ? max2 : max1
        let minloc = location < other.location ? location : other.location
        return NSRange(location: minloc, length: maxend - minloc)
    }
  @inlinable public func intersection(_ other: Foundation.NSRange) -> Foundation.NSRange? {
        let max1 = location + length
        let max2 = other.location + other.length
        let minend = (max1 < max2) ? max1 : max2
        if other.location <= location && location < max2 {
            return NSRange(location: location, length: minend - location)
        } else if location <= other.location && other.location < max1 {
            return NSRange(location: other.location, length: minend - other.location);
        }
        return nil
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._NSRange {
  @inlinable public init<R>(_ region: R) where R : Swift.RangeExpression, R.Bound : Swift.FixedWidthInteger {
        let r = region.relative(to: 0..<R.Bound.max)
        self.init(location: numericCast(r.lowerBound), length: numericCast(r.count))
    }
  public init<R, S>(_ region: R, in target: S) where R : Swift.RangeExpression, S : Swift.StringProtocol, R.Bound == Swift.String.Index
  @available(swift, deprecated: 4, message: "Use Range.init(_:) instead")
  public func toRange() -> Swift.Range<Swift.Int>?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Range where Bound : Swift.BinaryInteger {
  @inlinable public init?(_ range: Foundation.NSRange) {
        guard range.location != NSNotFound else { return nil }
        self.init(uncheckedBounds: (numericCast(range.lowerBound), numericCast(range.upperBound)))
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Range where Bound == Swift.Int {
  @inlinable public init?(_ range: Foundation.NSRange) {
        guard range.location != NSNotFound else { return nil }
        self.init(uncheckedBounds: (range.lowerBound, range.upperBound))
    }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Range where Bound == Swift.String.Index {
  public init?(_ range: Foundation.NSRange, in string: __shared Swift.String)
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public init?<S>(_ range: Foundation.NSRange, in string: __shared S) where S : Swift.StringProtocol
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._NSRange : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._NSRange : Swift._CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSRange.customPlaygroundQuickLook will be removed in a future Swift version")
  public var customPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation._NSRange : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public struct URLResource : Swift.Hashable, Swift.Codable, Swift.Sendable {
  public let bundle: Foundation.Bundle
  public let name: Swift.String
  public let subdirectory: Swift.String?
  public var locale: Foundation.Locale
  public init(name: Swift.String, subdirectory: Swift.String? = nil, locale: Foundation.Locale = .current, bundle: Foundation.Bundle = .main)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: Foundation.URLResource, b: Foundation.URLResource) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.URL {
  public init?(resource: Foundation.URLResource)
}
extension Foundation.Bundle {
  @available(macOS 15.4, iOS 18.4, tvOS 18.4, watchOS 11.4, visionOS 2.4, *)
  public func localizedString(forKey key: Swift.String, value: Swift.String?, table tableName: Swift.String?, localizations: [Foundation.Locale.Language]) -> Swift.String
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.Scanner {
  public enum NumberRepresentation : Swift.Sendable {
    case decimal
    case hexadecimal
    public static func == (a: Foundation.Scanner.NumberRepresentation, b: Foundation.Scanner.NumberRepresentation) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var currentIndex: Swift.String.Index {
    get
    set
  }
  public func scanInt(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Int?
  public func scanInt32(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Int32?
  public func scanInt64(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Int64?
  public func scanUInt64(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.UInt64?
  public func scanFloat(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Float?
  public func scanDouble(representation: Foundation.Scanner.NumberRepresentation = .decimal) -> Swift.Double?
  public func scanDecimal() -> Foundation.Decimal?
  public func scanString(_ searchString: Swift.String) -> Swift.String?
  public func scanCharacters(from set: Foundation.CharacterSet) -> Swift.String?
  public func scanUpToString(_ substring: Swift.String) -> Swift.String?
  public func scanUpToCharacters(from set: Foundation.CharacterSet) -> Swift.String?
  public func scanCharacter() -> Swift.Character?
}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString {
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  public func inflected() -> Foundation.AttributedString
  @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public func inflected(locale: Foundation.Locale = .current, userTermOfAddress: Foundation.TermOfAddress? = .currentUser, inflectionConcepts: [Foundation.InflectionConcept] = []) -> Foundation.AttributedString
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.PersonNameComponents {
  public struct FormatStyle : Foundation.FormatStyle, Swift.Sendable {
    public var style: Foundation.PersonNameComponents.FormatStyle.Style
    public var locale: Foundation.Locale
    public var attributed: Foundation.PersonNameComponents.AttributedStyle {
      get
    }
    public init(style: Foundation.PersonNameComponents.FormatStyle.Style = .medium, locale: Foundation.Locale = .autoupdatingCurrent)
    public func locale(_ locale: Foundation.Locale) -> Foundation.PersonNameComponents.FormatStyle
    public func format(_ value: Foundation.PersonNameComponents) -> Swift.String
    public enum Style : Swift.Int, Swift.Codable, Swift.Hashable, Swift.Sendable {
      case short
      case medium
      case long
      case abbreviated
      public init?(rawValue: Swift.Int)
      @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
    public static func == (a: Foundation.PersonNameComponents.FormatStyle, b: Foundation.PersonNameComponents.FormatStyle) -> Swift.Bool
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Foundation.PersonNameComponents
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct AttributedStyle : Foundation.FormatStyle, Swift.Sendable {
    public var style: Foundation.PersonNameComponents.FormatStyle.Style
    public var locale: Foundation.Locale
    public init(style: Foundation.PersonNameComponents.FormatStyle.Style = .medium, locale: Foundation.Locale = .autoupdatingCurrent)
    public func format(_ value: Foundation.PersonNameComponents) -> Foundation.AttributedString
    public func locale(_ locale: Foundation.Locale) -> Foundation.PersonNameComponents.AttributedStyle
    public static func == (a: Foundation.PersonNameComponents.AttributedStyle, b: Foundation.PersonNameComponents.AttributedStyle) -> Swift.Bool
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Foundation.PersonNameComponents
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = Foundation.AttributedString
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.PersonNameComponents {
  public struct ParseStrategy : Foundation.ParseStrategy, Swift.Sendable {
    public init()
    public func parse(_ value: Swift.String) throws -> Foundation.PersonNameComponents
    public static func == (a: Foundation.PersonNameComponents.ParseStrategy, b: Foundation.PersonNameComponents.ParseStrategy) -> Swift.Bool
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ParseInput = Swift.String
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ParseOutput = Foundation.PersonNameComponents
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.PersonNameComponents {
  public func formatted<S>(_ style: S) -> S.FormatOutput where S : Foundation.FormatStyle, S.FormatInput == Foundation.PersonNameComponents
  public func formatted() -> Swift.String
  public init<S>(_ value: S.ParseInput, strategy: S) throws where S : Foundation.ParseStrategy, S.ParseOutput == Foundation.PersonNameComponents
  public init(_ value: Swift.String) throws
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.PersonNameComponents.FormatStyle : Foundation.ParseableFormatStyle {
  public var parseStrategy: Foundation.PersonNameComponents.ParseStrategy {
    get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  public typealias Strategy = Foundation.PersonNameComponents.ParseStrategy
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.PersonNameComponents.FormatStyle {
  public static func name(style: Foundation.PersonNameComponents.FormatStyle.Style) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseableFormatStyle where Self == Foundation.PersonNameComponents.FormatStyle {
  public static func name(style: Foundation.PersonNameComponents.FormatStyle.Style) -> Self
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ParseStrategy where Self == Foundation.PersonNameComponents.ParseStrategy {
  public static var name: Foundation.PersonNameComponents.ParseStrategy {
    get
  }
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Int8 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int8?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int8?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int8
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSNumber
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.UInt8 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt8?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt8?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt8
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSNumber
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Int16 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int16?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int16?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int16
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSNumber
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.UInt16 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt16?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt16?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt16
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSNumber
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Int32 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int32?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int32?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int32
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSNumber
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.UInt32 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt32?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt32?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt32
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSNumber
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Int64 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int64?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int64?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int64
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSNumber
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.UInt64 : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt64?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt64?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt64
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSNumber
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Int : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Int?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Int
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSNumber
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.UInt : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.UInt?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.UInt
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSNumber
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Float : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Float?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Float?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Float
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSNumber
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Double : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Double?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Double?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Double
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSNumber
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Swift.Bool : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Bool?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout Swift.Bool?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> Swift.Bool
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSNumber
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CoreFoundation.CGFloat : Swift._ObjectiveCBridgeable {
  @available(swift, deprecated: 4, renamed: "init(truncating:)")
  public init(_ number: __shared Foundation.NSNumber)
  public init(truncating number: __shared Foundation.NSNumber)
  public init?(exactly number: __shared Foundation.NSNumber)
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> Foundation.NSNumber
  public static func _forceBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout CoreFoundation.CGFloat?)
  public static func _conditionallyBridgeFromObjectiveC(_ x: Foundation.NSNumber, result: inout CoreFoundation.CGFloat?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ source: Foundation.NSNumber?) -> CoreFoundation.CGFloat
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias _ObjectiveCType = Foundation.NSNumber
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSNumber : Swift.ExpressibleByFloatLiteral, Swift.ExpressibleByIntegerLiteral, Swift.ExpressibleByBooleanLiteral {
  @nonobjc required convenience public init(integerLiteral value: Swift.Int)
  @nonobjc required convenience public init(floatLiteral value: Swift.Double)
  @nonobjc required convenience public init(booleanLiteral value: Swift.Bool)
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias BooleanLiteralType = Swift.Bool
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias FloatLiteralType = Swift.Double
  @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
  public typealias IntegerLiteralType = Swift.Int
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.NSNumber : Swift._HasCustomAnyHashableRepresentation {
  @nonobjc public func _toCustomAnyHashable() -> Swift.AnyHashable?
}
extension Foundation.Date {
  @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
  public struct ComponentsFormatStyle : Foundation.FormatStyle, Swift.Codable, Swift.Hashable, Swift.Sendable {
    public struct Field : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public static var year: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var month: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var week: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var day: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var hour: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var minute: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static var second: Foundation.Date.ComponentsFormatStyle.Field {
        get
      }
      public static func == (a: Foundation.Date.ComponentsFormatStyle.Field, b: Foundation.Date.ComponentsFormatStyle.Field) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct Style : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public static var wide: Foundation.Date.ComponentsFormatStyle.Style {
        get
      }
      public static var abbreviated: Foundation.Date.ComponentsFormatStyle.Style {
        get
      }
      public static var condensedAbbreviated: Foundation.Date.ComponentsFormatStyle.Style {
        get
      }
      public static var narrow: Foundation.Date.ComponentsFormatStyle.Style {
        get
      }
      public static var spellOut: Foundation.Date.ComponentsFormatStyle.Style {
        get
      }
      public static func == (a: Foundation.Date.ComponentsFormatStyle.Style, b: Foundation.Date.ComponentsFormatStyle.Style) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public var style: Foundation.Date.ComponentsFormatStyle.Style
    public var fields: Swift.Set<Foundation.Date.ComponentsFormatStyle.Field>?
    public var calendar: Foundation.Calendar
    public var locale: Foundation.Locale
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public var isPositive: Swift.Bool
    public init(style: Foundation.Date.ComponentsFormatStyle.Style, locale: Foundation.Locale = .autoupdatingCurrent, calendar: Foundation.Calendar = .autoupdatingCurrent, fields: Swift.Set<Foundation.Date.ComponentsFormatStyle.Field>? = nil)
    public func format(_ v: Swift.Range<Foundation.Date>) -> Swift.String
    public func calendar(_ calendar: Foundation.Calendar) -> Foundation.Date.ComponentsFormatStyle
    public func locale(_ locale: Foundation.Locale) -> Foundation.Date.ComponentsFormatStyle
    public static func == (a: Foundation.Date.ComponentsFormatStyle, b: Foundation.Date.ComponentsFormatStyle) -> Swift.Bool
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Swift.Range<Foundation.Date>
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.FormatStyle where Self == Foundation.Date.ComponentsFormatStyle {
  public static func components(style: Foundation.Date.ComponentsFormatStyle.Style, fields: Swift.Set<Foundation.Date.ComponentsFormatStyle.Field>? = nil) -> Self
  public static var timeDuration: Foundation.Date.ComponentsFormatStyle {
    get
  }
}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Date.ComponentsFormatStyle : Foundation.DiscreteFormatStyle {
  public func discreteInput(before input: Swift.Range<Foundation.Date>) -> Swift.Range<Foundation.Date>?
  public func discreteInput(after input: Swift.Range<Foundation.Date>) -> Swift.Range<Foundation.Date>?
  public func input(before input: Swift.Range<Foundation.Date>) -> Swift.Range<Foundation.Date>?
  public func input(after input: Swift.Range<Foundation.Date>) -> Swift.Range<Foundation.Date>?
}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Calendar.Component : Swift.Equatable {}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Calendar.Component : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.DayPeriod.Width : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.DayPeriod.Width : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.TimeZone.Width : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.FormatStyle.Symbol.TimeZone.Width : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute.Component : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute.Component : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.MeasurementAttribute.Component : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ByteCountFormatStyle.Style : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.Width : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.Width : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.Width : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.ListType : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.ListType : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.ListFormatStyle.ListType : Swift.RawRepresentable {}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions : Swift.BitwiseCopyable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Foundation.Morphology.GrammaticalGender : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Foundation.Morphology.PartOfSpeech : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Foundation.Morphology.GrammaticalNumber : Swift.RawRepresentable {}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Morphology.GrammaticalCase : Swift.RawRepresentable {}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Morphology.GrammaticalPerson : Swift.RawRepresentable {}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Morphology.PronounType : Swift.RawRepresentable {}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Morphology.Determination : Swift.RawRepresentable {}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.Morphology.Definiteness : Swift.RawRepresentable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.FormatStyle.Component : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, watchOS 8, tvOS 15, *)
extension Foundation.PresentationIntent.TableColumn.Alignment : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeDynamicLookup : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.AttributeMergePolicy : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.AttributeMergePolicy : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.LinkAttribute : Swift.BitwiseCopyable {}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.AttributeScopes.FoundationAttributes.ReferentConceptAttribute : Swift.BitwiseCopyable {}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.AttributeScopes.FoundationAttributes.AgreementConceptAttribute : Swift.BitwiseCopyable {}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.AttributeScopes.FoundationAttributes.AgreementArgumentAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.MorphologyAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.InflectionRuleAttribute : Swift.BitwiseCopyable {}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedNumberFormatAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.LanguageIdentifierAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.DateFieldAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.InflectionAlternativeAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.InlinePresentationIntentAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.PresentationIntentAttribute : Swift.BitwiseCopyable {}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.AttributeScopes.FoundationAttributes.MarkdownSourcePositionAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.AlternateDescriptionAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.ImageURLAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.ReplacementIndexAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.FoundationAttributes.ByteCountAttribute : Swift.BitwiseCopyable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.AttributeScopes.FoundationAttributes.DurationFieldAttribute : Swift.BitwiseCopyable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.AttributeScopes.FoundationAttributes.DurationFieldAttribute.Field : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.AttributeScopes.FoundationAttributes.DurationFieldAttribute.Field : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.AttributeScopes.FoundationAttributes.DurationFieldAttribute.Field : Swift.RawRepresentable {}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedNumericArgumentAttribute : Swift.BitwiseCopyable {}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedDateArgumentAttribute : Swift.BitwiseCopyable {}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedDateIntervalArgumentAttribute : Swift.BitwiseCopyable {}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedURLArgumentAttribute : Swift.BitwiseCopyable {}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Calendar.Identifier : Swift.Equatable {}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Calendar.Identifier : Swift.Hashable {}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Calendar.SearchDirection : Swift.Equatable {}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Calendar.SearchDirection : Swift.Hashable {}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Calendar.RepeatedTimePolicy : Swift.Equatable {}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Calendar.RepeatedTimePolicy : Swift.Hashable {}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Calendar.MatchingPolicy : Swift.Hashable {}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Calendar.RecurrenceRule.Frequency : Swift.Hashable {}
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Foundation.Calendar.RecurrenceRule.Frequency : Swift.RawRepresentable {}
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Foundation.Data.InlineData : Swift.BitwiseCopyable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeZoneSeparator : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateSeparator : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateSeparator : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateSeparator : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeSeparator : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeSeparator : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.TimeSeparator : Swift.RawRepresentable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateTimeSeparator : Swift.Equatable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateTimeSeparator : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.Date.ISO8601FormatStyle.DateTimeSeparator : Swift.RawRepresentable {}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.IdentifierType : Swift.Equatable {}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.IdentifierType : Swift.Hashable {}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.LanguageCode.IdentifierType : Swift.Equatable {}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.LanguageCode.IdentifierType : Swift.Hashable {}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.Weekday : Swift.RawRepresentable {}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Foundation.Locale.HourCycle : Swift.RawRepresentable {}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.ArithmeticOperator : Swift.Equatable {}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.ArithmeticOperator : Swift.Hashable {}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.ComparisonOperator : Swift.Equatable {}
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Foundation.PredicateExpressions.ComparisonOperator : Swift.Hashable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.DirectoryHint : Swift.Equatable {}
@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Foundation.URL.DirectoryHint : Swift.Hashable {}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.SortOrder : Swift.BitwiseCopyable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.BackgroundTaskCancelledReason : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.BackgroundTaskCancelledReason : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.BackgroundTaskCancelledReason : Swift.RawRepresentable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.NetworkUnavailableReason : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.NetworkUnavailableReason : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.URLError.NetworkUnavailableReason : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.FailurePolicy : Swift.RawRepresentable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax : Swift.Equatable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax : Swift.Hashable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributedString.MarkdownParsingOptions.InterpretedSyntax : Swift.RawRepresentable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.Scanner.NumberRepresentation : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Foundation.Scanner.NumberRepresentation : Swift.Hashable {}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Foundation.PersonNameComponents.FormatStyle.Style : Swift.RawRepresentable {}
