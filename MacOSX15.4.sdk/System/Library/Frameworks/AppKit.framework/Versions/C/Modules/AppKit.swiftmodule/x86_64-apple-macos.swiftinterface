// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1 effective-5.10 (swiftlang-6.1.0.110.5 clang-1700.0.13.3)
// swift-module-flags: -target x86_64-apple-macos15.4 -target-variant x86_64-apple-ios18.4-macabi -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -library-level api -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 2575.50.26 -module-name AppKit
// swift-module-flags-ignorable:  -interface-compiler-version 6.1
@_exported import Accessibility
@_exported import AppKit
@_exported import CoreGraphics
import CoreText
import CoreTransferable
import DataDetection
@_exported import DeveloperToolsSupport
import Foundation
import OSLog
import OpenGL
import Swift
import Symbols
import UniformTypeIdentifiers.UTType
import UniformTypeIdentifiers
@_exported import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@available(macCatalyst 18.0, macOS 15.0, *)
@frozen public enum NSHorizontalDirection : Swift.Int8, Swift.CaseIterable, Swift.Codable {
  case left
  case right
  @frozen public struct Set : Swift.OptionSet, Swift.Equatable, Swift.Hashable {
    public typealias Element = AppKit.NSHorizontalDirection.Set
    public typealias RawValue = Swift.Int8
    public let rawValue: AppKit.NSHorizontalDirection.Set.RawValue
    public init(rawValue: AppKit.NSHorizontalDirection.Set.RawValue)
    public static let left: AppKit.NSHorizontalDirection.Set
    public static let right: AppKit.NSHorizontalDirection.Set
    public static let all: AppKit.NSHorizontalDirection.Set
    public init(_ direction: AppKit.NSHorizontalDirection)
    @available(macOS 15.0, macCatalyst 18.0, *)
    public typealias ArrayLiteralElement = AppKit.NSHorizontalDirection.Set.Element
  }
  public init?(rawValue: Swift.Int8)
  @available(macOS 15.0, macCatalyst 18.0, *)
  public typealias AllCases = [AppKit.NSHorizontalDirection]
  @available(macOS 15.0, macCatalyst 18.0, *)
  public typealias RawValue = Swift.Int8
  nonisolated public static var allCases: [AppKit.NSHorizontalDirection] {
    get
  }
  public var rawValue: Swift.Int8 {
    get
  }
}
extension AppKit.NSHorizontalDirection.Set {
  @available(macCatalyst 18.0, macOS 15.0, *)
  public func contains(_ member: AppKit.NSHorizontalDirection) -> Swift.Bool
  @available(macCatalyst 18.0, macOS 15.0, *)
  @discardableResult
  public mutating func insert(_ newMember: __owned AppKit.NSHorizontalDirection) -> (inserted: Swift.Bool, memberAfterInsert: AppKit.NSHorizontalDirection)
  @available(macCatalyst 18.0, macOS 15.0, *)
  @discardableResult
  public mutating func remove(_ member: AppKit.NSHorizontalDirection) -> AppKit.NSHorizontalDirection?
  @available(macCatalyst 18.0, macOS 15.0, *)
  @discardableResult
  public mutating func update(with newMember: __owned AppKit.NSHorizontalDirection) -> AppKit.NSHorizontalDirection?
}
extension AppKit.NSHorizontalDirection {
  @available(macOS 15.0, *)
  public static func leading(relativeTo layoutDirection: AppKit.NSUserInterfaceLayoutDirection) -> AppKit.NSHorizontalDirection
  @available(macOS 15.0, *)
  public static func trailing(relativeTo layoutDirection: AppKit.NSUserInterfaceLayoutDirection) -> AppKit.NSHorizontalDirection
}
@available(macCatalyst 18.0, macOS 15.0, *)
@frozen public enum NSVerticalDirection : Swift.Int8, Swift.CaseIterable, Swift.Codable {
  case up
  case down
  @frozen public struct Set : Swift.OptionSet, Swift.Equatable, Swift.Hashable {
    public typealias Element = AppKit.NSVerticalDirection.Set
    public typealias RawValue = Swift.Int8
    public let rawValue: AppKit.NSVerticalDirection.Set.RawValue
    public init(rawValue: AppKit.NSVerticalDirection.Set.RawValue)
    public static let up: AppKit.NSVerticalDirection.Set
    public static let down: AppKit.NSVerticalDirection.Set
    public static let all: AppKit.NSVerticalDirection.Set
    public init(_ direction: AppKit.NSVerticalDirection)
    @available(macOS 15.0, macCatalyst 18.0, *)
    public typealias ArrayLiteralElement = AppKit.NSVerticalDirection.Set.Element
  }
  public init?(rawValue: Swift.Int8)
  @available(macOS 15.0, macCatalyst 18.0, *)
  public typealias AllCases = [AppKit.NSVerticalDirection]
  @available(macOS 15.0, macCatalyst 18.0, *)
  public typealias RawValue = Swift.Int8
  nonisolated public static var allCases: [AppKit.NSVerticalDirection] {
    get
  }
  public var rawValue: Swift.Int8 {
    get
  }
}
extension AppKit.NSVerticalDirection.Set {
  @available(macCatalyst 18.0, macOS 15.0, *)
  public func contains(_ member: AppKit.NSVerticalDirection) -> Swift.Bool
  @available(macCatalyst 18.0, macOS 15.0, *)
  @discardableResult
  public mutating func insert(_ newMember: __owned AppKit.NSVerticalDirection) -> (inserted: Swift.Bool, memberAfterInsert: AppKit.NSVerticalDirection)
  @available(macCatalyst 18.0, macOS 15.0, *)
  @discardableResult
  public mutating func remove(_ member: AppKit.NSVerticalDirection) -> AppKit.NSVerticalDirection?
  @available(macCatalyst 18.0, macOS 15.0, *)
  @discardableResult
  public mutating func update(with newMember: __owned AppKit.NSVerticalDirection) -> AppKit.NSVerticalDirection?
}
@available(macOS 14.0, *)
extension AppKit.NSShadow : @unchecked Swift.Sendable {
}
@available(swift 5.1)
@available(macOS 12, *)
public protocol NSViewInvalidating {
  func invalidate(view: AppKit.NSView)
}
extension AppKit.NSView {
  @available(swift 5.1)
  @available(macOS 12, *)
  @propertyWrapper public struct Invalidating<Value, InvalidationType> where Value : Swift.Equatable, InvalidationType : AppKit.NSViewInvalidating {
    @available(*, unavailable, message: "@NSView.Invalidating can only be used on subclasses of NSView")
    public var wrappedValue: Value {
      get
      set
    }
    public init(wrappedValue: Value, _ invalidation: InvalidationType)
    public init<InvalidationType1, InvalidationType2>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2) where InvalidationType == AppKit.NSView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, InvalidationType1 : AppKit.NSViewInvalidating, InvalidationType2 : AppKit.NSViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3) where InvalidationType == AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, InvalidationType3>, InvalidationType1 : AppKit.NSViewInvalidating, InvalidationType2 : AppKit.NSViewInvalidating, InvalidationType3 : AppKit.NSViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4) where InvalidationType == AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, AppKit.NSView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, InvalidationType1 : AppKit.NSViewInvalidating, InvalidationType2 : AppKit.NSViewInvalidating, InvalidationType3 : AppKit.NSViewInvalidating, InvalidationType4 : AppKit.NSViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5) where InvalidationType == AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, AppKit.NSView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, InvalidationType5>, InvalidationType1 : AppKit.NSViewInvalidating, InvalidationType2 : AppKit.NSViewInvalidating, InvalidationType3 : AppKit.NSViewInvalidating, InvalidationType4 : AppKit.NSViewInvalidating, InvalidationType5 : AppKit.NSViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6) where InvalidationType == AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, AppKit.NSView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, AppKit.NSView.Invalidations.Tuple<InvalidationType5, InvalidationType6>>, InvalidationType1 : AppKit.NSViewInvalidating, InvalidationType2 : AppKit.NSViewInvalidating, InvalidationType3 : AppKit.NSViewInvalidating, InvalidationType4 : AppKit.NSViewInvalidating, InvalidationType5 : AppKit.NSViewInvalidating, InvalidationType6 : AppKit.NSViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6, InvalidationType7>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6, _ invalidation7: InvalidationType7) where InvalidationType == AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, AppKit.NSView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<InvalidationType5, InvalidationType6>, InvalidationType7>>, InvalidationType1 : AppKit.NSViewInvalidating, InvalidationType2 : AppKit.NSViewInvalidating, InvalidationType3 : AppKit.NSViewInvalidating, InvalidationType4 : AppKit.NSViewInvalidating, InvalidationType5 : AppKit.NSViewInvalidating, InvalidationType6 : AppKit.NSViewInvalidating, InvalidationType7 : AppKit.NSViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6, InvalidationType7, InvalidationType8>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6, _ invalidation7: InvalidationType7, _ invalidation8: InvalidationType8) where InvalidationType == AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, AppKit.NSView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<InvalidationType5, InvalidationType6>, AppKit.NSView.Invalidations.Tuple<InvalidationType7, InvalidationType8>>>, InvalidationType1 : AppKit.NSViewInvalidating, InvalidationType2 : AppKit.NSViewInvalidating, InvalidationType3 : AppKit.NSViewInvalidating, InvalidationType4 : AppKit.NSViewInvalidating, InvalidationType5 : AppKit.NSViewInvalidating, InvalidationType6 : AppKit.NSViewInvalidating, InvalidationType7 : AppKit.NSViewInvalidating, InvalidationType8 : AppKit.NSViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6, InvalidationType7, InvalidationType8, InvalidationType9>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6, _ invalidation7: InvalidationType7, _ invalidation8: InvalidationType8, _ invalidation9: InvalidationType9) where InvalidationType == AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, AppKit.NSView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<InvalidationType5, InvalidationType6>, AppKit.NSView.Invalidations.Tuple<InvalidationType7, InvalidationType8>>>, InvalidationType9>, InvalidationType1 : AppKit.NSViewInvalidating, InvalidationType2 : AppKit.NSViewInvalidating, InvalidationType3 : AppKit.NSViewInvalidating, InvalidationType4 : AppKit.NSViewInvalidating, InvalidationType5 : AppKit.NSViewInvalidating, InvalidationType6 : AppKit.NSViewInvalidating, InvalidationType7 : AppKit.NSViewInvalidating, InvalidationType8 : AppKit.NSViewInvalidating, InvalidationType9 : AppKit.NSViewInvalidating
    public init<InvalidationType1, InvalidationType2, InvalidationType3, InvalidationType4, InvalidationType5, InvalidationType6, InvalidationType7, InvalidationType8, InvalidationType9, InvalidationType10>(wrappedValue: Value, _ invalidation1: InvalidationType1, _ invalidation2: InvalidationType2, _ invalidation3: InvalidationType3, _ invalidation4: InvalidationType4, _ invalidation5: InvalidationType5, _ invalidation6: InvalidationType6, _ invalidation7: InvalidationType7, _ invalidation8: InvalidationType8, _ invalidation9: InvalidationType9, _ invalidation10: InvalidationType10) where InvalidationType == AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<InvalidationType1, InvalidationType2>, AppKit.NSView.Invalidations.Tuple<InvalidationType3, InvalidationType4>>, AppKit.NSView.Invalidations.Tuple<AppKit.NSView.Invalidations.Tuple<InvalidationType5, InvalidationType6>, AppKit.NSView.Invalidations.Tuple<InvalidationType7, InvalidationType8>>>, AppKit.NSView.Invalidations.Tuple<InvalidationType9, InvalidationType10>>, InvalidationType1 : AppKit.NSViewInvalidating, InvalidationType2 : AppKit.NSViewInvalidating, InvalidationType3 : AppKit.NSViewInvalidating, InvalidationType4 : AppKit.NSViewInvalidating, InvalidationType5 : AppKit.NSViewInvalidating, InvalidationType6 : AppKit.NSViewInvalidating, InvalidationType7 : AppKit.NSViewInvalidating, InvalidationType8 : AppKit.NSViewInvalidating, InvalidationType9 : AppKit.NSViewInvalidating, InvalidationType10 : AppKit.NSViewInvalidating
    public static subscript<EnclosingSelf>(_enclosingInstance observed: EnclosingSelf, wrapped wrappedKeyPath: Swift.ReferenceWritableKeyPath<EnclosingSelf, Value>, storage storageKeyPath: Swift.ReferenceWritableKeyPath<EnclosingSelf, AppKit.NSView.Invalidating<Value, InvalidationType>>) -> Value where EnclosingSelf : AppKit.NSView {
      get
      set
    }
  }
}
@available(swift 5.1)
@available(macOS 12, *)
extension AppKit.NSViewInvalidating where Self == AppKit.NSView.Invalidations.Display {
  @_alwaysEmitIntoClient public static var display: AppKit.NSView.Invalidations.Display {
    get { return .init() }
  }
}
@available(swift 5.1)
@available(macOS 12, *)
extension AppKit.NSViewInvalidating where Self == AppKit.NSView.Invalidations.Layout {
  @_alwaysEmitIntoClient public static var layout: AppKit.NSView.Invalidations.Layout {
    get { return .init() }
  }
}
@available(swift 5.1)
@available(macOS 12, *)
extension AppKit.NSViewInvalidating where Self == AppKit.NSView.Invalidations.Constraints {
  @_alwaysEmitIntoClient public static var constraints: AppKit.NSView.Invalidations.Constraints {
    get { return .init() }
  }
}
@available(swift 5.1)
@available(macOS 12, *)
extension AppKit.NSViewInvalidating where Self == AppKit.NSView.Invalidations.IntrinsicContentSize {
  @_alwaysEmitIntoClient public static var intrinsicContentSize: AppKit.NSView.Invalidations.IntrinsicContentSize {
    get { return .init() }
  }
}
@available(swift 5.1)
@available(macOS 12, *)
extension AppKit.NSViewInvalidating where Self == AppKit.NSView.Invalidations.RestorableState {
  @_alwaysEmitIntoClient public static var restorableState: AppKit.NSView.Invalidations.RestorableState {
    get { return .init() }
  }
}
extension AppKit.NSView {
  @available(swift 5.1)
  @available(macOS 12, *)
  public enum Invalidations {
    public struct Display : AppKit.NSViewInvalidating {
      public init()
      public func invalidate(view: AppKit.NSView)
    }
    public struct Layout : AppKit.NSViewInvalidating {
      public init()
      public func invalidate(view: AppKit.NSView)
    }
    public struct Constraints : AppKit.NSViewInvalidating {
      public init()
      public func invalidate(view: AppKit.NSView)
    }
    public struct IntrinsicContentSize : AppKit.NSViewInvalidating {
      public init()
      public func invalidate(view: AppKit.NSView)
    }
    public struct RestorableState : AppKit.NSViewInvalidating {
      public init()
      public func invalidate(view: AppKit.NSView)
    }
    public struct Tuple<Invalidation1, Invalidation2> : AppKit.NSViewInvalidating where Invalidation1 : AppKit.NSViewInvalidating, Invalidation2 : AppKit.NSViewInvalidating {
      public init(_ invalidation1: Invalidation1, _ invalidation2: Invalidation2)
      public func invalidate(view: AppKit.NSView)
    }
  }
}
@available(*, unavailable)
extension AppKit.NSView.Invalidating : Swift.Sendable {
}
@available(*, unavailable)
extension AppKit.NSView.Invalidations : Swift.Sendable {
}
@available(*, unavailable)
extension AppKit.NSView.Invalidations.Display : Swift.Sendable {
}
@available(*, unavailable)
extension AppKit.NSView.Invalidations.Layout : Swift.Sendable {
}
@available(*, unavailable)
extension AppKit.NSView.Invalidations.Constraints : Swift.Sendable {
}
@available(*, unavailable)
extension AppKit.NSView.Invalidations.IntrinsicContentSize : Swift.Sendable {
}
@available(*, unavailable)
extension AppKit.NSView.Invalidations.RestorableState : Swift.Sendable {
}
@available(*, unavailable)
extension AppKit.NSView.Invalidations.Tuple : Swift.Sendable {
}
extension AppKit.NSPopUpButton {
  @available(macOS 10.10, *)
  @_alwaysEmitIntoClient @_Concurrency.MainActor @preconcurrency internal func _configurePullDown(title: Swift.String?, image: AppKit.NSImage?, pullDownMenu: AppKit.NSMenu) {
        pullsDown = true

        if #available(macOS 14.0, *) {
            bezelStyle = .automatic
        } else {
            bezelStyle = .push
        }

        switch (title, image) {
        case (.some, .some):
            if #available(macOS 10.12, *) {
                imagePosition = .imageLeading
            } else {
                imagePosition = NSApp.userInterfaceLayoutDirection == .rightToLeft ? .imageRight : .imageLeft
            }
        case (nil, .some):
            imagePosition = .imageOnly
        default:
            imagePosition = .noImage
        }

        imageScaling = .scaleProportionallyDown
        lineBreakMode = .byTruncatingTail
        setButtonType(.momentaryPushIn)
        font = .systemFont(ofSize: 0.0)

        let popupCell = cell as? NSPopUpButtonCell
        popupCell?.usesItemFromMenu = false
        menu = pullDownMenu
        if pullDownMenu.numberOfItems > 0 {
            pullDownMenu.item(at: 0)?.isHidden = false
        }

        let displayItem = NSMenuItem()
        displayItem.title = title ?? ""
        displayItem.image = image
        popupCell?.menuItem = displayItem
    }
  @available(macOS 10.10, *)
  @backDeployed(before: macOS 15.0)
  @_Concurrency.MainActor @preconcurrency convenience public init(title: Swift.String, image: AppKit.NSImage? = nil, pullDownMenu: AppKit.NSMenu) {
        self.init(frame: .zero)
        _configurePullDown(title: title, image: image, pullDownMenu: pullDownMenu)
        sizeToFit()
    }
  @available(macOS 10.10, *)
  @backDeployed(before: macOS 15.0)
  @_Concurrency.MainActor @preconcurrency convenience public init(image: AppKit.NSImage, pullDownMenu: AppKit.NSMenu) {
        self.init(frame: .zero)
        _configurePullDown(title: nil, image: image, pullDownMenu: pullDownMenu)
        sizeToFit()
    }
  @available(macOS 10.10, *)
  @backDeployed(before: macOS 15.0)
  @_Concurrency.MainActor @preconcurrency convenience public init(popUpMenu: AppKit.NSMenu, target: Swift.AnyObject?, action: ObjectiveC.Selector?) {
        self.init(frame: .zero)
        
        if #available(macOS 14.0, *) {
            bezelStyle = .automatic
        } else {
            bezelStyle = .push
        }

        if #available(macOS 10.12, *) {
            imagePosition = .imageLeading
        } else {
            imagePosition = NSApp.userInterfaceLayoutDirection == .rightToLeft ? .imageRight : .imageLeft
        }

        imageScaling = .scaleProportionallyDown
        setButtonType(.momentaryPushIn)
        lineBreakMode = .byTruncatingTail
        font = .systemFont(ofSize: 0.0)

        menu = popUpMenu
        selectItem(at: 0)

        self.target = target
        self.action = action
        sizeToFit()
    }
}
@available(macOS 10.15.1, *)
public struct NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType> where SectionIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Hashable {
  public init()
  public var numberOfItems: Swift.Int {
    get
  }
  public var numberOfSections: Swift.Int {
    get
  }
  public var sectionIdentifiers: [SectionIdentifierType] {
    get
  }
  public var itemIdentifiers: [ItemIdentifierType] {
    get
  }
  public func numberOfItems(inSection identifier: SectionIdentifierType) -> Swift.Int
  public func itemIdentifiers(inSection identifier: SectionIdentifierType) -> [ItemIdentifierType]
  public func sectionIdentifier(containingItem identifier: ItemIdentifierType) -> SectionIdentifierType?
  public func indexOfItem(_ identifier: ItemIdentifierType) -> Swift.Int?
  public func indexOfSection(_ identifier: SectionIdentifierType) -> Swift.Int?
  public mutating func appendItems(_ identifiers: [ItemIdentifierType], toSection sectionIdentifier: SectionIdentifierType? = nil)
  public mutating func insertItems(_ identifiers: [ItemIdentifierType], beforeItem beforeIdentifier: ItemIdentifierType)
  public mutating func insertItems(_ identifiers: [ItemIdentifierType], afterItem afterIdentifier: ItemIdentifierType)
  public mutating func deleteItems(_ identifiers: [ItemIdentifierType])
  public mutating func deleteAllItems()
  public mutating func moveItem(_ identifier: ItemIdentifierType, beforeItem toIdentifier: ItemIdentifierType)
  public mutating func moveItem(_ identifier: ItemIdentifierType, afterItem toIdentifier: ItemIdentifierType)
  public mutating func reloadItems(_ identifiers: [ItemIdentifierType])
  public mutating func appendSections(_ identifiers: [SectionIdentifierType])
  public mutating func insertSections(_ identifiers: [SectionIdentifierType], beforeSection toIdentifier: SectionIdentifierType)
  public mutating func insertSections(_ identifiers: [SectionIdentifierType], afterSection toIdentifier: SectionIdentifierType)
  public mutating func deleteSections(_ identifiers: [SectionIdentifierType])
  public mutating func moveSection(_ identifier: SectionIdentifierType, beforeSection toIdentifier: SectionIdentifierType)
  public mutating func moveSection(_ identifier: SectionIdentifierType, afterSection toIdentifier: SectionIdentifierType)
  public mutating func reloadSections(_ identifiers: [SectionIdentifierType])
}
@available(macOS 10.15.1, *)
extension AppKit.NSDiffableDataSourceSnapshot : Swift._ObjectiveCBridgeable {
  @_semantics("convertToObjectiveC") public func _bridgeToObjectiveC() -> AppKit.NSDiffableDataSourceSnapshotReference
  public static func _forceBridgeFromObjectiveC(_ input: AppKit.NSDiffableDataSourceSnapshotReference, result: inout AppKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>?)
  public static func _conditionallyBridgeFromObjectiveC(_ input: AppKit.NSDiffableDataSourceSnapshotReference, result: inout AppKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>?) -> Swift.Bool
  @_effects(readonly) public static func _unconditionallyBridgeFromObjectiveC(_ snapshot: AppKit.NSDiffableDataSourceSnapshotReference?) -> AppKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
  @available(macOS 10.15.1, *)
  public typealias _ObjectiveCType = AppKit.NSDiffableDataSourceSnapshotReference
}
@available(macOS 10.9, *)
public func NSApplicationMain(_ argc: Swift.Int32, _ argv: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Swift.CChar>?>) -> Swift.Int32
extension AppKit.NSApplicationDelegate {
  @_alwaysEmitIntoClient public static func main() {
        exit(NSApplicationMain(CommandLine.argc, CommandLine.unsafeArgv))
    }
}
extension AppKit.NSApplication {
  @available(swift 4)
  @available(macOS 10.9, *)
  @_Concurrency.MainActor @preconcurrency public static func loadApplication()
}
@available(macOS 10.9, *)
extension AppKit.NSAppKitVersion {
  @available(*, deprecated, renamed: "macOS10_14")
  public static var number10_14: AppKit.NSAppKitVersion {
    get
  }
  @available(*, deprecated, renamed: "macOS10_14_1")
  public static var number10_14_1: AppKit.NSAppKitVersion {
    get
  }
  @available(*, deprecated, renamed: "macOS10_14_2")
  public static var number10_14_2: AppKit.NSAppKitVersion {
    get
  }
  @available(*, deprecated, renamed: "macOS10_14_3")
  public static var number10_14_3: AppKit.NSAppKitVersion {
    get
  }
  @available(*, deprecated, renamed: "macOS10_14_4")
  public static var number10_14_4: AppKit.NSAppKitVersion {
    get
  }
  @available(*, deprecated, renamed: "macOS10_14_5")
  public static var number10_14_5: AppKit.NSAppKitVersion {
    get
  }
  @available(*, deprecated, renamed: "macOS10_15")
  public static var number10_15: AppKit.NSAppKitVersion {
    get
  }
}
@available(macOS 11.0, *)
open class NSTableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType> : ObjectiveC.NSObject, AppKit.NSTableViewDataSource where SectionIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Hashable {
  public typealias CellProvider = (_ tableView: AppKit.NSTableView, _ tableColumn: AppKit.NSTableColumn, _ row: Swift.Int, _ identifier: ItemIdentifierType) -> AppKit.NSView
  public typealias SectionHeaderViewProvider = (_ tableView: AppKit.NSTableView, _ row: Swift.Int, _ identifier: SectionIdentifierType) -> AppKit.NSView
  public typealias RowProvider = (_ tableView: AppKit.NSTableView, _ row: Swift.Int, _ identifier: Swift.AnyHashable) -> AppKit.NSTableRowView
  public var rowViewProvider: AppKit.NSTableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.RowProvider?
  public var sectionHeaderViewProvider: AppKit.NSTableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.SectionHeaderViewProvider?
  public var defaultRowAnimation: AppKit.NSTableView.AnimationOptions
  public init(tableView: AppKit.NSTableView, cellProvider: @escaping AppKit.NSTableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.CellProvider)
  public func snapshot() -> AppKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
  public func apply(_ snapshot: AppKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Swift.Bool, completion: (() -> Swift.Void)? = nil)
  public func itemIdentifier(forRow row: Swift.Int) -> ItemIdentifierType?
  public func row(forItemIdentifier identifier: ItemIdentifierType) -> Swift.Int?
  public func sectionIdentifier(forRow row: Swift.Int) -> SectionIdentifierType?
  public func row(forSectionIdentifier identifier: SectionIdentifierType) -> Swift.Int?
  @_Concurrency.MainActor @preconcurrency @objc public func numberOfRows(in tableView: AppKit.NSTableView) -> Swift.Int
  @objc deinit
}
@available(macOS 14.0, *)
extension AppKit.NSImage {
  convenience public init(resource: DeveloperToolsSupport.ImageResource)
}
@available(macOS 10.9, *)
extension AppKit.NSImage : Swift._ExpressibleByImageLiteral {
  @nonobjc required convenience public init(imageLiteralResourceName name: Swift.String)
}
public typealias _ImageLiteralType = AppKit.NSImage
@available(macOS 14.0, *)
extension AppKit.NSMenuItemBadge {
  @objc dynamic public var stringValue: Swift.String? {
    @objc get
  }
}
@available(macOS 15.0, *)
extension AppKit.NSMenuItemBadge : Swift.Codable {
  required convenience public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 15.0, *)
public struct NSSuggestionItemSection<SuggestionItemType> {
  public typealias Item = AppKit.NSSuggestionItem<SuggestionItemType>
  public var title: Swift.String?
  public var items: [AppKit.NSSuggestionItemSection<SuggestionItemType>.Item]
  public init(title: Swift.String?, items: [AppKit.NSSuggestionItemSection<SuggestionItemType>.Item])
  public init(items: [AppKit.NSSuggestionItemSection<SuggestionItemType>.Item])
}
@available(macOS 15.0, *)
extension AppKit.NSSuggestionItemSection : Swift.Equatable where SuggestionItemType : Swift.Equatable {
  public static func == (a: AppKit.NSSuggestionItemSection<SuggestionItemType>, b: AppKit.NSSuggestionItemSection<SuggestionItemType>) -> Swift.Bool
}
@available(macOS 15.0, *)
extension AppKit.NSSuggestionItemSection : Swift.Hashable where SuggestionItemType : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 12, *)
extension Foundation.AttributeScopes {
  public var appKit: Foundation.AttributeScopes.AppKitAttributes.Type {
    get
  }
  public struct AppKitAttributes : Foundation.AttributeScope {
    public let font: Foundation.AttributeScopes.AppKitAttributes.FontAttribute
    public let paragraphStyle: Foundation.AttributeScopes.AppKitAttributes.ParagraphStyleAttribute
    public let foregroundColor: Foundation.AttributeScopes.AppKitAttributes.ForegroundColorAttribute
    public let backgroundColor: Foundation.AttributeScopes.AppKitAttributes.BackgroundColorAttribute
    public let ligature: Foundation.AttributeScopes.AppKitAttributes.LigatureAttribute
    public let kern: Foundation.AttributeScopes.AppKitAttributes.KernAttribute
    public let tracking: Foundation.AttributeScopes.AppKitAttributes.TrackingAttribute
    public let strikethroughStyle: Foundation.AttributeScopes.AppKitAttributes.StrikethroughStyleAttribute
    public let underlineStyle: Foundation.AttributeScopes.AppKitAttributes.UnderlineStyleAttribute
    public let strokeColor: Foundation.AttributeScopes.AppKitAttributes.StrokeColorAttribute
    public let strokeWidth: Foundation.AttributeScopes.AppKitAttributes.StrokeWidthAttribute
    public let shadow: Foundation.AttributeScopes.AppKitAttributes.ShadowAttribute
    public let textEffect: Foundation.AttributeScopes.AppKitAttributes.TextEffectAttribute
    public let attachment: Foundation.AttributeScopes.AppKitAttributes.AttachmentAttribute
    public let baselineOffset: Foundation.AttributeScopes.AppKitAttributes.BaselineOffsetAttribute
    public let underlineColor: Foundation.AttributeScopes.AppKitAttributes.UnderlineColorAttribute
    public let strikethroughColor: Foundation.AttributeScopes.AppKitAttributes.StrikethroughColorAttribute
    @available(macOS, introduced: 12.0, deprecated: 100000.0, message: "This attribute is not supported with TextKit 2")
    public let obliqueness: Foundation.AttributeScopes.AppKitAttributes.ObliquenessAttribute
    @available(macOS, introduced: 12.0, deprecated: 100000.0, message: "This attribute is not supported with TextKit 2")
    public let expansion: Foundation.AttributeScopes.AppKitAttributes.ExpansionAttribute
    public let toolTip: Foundation.AttributeScopes.AppKitAttributes.ToolTipAttribute
    public let markedClauseSegment: Foundation.AttributeScopes.AppKitAttributes.MarkedClauseSegmentAttribute
    public let superscript: Foundation.AttributeScopes.AppKitAttributes.SuperscriptAttribute
    public let textAlternatives: Foundation.AttributeScopes.AppKitAttributes.TextAlternativesAttribute
    public let glyphInfo: Foundation.AttributeScopes.AppKitAttributes.GlyphInfoAttribute
    public let cursor: Foundation.AttributeScopes.AppKitAttributes.CursorAttribute
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public let adaptiveImageGlyph: Foundation.AttributeScopes.AppKitAttributes.AdaptiveImageGlyphAttribute
    public let accessibility: Foundation.AttributeScopes.AccessibilityAttributes
    public let foundation: Foundation.AttributeScopes.FoundationAttributes
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias DecodingConfiguration = Foundation.AttributeScopeCodableConfiguration
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias EncodingConfiguration = Foundation.AttributeScopeCodableConfiguration
  }
}
@available(macOS 12, *)
extension Foundation.AttributeDynamicLookup {
  @_disfavoredOverload public subscript<T>(dynamicMember keyPath: Swift.KeyPath<Foundation.AttributeScopes.AppKitAttributes, T>) -> T where T : Foundation.AttributedStringKey {
    get
  }
}
@available(macOS 12, *)
extension AppKit.NSUnderlineStyle : Swift.Hashable {
}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes {
  @frozen public enum FontAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = AppKit.NSFont
    public static let name: Swift.String
  }
  @frozen public enum ParagraphStyleAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = AppKit.NSParagraphStyle
    public static let name: Swift.String
  }
  @frozen public enum ForegroundColorAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = AppKit.NSColor
    public static let name: Swift.String
  }
  @frozen public enum BackgroundColorAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = AppKit.NSColor
    public static let name: Swift.String
  }
  @frozen public enum LigatureAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Swift.Int
    public static let name: Swift.String
  }
  @frozen public enum KernAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreFoundation.CGFloat
    public static let name: Swift.String
  }
  @frozen public enum TrackingAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreFoundation.CGFloat
    public static let name: Swift.String
  }
  @frozen public enum StrikethroughStyleAttribute : Foundation.CodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey {
    public typealias Value = AppKit.NSUnderlineStyle
    public typealias ObjectiveCValue = Foundation.NSNumber
    public static let name: Swift.String
    public static func encode(_ value: AppKit.NSUnderlineStyle, to encoder: any Swift.Encoder) throws
    public static func decode(from decoder: any Swift.Decoder) throws -> AppKit.NSUnderlineStyle
  }
  @frozen public enum UnderlineStyleAttribute : Foundation.CodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey {
    public typealias Value = AppKit.NSUnderlineStyle
    public typealias ObjectiveCValue = Foundation.NSNumber
    public static let name: Swift.String
    public static func encode(_ value: AppKit.NSUnderlineStyle, to encoder: any Swift.Encoder) throws
    public static func decode(from decoder: any Swift.Decoder) throws -> AppKit.NSUnderlineStyle
  }
  @frozen public enum StrokeColorAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = AppKit.NSColor
    public static let name: Swift.String
  }
  @frozen public enum StrokeWidthAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreFoundation.CGFloat
    public static let name: Swift.String
  }
  @frozen public enum ShadowAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = AppKit.NSShadow
    public static let name: Swift.String
  }
  @frozen public enum TextEffectAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Foundation.NSAttributedString.TextEffectStyle
    public static let name: Swift.String
    public static func encode(_ value: Foundation.NSAttributedString.TextEffectStyle, to encoder: any Swift.Encoder) throws
    public static func decode(from decoder: any Swift.Decoder) throws -> Foundation.NSAttributedString.TextEffectStyle
  }
  @frozen public enum AttachmentAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = AppKit.NSTextAttachment
    public static let name: Swift.String
  }
  @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
  @frozen public enum BaselineOffsetAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreFoundation.CGFloat
    public static let name: Swift.String
  }
  @frozen public enum UnderlineColorAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = AppKit.NSColor
    public static let name: Swift.String
  }
  @frozen public enum StrikethroughColorAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = AppKit.NSColor
    public static let name: Swift.String
  }
  @available(macOS, introduced: 12.0, deprecated: 100000.0, message: "This attribute is not supported with TextKit 2")
  @frozen public enum ObliquenessAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreFoundation.CGFloat
    public static let name: Swift.String
  }
  @available(macOS, introduced: 12.0, deprecated: 100000.0, message: "This attribute is not supported with TextKit 2")
  @frozen public enum ExpansionAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = CoreFoundation.CGFloat
    public static let name: Swift.String
  }
  @frozen public enum ToolTipAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Swift.String
    public static let name: Swift.String
  }
  @frozen public enum MarkedClauseSegmentAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Swift.Int
    public static let name: Swift.String
  }
  @frozen public enum SuperscriptAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = Swift.Int
    public static let name: Swift.String
  }
  @frozen public enum TextAlternativesAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = AppKit.NSTextAlternatives
    public static let name: Swift.String
  }
  @frozen public enum GlyphInfoAttribute : Foundation.CodableAttributedStringKey {
    public typealias Value = AppKit.NSGlyphInfo
    public static let name: Swift.String
  }
  @frozen public enum CursorAttribute : Foundation.AttributedStringKey {
    public typealias Value = AppKit.NSCursor
    public static let name: Swift.String
  }
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Foundation.AttributedString.AdaptiveImageGlyph {
  public init(_ nsAdaptiveImageGlyph: AppKit.NSAdaptiveImageGlyph)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension AppKit.NSAdaptiveImageGlyph {
  convenience public init(_ adaptiveImageGlypth: Foundation.AttributedString.AdaptiveImageGlyph)
}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Foundation.AttributeScopes.AppKitAttributes {
  @frozen public enum AdaptiveImageGlyphAttribute : Foundation.CodableAttributedStringKey, Foundation.ObjectiveCConvertibleAttributedStringKey, Swift.Sendable {
    public typealias Value = Foundation.AttributedString.AdaptiveImageGlyph
    public typealias ObjectiveCValue = AppKit.NSAdaptiveImageGlyph
    public static let name: Swift.String
    public static var inheritedByAddedText: Swift.Bool
    public static var runBoundaries: Foundation.AttributedString.AttributeRunBoundaries? {
      get
    }
    public static func objectiveCValue(for value: Foundation.AttributedString.AdaptiveImageGlyph) throws -> AppKit.NSAdaptiveImageGlyph
    public static func value(for object: AppKit.NSAdaptiveImageGlyph) throws -> Foundation.AttributedString.AdaptiveImageGlyph
    public static func encode(_ value: Foundation.AttributedString.AdaptiveImageGlyph, to encoder: any Swift.Encoder) throws
    public static func decode(from decoder: any Swift.Decoder) throws -> Foundation.AttributedString.AdaptiveImageGlyph
  }
}
@available(macOS 14.0, *)
extension AppKit.NSColor {
  convenience public init(resource: DeveloperToolsSupport.ColorResource)
}
@available(macOS 10.9, *)
extension AppKit.NSColor : Swift._ExpressibleByColorLiteral {
  @nonobjc required convenience public init(_colorLiteralRed red: Swift.Float, green: Swift.Float, blue: Swift.Float, alpha: Swift.Float)
}
public typealias _ColorLiteralType = AppKit.NSColor
@available(macOS 10.9, *)
extension Foundation.IndexPath {
  public init(item: Swift.Int, section: Swift.Int)
  public var item: Swift.Int {
    get
    set
  }
  public var section: Swift.Int {
    get
    set
  }
}
@available(macOS 10.9, *)
extension Foundation.URLResourceValues {
  @available(macOS, introduced: 10.10, deprecated: 12.0, message: "Use the QuickLookThumbnailing framework and extension point instead")
  public var thumbnail: AppKit.NSImage? {
    get
  }
  public var labelColor: AppKit.NSColor? {
    get
  }
  public var effectiveIcon: Swift.AnyObject? {
    get
  }
  public var customIcon: AppKit.NSImage? {
    get
  }
  @available(macOS, introduced: 10.10, deprecated: 12.0, message: "Use the QuickLookThumbnailing framework and extension point instead")
  public var thumbnailDictionary: [Foundation.URLThumbnailDictionaryItem : AppKit.NSImage]? {
    get
  }
}
extension AppKit.NSScreen {
  @available(macOS 12, *)
  public var auxiliaryTopLeftArea: Foundation.NSRect? {
    get
  }
  @available(macOS 12, *)
  public var auxiliaryTopRightArea: Foundation.NSRect? {
    get
  }
}
extension AppKit.NSImageView {
  @available(macOS 14.0, *)
  @_Concurrency.MainActor @preconcurrency public func addSymbolEffect(_ effect: some SymbolEffect & DiscreteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true)
  @available(macOS 14.0, *)
  @_Concurrency.MainActor @preconcurrency public func addSymbolEffect(_ effect: some Symbols.SymbolEffect & Symbols.IndefiniteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true)
  @available(macOS 14.0, *)
  @_Concurrency.MainActor @preconcurrency public func addSymbolEffect(_ effect: some Symbols.SymbolEffect & Symbols.IndefiniteSymbolEffect & Symbols.DiscreteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true)
  @available(macOS 14.0, *)
  @_Concurrency.MainActor @preconcurrency public func removeSymbolEffect(ofType effect: some Symbols.SymbolEffect & Symbols.DiscreteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true)
  @available(macOS 14.0, *)
  @_Concurrency.MainActor @preconcurrency public func removeSymbolEffect(ofType effect: some Symbols.SymbolEffect & Symbols.IndefiniteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true)
  @available(macOS 14.0, *)
  @_Concurrency.MainActor @preconcurrency public func removeSymbolEffect(ofType effect: some Symbols.SymbolEffect & Symbols.DiscreteSymbolEffect & Symbols.IndefiniteSymbolEffect, options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true)
  @available(macOS 14.0, *)
  @_Concurrency.MainActor @preconcurrency public func removeAllSymbolEffects(options: Symbols.SymbolEffectOptions = .default, animated: Swift.Bool = true)
  @available(macOS 14.0, *)
  @_Concurrency.MainActor @preconcurrency public func setSymbolImage(_ image: AppKit.NSImage, contentTransition: some Symbols.SymbolEffect & Symbols.ContentTransitionSymbolEffect, options: Symbols.SymbolEffectOptions = .default)
}
@available(macOS 14.0, *)
extension AppKit.NSImage : CoreTransferable.Transferable {
  public static var transferRepresentation: some CoreTransferable.TransferRepresentation {
    get
  }
  @available(macOS 14.0, *)
  public typealias Representation = @_opaqueReturnTypeOf("$sSo7NSImageC6AppKitE22transferRepresentationQrvpZ", 0) __
}
@available(macOS 14.0, *)
extension AppKit.NSSound : CoreTransferable.Transferable {
  public static var transferRepresentation: some CoreTransferable.TransferRepresentation {
    get
  }
  @available(macOS 14.0, *)
  public typealias Representation = @_opaqueReturnTypeOf("$sSo7NSSoundC6AppKitE22transferRepresentationQrvpZ", 0) __
}
extension AppKit.NSTextField {
  @available(macOS 15.0, *)
  @_Concurrency.MainActor @preconcurrency weak public var suggestionsDelegate: (any AppKit.NSTextSuggestionsDelegate)? {
    get
    set
  }
}
@available(macOS 10.15.1, *)
open class NSCollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType> : ObjectiveC.NSObject, AppKit.NSCollectionViewDataSource where SectionIdentifierType : Swift.Hashable, ItemIdentifierType : Swift.Hashable {
  public typealias ItemProvider = (AppKit.NSCollectionView, Foundation.IndexPath, ItemIdentifierType) -> AppKit.NSCollectionViewItem?
  public typealias SupplementaryViewProvider = (AppKit.NSCollectionView, Swift.String, Foundation.IndexPath) -> (any AppKit.NSView & AppKit.NSCollectionViewElement)?
  public var supplementaryViewProvider: AppKit.NSCollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.SupplementaryViewProvider? {
    get
    set
  }
  public init(collectionView: AppKit.NSCollectionView, itemProvider: @escaping AppKit.NSCollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.ItemProvider)
  open func apply(_ snapshot: AppKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
  open func snapshot() -> AppKit.NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
  open func itemIdentifier(for indexPath: Foundation.IndexPath) -> ItemIdentifierType?
  open func indexPath(for itemIdentifier: ItemIdentifierType) -> Foundation.IndexPath?
  @_Concurrency.MainActor @preconcurrency @objc open func numberOfSections(in collectionView: AppKit.NSCollectionView) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc open func collectionView(_ collectionView: AppKit.NSCollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc open func collectionView(_ collectionView: AppKit.NSCollectionView, itemForRepresentedObjectAt indexPath: Foundation.IndexPath) -> AppKit.NSCollectionViewItem
  @_Concurrency.MainActor @preconcurrency @objc open func collectionView(_ collectionView: AppKit.NSCollectionView, viewForSupplementaryElementOfKind kind: AppKit.NSCollectionView.SupplementaryElementKind, at indexPath: Foundation.IndexPath) -> AppKit.NSView
  public func description() -> Swift.String
  @objc deinit
}
@available(macOS 15.0, *)
public struct NSSuggestionItemResponse<SuggestionItemType> {
  public typealias Item = AppKit.NSSuggestionItem<SuggestionItemType>
  public typealias ItemSection = AppKit.NSSuggestionItemSection<SuggestionItemType>
  public var itemSections: [AppKit.NSSuggestionItemResponse<SuggestionItemType>.ItemSection]
  public enum Phase : Swift.Equatable, Swift.Hashable {
    case intermediate
    case final
    public static func == (a: AppKit.NSSuggestionItemResponse<SuggestionItemType>.Phase, b: AppKit.NSSuggestionItemResponse<SuggestionItemType>.Phase) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var phase: AppKit.NSSuggestionItemResponse<SuggestionItemType>.Phase
  public enum Highlight : Swift.Equatable, Swift.Hashable {
    case automatic
    case firstSelectableItem
    public static func == (a: AppKit.NSSuggestionItemResponse<SuggestionItemType>.Highlight, b: AppKit.NSSuggestionItemResponse<SuggestionItemType>.Highlight) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var preferredHighlight: AppKit.NSSuggestionItemResponse<SuggestionItemType>.Highlight
  public init(itemSections: [AppKit.NSSuggestionItemResponse<SuggestionItemType>.ItemSection])
  public init(items: [AppKit.NSSuggestionItemResponse<SuggestionItemType>.Item])
  public init()
}
@available(macOS 15.0, *)
extension AppKit.NSSuggestionItemResponse : Swift.Equatable where SuggestionItemType : Swift.Equatable {
  public static func == (a: AppKit.NSSuggestionItemResponse<SuggestionItemType>, b: AppKit.NSSuggestionItemResponse<SuggestionItemType>) -> Swift.Bool
}
@available(macOS 15.0, *)
extension AppKit.NSSuggestionItemResponse : Swift.Hashable where SuggestionItemType : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.9, *)
extension CoreFoundation.CGRect {
  @available(swift 4)
  public func fill(using operation: AppKit.NSCompositingOperation = NSGraphicsContext.current?.compositingOperation ?? .sourceOver)
  @available(swift 4)
  public func frame(withWidth width: CoreFoundation.CGFloat = 1.0, using operation: AppKit.NSCompositingOperation = NSGraphicsContext.current?.compositingOperation ?? .sourceOver)
  @available(swift 4)
  public func clip()
}
@available(macOS 10.9, *)
extension Swift.Sequence where Self.Element == CoreFoundation.CGRect {
  @available(swift 4)
  public func fill(using operation: AppKit.NSCompositingOperation = NSGraphicsContext.current?.compositingOperation ?? .sourceOver)
  @available(swift 4)
  public func clip()
}
@available(macOS 10.9, *)
extension Swift.Sequence where Self.Element == (CoreFoundation.CGRect, AppKit.NSColor) {
  @available(swift 4)
  public func fill(using operation: AppKit.NSCompositingOperation = NSGraphicsContext.current?.compositingOperation ?? .sourceOver)
}
@available(macOS 10.9, *)
extension Swift.Sequence where Self.Element == (CoreFoundation.CGRect, gray: CoreFoundation.CGFloat) {
  @available(swift 4)
  public func fill(using operation: AppKit.NSCompositingOperation = NSGraphicsContext.current?.compositingOperation ?? .sourceOver)
}
@available(macOS 10.9, *)
extension AppKit.NSWindow.Depth {
  @available(swift 4)
  public static func bestDepth(colorSpaceName: AppKit.NSColorSpaceName, bitsPerSample: Swift.Int, bitsPerPixel: Swift.Int, isPlanar: Swift.Bool) -> (AppKit.NSWindow.Depth, isExactMatch: Swift.Bool)
  @available(swift 4)
  public static var availableDepths: [AppKit.NSWindow.Depth] {
    get
  }
}
@available(macOS, introduced: 10.9, deprecated: 14.0, message: "Use NSCursor.disappearingItemCursor instead")
extension AppKit.NSAnimationEffect {
  @available(swift 4)
  public func show(centeredAt centerLocation: Foundation.NSPoint, size: Foundation.NSSize, completionHandler: @escaping () -> Swift.Void = { })
}
@available(macOS 10.9, *)
extension AppKit.NSSound {
  @available(swift 4)
  public static func beep()
}
@available(macOS 10.9, *)
extension AppKit.NSView : Swift.__DefaultCustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSView._defaultCustomPlaygroundQuickLook will be removed in a future Swift version")
  @_Concurrency.MainActor @preconcurrency public var _defaultCustomPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 14.0, *)
extension DeveloperToolsSupport.Preview {
  @_Concurrency.MainActor public init(_ name: Swift.String? = nil, traits: DeveloperToolsSupport.PreviewTrait<DeveloperToolsSupport.Preview.ViewTraits>..., body: @escaping @_Concurrency.MainActor () -> AppKit.NSView)
  @_Concurrency.MainActor public init(_ name: Swift.String? = nil, traits: DeveloperToolsSupport.PreviewTrait<DeveloperToolsSupport.Preview.ViewTraits>..., body: @escaping @_Concurrency.MainActor () -> AppKit.NSViewController)
}
@available(macOS 14.0, *)
@freestanding(declaration) public macro Preview(_ name: Swift.String? = nil, traits: DeveloperToolsSupport.PreviewTrait<DeveloperToolsSupport.Preview.ViewTraits>..., @DeveloperToolsSupport.PreviewMacroBodyBuilder<AppKit.NSView> body: @escaping @_Concurrency.MainActor () -> AppKit.NSView) = #externalMacro(module: "PreviewsMacros", type: "KitViewMacro")
@available(macOS 14.0, *)
@freestanding(declaration) public macro Preview(_ name: Swift.String? = nil, traits: DeveloperToolsSupport.PreviewTrait<DeveloperToolsSupport.Preview.ViewTraits>..., @DeveloperToolsSupport.PreviewMacroBodyBuilder<AppKit.NSViewController> body: @escaping @_Concurrency.MainActor () -> AppKit.NSViewController) = #externalMacro(module: "PreviewsMacros", type: "KitViewMacro")
@available(macOS 15.0, *)
public struct NSSuggestionItem<SuggestionItemType> {
  public var representedValue: SuggestionItemType
  public var title: Swift.String {
    get
    set
  }
  public var attributedTitle: Foundation.AttributedString {
    get
    set
  }
  public var secondaryTitle: Swift.String? {
    get
    set
  }
  public var attributedSecondaryTitle: Foundation.AttributedString? {
    get
    set
  }
  public var toolTip: Swift.String?
  public var image: AppKit.NSImage?
  public init(representedValue: SuggestionItemType, title: Swift.String)
  public init(representedValue: SuggestionItemType, attributedTitle: Foundation.AttributedString)
}
@available(macOS 15.0, *)
extension AppKit.NSSuggestionItem : Swift.Equatable where SuggestionItemType : Swift.Equatable {
  public static func == (lhs: AppKit.NSSuggestionItem<SuggestionItemType>, rhs: AppKit.NSSuggestionItem<SuggestionItemType>) -> Swift.Bool
}
@available(macOS 15.0, *)
extension AppKit.NSSuggestionItem : Swift.Hashable where SuggestionItemType : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS, introduced: 10.9, deprecated: 10.14, message: "Please use Metal or MetalKit.")
extension AppKit.NSOpenGLGlobalOption {
  @available(swift 4)
  public var globalValue: OpenGL.GLint {
    get
    set
  }
}
@available(macOS, introduced: 10.9, deprecated: 10.14, message: "Please use Metal or MetalKit.")
extension AppKit.NSOpenGLContext {
  @available(swift 4)
  public static var openGLVersion: (major: OpenGL.GLint, minor: OpenGL.GLint) {
    get
  }
}
extension AppKit.NSViewController {
  @available(swift 5.1)
  @available(macOS 13.3, *)
  @propertyWrapper public struct ViewLoading<Value> {
    @available(*, unavailable, message: "@NSViewController.ViewLoading can only be used on subclasses of NSViewController")
    public var wrappedValue: Value {
      get
      set
    }
    public init()
    public init(wrappedValue: Value)
    public static subscript<EnclosingSelf>(_enclosingInstance observed: EnclosingSelf, wrapped wrappedKeyPath: Swift.ReferenceWritableKeyPath<EnclosingSelf, Value>, storage storageKeyPath: Swift.ReferenceWritableKeyPath<EnclosingSelf, AppKit.NSViewController.ViewLoading<Value>>) -> Value where EnclosingSelf : AppKit.NSViewController {
      get
      set
    }
  }
}
extension AppKit.NSWindowController {
  @available(swift 5.1)
  @available(macOS 13.3, *)
  @propertyWrapper public struct WindowLoading<Value> {
    @available(*, unavailable, message: "@NSWindowController.WindowLoading can only be used on subclasses of NSWindowController")
    public var wrappedValue: Value {
      get
      set
    }
    public init()
    public init(wrappedValue: Value)
    public static subscript<EnclosingSelf>(_enclosingInstance observed: EnclosingSelf, wrapped wrappedKeyPath: Swift.ReferenceWritableKeyPath<EnclosingSelf, Value>, storage storageKeyPath: Swift.ReferenceWritableKeyPath<EnclosingSelf, AppKit.NSWindowController.WindowLoading<Value>>) -> Value where EnclosingSelf : AppKit.NSWindowController {
      get
      set
    }
  }
}
@available(macOS 10.9, *)
extension AppKit.NSGradient {
  convenience public init?(colorsAndLocations objects: (AppKit.NSColor, CoreFoundation.CGFloat)...)
}
@available(macOS 10.10, *)
extension AppKit.NSStoryboard {
  @available(macOS 10.15, *)
  public func instantiateInitialController<Controller>(creator: ((Foundation.NSCoder) -> Controller?)? = nil) -> Controller? where Controller : AppKit.NSViewController
  @available(macOS 10.15, *)
  public func instantiateInitialController<Controller>(creator: ((Foundation.NSCoder) -> Controller?)? = nil) -> Controller? where Controller : AppKit.NSWindowController
  @available(macOS 10.15, *)
  public func instantiateController<Controller>(identifier: AppKit.NSStoryboard.SceneIdentifier, creator: ((Foundation.NSCoder) -> Controller?)? = nil) -> Controller where Controller : AppKit.NSViewController
  @available(macOS 10.15, *)
  public func instantiateController<Controller>(identifier: AppKit.NSStoryboard.SceneIdentifier, creator: ((Foundation.NSCoder) -> Controller?)? = nil) -> Controller where Controller : AppKit.NSWindowController
}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSCursor {
  public class func columnResize(directions: AppKit.NSHorizontalDirection.Set) -> AppKit.NSCursor
  public class func rowResize(directions: AppKit.NSVerticalDirection.Set) -> AppKit.NSCursor
  public enum FrameResizeDirection : Swift.Int8, Swift.CaseIterable {
    case inward
    case outward
    public struct Set : Swift.OptionSet, Swift.Equatable, Swift.Hashable {
      public typealias Element = AppKit.NSCursor.FrameResizeDirection.Set
      public typealias RawValue = Swift.Int8
      public let rawValue: AppKit.NSCursor.FrameResizeDirection.Set.RawValue
      public init(rawValue: AppKit.NSCursor.FrameResizeDirection.Set.RawValue)
      public static let inward: AppKit.NSCursor.FrameResizeDirection.Set
      public static let outward: AppKit.NSCursor.FrameResizeDirection.Set
      public static let all: AppKit.NSCursor.FrameResizeDirection.Set
      public init(_ direction: AppKit.NSCursor.FrameResizeDirection)
      @available(macOS 15.0, macCatalyst 18.0, *)
      public typealias ArrayLiteralElement = AppKit.NSCursor.FrameResizeDirection.Set.Element
    }
    public init?(rawValue: Swift.Int8)
    @available(macOS 15.0, macCatalyst 18.0, *)
    public typealias AllCases = [AppKit.NSCursor.FrameResizeDirection]
    @available(macOS 15.0, macCatalyst 18.0, *)
    public typealias RawValue = Swift.Int8
    nonisolated public static var allCases: [AppKit.NSCursor.FrameResizeDirection] {
      get
    }
    public var rawValue: Swift.Int8 {
      get
    }
  }
  public class func frameResize(position: AppKit.NSCursor.FrameResizePosition, directions: AppKit.NSCursor.FrameResizeDirection.Set) -> AppKit.NSCursor
}
extension AppKit.NSCursor.FrameResizeDirection.Set {
  @available(macCatalyst 18.0, macOS 15.0, *)
  public func contains(_ member: AppKit.NSCursor.FrameResizeDirection) -> Swift.Bool
  @available(macCatalyst 18.0, macOS 15.0, *)
  @discardableResult
  public mutating func insert(_ newMember: __owned AppKit.NSCursor.FrameResizeDirection) -> (inserted: Swift.Bool, memberAfterInsert: AppKit.NSCursor.FrameResizeDirection)
  @available(macCatalyst 18.0, macOS 15.0, *)
  @discardableResult
  public mutating func remove(_ member: AppKit.NSCursor.FrameResizeDirection) -> AppKit.NSCursor.FrameResizeDirection?
  @available(macCatalyst 18.0, macOS 15.0, *)
  @discardableResult
  public mutating func update(with newMember: __owned AppKit.NSCursor.FrameResizeDirection) -> AppKit.NSCursor.FrameResizeDirection?
}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSCursor.FrameResizePosition : Swift.CaseIterable {
  public static var allCases: [AppKit.NSCursor.FrameResizePosition] {
    get
  }
  @available(macOS 15.0, macCatalyst 18.0, *)
  public typealias AllCases = [AppKit.NSCursor.FrameResizePosition]
}
extension AppKit.NSCursor.FrameResizePosition {
  @available(macOS 15.0, *)
  public static func leading(relativeTo layoutDirection: AppKit.NSUserInterfaceLayoutDirection) -> AppKit.NSCursor.FrameResizePosition
  @available(macOS 15.0, *)
  public static func trailing(relativeTo layoutDirection: AppKit.NSUserInterfaceLayoutDirection) -> AppKit.NSCursor.FrameResizePosition
  @available(macOS 15.0, *)
  public static func topLeading(relativeTo layoutDirection: AppKit.NSUserInterfaceLayoutDirection) -> AppKit.NSCursor.FrameResizePosition
  @available(macOS 15.0, *)
  public static func topTrailing(relativeTo layoutDirection: AppKit.NSUserInterfaceLayoutDirection) -> AppKit.NSCursor.FrameResizePosition
  @available(macOS 15.0, *)
  public static func bottomLeading(relativeTo layoutDirection: AppKit.NSUserInterfaceLayoutDirection) -> AppKit.NSCursor.FrameResizePosition
  @available(macOS 15.0, *)
  public static func bottomTrailing(relativeTo layoutDirection: AppKit.NSUserInterfaceLayoutDirection) -> AppKit.NSCursor.FrameResizePosition
}
@available(macOS 10.9, *)
extension AppKit.NSCursor : Swift.__DefaultCustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "NSCursor._defaultCustomPlaygroundQuickLook will be removed in a future Swift version")
  public var _defaultCustomPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 10.9, *)
extension AppKit.NSEvent {
  public struct SpecialKey : Swift.RawRepresentable, Swift.Equatable, Swift.Hashable {
    public init(rawValue: Swift.Int)
    public let rawValue: Swift.Int
    public var unicodeScalar: Swift.Unicode.Scalar {
      get
    }
    @available(macOS 10.9, *)
    public typealias RawValue = Swift.Int
  }
  public var specialKey: AppKit.NSEvent.SpecialKey? {
    get
  }
}
@available(macOS 10.9, *)
extension AppKit.NSEvent.SpecialKey {
  public static let upArrow: AppKit.NSEvent.SpecialKey
  public static let downArrow: AppKit.NSEvent.SpecialKey
  public static let leftArrow: AppKit.NSEvent.SpecialKey
  public static let rightArrow: AppKit.NSEvent.SpecialKey
  public static let f1: AppKit.NSEvent.SpecialKey
  public static let f2: AppKit.NSEvent.SpecialKey
  public static let f3: AppKit.NSEvent.SpecialKey
  public static let f4: AppKit.NSEvent.SpecialKey
  public static let f5: AppKit.NSEvent.SpecialKey
  public static let f6: AppKit.NSEvent.SpecialKey
  public static let f7: AppKit.NSEvent.SpecialKey
  public static let f8: AppKit.NSEvent.SpecialKey
  public static let f9: AppKit.NSEvent.SpecialKey
  public static let f10: AppKit.NSEvent.SpecialKey
  public static let f11: AppKit.NSEvent.SpecialKey
  public static let f12: AppKit.NSEvent.SpecialKey
  public static let f13: AppKit.NSEvent.SpecialKey
  public static let f14: AppKit.NSEvent.SpecialKey
  public static let f15: AppKit.NSEvent.SpecialKey
  public static let f16: AppKit.NSEvent.SpecialKey
  public static let f17: AppKit.NSEvent.SpecialKey
  public static let f18: AppKit.NSEvent.SpecialKey
  public static let f19: AppKit.NSEvent.SpecialKey
  public static let f20: AppKit.NSEvent.SpecialKey
  public static let f21: AppKit.NSEvent.SpecialKey
  public static let f22: AppKit.NSEvent.SpecialKey
  public static let f23: AppKit.NSEvent.SpecialKey
  public static let f24: AppKit.NSEvent.SpecialKey
  public static let f25: AppKit.NSEvent.SpecialKey
  public static let f26: AppKit.NSEvent.SpecialKey
  public static let f27: AppKit.NSEvent.SpecialKey
  public static let f28: AppKit.NSEvent.SpecialKey
  public static let f29: AppKit.NSEvent.SpecialKey
  public static let f30: AppKit.NSEvent.SpecialKey
  public static let f31: AppKit.NSEvent.SpecialKey
  public static let f32: AppKit.NSEvent.SpecialKey
  public static let f33: AppKit.NSEvent.SpecialKey
  public static let f34: AppKit.NSEvent.SpecialKey
  public static let f35: AppKit.NSEvent.SpecialKey
  public static let insert: AppKit.NSEvent.SpecialKey
  public static let deleteForward: AppKit.NSEvent.SpecialKey
  public static let home: AppKit.NSEvent.SpecialKey
  public static let begin: AppKit.NSEvent.SpecialKey
  public static let end: AppKit.NSEvent.SpecialKey
  public static let pageUp: AppKit.NSEvent.SpecialKey
  public static let pageDown: AppKit.NSEvent.SpecialKey
  public static let printScreen: AppKit.NSEvent.SpecialKey
  public static let scrollLock: AppKit.NSEvent.SpecialKey
  public static let pause: AppKit.NSEvent.SpecialKey
  public static let sysReq: AppKit.NSEvent.SpecialKey
  public static let `break`: AppKit.NSEvent.SpecialKey
  public static let reset: AppKit.NSEvent.SpecialKey
  public static let stop: AppKit.NSEvent.SpecialKey
  public static let menu: AppKit.NSEvent.SpecialKey
  public static let user: AppKit.NSEvent.SpecialKey
  public static let system: AppKit.NSEvent.SpecialKey
  public static let print: AppKit.NSEvent.SpecialKey
  public static let clearLine: AppKit.NSEvent.SpecialKey
  public static let clearDisplay: AppKit.NSEvent.SpecialKey
  public static let insertLine: AppKit.NSEvent.SpecialKey
  public static let deleteLine: AppKit.NSEvent.SpecialKey
  public static let insertCharacter: AppKit.NSEvent.SpecialKey
  public static let deleteCharacter: AppKit.NSEvent.SpecialKey
  public static let prev: AppKit.NSEvent.SpecialKey
  public static let next: AppKit.NSEvent.SpecialKey
  public static let select: AppKit.NSEvent.SpecialKey
  public static let execute: AppKit.NSEvent.SpecialKey
  public static let undo: AppKit.NSEvent.SpecialKey
  public static let redo: AppKit.NSEvent.SpecialKey
  public static let find: AppKit.NSEvent.SpecialKey
  public static let help: AppKit.NSEvent.SpecialKey
  public static let modeSwitch: AppKit.NSEvent.SpecialKey
  public static let enter: AppKit.NSEvent.SpecialKey
  public static let backspace: AppKit.NSEvent.SpecialKey
  public static let tab: AppKit.NSEvent.SpecialKey
  public static let newline: AppKit.NSEvent.SpecialKey
  public static let formFeed: AppKit.NSEvent.SpecialKey
  public static let carriageReturn: AppKit.NSEvent.SpecialKey
  public static let backTab: AppKit.NSEvent.SpecialKey
  public static let delete: AppKit.NSEvent.SpecialKey
  public static let lineSeparator: AppKit.NSEvent.SpecialKey
  public static let paragraphSeparator: AppKit.NSEvent.SpecialKey
}
@available(macOS 15.0, *)
@_Concurrency.MainActor public protocol NSTextSuggestionsDelegate<SuggestionItemType> : AnyObject {
  associatedtype SuggestionItemType
  typealias Item = AppKit.NSSuggestionItem<Self.SuggestionItemType>
  typealias ItemSection = AppKit.NSSuggestionItemSection<Self.SuggestionItemType>
  typealias ItemResponse = AppKit.NSSuggestionItemResponse<Self.SuggestionItemType>
  @_Concurrency.MainActor func textField(_ textField: AppKit.NSTextField, provideUpdatedSuggestions responseHandler: @escaping (Self.ItemResponse) -> Swift.Void)
  @_Concurrency.MainActor func textField(_ textField: AppKit.NSTextField, textCompletionFor item: Self.Item) -> Swift.String?
  @_Concurrency.MainActor func textField(_ textField: AppKit.NSTextField, didSelect item: Self.Item)
}
extension AppKit.NSTextSuggestionsDelegate {
  @available(macOS 15.0, *)
  @_Concurrency.MainActor public func textField(_ textField: AppKit.NSTextField, textCompletionFor item: Self.Item) -> Swift.String?
  @available(macOS 15.0, *)
  @_Concurrency.MainActor public func textField(_ textField: AppKit.NSTextField, didSelect item: Self.Item)
}
@available(macOS 10.9, *)
extension Foundation.CocoaError.Code {
  public static var textReadInapplicableDocumentType: Foundation.CocoaError.Code {
    get
  }
  public static var textWriteInapplicableDocumentType: Foundation.CocoaError.Code {
    get
  }
  public static var serviceApplicationNotFound: Foundation.CocoaError.Code {
    get
  }
  public static var serviceApplicationLaunchFailed: Foundation.CocoaError.Code {
    get
  }
  public static var serviceRequestTimedOut: Foundation.CocoaError.Code {
    get
  }
  public static var serviceInvalidPasteboardData: Foundation.CocoaError.Code {
    get
  }
  public static var serviceMalformedServiceDictionary: Foundation.CocoaError.Code {
    get
  }
  public static var serviceMiscellaneousError: Foundation.CocoaError.Code {
    get
  }
  public static var sharingServiceNotConfigured: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.13, *)
  public static var fontAssetDownloadError: Foundation.CocoaError.Code {
    get
  }
}
@available(macOS 10.9, *)
extension Foundation.CocoaError.Code {
  @available(*, deprecated, renamed: "textReadInapplicableDocumentType")
  public static var textReadInapplicableDocumentTypeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "textWriteInapplicableDocumentType")
  public static var textWriteInapplicableDocumentTypeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceApplicationNotFound")
  public static var serviceApplicationNotFoundError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceApplicationLaunchFailed")
  public static var serviceApplicationLaunchFailedError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceRequestTimedOut")
  public static var serviceRequestTimedOutError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceInvalidPasteboardData")
  public static var serviceInvalidPasteboardDataError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceMalformedServiceDictionary")
  public static var serviceMalformedServiceDictionaryError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceMiscellaneousError")
  public static var serviceMiscellaneous: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "sharingServiceNotConfigured")
  public static var sharingServiceNotConfiguredError: Foundation.CocoaError.Code {
    get
  }
}
@available(macOS 10.9, *)
extension Foundation.CocoaError {
  public static var textReadInapplicableDocumentType: Foundation.CocoaError.Code {
    get
  }
  public static var textWriteInapplicableDocumentType: Foundation.CocoaError.Code {
    get
  }
  public static var serviceApplicationNotFound: Foundation.CocoaError.Code {
    get
  }
  public static var serviceApplicationLaunchFailed: Foundation.CocoaError.Code {
    get
  }
  public static var serviceRequestTimedOut: Foundation.CocoaError.Code {
    get
  }
  public static var serviceInvalidPasteboardData: Foundation.CocoaError.Code {
    get
  }
  public static var serviceMalformedServiceDictionary: Foundation.CocoaError.Code {
    get
  }
  public static var serviceMiscellaneous: Foundation.CocoaError.Code {
    get
  }
  public static var sharingServiceNotConfigured: Foundation.CocoaError.Code {
    get
  }
  @available(macOS 10.13, *)
  public static var fontAssetDownloadError: Foundation.CocoaError.Code {
    get
  }
}
@available(macOS 10.9, *)
extension Foundation.CocoaError {
  @available(*, deprecated, renamed: "textReadInapplicableDocumentType")
  public static var textReadInapplicableDocumentTypeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "textWriteInapplicableDocumentType")
  public static var textWriteInapplicableDocumentTypeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceApplicationNotFound")
  public static var serviceApplicationNotFoundError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceApplicationLaunchFailed")
  public static var serviceApplicationLaunchFailedError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceRequestTimedOut")
  public static var serviceRequestTimedOutError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceInvalidPasteboardData")
  public static var serviceInvalidPasteboardDataError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceMalformedServiceDictionary")
  public static var serviceMalformedServiceDictionaryError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceMiscellaneous")
  public static var serviceMiscellaneousError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "sharingServiceNotConfigured")
  public static var sharingServiceNotConfiguredError: Foundation.CocoaError.Code {
    get
  }
}
@available(macOS 10.9, *)
extension Foundation.CocoaError {
  public var isServiceError: Swift.Bool {
    get
  }
  public var isSharingServiceError: Swift.Bool {
    get
  }
  public var isTextReadWriteError: Swift.Bool {
    get
  }
  @available(macOS 10.13, *)
  public var isFontError: Swift.Bool {
    get
  }
}
@available(macOS 10.9, *)
extension Foundation.CocoaError {
  @available(*, deprecated, renamed: "textReadInapplicableDocumentType")
  public static var TextReadInapplicableDocumentTypeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "textWriteInapplicableDocumentType")
  public static var TextWriteInapplicableDocumentTypeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceApplicationNotFound")
  public static var ServiceApplicationNotFoundError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceApplicationLaunchFailed")
  public static var ServiceApplicationLaunchFailedError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceRequestTimedOut")
  public static var ServiceRequestTimedOutError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceInvalidPasteboardData")
  public static var ServiceInvalidPasteboardDataError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceMalformedServiceDictionary")
  public static var ServiceMalformedServiceDictionaryError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceMiscellaneous")
  public static var ServiceMiscellaneousError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "sharingServiceNotConfigured")
  public static var SharingServiceNotConfiguredError: Foundation.CocoaError.Code {
    get
  }
}
@available(macOS 10.9, *)
extension Foundation.CocoaError.Code {
  @available(*, deprecated, renamed: "textReadInapplicableDocumentType")
  public static var TextReadInapplicableDocumentTypeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "textWriteInapplicableDocumentType")
  public static var TextWriteInapplicableDocumentTypeError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceApplicationNotFound")
  public static var ServiceApplicationNotFoundError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceApplicationLaunchFailed")
  public static var ServiceApplicationLaunchFailedError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceRequestTimedOut")
  public static var ServiceRequestTimedOutError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceInvalidPasteboardData")
  public static var ServiceInvalidPasteboardDataError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceMalformedServiceDictionary")
  public static var ServiceMalformedServiceDictionaryError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "serviceMiscellaneous")
  public static var ServiceMiscellaneousError: Foundation.CocoaError.Code {
    get
  }
  @available(*, deprecated, renamed: "sharingServiceNotConfigured")
  public static var SharingServiceNotConfiguredError: Foundation.CocoaError.Code {
    get
  }
}
@available(macOS 14.0, *)
extension AppKit.NSMenuItem {
  @available(*, deprecated, renamed: "sectionHeader(title:)", message: "Use sectionHeader(title:) instead.")
  public static func sectionHeader(withTitle title: Swift.String) -> AppKit.NSMenuItem
  public static func sectionHeader(title: Swift.String) -> AppKit.NSMenuItem
}
extension AppKit.NSTextSuggestionsDelegate where Self.SuggestionItemType : Swift.Hashable {
  @available(macOS 15.0, *)
  @_Concurrency.MainActor public func appending(_ other: some NSTextSuggestionsDelegate<SuggestionItemType>) -> some AppKit.NSTextSuggestionsDelegate<Self.SuggestionItemType>
  
  @available(macOS 15.0, *)
  @_disfavoredOverload @_Concurrency.MainActor public func appending<T>(_ other: some NSTextSuggestionsDelegate<T>) -> some AppKit.NSTextSuggestionsDelegate<Swift.AnyHashable> where T : Swift.Hashable
  
}
@available(macOS 14.0, *)
extension AppKit.NSMenu {
  public static func palette(colors: [AppKit.NSColor], titles: [Swift.String] = [], template: AppKit.NSImage? = nil, onSelectionChange: ((AppKit.NSMenu) -> Swift.Void)? = nil) -> AppKit.NSMenu
}
@available(macOS 10.12.2, *)
extension AppKit.NSTouchBar : Swift.__DefaultCustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "PlaygroundQuickLook will be removed in a future Swift version. For customizing how types are presented in playgrounds, use CustomPlaygroundDisplayConvertible instead.")
  @_Concurrency.MainActor @preconcurrency public var _defaultCustomPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(macOS 10.12.2, *)
extension AppKit.NSTouchBarItem : Swift.__DefaultCustomPlaygroundQuickLookable {
  @available(swift, deprecated: 4.2, message: "PlaygroundQuickLook will be removed in a future Swift version. For customizing how types are presented in playgrounds, use CustomPlaygroundDisplayConvertible instead.")
  @_Concurrency.MainActor @preconcurrency public var _defaultCustomPlaygroundQuickLook: Swift.PlaygroundQuickLook {
    get
  }
}
@available(swift 4)
@available(macOS 10.13, *)
public protocol _AppKitKitNumericRawRepresentable : Swift.Comparable, Swift.RawRepresentable where Self.RawValue : Swift.Comparable, Self.RawValue : Swift.Numeric {
}
@available(swift 4)
@available(macOS 10.13, *)
extension AppKit._AppKitKitNumericRawRepresentable {
  public static func < (lhs: Self, rhs: Self) -> Swift.Bool
  public static func + (lhs: Self, rhs: Self.RawValue) -> Self
  public static func + (lhs: Self.RawValue, rhs: Self) -> Self
  public static func - (lhs: Self, rhs: Self.RawValue) -> Self
  public static func - (lhs: Self, rhs: Self) -> Self.RawValue
  public static func += (lhs: inout Self, rhs: Self.RawValue)
  public static func -= (lhs: inout Self, rhs: Self.RawValue)
}
@available(swift 4)
@available(macOS 10.13, *)
extension AppKit.NSAppKitVersion : AppKit._AppKitKitNumericRawRepresentable {
}
@available(swift 4)
@available(macOS 10.13, *)
extension AppKit.NSLayoutConstraint.Priority : AppKit._AppKitKitNumericRawRepresentable {
}
@available(swift 4)
@available(macOS 10.13, *)
extension AppKit.NSStackView.VisibilityPriority : AppKit._AppKitKitNumericRawRepresentable {
}
@available(swift 4)
@available(macOS 10.13, *)
extension AppKit.NSToolbarItem.VisibilityPriority : AppKit._AppKitKitNumericRawRepresentable {
}
@available(swift 4)
@available(macOS 10.13, *)
extension AppKit.NSTouchBarItem.Priority : AppKit._AppKitKitNumericRawRepresentable {
}
@available(swift 4)
@available(macOS 10.13, *)
extension AppKit.NSWindow.Level : AppKit._AppKitKitNumericRawRepresentable {
}
@available(swift 4)
@available(macOS 10.13, *)
extension AppKit.NSFont.Weight : AppKit._AppKitKitNumericRawRepresentable {
}
@available(swift 4)
@available(macOS 13, *)
extension AppKit.NSFont.Width : AppKit._AppKitKitNumericRawRepresentable {
}
@available(macOS 14.0, *)
extension AppKit.NSColor : CoreTransferable.Transferable {
  public static var transferRepresentation: some CoreTransferable.TransferRepresentation {
    get
  }
  @available(macOS 14.0, *)
  public typealias Representation = @_opaqueReturnTypeOf("$sSo7NSColorC6AppKitE22transferRepresentationQrvpZ", 0) __
}
extension AppKit.NSPasteboard {
  @available(macOS 15.4, *)
  @objc dynamic public var accessBehavior: AppKit.NSPasteboard.AccessBehavior {
    @objc get
  }
}
extension AppKit.NSPasteboard {
  @available(macOS 15.4, *)
  public struct DetectedValues {
    public var patterns: Swift.Set<Swift.PartialKeyPath<AppKit.NSPasteboard.DetectedValues>> {
      get
    }
    public var probableWebURL: Swift.String {
      get
    }
    public var probableWebSearch: Swift.String {
      get
    }
    public var number: Swift.Double? {
      get
    }
    public var links: [DataDetection.DDMatchLink] {
      get
    }
    public var phoneNumbers: [DataDetection.DDMatchPhoneNumber] {
      get
    }
    public var emailAddresses: [DataDetection.DDMatchEmailAddress] {
      get
    }
    public var postalAddresses: [DataDetection.DDMatchPostalAddress] {
      get
    }
    public var calendarEvents: [DataDetection.DDMatchCalendarEvent] {
      get
    }
    public var shipmentTrackingNumbers: [DataDetection.DDMatchShipmentTrackingNumber] {
      get
    }
    public var flightNumbers: [DataDetection.DDMatchFlightNumber] {
      get
    }
    public var moneyAmounts: [DataDetection.DDMatchMoneyAmount] {
      get
    }
  }
}
extension AppKit.NSPasteboard {
  @available(macOS 15.4, *)
  public struct DetectedMetadata {
    public var metadataTypes: Swift.Set<Swift.PartialKeyPath<AppKit.NSPasteboard.DetectedMetadata>> {
      get
    }
    public var contentType: UniformTypeIdentifiers.UTType? {
      get
    }
  }
}
extension AppKit.NSPasteboard {
  @available(macOS 15.4, *)
  public func detectedPatterns(for keyPaths: Swift.Set<Swift.PartialKeyPath<AppKit.NSPasteboard.DetectedValues>>) async throws -> Swift.Set<Swift.PartialKeyPath<AppKit.NSPasteboard.DetectedValues>>
  @available(macOS 15.4, *)
  public func detectedValues(for keyPaths: Swift.Set<Swift.PartialKeyPath<AppKit.NSPasteboard.DetectedValues>>) async throws -> AppKit.NSPasteboard.DetectedValues
  @available(macOS 15.4, *)
  public func detectedMetadata(for keyPaths: Swift.Set<Swift.PartialKeyPath<AppKit.NSPasteboard.DetectedMetadata>>) async throws -> AppKit.NSPasteboard.DetectedMetadata
}
extension AppKit.NSPasteboardItem {
  @available(macOS 15.4, *)
  public typealias DetectedValues = AppKit.NSPasteboard.DetectedValues
  @available(macOS 15.4, *)
  public typealias DetectedMetadata = AppKit.NSPasteboard.DetectedMetadata
  @available(macOS 15.4, *)
  public func detectedPatterns(for keyPaths: Swift.Set<Swift.PartialKeyPath<AppKit.NSPasteboardItem.DetectedValues>>) async throws -> Swift.Set<Swift.PartialKeyPath<AppKit.NSPasteboardItem.DetectedValues>>
  @available(macOS 15.4, *)
  public func detectedValues(for keyPaths: Swift.Set<Swift.PartialKeyPath<AppKit.NSPasteboardItem.DetectedValues>>) async throws -> AppKit.NSPasteboardItem.DetectedValues
  @available(macOS 15.4, *)
  public func detectedMetadata(for keyPaths: Swift.Set<Swift.PartialKeyPath<AppKit.NSPasteboardItem.DetectedMetadata>>) async throws -> AppKit.NSPasteboardItem.DetectedMetadata
}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSHorizontalDirection : Swift.Equatable {}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSHorizontalDirection : Swift.Hashable {}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSHorizontalDirection : Swift.RawRepresentable {}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSHorizontalDirection : Swift.Sendable {}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSHorizontalDirection : Swift.BitwiseCopyable {}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSHorizontalDirection.Set : Swift.Sendable {}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSHorizontalDirection.Set : Swift.BitwiseCopyable {}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSVerticalDirection : Swift.Equatable {}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSVerticalDirection : Swift.Hashable {}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSVerticalDirection : Swift.RawRepresentable {}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSVerticalDirection : Swift.Sendable {}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSVerticalDirection : Swift.BitwiseCopyable {}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSVerticalDirection.Set : Swift.Sendable {}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSVerticalDirection.Set : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.FontAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.FontAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.ParagraphStyleAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.ParagraphStyleAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.ForegroundColorAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.ForegroundColorAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.BackgroundColorAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.BackgroundColorAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.LigatureAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.LigatureAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.KernAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.KernAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.TrackingAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.TrackingAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.StrikethroughStyleAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.StrikethroughStyleAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.UnderlineStyleAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.UnderlineStyleAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.StrokeColorAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.StrokeColorAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.StrokeWidthAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.StrokeWidthAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.ShadowAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.ShadowAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.TextEffectAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.TextEffectAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.AttachmentAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.AttachmentAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.AppKitAttributes.BaselineOffsetAttribute : Swift.Sendable {}
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Foundation.AttributeScopes.AppKitAttributes.BaselineOffsetAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.UnderlineColorAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.UnderlineColorAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.StrikethroughColorAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.StrikethroughColorAttribute : Swift.BitwiseCopyable {}
@available(macOS, introduced: 12.0, deprecated: 100000.0, message: "This attribute is not supported with TextKit 2")
extension Foundation.AttributeScopes.AppKitAttributes.ObliquenessAttribute : Swift.Sendable {}
@available(macOS, introduced: 12.0, deprecated: 100000.0, message: "This attribute is not supported with TextKit 2")
extension Foundation.AttributeScopes.AppKitAttributes.ObliquenessAttribute : Swift.BitwiseCopyable {}
@available(macOS, introduced: 12.0, deprecated: 100000.0, message: "This attribute is not supported with TextKit 2")
extension Foundation.AttributeScopes.AppKitAttributes.ExpansionAttribute : Swift.Sendable {}
@available(macOS, introduced: 12.0, deprecated: 100000.0, message: "This attribute is not supported with TextKit 2")
extension Foundation.AttributeScopes.AppKitAttributes.ExpansionAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.ToolTipAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.ToolTipAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.MarkedClauseSegmentAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.MarkedClauseSegmentAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.SuperscriptAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.SuperscriptAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.TextAlternativesAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.TextAlternativesAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.GlyphInfoAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.GlyphInfoAttribute : Swift.BitwiseCopyable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.CursorAttribute : Swift.Sendable {}
@available(macOS 12, *)
extension Foundation.AttributeScopes.AppKitAttributes.CursorAttribute : Swift.BitwiseCopyable {}
@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension Foundation.AttributeScopes.AppKitAttributes.AdaptiveImageGlyphAttribute : Swift.BitwiseCopyable {}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSCursor.FrameResizeDirection : Swift.Equatable {}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSCursor.FrameResizeDirection : Swift.Hashable {}
@available(macCatalyst 18.0, macOS 15.0, *)
extension AppKit.NSCursor.FrameResizeDirection : Swift.RawRepresentable {}
