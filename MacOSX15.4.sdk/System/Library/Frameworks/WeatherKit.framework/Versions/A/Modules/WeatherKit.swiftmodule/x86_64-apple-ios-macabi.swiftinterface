// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1 effective-5.10 (swiftlang-6.1.0.110.5 clang-1700.0.13.3)
// swift-module-flags: -target x86_64-apple-ios18.4-macabi -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Osize -library-level api -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -user-module-version 868.0.1 -module-name WeatherKit
// swift-module-flags-ignorable:  -interface-compiler-version 6.1
import CoreLocation
import Foundation
import Network
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct MonthPrecipitationStatistics : Swift.Codable, Swift.Equatable, Swift.Sendable {
  public var month: Swift.Int
  public var averagePrecipitationProbability: Swift.Double
  public var averagePrecipitationAmount: Foundation.Measurement<Foundation.UnitLength>
  public var averageSnowfallAmount: Foundation.Measurement<Foundation.UnitLength>
  public static func == (a: WeatherKit.MonthPrecipitationStatistics, b: WeatherKit.MonthPrecipitationStatistics) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct WeatherAvailability {
  public var minuteAvailability: WeatherKit.WeatherAvailability.AvailabilityKind
  public var alertAvailability: WeatherKit.WeatherAvailability.AvailabilityKind
  public enum AvailabilityKind : Swift.String, Swift.Codable {
    case available
    case temporarilyUnavailable
    case unsupported
    case unknown
    public init?(rawValue: Swift.String)
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherAvailability : Swift.Equatable {
  public static func == (a: WeatherKit.WeatherAvailability, b: WeatherKit.WeatherAvailability) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherAvailability : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct MinuteWeather {
  public var date: Foundation.Date
  public var precipitation: WeatherKit.Precipitation
  public var precipitationChance: Swift.Double
  public var precipitationIntensity: Foundation.Measurement<Foundation.UnitSpeed>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.MinuteWeather : Swift.Equatable {
  public static func == (a: WeatherKit.MinuteWeather, b: WeatherKit.MinuteWeather) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.MinuteWeather : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct DayWeather {
  public var date: Foundation.Date
  public var condition: WeatherKit.WeatherCondition
  public var symbolName: Swift.String
  public var highTemperature: Foundation.Measurement<Foundation.UnitTemperature>
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public var highTemperatureTime: Foundation.Date?
  public var lowTemperature: Foundation.Measurement<Foundation.UnitTemperature>
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public var lowTemperatureTime: Foundation.Date?
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public var maximumHumidity: Swift.Double
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public var minimumHumidity: Swift.Double
  public var precipitation: WeatherKit.Precipitation
  public var precipitationChance: Swift.Double
  @backDeployed(before: iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4)
  @available(iOS, introduced: 16.0, deprecated: 18.0, message: "Use precipitationAmountByType")
  @available(macOS, introduced: 13.0, deprecated: 15.0, message: "Use precipitationAmountByType")
  @available(tvOS, introduced: 16.0, deprecated: 18.0, message: "Use precipitationAmountByType")
  @available(watchOS, introduced: 9.0, deprecated: 11.0, message: "Use precipitationAmountByType")
  public var precipitationAmount: Foundation.Measurement<Foundation.UnitLength> {
    get {
        return rainfallAmount
    }
  }
  @available(iOS, introduced: 16.0, deprecated: 16.4, message: "Use precipitationAmountByType")
  @available(macOS, introduced: 13.0, deprecated: 13.3, message: "Use precipitationAmountByType")
  @available(tvOS, introduced: 16.0, deprecated: 16.4, message: "Use precipitationAmountByType")
  @available(watchOS, introduced: 9.0, deprecated: 9.4, message: "Use precipitationAmountByType")
  public var rainfallAmount: Foundation.Measurement<Foundation.UnitLength>
  @available(iOS, introduced: 16.0, deprecated: 18.0, message: "Use precipitationAmountByType")
  @available(macOS, introduced: 13.0, deprecated: 15.0, message: "Use precipitationAmountByType")
  @available(tvOS, introduced: 16.0, deprecated: 18.0, message: "Use precipitationAmountByType")
  @available(watchOS, introduced: 9.0, deprecated: 11.0, message: "Use precipitationAmountByType")
  public var snowfallAmount: Foundation.Measurement<Foundation.UnitLength>
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public var precipitationAmountByType: WeatherKit.PrecipitationAmountByType
  public var sun: WeatherKit.SunEvents
  public var moon: WeatherKit.MoonEvents
  public var uvIndex: WeatherKit.UVIndex
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public var maximumVisibility: Swift.Double
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public var minimumVisibility: Swift.Double
  public var wind: WeatherKit.Wind
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, *)
  public var highWindSpeed: Foundation.Measurement<Foundation.UnitSpeed>?
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public var daytimeForecast: WeatherKit.DayPartForecast
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public var overnightForecast: WeatherKit.DayPartForecast
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public var restOfDayForecast: WeatherKit.DayPartForecast?
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.DayWeather : Swift.Equatable {
  public static func == (a: WeatherKit.DayWeather, b: WeatherKit.DayWeather) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.DayWeather : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct PrecipitationAmountByType : Swift.Codable, Swift.Equatable {
  public var hail: Foundation.Measurement<Foundation.UnitLength>
  public var mixed: Foundation.Measurement<Foundation.UnitLength>
  public var rainfall: Foundation.Measurement<Foundation.UnitLength>
  public var sleet: Foundation.Measurement<Foundation.UnitLength>
  public var precipitation: Foundation.Measurement<Foundation.UnitLength>
  public var snowfallAmount: WeatherKit.SnowfallAmount
  public static func == (a: WeatherKit.PrecipitationAmountByType, b: WeatherKit.PrecipitationAmountByType) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct Trend<Dimension> : Swift.Codable, Swift.Equatable where Dimension : Foundation.Dimension {
  public var baseline: WeatherKit.TrendBaseline<Dimension>
  public var currentValue: Foundation.Measurement<Dimension>
  public var deviation: WeatherKit.Deviation
  public static func == (a: WeatherKit.Trend<Dimension>, b: WeatherKit.Trend<Dimension>) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct HistoricalComparisons : Swift.Codable, Swift.Equatable, Swift.RandomAccessCollection {
  public typealias Element = WeatherKit.HistoricalComparison
  public typealias Index = Swift.Int
  public var comparisons: [WeatherKit.HistoricalComparison]
  public var metadata: WeatherKit.WeatherMetadata
  public var startIndex: WeatherKit.HistoricalComparisons.Index {
    get
  }
  public var endIndex: WeatherKit.HistoricalComparisons.Index {
    get
  }
  public subscript(position: WeatherKit.HistoricalComparisons.Index) -> WeatherKit.HistoricalComparisons.Element {
    get
  }
  public static func == (a: WeatherKit.HistoricalComparisons, b: WeatherKit.HistoricalComparisons) -> Swift.Bool
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Indices = Swift.Range<WeatherKit.HistoricalComparisons.Index>
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Iterator = Swift.IndexingIterator<WeatherKit.HistoricalComparisons>
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias SubSequence = Swift.Slice<WeatherKit.HistoricalComparisons>
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct DayTemperatureStatistics : Swift.Codable, Swift.Equatable, Swift.Sendable {
  public var day: Swift.Int
  public var averageLowTemperature: Foundation.Measurement<Foundation.UnitTemperature>
  public var averageHighTemperature: Foundation.Measurement<Foundation.UnitTemperature>
  public static func == (a: WeatherKit.DayTemperatureStatistics, b: WeatherKit.DayTemperatureStatistics) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct UVIndex {
  public var value: Swift.Int
  public var category: WeatherKit.UVIndex.ExposureCategory
  @frozen public enum ExposureCategory : Swift.String, Swift.Codable, Swift.Comparable, Swift.CustomStringConvertible, Swift.CaseIterable {
    case low
    case moderate
    case high
    case veryHigh
    case extreme
    public var rangeValue: Swift.ClosedRange<Swift.Int> {
      get
    }
    public var description: Swift.String {
      get
    }
    public var accessibilityDescription: Swift.String {
      get
    }
    public static func < (lhs: WeatherKit.UVIndex.ExposureCategory, rhs: WeatherKit.UVIndex.ExposureCategory) -> Swift.Bool
    public init?(rawValue: Swift.String)
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias AllCases = [WeatherKit.UVIndex.ExposureCategory]
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [WeatherKit.UVIndex.ExposureCategory] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.UVIndex : Swift.Equatable {
  public static func == (a: WeatherKit.UVIndex, b: WeatherKit.UVIndex) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.UVIndex : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct WeatherChanges : Swift.RandomAccessCollection {
  public typealias Element = WeatherKit.WeatherChange
  public typealias Index = Swift.Int
  public var changes: [WeatherKit.WeatherChange]
  public var metadata: WeatherKit.WeatherMetadata
  public var startIndex: WeatherKit.WeatherChanges.Index {
    get
  }
  public var endIndex: WeatherKit.WeatherChanges.Index {
    get
  }
  public subscript(position: WeatherKit.WeatherChanges.Index) -> WeatherKit.WeatherChanges.Element {
    get
  }
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Indices = Swift.Range<WeatherKit.WeatherChanges.Index>
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Iterator = Swift.IndexingIterator<WeatherKit.WeatherChanges>
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias SubSequence = Swift.Slice<WeatherKit.WeatherChanges>
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension WeatherKit.WeatherChanges : Swift.Equatable {
  public static func == (a: WeatherKit.WeatherChanges, b: WeatherKit.WeatherChanges) -> Swift.Bool
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension WeatherKit.WeatherChanges : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct HourWeather {
  public var date: Foundation.Date
  public var cloudCover: Swift.Double
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public var cloudCoverByAltitude: WeatherKit.CloudCoverByAltitude
  public var condition: WeatherKit.WeatherCondition
  public var symbolName: Swift.String
  public var dewPoint: Foundation.Measurement<Foundation.UnitTemperature>
  public var humidity: Swift.Double
  public var isDaylight: Swift.Bool
  public var precipitation: WeatherKit.Precipitation
  public var precipitationChance: Swift.Double
  public var precipitationAmount: Foundation.Measurement<Foundation.UnitLength>
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public var snowfallAmount: Foundation.Measurement<Foundation.UnitLength>
  public var pressure: Foundation.Measurement<Foundation.UnitPressure>
  public var pressureTrend: WeatherKit.PressureTrend
  public var temperature: Foundation.Measurement<Foundation.UnitTemperature>
  public var apparentTemperature: Foundation.Measurement<Foundation.UnitTemperature>
  public var uvIndex: WeatherKit.UVIndex
  public var visibility: Foundation.Measurement<Foundation.UnitLength>
  public var wind: WeatherKit.Wind
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.HourWeather : Swift.Equatable {
  public static func == (a: WeatherKit.HourWeather, b: WeatherKit.HourWeather) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.HourWeather : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public enum WeatherError : Foundation.LocalizedError {
  case permissionDenied
  case unknown
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
  public var helpAnchor: Swift.String? {
    get
  }
  public var recoverySuggestion: Swift.String? {
    get
  }
  public static func == (a: WeatherKit.WeatherError, b: WeatherKit.WeatherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct DailyWeatherStatisticsQuery<T> where T : Swift.Decodable, T : Swift.Encodable, T : Swift.Equatable {
  public static var temperature: WeatherKit.DailyWeatherStatisticsQuery<WeatherKit.DayTemperatureStatistics> {
    get
  }
  public static var precipitation: WeatherKit.DailyWeatherStatisticsQuery<WeatherKit.DayPrecipitationStatistics> {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct SunEvents {
  public var astronomicalDawn: Foundation.Date?
  public var nauticalDawn: Foundation.Date?
  public var civilDawn: Foundation.Date?
  public var sunrise: Foundation.Date?
  public var solarNoon: Foundation.Date?
  public var sunset: Foundation.Date?
  public var civilDusk: Foundation.Date?
  public var nauticalDusk: Foundation.Date?
  public var astronomicalDusk: Foundation.Date?
  public var solarMidnight: Foundation.Date?
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.SunEvents : Swift.Equatable {
  public static func == (a: WeatherKit.SunEvents, b: WeatherKit.SunEvents) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.SunEvents : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public enum WeatherCondition : Swift.String, Swift.CaseIterable, Swift.CustomStringConvertible, Swift.Hashable {
  case blizzard
  case blowingDust
  case blowingSnow
  case breezy
  case clear
  case cloudy
  case drizzle
  case flurries
  case foggy
  case freezingDrizzle
  case freezingRain
  case frigid
  case hail
  case haze
  case heavyRain
  case heavySnow
  case hot
  case hurricane
  case isolatedThunderstorms
  case mostlyClear
  case mostlyCloudy
  case partlyCloudy
  case rain
  case scatteredThunderstorms
  case sleet
  case smoky
  case snow
  case strongStorms
  case sunFlurries
  case sunShowers
  case thunderstorms
  case tropicalStorm
  case windy
  case wintryMix
  public var description: Swift.String {
    get
  }
  public var accessibilityDescription: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias AllCases = [WeatherKit.WeatherCondition]
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [WeatherKit.WeatherCondition] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherCondition : Swift.Equatable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherCondition : Swift.Codable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct WeatherAttribution {
  public var serviceName: Swift.String {
    get
    set
  }
  public var legalPageURL: Foundation.URL {
    get
    set
  }
  public var squareMarkURL: Foundation.URL {
    get
    set
  }
  public var combinedMarkDarkURL: Foundation.URL {
    get
    set
  }
  public var combinedMarkLightURL: Foundation.URL {
    get
    set
  }
  @available(iOS 16.4, macOS 13.3, tvOS 16.4, watchOS 9.4, *)
  public var legalAttributionText: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherAttribution : Swift.Equatable {
  public static func == (a: WeatherKit.WeatherAttribution, b: WeatherKit.WeatherAttribution) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherAttribution : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct CloudCoverByAltitude {
  public var low: Swift.Double
  public var medium: Swift.Double
  public var high: Swift.Double
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension WeatherKit.CloudCoverByAltitude : Swift.Equatable {
  public static func == (a: WeatherKit.CloudCoverByAltitude, b: WeatherKit.CloudCoverByAltitude) -> Swift.Bool
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension WeatherKit.CloudCoverByAltitude : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct MonthlyWeatherStatisticsQuery<T> where T : Swift.Decodable, T : Swift.Encodable, T : Swift.Equatable {
  public static var temperature: WeatherKit.MonthlyWeatherStatisticsQuery<WeatherKit.MonthTemperatureStatistics> {
    get
  }
  public static var precipitation: WeatherKit.MonthlyWeatherStatisticsQuery<WeatherKit.MonthPrecipitationStatistics> {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct WeatherQuery<T> {
  public static var current: WeatherKit.WeatherQuery<WeatherKit.CurrentWeather> {
    get
  }
  public static var minute: WeatherKit.WeatherQuery<WeatherKit.Forecast<WeatherKit.MinuteWeather>?> {
    get
  }
  public static var hourly: WeatherKit.WeatherQuery<WeatherKit.Forecast<WeatherKit.HourWeather>> {
    get
  }
  public static var daily: WeatherKit.WeatherQuery<WeatherKit.Forecast<WeatherKit.DayWeather>> {
    get
  }
  public static var alerts: WeatherKit.WeatherQuery<[WeatherKit.WeatherAlert]?> {
    get
  }
  public static var availability: WeatherKit.WeatherQuery<WeatherKit.WeatherAvailability> {
    get
  }
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public static var changes: WeatherKit.WeatherQuery<WeatherKit.WeatherChanges?> {
    get
  }
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public static var historicalComparisons: WeatherKit.WeatherQuery<WeatherKit.HistoricalComparisons?> {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherQuery where T == WeatherKit.Forecast<WeatherKit.DayWeather> {
  public static func daily(startDate: Foundation.Date, endDate: Foundation.Date) -> WeatherKit.WeatherQuery<T>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherQuery where T == WeatherKit.Forecast<WeatherKit.HourWeather> {
  public static func hourly(startDate: Foundation.Date, endDate: Foundation.Date) -> WeatherKit.WeatherQuery<T>
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public enum HistoricalComparison : Swift.Codable, Swift.Equatable {
  case highTemperature(WeatherKit.Trend<Foundation.UnitTemperature>)
  case lowTemperature(WeatherKit.Trend<Foundation.UnitTemperature>)
  case precipitationAmount(WeatherKit.Trend<Foundation.UnitLength>)
  case snowfallAmount(WeatherKit.Trend<Foundation.UnitLength>)
  public static func == (a: WeatherKit.HistoricalComparison, b: WeatherKit.HistoricalComparison) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct DailyWeatherSummaryQuery<T> where T : Swift.Decodable, T : Swift.Encodable, T : Swift.Equatable {
  public static var temperature: WeatherKit.DailyWeatherSummaryQuery<WeatherKit.DayTemperatureSummary> {
    get
  }
  public static var precipitation: WeatherKit.DailyWeatherSummaryQuery<WeatherKit.DayPrecipitationSummary> {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct MoonEvents {
  public var phase: WeatherKit.MoonPhase
  public var moonrise: Foundation.Date?
  public var moonset: Foundation.Date?
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.MoonEvents : Swift.Equatable {
  public static func == (a: WeatherKit.MoonEvents, b: WeatherKit.MoonEvents) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.MoonEvents : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct DayTemperatureSummary : Swift.Codable, Swift.Equatable, Swift.Sendable {
  public var date: Foundation.Date
  public var lowTemperature: Foundation.Measurement<Foundation.UnitTemperature>
  public var highTemperature: Foundation.Measurement<Foundation.UnitTemperature>
  public static func == (a: WeatherKit.DayTemperatureSummary, b: WeatherKit.DayTemperatureSummary) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct SnowfallAmount : Swift.Codable, Swift.Equatable {
  public var amount: Foundation.Measurement<Foundation.UnitLength>
  public var maximum: Foundation.Measurement<Foundation.UnitLength>
  public var minimum: Foundation.Measurement<Foundation.UnitLength>
  public var amountLiquidEquivalent: Foundation.Measurement<Foundation.UnitLength>
  public var maximumLiquidEquivalent: Foundation.Measurement<Foundation.UnitLength>
  public var minimumLiquidEquivalent: Foundation.Measurement<Foundation.UnitLength>
  public static func == (a: WeatherKit.SnowfallAmount, b: WeatherKit.SnowfallAmount) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct TrendBaseline<Dimension> : Swift.Codable, Swift.Equatable where Dimension : Foundation.Dimension {
  public enum Kind : Swift.Codable, Swift.Equatable {
    case mean
    public static func == (a: WeatherKit.TrendBaseline<Dimension>.Kind, b: WeatherKit.TrendBaseline<Dimension>.Kind) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public let kind: WeatherKit.TrendBaseline<Dimension>.Kind
  public let value: Foundation.Measurement<Dimension>
  public let startDate: Foundation.Date
  public static func == (a: WeatherKit.TrendBaseline<Dimension>, b: WeatherKit.TrendBaseline<Dimension>) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct WeatherMetadata {
  public var date: Foundation.Date
  public var expirationDate: Foundation.Date
  public var location: CoreLocation.CLLocation {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherMetadata : Swift.Equatable {
  public static func == (a: WeatherKit.WeatherMetadata, b: WeatherKit.WeatherMetadata) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherMetadata : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct HourlyWeatherStatistics<T> : Swift.Codable, Swift.Equatable, Swift.Sendable, Swift.RandomAccessCollection where T : Swift.Decodable, T : Swift.Encodable, T : Swift.Equatable, T : Swift.Sendable {
  public typealias Element = T
  public typealias Index = Swift.Int
  public var hours: [T]
  public var baselineStartDate: Foundation.Date
  public var metadata: WeatherKit.WeatherMetadata
  public var startIndex: WeatherKit.HourlyWeatherStatistics<T>.Index {
    get
  }
  public var endIndex: WeatherKit.HourlyWeatherStatistics<T>.Index {
    get
  }
  public subscript(position: WeatherKit.HourlyWeatherStatistics<T>.Index) -> WeatherKit.HourlyWeatherStatistics<T>.Element {
    get
  }
  public static func == (a: WeatherKit.HourlyWeatherStatistics<T>, b: WeatherKit.HourlyWeatherStatistics<T>) -> Swift.Bool
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Indices = Swift.Range<WeatherKit.HourlyWeatherStatistics<T>.Index>
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Iterator = Swift.IndexingIterator<WeatherKit.HourlyWeatherStatistics<T>>
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias SubSequence = Swift.Slice<WeatherKit.HourlyWeatherStatistics<T>>
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct Weather {
  public var currentWeather: WeatherKit.CurrentWeather
  public var minuteForecast: WeatherKit.Forecast<WeatherKit.MinuteWeather>?
  public var hourlyForecast: WeatherKit.Forecast<WeatherKit.HourWeather>
  public var dailyForecast: WeatherKit.Forecast<WeatherKit.DayWeather>
  public var weatherAlerts: [WeatherKit.WeatherAlert]?
  public var availability: WeatherKit.WeatherAvailability
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.Weather : Swift.Equatable {
  public static func == (a: WeatherKit.Weather, b: WeatherKit.Weather) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.Weather : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct DailyWeatherStatistics<T> : Swift.Codable, Swift.Equatable, Swift.Sendable, Swift.RandomAccessCollection where T : Swift.Decodable, T : Swift.Encodable, T : Swift.Equatable, T : Swift.Sendable {
  public typealias Element = T
  public typealias Index = Swift.Int
  public var days: [T]
  public var baselineStartDate: Foundation.Date
  public var metadata: WeatherKit.WeatherMetadata
  public var startIndex: WeatherKit.DailyWeatherStatistics<T>.Index {
    get
  }
  public var endIndex: WeatherKit.DailyWeatherStatistics<T>.Index {
    get
  }
  public subscript(position: WeatherKit.DailyWeatherStatistics<T>.Index) -> WeatherKit.DailyWeatherStatistics<T>.Element {
    get
  }
  public static func == (a: WeatherKit.DailyWeatherStatistics<T>, b: WeatherKit.DailyWeatherStatistics<T>) -> Swift.Bool
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Indices = Swift.Range<WeatherKit.DailyWeatherStatistics<T>.Index>
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Iterator = Swift.IndexingIterator<WeatherKit.DailyWeatherStatistics<T>>
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias SubSequence = Swift.Slice<WeatherKit.DailyWeatherStatistics<T>>
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct Percentiles<Dimension> : Swift.Codable, Swift.Equatable, Swift.Sendable where Dimension : Foundation.Dimension {
  public var p10: Foundation.Measurement<Dimension>
  public var p50: Foundation.Measurement<Dimension>
  public var p90: Foundation.Measurement<Dimension>
  public static func == (a: WeatherKit.Percentiles<Dimension>, b: WeatherKit.Percentiles<Dimension>) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct DayPrecipitationStatistics : Swift.Codable, Swift.Equatable, Swift.Sendable {
  public var day: Swift.Int
  public var averagePrecipitationProbability: Swift.Double
  public var averagePrecipitationAmount: Foundation.Measurement<Foundation.UnitLength>
  public var averageSnowfallAmount: Foundation.Measurement<Foundation.UnitLength>
  public static func == (a: WeatherKit.DayPrecipitationStatistics, b: WeatherKit.DayPrecipitationStatistics) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct MonthlyWeatherStatistics<T> : Swift.Codable, Swift.Equatable, Swift.Sendable, Swift.RandomAccessCollection where T : Swift.Decodable, T : Swift.Encodable, T : Swift.Equatable, T : Swift.Sendable {
  public typealias Element = T
  public typealias Index = Swift.Int
  public var months: [T]
  public var baselineStartDate: Foundation.Date
  public var metadata: WeatherKit.WeatherMetadata
  public var startIndex: WeatherKit.MonthlyWeatherStatistics<T>.Index {
    get
  }
  public var endIndex: WeatherKit.MonthlyWeatherStatistics<T>.Index {
    get
  }
  public subscript(position: WeatherKit.MonthlyWeatherStatistics<T>.Index) -> WeatherKit.MonthlyWeatherStatistics<T>.Element {
    get
  }
  public static func == (a: WeatherKit.MonthlyWeatherStatistics<T>, b: WeatherKit.MonthlyWeatherStatistics<T>) -> Swift.Bool
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Indices = Swift.Range<WeatherKit.MonthlyWeatherStatistics<T>.Index>
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Iterator = Swift.IndexingIterator<WeatherKit.MonthlyWeatherStatistics<T>>
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias SubSequence = Swift.Slice<WeatherKit.MonthlyWeatherStatistics<T>>
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct Forecast<Element> : Swift.RandomAccessCollection, Swift.Codable, Swift.Equatable where Element : Swift.Decodable, Element : Swift.Encodable, Element : Swift.Equatable {
  public typealias Index = Swift.Int
  public var forecast: [Element]
  public var metadata: WeatherKit.WeatherMetadata
  public var startIndex: WeatherKit.Forecast<Element>.Index {
    get
  }
  public var endIndex: WeatherKit.Forecast<Element>.Index {
    get
  }
  public subscript(position: WeatherKit.Forecast<Element>.Index) -> Element {
    get
  }
  public static func == (a: WeatherKit.Forecast<Element>, b: WeatherKit.Forecast<Element>) -> Swift.Bool
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Indices = Swift.Range<WeatherKit.Forecast<Element>.Index>
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias Iterator = Swift.IndexingIterator<WeatherKit.Forecast<Element>>
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias SubSequence = Swift.Slice<WeatherKit.Forecast<Element>>
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.Forecast where Element == WeatherKit.MinuteWeather {
  public var summary: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.Forecast {
  public static func == (lhs: WeatherKit.Forecast<WeatherKit.MinuteWeather>, rhs: WeatherKit.Forecast<WeatherKit.MinuteWeather>) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.Forecast where Element == WeatherKit.HourWeather {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.Forecast where Element == WeatherKit.DayWeather {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public enum Precipitation : Swift.String, Swift.CaseIterable, Swift.CustomStringConvertible, Swift.Hashable {
  case none
  case hail
  case mixed
  case rain
  case sleet
  case snow
  public var description: Swift.String {
    get
  }
  public var accessibilityDescription: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias AllCases = [WeatherKit.Precipitation]
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [WeatherKit.Precipitation] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.Precipitation : Swift.Equatable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.Precipitation : Swift.Codable {
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct WeatherChange {
  @frozen public enum Direction {
    case increase
    case decrease
    case steady
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var date: Foundation.Date
  public var highTemperature: WeatherKit.WeatherChange.Direction
  public var lowTemperature: WeatherKit.WeatherChange.Direction
  public var dayPrecipitationAmount: WeatherKit.WeatherChange.Direction
  public var nightPrecipitationAmount: WeatherKit.WeatherChange.Direction
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension WeatherKit.WeatherChange : Swift.Equatable {
  public static func == (a: WeatherKit.WeatherChange, b: WeatherKit.WeatherChange) -> Swift.Bool
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension WeatherKit.WeatherChange.Direction : Swift.Equatable {
  public static func == (a: WeatherKit.WeatherChange.Direction, b: WeatherKit.WeatherChange.Direction) -> Swift.Bool
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension WeatherKit.WeatherChange : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension WeatherKit.WeatherChange.Direction : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public enum PressureTrend : Swift.String, Swift.CaseIterable, Swift.CustomStringConvertible, Swift.Hashable {
  case rising
  case falling
  case steady
  public var description: Swift.String {
    get
  }
  public var accessibilityDescription: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias AllCases = [WeatherKit.PressureTrend]
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [WeatherKit.PressureTrend] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.PressureTrend : Swift.Equatable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.PressureTrend : Swift.Codable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct Wind {
  public var compassDirection: WeatherKit.Wind.CompassDirection
  public var direction: Foundation.Measurement<Foundation.UnitAngle>
  public var speed: Foundation.Measurement<Foundation.UnitSpeed>
  public var gust: Foundation.Measurement<Foundation.UnitSpeed>?
  @frozen public enum CompassDirection : Swift.String, Swift.Codable, Swift.CaseIterable, Swift.CustomStringConvertible {
    case north
    case northNortheast
    case northeast
    case eastNortheast
    case east
    case eastSoutheast
    case southeast
    case southSoutheast
    case south
    case southSouthwest
    case southwest
    case westSouthwest
    case west
    case westNorthwest
    case northwest
    case northNorthwest
    public var abbreviation: Swift.String {
      get
    }
    public var description: Swift.String {
      get
    }
    public var accessibilityDescription: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias AllCases = [WeatherKit.Wind.CompassDirection]
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [WeatherKit.Wind.CompassDirection] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.Wind : Swift.Equatable {
  public static func == (a: WeatherKit.Wind, b: WeatherKit.Wind) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.Wind : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct HourTemperatureStatistics : Swift.Codable, Swift.Equatable, Swift.Sendable {
  public var hour: Swift.Int
  public var percentiles: WeatherKit.Percentiles<Foundation.UnitTemperature>
  public static func == (a: WeatherKit.HourTemperatureStatistics, b: WeatherKit.HourTemperatureStatistics) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
final public class WeatherService : @unchecked Swift.Sendable {
  public static let shared: WeatherKit.WeatherService
  final public var attribution: WeatherKit.WeatherAttribution {
    get async throws
  }
  convenience public init()
  final public func weather(for location: CoreLocation.CLLocation) async throws -> WeatherKit.Weather
  final public func weather<T>(for location: CoreLocation.CLLocation, including dataSet: WeatherKit.WeatherQuery<T>) async throws -> T
  final public func weather<T1, T2>(for location: CoreLocation.CLLocation, including dataSet1: WeatherKit.WeatherQuery<T1>, _ dataSet2: WeatherKit.WeatherQuery<T2>) async throws -> (T1, T2)
  final public func weather<T1, T2, T3>(for location: CoreLocation.CLLocation, including dataSet1: WeatherKit.WeatherQuery<T1>, _ dataSet2: WeatherKit.WeatherQuery<T2>, _ dataSet3: WeatherKit.WeatherQuery<T3>) async throws -> (T1, T2, T3)
  final public func weather<T1, T2, T3, T4>(for location: CoreLocation.CLLocation, including dataSet1: WeatherKit.WeatherQuery<T1>, _ dataSet2: WeatherKit.WeatherQuery<T2>, _ dataSet3: WeatherKit.WeatherQuery<T3>, _ dataSet4: WeatherKit.WeatherQuery<T4>) async throws -> (T1, T2, T3, T4)
  final public func weather<T1, T2, T3, T4, T5>(for location: CoreLocation.CLLocation, including dataSet1: WeatherKit.WeatherQuery<T1>, _ dataSet2: WeatherKit.WeatherQuery<T2>, _ dataSet3: WeatherKit.WeatherQuery<T3>, _ dataSet4: WeatherKit.WeatherQuery<T4>, _ dataSet5: WeatherKit.WeatherQuery<T5>) async throws -> (T1, T2, T3, T4, T5)
  final public func weather<T1, T2, T3, T4, T5, T6>(for location: CoreLocation.CLLocation, including dataSet1: WeatherKit.WeatherQuery<T1>, _ dataSet2: WeatherKit.WeatherQuery<T2>, _ dataSet3: WeatherKit.WeatherQuery<T3>, _ dataSet4: WeatherKit.WeatherQuery<T4>, _ dataSet5: WeatherKit.WeatherQuery<T5>, _ dataSet6: WeatherKit.WeatherQuery<T6>) async throws -> (T1, T2, T3, T4, T5, T6)
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  final public func weather<each T>(for location: CoreLocation.CLLocation, including dataSet: repeat WeatherKit.WeatherQuery<each T>) async throws -> (repeat each T)
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  final public func dailyStatistics<each T>(for location: CoreLocation.CLLocation, forDaysIn interval: Foundation.DateInterval, including dataSets: repeat WeatherKit.DailyWeatherStatisticsQuery<each T>) async throws -> (repeat WeatherKit.DailyWeatherStatistics<each T>) where repeat each T : Swift.Decodable, repeat each T : Swift.Encodable, repeat each T : Swift.Equatable, repeat each T : Swift.Sendable
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  final public func dailyStatistics<each T>(for location: CoreLocation.CLLocation, including dataSets: repeat WeatherKit.DailyWeatherStatisticsQuery<each T>) async throws -> (repeat WeatherKit.DailyWeatherStatistics<each T>) where repeat each T : Swift.Decodable, repeat each T : Swift.Encodable, repeat each T : Swift.Equatable, repeat each T : Swift.Sendable
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  final public func dailyStatistics<each T>(for location: CoreLocation.CLLocation, startDay: Swift.Int, endDay: Swift.Int, including dataSets: repeat WeatherKit.DailyWeatherStatisticsQuery<each T>) async throws -> (repeat WeatherKit.DailyWeatherStatistics<each T>) where repeat each T : Swift.Decodable, repeat each T : Swift.Encodable, repeat each T : Swift.Equatable, repeat each T : Swift.Sendable
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  final public func dailySummary<each T>(for location: CoreLocation.CLLocation, forDaysIn interval: Foundation.DateInterval, including dataSets: repeat WeatherKit.DailyWeatherSummaryQuery<each T>) async throws -> (repeat WeatherKit.DailyWeatherSummary<each T>) where repeat each T : Swift.Decodable, repeat each T : Swift.Encodable, repeat each T : Swift.Equatable, repeat each T : Swift.Sendable
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  final public func dailySummary<each T>(for location: CoreLocation.CLLocation, including dataSets: repeat WeatherKit.DailyWeatherSummaryQuery<each T>) async throws -> (repeat WeatherKit.DailyWeatherSummary<each T>) where repeat each T : Swift.Decodable, repeat each T : Swift.Encodable, repeat each T : Swift.Equatable, repeat each T : Swift.Sendable
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  final public func hourlyStatistics<each T>(for location: CoreLocation.CLLocation, forHoursIn interval: Foundation.DateInterval, including dataSets: repeat WeatherKit.HourlyWeatherStatisticsQuery<each T>) async throws -> (repeat WeatherKit.HourlyWeatherStatistics<each T>) where repeat each T : Swift.Decodable, repeat each T : Swift.Encodable, repeat each T : Swift.Equatable, repeat each T : Swift.Sendable
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  final public func hourlyStatistics<each T>(for location: CoreLocation.CLLocation, including dataSets: repeat WeatherKit.HourlyWeatherStatisticsQuery<each T>) async throws -> (repeat WeatherKit.HourlyWeatherStatistics<each T>) where repeat each T : Swift.Decodable, repeat each T : Swift.Encodable, repeat each T : Swift.Equatable, repeat each T : Swift.Sendable
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  final public func hourlyStatistics<each T>(for location: CoreLocation.CLLocation, startHour: Swift.Int, endHour: Swift.Int, including dataSets: repeat WeatherKit.HourlyWeatherStatisticsQuery<each T>) async throws -> (repeat WeatherKit.HourlyWeatherStatistics<each T>) where repeat each T : Swift.Decodable, repeat each T : Swift.Encodable, repeat each T : Swift.Equatable, repeat each T : Swift.Sendable
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  final public func monthlyStatistics<each T>(for location: CoreLocation.CLLocation, including dataSets: repeat WeatherKit.MonthlyWeatherStatisticsQuery<each T>) async throws -> (repeat WeatherKit.MonthlyWeatherStatistics<each T>) where repeat each T : Swift.Decodable, repeat each T : Swift.Encodable, repeat each T : Swift.Equatable, repeat each T : Swift.Sendable
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  final public func monthlyStatistics<each T>(for location: CoreLocation.CLLocation, forMonthsIn interval: Foundation.DateInterval, including dataSets: repeat WeatherKit.MonthlyWeatherStatisticsQuery<each T>) async throws -> (repeat WeatherKit.MonthlyWeatherStatistics<each T>) where repeat each T : Swift.Decodable, repeat each T : Swift.Encodable, repeat each T : Swift.Equatable, repeat each T : Swift.Sendable
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  final public func monthlyStatistics<each T>(for location: CoreLocation.CLLocation, startMonth: Swift.Int, endMonth: Swift.Int, including dataSets: repeat WeatherKit.MonthlyWeatherStatisticsQuery<each T>) async throws -> (repeat WeatherKit.MonthlyWeatherStatistics<each T>) where repeat each T : Swift.Decodable, repeat each T : Swift.Encodable, repeat each T : Swift.Equatable, repeat each T : Swift.Sendable
  @objc deinit
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct DailyWeatherSummary<T> : Swift.Codable, Swift.Equatable, Swift.Sendable, Swift.RandomAccessCollection where T : Swift.Decodable, T : Swift.Encodable, T : Swift.Equatable, T : Swift.Sendable {
  public typealias Element = T
  public typealias Index = Swift.Int
  public var days: [T]
  public var metadata: WeatherKit.WeatherMetadata
  public var startIndex: WeatherKit.DailyWeatherSummary<T>.Index {
    get
  }
  public var endIndex: WeatherKit.DailyWeatherSummary<T>.Index {
    get
  }
  public subscript(position: WeatherKit.DailyWeatherSummary<T>.Index) -> WeatherKit.DailyWeatherSummary<T>.Element {
    get
  }
  public static func == (a: WeatherKit.DailyWeatherSummary<T>, b: WeatherKit.DailyWeatherSummary<T>) -> Swift.Bool
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Indices = Swift.Range<WeatherKit.DailyWeatherSummary<T>.Index>
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias Iterator = Swift.IndexingIterator<WeatherKit.DailyWeatherSummary<T>>
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias SubSequence = Swift.Slice<WeatherKit.DailyWeatherSummary<T>>
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct MonthTemperatureStatistics : Swift.Codable, Swift.Equatable, Swift.Sendable {
  public var month: Swift.Int
  public var averageLowTemperature: Foundation.Measurement<Foundation.UnitTemperature>
  public var averageHighTemperature: Foundation.Measurement<Foundation.UnitTemperature>
  public static func == (a: WeatherKit.MonthTemperatureStatistics, b: WeatherKit.MonthTemperatureStatistics) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct DayPrecipitationSummary : Swift.Codable, Swift.Equatable, Swift.Sendable {
  public var date: Foundation.Date
  public var precipitationAmount: Foundation.Measurement<Foundation.UnitLength>
  public var snowfallAmount: Foundation.Measurement<Foundation.UnitLength>
  public static func == (a: WeatherKit.DayPrecipitationSummary, b: WeatherKit.DayPrecipitationSummary) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public enum WeatherSeverity : Swift.String, Swift.CaseIterable, Swift.CustomStringConvertible, Swift.Hashable {
  case minor
  case moderate
  case severe
  case extreme
  case unknown
  public var description: Swift.String {
    get
  }
  public var accessibilityDescription: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias AllCases = [WeatherKit.WeatherSeverity]
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [WeatherKit.WeatherSeverity] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherSeverity : Swift.Equatable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherSeverity : Swift.Codable {
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public enum Deviation : Swift.Codable, Swift.Equatable {
  case muchHigher
  case higher
  case normal
  case lower
  case muchLower
  public static func == (a: WeatherKit.Deviation, b: WeatherKit.Deviation) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
@frozen public enum MoonPhase : Swift.String, Swift.CustomStringConvertible, Swift.CaseIterable {
  case new
  case waxingCrescent
  case firstQuarter
  case waxingGibbous
  case full
  case waningGibbous
  case lastQuarter
  case waningCrescent
  public var description: Swift.String {
    get
  }
  public var accessibilityDescription: Swift.String {
    get
  }
  public var symbolName: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias AllCases = [WeatherKit.MoonPhase]
  @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [WeatherKit.MoonPhase] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.MoonPhase : Swift.Equatable {
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.MoonPhase : Swift.Codable {
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct HourlyWeatherStatisticsQuery<T> where T : Swift.Decodable, T : Swift.Encodable, T : Swift.Equatable {
  public static var temperature: WeatherKit.HourlyWeatherStatisticsQuery<WeatherKit.HourTemperatureStatistics> {
    get
  }
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct CurrentWeather {
  public var date: Foundation.Date
  public var cloudCover: Swift.Double
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  public var cloudCoverByAltitude: WeatherKit.CloudCoverByAltitude
  public var condition: WeatherKit.WeatherCondition
  public var symbolName: Swift.String
  public var dewPoint: Foundation.Measurement<Foundation.UnitTemperature>
  public var humidity: Swift.Double
  @available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
  public var precipitationIntensity: Foundation.Measurement<Foundation.UnitSpeed>
  public var pressure: Foundation.Measurement<Foundation.UnitPressure>
  public var pressureTrend: WeatherKit.PressureTrend
  public var isDaylight: Swift.Bool
  public var temperature: Foundation.Measurement<Foundation.UnitTemperature>
  public var apparentTemperature: Foundation.Measurement<Foundation.UnitTemperature>
  public var uvIndex: WeatherKit.UVIndex
  public var visibility: Foundation.Measurement<Foundation.UnitLength>
  public var wind: WeatherKit.Wind
  public var metadata: WeatherKit.WeatherMetadata
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.CurrentWeather : Swift.Equatable {
  public static func == (a: WeatherKit.CurrentWeather, b: WeatherKit.CurrentWeather) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.CurrentWeather : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
public struct DayPartForecast {
  public var cloudCover: Swift.Double
  public var cloudCoverByAltitude: WeatherKit.CloudCoverByAltitude
  public var condition: WeatherKit.WeatherCondition
  public var highTemperature: Foundation.Measurement<Foundation.UnitTemperature>
  public var lowTemperature: Foundation.Measurement<Foundation.UnitTemperature>
  public var precipitation: WeatherKit.Precipitation
  public var precipitationAmountByType: WeatherKit.PrecipitationAmountByType
  public var precipitationChance: Swift.Double
  public var maximumHumidity: Swift.Double
  public var minimumHumidity: Swift.Double
  public var maximumVisibility: Foundation.Measurement<Foundation.UnitLength>
  public var minimumVisibility: Foundation.Measurement<Foundation.UnitLength>
  public var wind: WeatherKit.Wind
  public var highWindSpeed: Foundation.Measurement<Foundation.UnitSpeed>
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
public struct WeatherAlert {
  public var detailsURL: Foundation.URL
  public var source: Swift.String
  public var summary: Swift.String
  public var region: Swift.String?
  public var severity: WeatherKit.WeatherSeverity
  public var metadata: WeatherKit.WeatherMetadata
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherAlert : Swift.Equatable {
  public static func == (a: WeatherKit.WeatherAlert, b: WeatherKit.WeatherAlert) -> Swift.Bool
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherAlert : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherAvailability.AvailabilityKind : Swift.Equatable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherAvailability.AvailabilityKind : Swift.Hashable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherAvailability.AvailabilityKind : Swift.RawRepresentable {}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension WeatherKit.WeatherChange.Direction : Swift.Hashable {}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension WeatherKit.WeatherChange.Direction : Swift.Sendable {}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension WeatherKit.WeatherChange.Direction : Swift.BitwiseCopyable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.UVIndex.ExposureCategory : Swift.Hashable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.UVIndex.ExposureCategory : Swift.RawRepresentable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.UVIndex.ExposureCategory : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.UVIndex.ExposureCategory : Swift.BitwiseCopyable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherError : Swift.Equatable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherError : Swift.Hashable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherCondition : Swift.RawRepresentable {}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension WeatherKit.TrendBaseline.Kind : Swift.Hashable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.Precipitation : Swift.RawRepresentable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.PressureTrend : Swift.RawRepresentable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.Wind.CompassDirection : Swift.Equatable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.Wind.CompassDirection : Swift.Hashable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.Wind.CompassDirection : Swift.RawRepresentable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.Wind.CompassDirection : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.Wind.CompassDirection : Swift.BitwiseCopyable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.WeatherSeverity : Swift.RawRepresentable {}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension WeatherKit.Deviation : Swift.Hashable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.MoonPhase : Swift.Hashable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.MoonPhase : Swift.RawRepresentable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.MoonPhase : Swift.Sendable {}
@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension WeatherKit.MoonPhase : Swift.BitwiseCopyable {}
