// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1 effective-5.10 (swiftlang-6.1.0.110.5 clang-1700.0.13.3)
// swift-module-flags: -target arm64e-apple-ios14.5-macabi -enable-objc-interop -enable-library-evolution -module-link-name swiftSynchronization -swift-version 5 -O -library-level api -enforce-exclusivity=unchecked -target-min-inlining-version min -enable-experimental-feature NoncopyableGenerics2 -enable-experimental-feature SuppressedAssociatedTypes -enable-experimental-feature SE427NoInferenceOnExtension -enable-experimental-feature AllowUnsafeAttribute -enable-experimental-feature NonescapableTypes -enable-experimental-feature LifetimeDependence -enable-experimental-feature ExtensionImportVisiblity -enable-experimental-feature RawLayout -enable-experimental-feature StaticExclusiveOnly -enable-experimental-feature Extern -user-module-version 6.1.0.110.5 -enable-builtin-module -module-name Synchronization
// swift-module-flags-ignorable: -enable-lexical-lifetimes=false -interface-compiler-version 6.1
import Builtin
import Darwin
import Swift
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@frozen @_rawLayout(like: Value.AtomicRepresentation) @_staticExclusiveOnly public struct Atomic<Value> : ~Swift.Copyable where Value : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent internal var _address: Swift.UnsafeMutablePointer<Value.AtomicRepresentation> {
    @_transparent get {
    UnsafeMutablePointer<Value.AtomicRepresentation>(_rawAddress)
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent internal var _rawAddress: Builtin.RawPointer {
    @_transparent get {
    Builtin.unprotectedAddressOfBorrow(self)
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public init(_ initialValue: consuming Value) {
    _address.initialize(to: Value.encodeAtomicRepresentation(initialValue))
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @inlinable deinit {
    let oldValue = Value.decodeAtomicRepresentation(_address.pointee)
    _ = consume oldValue

    _address.deinitialize(count: 1)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic : @unchecked Swift.Sendable where Value : Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Bool : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Swift.UInt8.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: borrowing Swift.Bool) -> Swift.Bool.AtomicRepresentation {
    UInt8.encodeAtomicRepresentation(
      UInt8(Builtin.zext_Int1_Int8(value._value))
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.Bool.AtomicRepresentation) -> Swift.Bool {
    Bool(Builtin.trunc_Int8_Int1(
      UInt8.decodeAtomicRepresentation(representation)._value)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value == Swift.Bool {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func logicalAnd(_ operand: Swift.Bool, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Bool, newValue: Swift.Bool) {
    let builtinOperand = Bool.encodeAtomicRepresentation(operand)._storage

    let original = switch ordering {
    case .relaxed:
      Builtin.atomicrmw_and_monotonic_Int8(
        _rawAddress,
        builtinOperand
      )

    case .acquiring:
      Builtin.atomicrmw_and_acquire_Int8(
        _rawAddress,
        builtinOperand
      )

    case .releasing:
      Builtin.atomicrmw_and_release_Int8(
        _rawAddress,
        builtinOperand
      )

    case .acquiringAndReleasing:
      Builtin.atomicrmw_and_acqrel_Int8(
        _rawAddress,
        builtinOperand
      )

    case .sequentiallyConsistent:
      Builtin.atomicrmw_and_seqcst_Int8(
        _rawAddress,
        builtinOperand
      )

    default:
      Builtin.unreachable()
    }

    let old = Bool.decodeAtomicRepresentation(UInt8.AtomicRepresentation(original))

    return (oldValue: old, newValue: old && operand)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func logicalOr(_ operand: Swift.Bool, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Bool, newValue: Swift.Bool) {
    let builtinOperand = Bool.encodeAtomicRepresentation(operand)._storage

    let original = switch ordering {
    case .relaxed:
      Builtin.atomicrmw_or_monotonic_Int8(
        _rawAddress,
        builtinOperand
      )

    case .acquiring:
      Builtin.atomicrmw_or_acquire_Int8(
        _rawAddress,
        builtinOperand
      )

    case .releasing:
      Builtin.atomicrmw_or_release_Int8(
        _rawAddress,
        builtinOperand
      )

    case .acquiringAndReleasing:
      Builtin.atomicrmw_or_acqrel_Int8(
        _rawAddress,
        builtinOperand
      )

    case .sequentiallyConsistent:
      Builtin.atomicrmw_or_seqcst_Int8(
        _rawAddress,
        builtinOperand
      )

    default:
      Builtin.unreachable()
    }

    let old = Bool.decodeAtomicRepresentation(UInt8.AtomicRepresentation(original))

    return (oldValue: old, newValue: old || operand)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func logicalXor(_ operand: Swift.Bool, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Bool, newValue: Swift.Bool) {
    let builtinOperand = Bool.encodeAtomicRepresentation(operand)._storage

    let original = switch ordering {
    case .relaxed:
      Builtin.atomicrmw_xor_monotonic_Int8(
        _rawAddress,
        builtinOperand
      )

    case .acquiring:
      Builtin.atomicrmw_xor_acquire_Int8(
        _rawAddress,
        builtinOperand
      )

    case .releasing:
      Builtin.atomicrmw_xor_release_Int8(
        _rawAddress,
        builtinOperand
      )

    case .acquiringAndReleasing:
      Builtin.atomicrmw_xor_acqrel_Int8(
        _rawAddress,
        builtinOperand
      )

    case .sequentiallyConsistent:
      Builtin.atomicrmw_xor_seqcst_Int8(
        _rawAddress,
        builtinOperand
      )

    default:
      Builtin.unreachable()
    }

    let old = Bool.decodeAtomicRepresentation(UInt8.AtomicRepresentation(original))

    return (oldValue: old, newValue: old != operand)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Float16 : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Swift.UInt16.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Swift.Float16) -> Swift.Float16.AtomicRepresentation {
    UInt16.encodeAtomicRepresentation(value.bitPattern)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.Float16.AtomicRepresentation) -> Swift.Float16 {
    Float16(bitPattern: UInt16.decodeAtomicRepresentation(representation))
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Float : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Swift.UInt32.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Swift.Float) -> Swift.Float.AtomicRepresentation {
    UInt32.encodeAtomicRepresentation(value.bitPattern)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.Float.AtomicRepresentation) -> Swift.Float {
    Float(bitPattern: UInt32.decodeAtomicRepresentation(representation))
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Double : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Swift.UInt64.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Swift.Double) -> Swift.Double.AtomicRepresentation {
    UInt64.encodeAtomicRepresentation(value.bitPattern)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.Double.AtomicRepresentation) -> Swift.Double {
    Double(bitPattern: UInt64.decodeAtomicRepresentation(representation))
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@frozen @_staticExclusiveOnly public struct AtomicLazyReference<Instance> : ~Swift.Copyable where Instance : AnyObject {
  @usableFromInline
  internal let storage: Synchronization.Atomic<Swift.Unmanaged<Instance>?>
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public init() {
    storage = Atomic<Unmanaged<Instance>?>(nil)
  }
  @inlinable deinit {
    if let unmanaged = storage.load(ordering: .acquiring) {
      unmanaged.release()
    }
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicLazyReference {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func storeIfNil(_ desired: consuming Instance) -> Instance
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public func load() -> Instance?
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicLazyReference : @unchecked Swift.Sendable where Instance : Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@frozen public struct AtomicLoadOrdering {
  @usableFromInline
  internal var _rawValue: Swift.Int
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable @_semantics("constant_evaluable") @_transparent internal init(_rawValue: Swift.Int) {
    self._rawValue = _rawValue
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicLoadOrdering {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var relaxed: Synchronization.AtomicLoadOrdering {
    @_transparent get {
    Self(_rawValue: 0)
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var acquiring: Synchronization.AtomicLoadOrdering {
    @_transparent get {
    Self(_rawValue: 2)
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var sequentiallyConsistent: Synchronization.AtomicLoadOrdering {
    @_transparent get {
    Self(_rawValue: 5)
  }
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicLoadOrdering : Swift.Equatable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func == (left: Synchronization.AtomicLoadOrdering, right: Synchronization.AtomicLoadOrdering) -> Swift.Bool {
    left._rawValue == right._rawValue
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicLoadOrdering : Swift.Hashable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(_rawValue)
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicLoadOrdering : Swift.CustomStringConvertible {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@frozen public struct AtomicStoreOrdering {
  @usableFromInline
  internal var _rawValue: Swift.Int
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable @_semantics("constant_evaluable") @_transparent internal init(_rawValue: Swift.Int) {
    self._rawValue = _rawValue
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicStoreOrdering {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var relaxed: Synchronization.AtomicStoreOrdering {
    @_transparent get {
    Self(_rawValue: 0)
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var releasing: Synchronization.AtomicStoreOrdering {
    @_transparent get {
    Self(_rawValue: 3)
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var sequentiallyConsistent: Synchronization.AtomicStoreOrdering {
    @_transparent get {
    Self(_rawValue: 5)
  }
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicStoreOrdering : Swift.Equatable {
  @_transparent public static func == (left: Synchronization.AtomicStoreOrdering, right: Synchronization.AtomicStoreOrdering) -> Swift.Bool {
    left._rawValue == right._rawValue
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicStoreOrdering : Swift.Hashable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(_rawValue)
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicStoreOrdering : Swift.CustomStringConvertible {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@frozen public struct AtomicUpdateOrdering {
  @usableFromInline
  internal var _rawValue: Swift.Int
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable @_semantics("constant_evaluable") @_transparent internal init(_rawValue: Swift.Int) {
    self._rawValue = _rawValue
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicUpdateOrdering {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var relaxed: Synchronization.AtomicUpdateOrdering {
    @_transparent get {
    Self(_rawValue: 0)
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var acquiring: Synchronization.AtomicUpdateOrdering {
    @_transparent get {
    Self(_rawValue: 2)
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var releasing: Synchronization.AtomicUpdateOrdering {
    @_transparent get {
    Self(_rawValue: 3)
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var acquiringAndReleasing: Synchronization.AtomicUpdateOrdering {
    @_transparent get {
    Self(_rawValue: 4)
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var sequentiallyConsistent: Synchronization.AtomicUpdateOrdering {
    @_transparent get {
    Self(_rawValue: 5)
  }
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicUpdateOrdering : Swift.Equatable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_transparent public static func == (left: Synchronization.AtomicUpdateOrdering, right: Synchronization.AtomicUpdateOrdering) -> Swift.Bool {
    left._rawValue == right._rawValue
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicUpdateOrdering : Swift.Hashable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(_rawValue)
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicUpdateOrdering : Swift.CustomStringConvertible {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicLoadOrdering {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("constant_evaluable") @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal static func _failureOrdering(for ordering: Synchronization.AtomicUpdateOrdering) -> Synchronization.AtomicLoadOrdering {
    switch ordering {
    case .relaxed: return .relaxed
    case .acquiring: return .acquiring
    case .releasing: return .relaxed
    case .acquiringAndReleasing: return .acquiring
    case .sequentiallyConsistent: return .sequentiallyConsistent
    default: fatalError("Unsupported ordering")
    }
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func atomicMemoryFence(ordering: Synchronization.AtomicUpdateOrdering) {
  switch ordering {
  case .relaxed:
    return

  case .acquiring:
    Builtin.fence_acquire()

  case .releasing:
    Builtin.fence_release()

  case .acquiringAndReleasing:
    Builtin.fence_acqrel()

  case .sequentiallyConsistent:
    Builtin.fence_seqcst()

  default:
    Builtin.unreachable()
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public protocol AtomicOptionalRepresentable : Synchronization.AtomicRepresentable {
  associatedtype AtomicOptionalRepresentation : Swift.BitwiseCopyable
  static func encodeAtomicOptionalRepresentation(_ value: consuming Self?) -> Self.AtomicOptionalRepresentation
  static func decodeAtomicOptionalRepresentation(_ representation: consuming Self.AtomicOptionalRepresentation) -> Self?
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RawRepresentable where Self : Synchronization.AtomicOptionalRepresentable, Self.RawValue : Synchronization.AtomicOptionalRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicOptionalRepresentation = Self.RawValue.AtomicOptionalRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicOptionalRepresentation(_ value: consuming Self?) -> Self.RawValue.AtomicOptionalRepresentation {
     
     
     

    if let value = value {
      return RawValue.encodeAtomicOptionalRepresentation(value.rawValue)
    }

    return RawValue.encodeAtomicOptionalRepresentation(nil)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicOptionalRepresentation(_ representation: consuming Self.RawValue.AtomicOptionalRepresentation) -> Self? {
    RawValue.decodeAtomicOptionalRepresentation(representation).flatMap {
      Self(rawValue: $0)
    }
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Optional : Synchronization.AtomicRepresentable where Wrapped : Synchronization.AtomicOptionalRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Wrapped.AtomicOptionalRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Wrapped?) -> Swift.Optional<Wrapped>.AtomicRepresentation {
    Wrapped.encodeAtomicOptionalRepresentation(value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.Optional<Wrapped>.AtomicRepresentation) -> Wrapped? {
    Wrapped.decodeAtomicOptionalRepresentation(representation)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UnsafePointer : Synchronization.AtomicRepresentable where Pointee : ~Copyable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Swift.Int.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Swift.UnsafePointer<Pointee>) -> Swift.UnsafePointer<Pointee>.AtomicRepresentation {
    Int.encodeAtomicRepresentation(
      Int(bitPattern: value)
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.UnsafePointer<Pointee>.AtomicRepresentation) -> Swift.UnsafePointer<Pointee> {
    UnsafePointer<Pointee>(
      bitPattern: Int.decodeAtomicRepresentation(representation)
    )!
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UnsafePointer : Synchronization.AtomicOptionalRepresentable where Pointee : ~Copyable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicOptionalRepresentation = Swift.Int.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicOptionalRepresentation(_ value: consuming Swift.UnsafePointer<Pointee>?) -> Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation {
    Int.encodeAtomicRepresentation(
      Int(bitPattern: value)
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicOptionalRepresentation(_ representation: consuming Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation) -> Swift.UnsafePointer<Pointee>? {
    UnsafePointer<Pointee>(
      bitPattern: Int.decodeAtomicRepresentation(representation)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UnsafeMutablePointer : Synchronization.AtomicRepresentable where Pointee : ~Copyable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Swift.Int.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Swift.UnsafeMutablePointer<Pointee>) -> Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation {
    Int.encodeAtomicRepresentation(
      Int(bitPattern: value)
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation) -> Swift.UnsafeMutablePointer<Pointee> {
    UnsafeMutablePointer<Pointee>(
      bitPattern: Int.decodeAtomicRepresentation(representation)
    )!
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UnsafeMutablePointer : Synchronization.AtomicOptionalRepresentable where Pointee : ~Copyable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicOptionalRepresentation = Swift.Int.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicOptionalRepresentation(_ value: consuming Swift.UnsafeMutablePointer<Pointee>?) -> Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation {
    Int.encodeAtomicRepresentation(
      Int(bitPattern: value)
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicOptionalRepresentation(_ representation: consuming Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation) -> Swift.UnsafeMutablePointer<Pointee>? {
    UnsafeMutablePointer<Pointee>(
      bitPattern: Int.decodeAtomicRepresentation(representation)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UnsafeRawPointer : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Swift.Int.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Swift.UnsafeRawPointer) -> Swift.UnsafeRawPointer.AtomicRepresentation {
    Int.encodeAtomicRepresentation(
      Int(bitPattern: value)
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.UnsafeRawPointer.AtomicRepresentation) -> Swift.UnsafeRawPointer {
    UnsafeRawPointer(
      bitPattern: Int.decodeAtomicRepresentation(representation)
    )!
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UnsafeRawPointer : Synchronization.AtomicOptionalRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicOptionalRepresentation = Swift.Int.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicOptionalRepresentation(_ value: consuming Swift.UnsafeRawPointer?) -> Swift.UnsafeRawPointer.AtomicOptionalRepresentation {
    Int.encodeAtomicRepresentation(
      Int(bitPattern: value)
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicOptionalRepresentation(_ representation: consuming Swift.UnsafeRawPointer.AtomicOptionalRepresentation) -> Swift.UnsafeRawPointer? {
    UnsafeRawPointer(
      bitPattern: Int.decodeAtomicRepresentation(representation)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UnsafeMutableRawPointer : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Swift.Int.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Swift.UnsafeMutableRawPointer) -> Swift.UnsafeMutableRawPointer.AtomicRepresentation {
    Int.encodeAtomicRepresentation(
      Int(bitPattern: value)
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.UnsafeMutableRawPointer.AtomicRepresentation) -> Swift.UnsafeMutableRawPointer {
    UnsafeMutableRawPointer(
      bitPattern: Int.decodeAtomicRepresentation(representation)
    )!
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UnsafeMutableRawPointer : Synchronization.AtomicOptionalRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicOptionalRepresentation = Swift.Int.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicOptionalRepresentation(_ value: consuming Swift.UnsafeMutableRawPointer?) -> Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation {
    Int.encodeAtomicRepresentation(
      Int(bitPattern: value)
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicOptionalRepresentation(_ representation: consuming Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation) -> Swift.UnsafeMutableRawPointer? {
    UnsafeMutableRawPointer(
      bitPattern: Int.decodeAtomicRepresentation(representation)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Unmanaged : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Swift.Int.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Swift.Unmanaged<Instance>) -> Swift.Unmanaged<Instance>.AtomicRepresentation {
    Int.encodeAtomicRepresentation(
      Int(bitPattern: value.toOpaque())
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.Unmanaged<Instance>.AtomicRepresentation) -> Swift.Unmanaged<Instance> {
    Unmanaged<Instance>.fromOpaque(
      UnsafeRawPointer.decodeAtomicRepresentation(representation)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Unmanaged : Synchronization.AtomicOptionalRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicOptionalRepresentation = Swift.Int.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicOptionalRepresentation(_ value: consuming Swift.Unmanaged<Instance>?) -> Swift.Unmanaged<Instance>.AtomicOptionalRepresentation {
     
     
     

    if let unmanaged = value {
      return Int.encodeAtomicRepresentation(
        Int(bitPattern: unmanaged.toOpaque())
      )
    }

    return Int.AtomicRepresentation(0._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicOptionalRepresentation(_ representation: consuming Swift.Unmanaged<Instance>.AtomicOptionalRepresentation) -> Swift.Unmanaged<Instance>? {
    UnsafeRawPointer.decodeAtomicOptionalRepresentation(representation).map {
      Unmanaged.fromOpaque($0)
    }
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.OpaquePointer : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Swift.Int.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Swift.OpaquePointer) -> Swift.OpaquePointer.AtomicRepresentation {
    Int.encodeAtomicRepresentation(
      Int(bitPattern: value)
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.OpaquePointer.AtomicRepresentation) -> Swift.OpaquePointer {
    OpaquePointer(
      bitPattern: Int.decodeAtomicRepresentation(representation)
    )!
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.OpaquePointer : Synchronization.AtomicOptionalRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicOptionalRepresentation = Swift.Int.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicOptionalRepresentation(_ value: consuming Swift.OpaquePointer?) -> Swift.OpaquePointer.AtomicOptionalRepresentation {
    Int.encodeAtomicRepresentation(
      Int(bitPattern: value)
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicOptionalRepresentation(_ representation: consuming Swift.OpaquePointer.AtomicOptionalRepresentation) -> Swift.OpaquePointer? {
    OpaquePointer(
      bitPattern: Int.decodeAtomicRepresentation(representation)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.ObjectIdentifier : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Swift.Int.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Swift.ObjectIdentifier) -> Swift.ObjectIdentifier.AtomicRepresentation {
    Int.encodeAtomicRepresentation(
      Int(bitPattern: value)
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.ObjectIdentifier.AtomicRepresentation) -> Swift.ObjectIdentifier {
     
    unsafeBitCast(
      Int.decodeAtomicRepresentation(representation),
      to: ObjectIdentifier.self
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.ObjectIdentifier : Synchronization.AtomicOptionalRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicOptionalRepresentation = Swift.Int.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicOptionalRepresentation(_ value: consuming Swift.ObjectIdentifier?) -> Swift.ObjectIdentifier.AtomicOptionalRepresentation {
    Int.encodeAtomicRepresentation(
       
       
      unsafeBitCast(value, to: Int.self)
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicOptionalRepresentation(_ representation: consuming Swift.ObjectIdentifier.AtomicOptionalRepresentation) -> Swift.ObjectIdentifier? {
     
    unsafeBitCast(
      Int.decodeAtomicRepresentation(representation),
      to: ObjectIdentifier?.self
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UnsafeBufferPointer : Synchronization.AtomicRepresentable where Element : ~Copyable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization.WordPair.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Swift.UnsafeBufferPointer<Element>) -> Swift.UnsafeBufferPointer<Element>.AtomicRepresentation {
    let valueCopy = value

    return WordPair.encodeAtomicRepresentation(
      WordPair(
        first: UInt(bitPattern: valueCopy.baseAddress),
        second: UInt(truncatingIfNeeded: valueCopy.count)
      )
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.UnsafeBufferPointer<Element>.AtomicRepresentation) -> Swift.UnsafeBufferPointer<Element> {
    let wp = WordPair.decodeAtomicRepresentation(representation)

    return UnsafeBufferPointer<Element>(
      start: UnsafePointer<Element>(bitPattern: wp.first),
      count: Int(truncatingIfNeeded: wp.second)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UnsafeMutableBufferPointer : Synchronization.AtomicRepresentable where Element : ~Copyable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization.WordPair.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Swift.UnsafeMutableBufferPointer<Element>) -> Swift.UnsafeMutableBufferPointer<Element>.AtomicRepresentation {
    let valueCopy = value

    return WordPair.encodeAtomicRepresentation(
      WordPair(
        first: UInt(bitPattern: valueCopy.baseAddress),
        second: UInt(truncatingIfNeeded: valueCopy.count)
      )
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.UnsafeMutableBufferPointer<Element>.AtomicRepresentation) -> Swift.UnsafeMutableBufferPointer<Element> {
    let wp = WordPair.decodeAtomicRepresentation(representation)

    return UnsafeMutableBufferPointer<Element>(
      start: UnsafeMutablePointer<Element>(bitPattern: wp.first),
      count: Int(truncatingIfNeeded: wp.second)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UnsafeRawBufferPointer : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization.WordPair.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Swift.UnsafeRawBufferPointer) -> Swift.UnsafeRawBufferPointer.AtomicRepresentation {
    let valueCopy = value

    return WordPair.encodeAtomicRepresentation(
      WordPair(
        first: UInt(bitPattern: valueCopy.baseAddress),
        second: UInt(truncatingIfNeeded: valueCopy.count)
      )
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.UnsafeRawBufferPointer.AtomicRepresentation) -> Swift.UnsafeRawBufferPointer {
    let wp = WordPair.decodeAtomicRepresentation(representation)

    return UnsafeRawBufferPointer(
      start: UnsafeRawPointer(bitPattern: wp.first),
      count: Int(truncatingIfNeeded: wp.second)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UnsafeMutableRawBufferPointer : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization.WordPair.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Swift.UnsafeMutableRawBufferPointer) -> Swift.UnsafeMutableRawBufferPointer.AtomicRepresentation {
    let valueCopy = value

    return WordPair.encodeAtomicRepresentation(
      WordPair(
        first: UInt(bitPattern: valueCopy.baseAddress),
        second: UInt(truncatingIfNeeded: valueCopy.count)
      )
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.UnsafeMutableRawBufferPointer.AtomicRepresentation) -> Swift.UnsafeMutableRawBufferPointer {
    let wp = WordPair.decodeAtomicRepresentation(representation)

    return UnsafeMutableRawBufferPointer(
      start: UnsafeMutableRawPointer(bitPattern: wp.first),
      count: Int(truncatingIfNeeded: wp.second)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public protocol AtomicRepresentable {
  associatedtype AtomicRepresentation : Swift.BitwiseCopyable
  static func encodeAtomicRepresentation(_ value: consuming Self) -> Self.AtomicRepresentation
  static func decodeAtomicRepresentation(_ storage: consuming Self.AtomicRepresentation) -> Self
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.RawRepresentable where Self : Synchronization.AtomicRepresentable, Self.RawValue : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Self.RawValue.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Self) -> Self.RawValue.AtomicRepresentation {
    RawValue.encodeAtomicRepresentation(value.rawValue)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Self.RawValue.AtomicRepresentation) -> Self {
    Self(rawValue: RawValue.decodeAtomicRepresentation(representation))!
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Never : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Swift.Never
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Swift.Never) -> Swift.Never {}
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.Never) -> Swift.Never {}
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Duration : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization.WordPair.AtomicRepresentation
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Swift.Duration) -> Swift.Duration.AtomicRepresentation {
    WordPair.encodeAtomicRepresentation(
      WordPair(
        first: UInt(truncatingIfNeeded: value._high),
        second: UInt(truncatingIfNeeded: value._low)
      )
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.Duration.AtomicRepresentation) -> Swift.Duration {
    let wp = WordPair.decodeAtomicRepresentation(representation)

    return Duration(
      _high: Int64(truncatingIfNeeded: wp.first),
      low: UInt64(truncatingIfNeeded: wp.second)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@frozen public struct WordPair {
  public var first: Swift.UInt
  public var second: Swift.UInt
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public init(first: Swift.UInt, second: Swift.UInt) {
    self.first = first
    self.second = second
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.WordPair : Synchronization.AtomicRepresentable {
  public typealias AtomicRepresentation = Synchronization._Atomic128BitStorage
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: consuming Synchronization.WordPair) -> Synchronization.WordPair.AtomicRepresentation {
    var i128 = Builtin.zext_Int64_Int128(value.first._value)
    var high128 = Builtin.zext_Int64_Int128(value.second._value)
    let highShift = Builtin.zext_Int64_Int128(UInt(64)._value)
    high128 = Builtin.shl_Int128(high128, highShift)
    i128 = Builtin.or_Int128(i128, high128)

    return AtomicRepresentation(i128)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Synchronization.WordPair.AtomicRepresentation) -> Synchronization.WordPair {
    let highShift = Builtin.zext_Int64_Int128(UInt(64)._value)
    let high128 = Builtin.lshr_Int128(representation._storage, highShift)
    let high = Builtin.trunc_Int128_Int64(high128)
    let low = Builtin.trunc_Int128_Int64(representation._storage)

    return WordPair(first: UInt(low), second: UInt(high))
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.WordPair : Swift.Equatable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func == (lhs: Synchronization.WordPair, rhs: Synchronization.WordPair) -> Swift.Bool {
    lhs.first == rhs.first && lhs.second == rhs.second
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.WordPair : Swift.Hashable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(first)
    hasher.combine(second)
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 15.4, iOS 18.4, watchOS 11.4, tvOS 18.4, visionOS 2.4, *)
extension Synchronization.WordPair : Swift.Comparable {
  @available(macOS 15.4, iOS 18.4, watchOS 11.4, tvOS 18.4, visionOS 2.4, *)
  @_alwaysEmitIntoClient @_transparent public static func < (lhs: Synchronization.WordPair, rhs: Synchronization.WordPair) -> Swift.Bool {
    (lhs.first, lhs.second) < (rhs.first, rhs.second)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.WordPair : Swift.CustomStringConvertible {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public var description: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.WordPair : Swift.CustomDebugStringConvertible {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public var debugDescription: Swift.String {
    get
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.WordPair : Swift.Sendable {
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@usableFromInline
@frozen @_rawLayout(like: Value) internal struct _Cell<Value> : ~Swift.Copyable where Value : ~Copyable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent internal var _address: Swift.UnsafeMutablePointer<Value> {
    @_transparent get {
    UnsafeMutablePointer<Value>(_rawAddress)
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent internal var _rawAddress: Builtin.RawPointer {
    @_transparent get {
    Builtin.addressOfRawLayout(self)
  }
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent internal init(_ initialValue: consuming Value) {
    _address.initialize(to: initialValue)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @inlinable deinit {
    _address.deinitialize(count: 1)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@frozen @_staticExclusiveOnly public struct _MutexHandle : ~Swift.Copyable {
  @usableFromInline
  internal let value: Synchronization._Cell<Darwin.os_unfair_lock>
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public init() {
    value = _Cell(os_unfair_lock())
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent internal borrowing func _lock() {
    os_unfair_lock_lock(value._address)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent internal borrowing func _tryLock() -> Swift.Bool {
    os_unfair_lock_trylock(value._address)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent internal borrowing func _unlock() {
    os_unfair_lock_unlock(value._address)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@frozen @_staticExclusiveOnly public struct Mutex<Value> : ~Swift.Copyable where Value : ~Copyable {
  @usableFromInline
  internal let handle: Synchronization._MutexHandle = _MutexHandle()
  @usableFromInline
  internal let value: Synchronization._Cell<Value>
  #if compiler(>=5.3) && $SendingArgsAndResults
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public init(_ initialValue: consuming sending Value) {
    value = _Cell(initialValue)
  }
  #else
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public init(_ initialValue: consuming Value) {
    value = _Cell(initialValue)
  }
  #endif
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Mutex : @unchecked Swift.Sendable where Value : ~Copyable {
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Mutex where Value : ~Copyable {
  #if compiler(>=5.3) && $SendingArgsAndResults
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public borrowing func withLock<Result, E>(_ body: (inout sending Value) throws(E) -> sending Result) throws(E) -> sending Result where E : Swift.Error, Result : ~Copyable {
    handle._lock()

    defer {
      handle._unlock()
    }

    return try body(&value._address.pointee)
  }
  #else
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public borrowing func withLock<Result, E>(_ body: (inout Value) throws(E) -> Result) throws(E) -> Result where E : Swift.Error, Result : ~Copyable {
    handle._lock()

    defer {
      handle._unlock()
    }

    return try body(&value._address.pointee)
  }
  #endif
  #if compiler(>=5.3) && $SendingArgsAndResults
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public borrowing func withLockIfAvailable<Result, E>(_ body: (inout sending Value) throws(E) -> sending Result) throws(E) -> sending Result? where E : Swift.Error, Result : ~Copyable {
    guard handle._tryLock() else {
      return nil
    }

    defer {
      handle._unlock()
    }

    return try body(&value._address.pointee)
  }
  #else
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public borrowing func withLockIfAvailable<Result, E>(_ body: (inout Value) throws(E) -> Result) throws(E) -> Result? where E : Swift.Error, Result : ~Copyable {
    guard handle._tryLock() else {
      return nil
    }

    defer {
      handle._unlock()
    }

    return try body(&value._address.pointee)
  }
  #endif
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Mutex where Value == () {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public borrowing func _unsafeLock() {
    handle._lock()
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public borrowing func _unsafeTryLock() -> Swift.Bool {
    handle._tryLock()
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public borrowing func _unsafeUnlock() {
    handle._unlock()
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization._MutexHandle {
  #if compiler(>=5.3) && $AllowUnsafeAttribute
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent @unsafe public borrowing func unsafeLock() {
    _lock()
  }
  #else
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public borrowing func unsafeLock() {
    _lock()
  }
  #endif
  #if compiler(>=5.3) && $AllowUnsafeAttribute
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent @unsafe public borrowing func unsafeTryLock() -> Swift.Bool {
    _tryLock()
  }
  #else
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public borrowing func unsafeTryLock() -> Swift.Bool {
    _tryLock()
  }
  #endif
  #if compiler(>=5.3) && $AllowUnsafeAttribute
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent @unsafe public borrowing func unsafeUnlock() {
    _unlock()
  }
  #else
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public borrowing func unsafeUnlock() {
    _unlock()
  }
  #endif
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization._Atomic64BitStorage
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: borrowing Swift.Int) -> Swift.Int.AtomicRepresentation {
    AtomicRepresentation(value._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.Int.AtomicRepresentation) -> Swift.Int {
    Int(representation._storage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value == Swift.Int {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingAdd(_ operand: Swift.Int, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int, newValue: Swift.Int) {
    let original = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_add_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
      Builtin.atomicrmw_add_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
      Builtin.atomicrmw_add_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_add_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_add_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int(original),
 
      newValue: Int(original) &+ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingSubtract(_ operand: Swift.Int, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int, newValue: Swift.Int) {
    let original = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_sub_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
      Builtin.atomicrmw_sub_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
      Builtin.atomicrmw_sub_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_sub_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_sub_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int(original),
 
      newValue: Int(original) &- operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseAnd(_ operand: Swift.Int, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int, newValue: Swift.Int) {
    let original = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_and_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
      Builtin.atomicrmw_and_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
      Builtin.atomicrmw_and_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_and_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_and_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int(original),
 
      newValue: Int(original) & operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseOr(_ operand: Swift.Int, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int, newValue: Swift.Int) {
    let original = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_or_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
      Builtin.atomicrmw_or_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
      Builtin.atomicrmw_or_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_or_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_or_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int(original),
 
      newValue: Int(original) | operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseXor(_ operand: Swift.Int, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int, newValue: Swift.Int) {
    let original = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_xor_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
      Builtin.atomicrmw_xor_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
      Builtin.atomicrmw_xor_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_xor_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_xor_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int(original),
 
      newValue: Int(original) ^ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func min(_ operand: Swift.Int, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int, newValue: Swift.Int) {
    let original = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_min_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
      Builtin.atomicrmw_min_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
      Builtin.atomicrmw_min_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_min_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_min_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int(original),
 
      newValue: Swift.min(Int(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func max(_ operand: Swift.Int, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int, newValue: Swift.Int) {
    let original = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_max_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
      Builtin.atomicrmw_max_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
      Builtin.atomicrmw_max_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_max_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_max_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int(original),
 
      newValue: Swift.max(Int(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func add(_ operand: Swift.Int, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int, newValue: Swift.Int) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: Int

    repeat {
      new = result.original + operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func subtract(_ operand: Swift.Int, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int, newValue: Swift.Int) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: Int

    repeat {
      new = result.original - operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int8 : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization._Atomic8BitStorage
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: borrowing Swift.Int8) -> Swift.Int8.AtomicRepresentation {
    AtomicRepresentation(value._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.Int8.AtomicRepresentation) -> Swift.Int8 {
    Int8(representation._storage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value == Swift.Int8 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingAdd(_ operand: Swift.Int8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int8, newValue: Swift.Int8) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_add_monotonic_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_add_acquire_Int8(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_add_release_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_add_acqrel_Int8(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_add_seqcst_Int8(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int8(original),
 
      newValue: Int8(original) &+ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingSubtract(_ operand: Swift.Int8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int8, newValue: Swift.Int8) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_sub_monotonic_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_sub_acquire_Int8(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_sub_release_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_sub_acqrel_Int8(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_sub_seqcst_Int8(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int8(original),
 
      newValue: Int8(original) &- operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseAnd(_ operand: Swift.Int8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int8, newValue: Swift.Int8) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_and_monotonic_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_and_acquire_Int8(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_and_release_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_and_acqrel_Int8(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_and_seqcst_Int8(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int8(original),
 
      newValue: Int8(original) & operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseOr(_ operand: Swift.Int8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int8, newValue: Swift.Int8) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_or_monotonic_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_or_acquire_Int8(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_or_release_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_or_acqrel_Int8(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_or_seqcst_Int8(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int8(original),
 
      newValue: Int8(original) | operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseXor(_ operand: Swift.Int8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int8, newValue: Swift.Int8) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_xor_monotonic_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_xor_acquire_Int8(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_xor_release_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_xor_acqrel_Int8(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_xor_seqcst_Int8(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int8(original),
 
      newValue: Int8(original) ^ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func min(_ operand: Swift.Int8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int8, newValue: Swift.Int8) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_min_monotonic_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_min_acquire_Int8(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_min_release_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_min_acqrel_Int8(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_min_seqcst_Int8(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int8(original),
 
      newValue: Swift.min(Int8(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func max(_ operand: Swift.Int8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int8, newValue: Swift.Int8) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_max_monotonic_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_max_acquire_Int8(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_max_release_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_max_acqrel_Int8(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_max_seqcst_Int8(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int8(original),
 
      newValue: Swift.max(Int8(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func add(_ operand: Swift.Int8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int8, newValue: Swift.Int8) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: Int8

    repeat {
      new = result.original + operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func subtract(_ operand: Swift.Int8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int8, newValue: Swift.Int8) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: Int8

    repeat {
      new = result.original - operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int16 : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization._Atomic16BitStorage
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: borrowing Swift.Int16) -> Swift.Int16.AtomicRepresentation {
    AtomicRepresentation(value._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.Int16.AtomicRepresentation) -> Swift.Int16 {
    Int16(representation._storage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value == Swift.Int16 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingAdd(_ operand: Swift.Int16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int16, newValue: Swift.Int16) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_add_monotonic_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_add_acquire_Int16(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_add_release_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_add_acqrel_Int16(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_add_seqcst_Int16(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int16(original),
 
      newValue: Int16(original) &+ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingSubtract(_ operand: Swift.Int16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int16, newValue: Swift.Int16) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_sub_monotonic_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_sub_acquire_Int16(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_sub_release_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_sub_acqrel_Int16(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_sub_seqcst_Int16(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int16(original),
 
      newValue: Int16(original) &- operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseAnd(_ operand: Swift.Int16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int16, newValue: Swift.Int16) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_and_monotonic_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_and_acquire_Int16(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_and_release_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_and_acqrel_Int16(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_and_seqcst_Int16(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int16(original),
 
      newValue: Int16(original) & operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseOr(_ operand: Swift.Int16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int16, newValue: Swift.Int16) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_or_monotonic_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_or_acquire_Int16(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_or_release_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_or_acqrel_Int16(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_or_seqcst_Int16(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int16(original),
 
      newValue: Int16(original) | operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseXor(_ operand: Swift.Int16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int16, newValue: Swift.Int16) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_xor_monotonic_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_xor_acquire_Int16(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_xor_release_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_xor_acqrel_Int16(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_xor_seqcst_Int16(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int16(original),
 
      newValue: Int16(original) ^ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func min(_ operand: Swift.Int16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int16, newValue: Swift.Int16) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_min_monotonic_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_min_acquire_Int16(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_min_release_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_min_acqrel_Int16(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_min_seqcst_Int16(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int16(original),
 
      newValue: Swift.min(Int16(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func max(_ operand: Swift.Int16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int16, newValue: Swift.Int16) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_max_monotonic_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_max_acquire_Int16(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_max_release_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_max_acqrel_Int16(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_max_seqcst_Int16(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int16(original),
 
      newValue: Swift.max(Int16(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func add(_ operand: Swift.Int16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int16, newValue: Swift.Int16) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: Int16

    repeat {
      new = result.original + operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func subtract(_ operand: Swift.Int16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int16, newValue: Swift.Int16) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: Int16

    repeat {
      new = result.original - operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int32 : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization._Atomic32BitStorage
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: borrowing Swift.Int32) -> Swift.Int32.AtomicRepresentation {
    AtomicRepresentation(value._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.Int32.AtomicRepresentation) -> Swift.Int32 {
    Int32(representation._storage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value == Swift.Int32 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingAdd(_ operand: Swift.Int32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int32, newValue: Swift.Int32) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_add_monotonic_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_add_acquire_Int32(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_add_release_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_add_acqrel_Int32(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_add_seqcst_Int32(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int32(original),
 
      newValue: Int32(original) &+ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingSubtract(_ operand: Swift.Int32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int32, newValue: Swift.Int32) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_sub_monotonic_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_sub_acquire_Int32(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_sub_release_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_sub_acqrel_Int32(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_sub_seqcst_Int32(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int32(original),
 
      newValue: Int32(original) &- operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseAnd(_ operand: Swift.Int32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int32, newValue: Swift.Int32) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_and_monotonic_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_and_acquire_Int32(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_and_release_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_and_acqrel_Int32(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_and_seqcst_Int32(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int32(original),
 
      newValue: Int32(original) & operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseOr(_ operand: Swift.Int32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int32, newValue: Swift.Int32) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_or_monotonic_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_or_acquire_Int32(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_or_release_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_or_acqrel_Int32(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_or_seqcst_Int32(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int32(original),
 
      newValue: Int32(original) | operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseXor(_ operand: Swift.Int32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int32, newValue: Swift.Int32) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_xor_monotonic_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_xor_acquire_Int32(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_xor_release_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_xor_acqrel_Int32(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_xor_seqcst_Int32(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int32(original),
 
      newValue: Int32(original) ^ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func min(_ operand: Swift.Int32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int32, newValue: Swift.Int32) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_min_monotonic_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_min_acquire_Int32(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_min_release_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_min_acqrel_Int32(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_min_seqcst_Int32(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int32(original),
 
      newValue: Swift.min(Int32(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func max(_ operand: Swift.Int32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int32, newValue: Swift.Int32) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_max_monotonic_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_max_acquire_Int32(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_max_release_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_max_acqrel_Int32(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_max_seqcst_Int32(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int32(original),
 
      newValue: Swift.max(Int32(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func add(_ operand: Swift.Int32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int32, newValue: Swift.Int32) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: Int32

    repeat {
      new = result.original + operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func subtract(_ operand: Swift.Int32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int32, newValue: Swift.Int32) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: Int32

    repeat {
      new = result.original - operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int64 : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization._Atomic64BitStorage
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: borrowing Swift.Int64) -> Swift.Int64.AtomicRepresentation {
    AtomicRepresentation(value._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.Int64.AtomicRepresentation) -> Swift.Int64 {
    Int64(representation._storage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value == Swift.Int64 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingAdd(_ operand: Swift.Int64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int64, newValue: Swift.Int64) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_add_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_add_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_add_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_add_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_add_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int64(original),
 
      newValue: Int64(original) &+ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingSubtract(_ operand: Swift.Int64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int64, newValue: Swift.Int64) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_sub_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_sub_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_sub_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_sub_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_sub_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int64(original),
 
      newValue: Int64(original) &- operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseAnd(_ operand: Swift.Int64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int64, newValue: Swift.Int64) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_and_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_and_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_and_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_and_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_and_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int64(original),
 
      newValue: Int64(original) & operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseOr(_ operand: Swift.Int64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int64, newValue: Swift.Int64) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_or_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_or_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_or_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_or_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_or_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int64(original),
 
      newValue: Int64(original) | operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseXor(_ operand: Swift.Int64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int64, newValue: Swift.Int64) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_xor_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_xor_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_xor_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_xor_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_xor_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int64(original),
 
      newValue: Int64(original) ^ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func min(_ operand: Swift.Int64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int64, newValue: Swift.Int64) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_min_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_min_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_min_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_min_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_min_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int64(original),
 
      newValue: Swift.min(Int64(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func max(_ operand: Swift.Int64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int64, newValue: Swift.Int64) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_max_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_max_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_max_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_max_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_max_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int64(original),
 
      newValue: Swift.max(Int64(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func add(_ operand: Swift.Int64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int64, newValue: Swift.Int64) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: Int64

    repeat {
      new = result.original + operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func subtract(_ operand: Swift.Int64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int64, newValue: Swift.Int64) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: Int64

    repeat {
      new = result.original - operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.Int128 : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization._Atomic128BitStorage
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: borrowing Swift.Int128) -> Swift.Int128.AtomicRepresentation {
    AtomicRepresentation(value._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.Int128.AtomicRepresentation) -> Swift.Int128 {
    Int128(representation._storage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value == Swift.Int128 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingAdd(_ operand: Swift.Int128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int128, newValue: Swift.Int128) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_add_monotonic_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_add_acquire_Int128(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_add_release_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_add_acqrel_Int128(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_add_seqcst_Int128(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int128(original),
 
      newValue: Int128(original) &+ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingSubtract(_ operand: Swift.Int128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int128, newValue: Swift.Int128) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_sub_monotonic_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_sub_acquire_Int128(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_sub_release_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_sub_acqrel_Int128(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_sub_seqcst_Int128(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int128(original),
 
      newValue: Int128(original) &- operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseAnd(_ operand: Swift.Int128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int128, newValue: Swift.Int128) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_and_monotonic_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_and_acquire_Int128(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_and_release_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_and_acqrel_Int128(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_and_seqcst_Int128(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int128(original),
 
      newValue: Int128(original) & operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseOr(_ operand: Swift.Int128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int128, newValue: Swift.Int128) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_or_monotonic_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_or_acquire_Int128(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_or_release_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_or_acqrel_Int128(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_or_seqcst_Int128(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int128(original),
 
      newValue: Int128(original) | operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseXor(_ operand: Swift.Int128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int128, newValue: Swift.Int128) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_xor_monotonic_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_xor_acquire_Int128(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_xor_release_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_xor_acqrel_Int128(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_xor_seqcst_Int128(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int128(original),
 
      newValue: Int128(original) ^ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func min(_ operand: Swift.Int128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int128, newValue: Swift.Int128) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_min_monotonic_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_min_acquire_Int128(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_min_release_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_min_acqrel_Int128(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_min_seqcst_Int128(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int128(original),
 
      newValue: Swift.min(Int128(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func max(_ operand: Swift.Int128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int128, newValue: Swift.Int128) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_max_monotonic_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_max_acquire_Int128(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_max_release_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_max_acqrel_Int128(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_max_seqcst_Int128(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: Int128(original),
 
      newValue: Swift.max(Int128(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func add(_ operand: Swift.Int128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int128, newValue: Swift.Int128) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: Int128

    repeat {
      new = result.original + operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func subtract(_ operand: Swift.Int128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.Int128, newValue: Swift.Int128) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: Int128

    repeat {
      new = result.original - operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization._Atomic64BitStorage
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: borrowing Swift.UInt) -> Swift.UInt.AtomicRepresentation {
    AtomicRepresentation(value._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.UInt.AtomicRepresentation) -> Swift.UInt {
    UInt(representation._storage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value == Swift.UInt {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingAdd(_ operand: Swift.UInt, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt, newValue: Swift.UInt) {
    let original = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_add_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
      Builtin.atomicrmw_add_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
      Builtin.atomicrmw_add_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_add_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_add_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt(original),
 
      newValue: UInt(original) &+ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingSubtract(_ operand: Swift.UInt, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt, newValue: Swift.UInt) {
    let original = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_sub_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
      Builtin.atomicrmw_sub_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
      Builtin.atomicrmw_sub_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_sub_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_sub_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt(original),
 
      newValue: UInt(original) &- operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseAnd(_ operand: Swift.UInt, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt, newValue: Swift.UInt) {
    let original = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_and_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
      Builtin.atomicrmw_and_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
      Builtin.atomicrmw_and_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_and_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_and_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt(original),
 
      newValue: UInt(original) & operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseOr(_ operand: Swift.UInt, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt, newValue: Swift.UInt) {
    let original = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_or_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
      Builtin.atomicrmw_or_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
      Builtin.atomicrmw_or_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_or_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_or_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt(original),
 
      newValue: UInt(original) | operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseXor(_ operand: Swift.UInt, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt, newValue: Swift.UInt) {
    let original = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_xor_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
      Builtin.atomicrmw_xor_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
      Builtin.atomicrmw_xor_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_xor_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_xor_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt(original),
 
      newValue: UInt(original) ^ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func min(_ operand: Swift.UInt, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt, newValue: Swift.UInt) {
    let original = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_min_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
      Builtin.atomicrmw_min_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
      Builtin.atomicrmw_min_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_min_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_min_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt(original),
 
      newValue: Swift.min(UInt(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func max(_ operand: Swift.UInt, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt, newValue: Swift.UInt) {
    let original = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_max_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
      Builtin.atomicrmw_max_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
      Builtin.atomicrmw_max_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_max_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_max_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt(original),
 
      newValue: Swift.max(UInt(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func add(_ operand: Swift.UInt, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt, newValue: Swift.UInt) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: UInt

    repeat {
      new = result.original + operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func subtract(_ operand: Swift.UInt, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt, newValue: Swift.UInt) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: UInt

    repeat {
      new = result.original - operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt8 : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization._Atomic8BitStorage
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: borrowing Swift.UInt8) -> Swift.UInt8.AtomicRepresentation {
    AtomicRepresentation(value._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.UInt8.AtomicRepresentation) -> Swift.UInt8 {
    UInt8(representation._storage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value == Swift.UInt8 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingAdd(_ operand: Swift.UInt8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt8, newValue: Swift.UInt8) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_add_monotonic_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_add_acquire_Int8(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_add_release_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_add_acqrel_Int8(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_add_seqcst_Int8(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt8(original),
 
      newValue: UInt8(original) &+ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingSubtract(_ operand: Swift.UInt8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt8, newValue: Swift.UInt8) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_sub_monotonic_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_sub_acquire_Int8(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_sub_release_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_sub_acqrel_Int8(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_sub_seqcst_Int8(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt8(original),
 
      newValue: UInt8(original) &- operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseAnd(_ operand: Swift.UInt8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt8, newValue: Swift.UInt8) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_and_monotonic_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_and_acquire_Int8(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_and_release_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_and_acqrel_Int8(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_and_seqcst_Int8(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt8(original),
 
      newValue: UInt8(original) & operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseOr(_ operand: Swift.UInt8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt8, newValue: Swift.UInt8) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_or_monotonic_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_or_acquire_Int8(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_or_release_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_or_acqrel_Int8(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_or_seqcst_Int8(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt8(original),
 
      newValue: UInt8(original) | operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseXor(_ operand: Swift.UInt8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt8, newValue: Swift.UInt8) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_xor_monotonic_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_xor_acquire_Int8(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_xor_release_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_xor_acqrel_Int8(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_xor_seqcst_Int8(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt8(original),
 
      newValue: UInt8(original) ^ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func min(_ operand: Swift.UInt8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt8, newValue: Swift.UInt8) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_min_monotonic_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_min_acquire_Int8(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_min_release_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_min_acqrel_Int8(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_min_seqcst_Int8(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt8(original),
 
      newValue: Swift.min(UInt8(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func max(_ operand: Swift.UInt8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt8, newValue: Swift.UInt8) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_max_monotonic_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_max_acquire_Int8(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_max_release_Int8(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_max_acqrel_Int8(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_max_seqcst_Int8(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt8(original),
 
      newValue: Swift.max(UInt8(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func add(_ operand: Swift.UInt8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt8, newValue: Swift.UInt8) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: UInt8

    repeat {
      new = result.original + operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func subtract(_ operand: Swift.UInt8, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt8, newValue: Swift.UInt8) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: UInt8

    repeat {
      new = result.original - operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt16 : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization._Atomic16BitStorage
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: borrowing Swift.UInt16) -> Swift.UInt16.AtomicRepresentation {
    AtomicRepresentation(value._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.UInt16.AtomicRepresentation) -> Swift.UInt16 {
    UInt16(representation._storage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value == Swift.UInt16 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingAdd(_ operand: Swift.UInt16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt16, newValue: Swift.UInt16) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_add_monotonic_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_add_acquire_Int16(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_add_release_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_add_acqrel_Int16(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_add_seqcst_Int16(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt16(original),
 
      newValue: UInt16(original) &+ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingSubtract(_ operand: Swift.UInt16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt16, newValue: Swift.UInt16) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_sub_monotonic_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_sub_acquire_Int16(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_sub_release_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_sub_acqrel_Int16(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_sub_seqcst_Int16(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt16(original),
 
      newValue: UInt16(original) &- operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseAnd(_ operand: Swift.UInt16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt16, newValue: Swift.UInt16) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_and_monotonic_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_and_acquire_Int16(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_and_release_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_and_acqrel_Int16(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_and_seqcst_Int16(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt16(original),
 
      newValue: UInt16(original) & operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseOr(_ operand: Swift.UInt16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt16, newValue: Swift.UInt16) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_or_monotonic_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_or_acquire_Int16(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_or_release_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_or_acqrel_Int16(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_or_seqcst_Int16(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt16(original),
 
      newValue: UInt16(original) | operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseXor(_ operand: Swift.UInt16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt16, newValue: Swift.UInt16) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_xor_monotonic_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_xor_acquire_Int16(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_xor_release_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_xor_acqrel_Int16(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_xor_seqcst_Int16(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt16(original),
 
      newValue: UInt16(original) ^ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func min(_ operand: Swift.UInt16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt16, newValue: Swift.UInt16) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_min_monotonic_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_min_acquire_Int16(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_min_release_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_min_acqrel_Int16(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_min_seqcst_Int16(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt16(original),
 
      newValue: Swift.min(UInt16(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func max(_ operand: Swift.UInt16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt16, newValue: Swift.UInt16) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_max_monotonic_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_max_acquire_Int16(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_max_release_Int16(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_max_acqrel_Int16(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_max_seqcst_Int16(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt16(original),
 
      newValue: Swift.max(UInt16(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func add(_ operand: Swift.UInt16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt16, newValue: Swift.UInt16) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: UInt16

    repeat {
      new = result.original + operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func subtract(_ operand: Swift.UInt16, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt16, newValue: Swift.UInt16) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: UInt16

    repeat {
      new = result.original - operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt32 : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization._Atomic32BitStorage
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: borrowing Swift.UInt32) -> Swift.UInt32.AtomicRepresentation {
    AtomicRepresentation(value._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.UInt32.AtomicRepresentation) -> Swift.UInt32 {
    UInt32(representation._storage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value == Swift.UInt32 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingAdd(_ operand: Swift.UInt32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt32, newValue: Swift.UInt32) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_add_monotonic_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_add_acquire_Int32(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_add_release_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_add_acqrel_Int32(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_add_seqcst_Int32(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt32(original),
 
      newValue: UInt32(original) &+ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingSubtract(_ operand: Swift.UInt32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt32, newValue: Swift.UInt32) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_sub_monotonic_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_sub_acquire_Int32(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_sub_release_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_sub_acqrel_Int32(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_sub_seqcst_Int32(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt32(original),
 
      newValue: UInt32(original) &- operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseAnd(_ operand: Swift.UInt32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt32, newValue: Swift.UInt32) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_and_monotonic_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_and_acquire_Int32(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_and_release_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_and_acqrel_Int32(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_and_seqcst_Int32(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt32(original),
 
      newValue: UInt32(original) & operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseOr(_ operand: Swift.UInt32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt32, newValue: Swift.UInt32) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_or_monotonic_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_or_acquire_Int32(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_or_release_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_or_acqrel_Int32(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_or_seqcst_Int32(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt32(original),
 
      newValue: UInt32(original) | operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseXor(_ operand: Swift.UInt32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt32, newValue: Swift.UInt32) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_xor_monotonic_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_xor_acquire_Int32(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_xor_release_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_xor_acqrel_Int32(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_xor_seqcst_Int32(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt32(original),
 
      newValue: UInt32(original) ^ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func min(_ operand: Swift.UInt32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt32, newValue: Swift.UInt32) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_min_monotonic_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_min_acquire_Int32(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_min_release_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_min_acqrel_Int32(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_min_seqcst_Int32(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt32(original),
 
      newValue: Swift.min(UInt32(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func max(_ operand: Swift.UInt32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt32, newValue: Swift.UInt32) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_max_monotonic_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_max_acquire_Int32(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_max_release_Int32(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_max_acqrel_Int32(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_max_seqcst_Int32(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt32(original),
 
      newValue: Swift.max(UInt32(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func add(_ operand: Swift.UInt32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt32, newValue: Swift.UInt32) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: UInt32

    repeat {
      new = result.original + operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func subtract(_ operand: Swift.UInt32, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt32, newValue: Swift.UInt32) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: UInt32

    repeat {
      new = result.original - operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt64 : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization._Atomic64BitStorage
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: borrowing Swift.UInt64) -> Swift.UInt64.AtomicRepresentation {
    AtomicRepresentation(value._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.UInt64.AtomicRepresentation) -> Swift.UInt64 {
    UInt64(representation._storage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value == Swift.UInt64 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingAdd(_ operand: Swift.UInt64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt64, newValue: Swift.UInt64) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_add_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_add_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_add_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_add_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_add_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt64(original),
 
      newValue: UInt64(original) &+ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingSubtract(_ operand: Swift.UInt64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt64, newValue: Swift.UInt64) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_sub_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_sub_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_sub_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_sub_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_sub_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt64(original),
 
      newValue: UInt64(original) &- operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseAnd(_ operand: Swift.UInt64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt64, newValue: Swift.UInt64) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_and_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_and_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_and_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_and_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_and_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt64(original),
 
      newValue: UInt64(original) & operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseOr(_ operand: Swift.UInt64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt64, newValue: Swift.UInt64) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_or_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_or_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_or_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_or_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_or_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt64(original),
 
      newValue: UInt64(original) | operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseXor(_ operand: Swift.UInt64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt64, newValue: Swift.UInt64) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_xor_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_xor_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_xor_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_xor_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_xor_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt64(original),
 
      newValue: UInt64(original) ^ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func min(_ operand: Swift.UInt64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt64, newValue: Swift.UInt64) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_min_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_min_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_min_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_min_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_min_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt64(original),
 
      newValue: Swift.min(UInt64(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func max(_ operand: Swift.UInt64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt64, newValue: Swift.UInt64) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_max_monotonic_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_max_acquire_Int64(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_max_release_Int64(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_max_acqrel_Int64(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_max_seqcst_Int64(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt64(original),
 
      newValue: Swift.max(UInt64(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func add(_ operand: Swift.UInt64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt64, newValue: Swift.UInt64) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: UInt64

    repeat {
      new = result.original + operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func subtract(_ operand: Swift.UInt64, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt64, newValue: Swift.UInt64) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: UInt64

    repeat {
      new = result.original - operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Swift.UInt128 : Synchronization.AtomicRepresentable {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  public typealias AtomicRepresentation = Synchronization._Atomic128BitStorage
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func encodeAtomicRepresentation(_ value: borrowing Swift.UInt128) -> Swift.UInt128.AtomicRepresentation {
    AtomicRepresentation(value._value)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public static func decodeAtomicRepresentation(_ representation: consuming Swift.UInt128.AtomicRepresentation) -> Swift.UInt128 {
    UInt128(representation._storage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value == Swift.UInt128 {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingAdd(_ operand: Swift.UInt128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt128, newValue: Swift.UInt128) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_add_monotonic_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_add_acquire_Int128(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_add_release_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_add_acqrel_Int128(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_add_seqcst_Int128(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt128(original),
 
      newValue: UInt128(original) &+ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func wrappingSubtract(_ operand: Swift.UInt128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt128, newValue: Swift.UInt128) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_sub_monotonic_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_sub_acquire_Int128(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_sub_release_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_sub_acqrel_Int128(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_sub_seqcst_Int128(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt128(original),
 
      newValue: UInt128(original) &- operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseAnd(_ operand: Swift.UInt128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt128, newValue: Swift.UInt128) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_and_monotonic_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_and_acquire_Int128(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_and_release_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_and_acqrel_Int128(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_and_seqcst_Int128(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt128(original),
 
      newValue: UInt128(original) & operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseOr(_ operand: Swift.UInt128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt128, newValue: Swift.UInt128) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_or_monotonic_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_or_acquire_Int128(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_or_release_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_or_acqrel_Int128(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_or_seqcst_Int128(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt128(original),
 
      newValue: UInt128(original) | operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func bitwiseXor(_ operand: Swift.UInt128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt128, newValue: Swift.UInt128) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_xor_monotonic_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_xor_acquire_Int128(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_xor_release_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_xor_acqrel_Int128(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_xor_seqcst_Int128(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt128(original),
 
      newValue: UInt128(original) ^ operand
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func min(_ operand: Swift.UInt128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt128, newValue: Swift.UInt128) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_min_monotonic_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_min_acquire_Int128(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_min_release_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_min_acqrel_Int128(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_min_seqcst_Int128(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt128(original),
 
      newValue: Swift.min(UInt128(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func max(_ operand: Swift.UInt128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt128, newValue: Swift.UInt128) {
    let original = switch ordering {
 
    case .relaxed:
 
      Builtin.atomicrmw_max_monotonic_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiring:
 
      Builtin.atomicrmw_max_acquire_Int128(
        _rawAddress,
        operand._value
      )
 
    case .releasing:
 
      Builtin.atomicrmw_max_release_Int128(
        _rawAddress,
        operand._value
      )
 
    case .acquiringAndReleasing:
 
      Builtin.atomicrmw_max_acqrel_Int128(
        _rawAddress,
        operand._value
      )
 
    case .sequentiallyConsistent:
 
      Builtin.atomicrmw_max_seqcst_Int128(
        _rawAddress,
        operand._value
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      oldValue: UInt128(original),
 
      newValue: Swift.max(UInt128(original), operand)
 
    )
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func add(_ operand: Swift.UInt128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt128, newValue: Swift.UInt128) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: UInt128

    repeat {
      new = result.original + operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func subtract(_ operand: Swift.UInt128, ordering: Synchronization.AtomicUpdateOrdering) -> (oldValue: Swift.UInt128, newValue: Swift.UInt128) {
    var result = (
      exchanged: false,
      original: load(ordering: .relaxed)
    )
    var new: UInt128

    repeat {
      new = result.original - operand

      result = weakCompareExchange(
        expected: result.original,
        desired: new,
        ordering: ordering
      )
    } while !result.exchanged

    return (oldValue: result.original, newValue: new)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@frozen @_alignment(1) public struct _Atomic8BitStorage {
  public var _storage: Builtin.Int8
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public init(_ _builtin: Builtin.Int8) {
    self._storage = _builtin
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic8BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func load(ordering: Synchronization.AtomicLoadOrdering) -> Value {
    let result = switch ordering {
 
    case .relaxed:
      Builtin.atomicload_monotonic_Int8(_rawAddress)
 
    case .acquiring:
      Builtin.atomicload_acquire_Int8(_rawAddress)
 
    case .sequentiallyConsistent:
      Builtin.atomicload_seqcst_Int8(_rawAddress)
 

    default:
      Builtin.unreachable()
    }

    return Value.decodeAtomicRepresentation(Value.AtomicRepresentation(result))
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic8BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func store(_ desired: consuming Value, ordering: Synchronization.AtomicStoreOrdering) {
    switch ordering {
 
    case .relaxed:
      Builtin.atomicstore_monotonic_Int8(
        _rawAddress,
        Value.encodeAtomicRepresentation(desired)._storage
      )
 
    case .releasing:
      Builtin.atomicstore_release_Int8(
        _rawAddress,
        Value.encodeAtomicRepresentation(desired)._storage
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicstore_seqcst_Int8(
        _rawAddress,
        Value.encodeAtomicRepresentation(desired)._storage
      )
 

    default:
      Builtin.unreachable()
    }
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic8BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func exchange(_ desired: consuming Value, ordering: Synchronization.AtomicUpdateOrdering) -> Value {
    let desired = Value.encodeAtomicRepresentation(desired)._storage

    let result = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_xchg_monotonic_Int8(_rawAddress, desired)
 
    case .acquiring:
      Builtin.atomicrmw_xchg_acquire_Int8(_rawAddress, desired)
 
    case .releasing:
      Builtin.atomicrmw_xchg_release_Int8(_rawAddress, desired)
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_xchg_acqrel_Int8(_rawAddress, desired)
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_xchg_seqcst_Int8(_rawAddress, desired)
 

    default:
      Builtin.unreachable()
    }

    let atomicStorage = Value.AtomicRepresentation(result)

    return Value.decodeAtomicRepresentation(atomicStorage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic8BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func compareExchange(expected: consuming Value, desired: consuming Value, ordering: Synchronization.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    compareExchange(
      expected: expected,
      desired: desired,
      successOrdering: ordering,
      failureOrdering: ._failureOrdering(for: ordering)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic8BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func compareExchange(expected: consuming Value, desired: consuming Value, successOrdering: Synchronization.AtomicUpdateOrdering, failureOrdering: Synchronization.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    let expected = Value.encodeAtomicRepresentation(expected)._storage
    let desired = Value.encodeAtomicRepresentation(desired)._storage

    let (ov, won) = switch (successOrdering, failureOrdering) {
 
    case (.relaxed, .relaxed):
      Builtin.cmpxchg_monotonic_monotonic_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .acquiring):
      Builtin.cmpxchg_acquire_acquire_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .relaxed):
      Builtin.cmpxchg_acquire_monotonic_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .acquiring):
      Builtin.cmpxchg_acquire_acquire_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .relaxed):
      Builtin.cmpxchg_release_monotonic_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .relaxed):
      Builtin.cmpxchg_acqrel_monotonic_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .relaxed):
      Builtin.cmpxchg_seqcst_monotonic_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .acquiring):
      Builtin.cmpxchg_seqcst_acquire_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawAddress,
        expected,
        desired
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      exchanged: Bool(won),
      original: Value.decodeAtomicRepresentation(Value.AtomicRepresentation(ov))
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic8BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func weakCompareExchange(expected: consuming Value, desired: consuming Value, ordering: Synchronization.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    weakCompareExchange(
      expected: expected,
      desired: desired,
      successOrdering: ordering,
      failureOrdering: ._failureOrdering(for: ordering)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic8BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func weakCompareExchange(expected: consuming Value, desired: consuming Value, successOrdering: Synchronization.AtomicUpdateOrdering, failureOrdering: Synchronization.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    let expected = Value.encodeAtomicRepresentation(expected)._storage
    let desired = Value.encodeAtomicRepresentation(desired)._storage

    let (ov, won) = switch (successOrdering, failureOrdering) {
 
    case (.relaxed, .relaxed):
      Builtin.cmpxchg_monotonic_monotonic_weak_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .acquiring):
      Builtin.cmpxchg_acquire_acquire_weak_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .relaxed):
      Builtin.cmpxchg_acquire_monotonic_weak_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .acquiring):
      Builtin.cmpxchg_acquire_acquire_weak_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .relaxed):
      Builtin.cmpxchg_release_monotonic_weak_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_weak_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .relaxed):
      Builtin.cmpxchg_acqrel_monotonic_weak_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_weak_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .relaxed):
      Builtin.cmpxchg_seqcst_monotonic_weak_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .acquiring):
      Builtin.cmpxchg_seqcst_acquire_weak_Int8(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int8(
        _rawAddress,
        expected,
        desired
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      exchanged: Bool(won),
      original: Value.decodeAtomicRepresentation(Value.AtomicRepresentation(ov))
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@frozen @_alignment(2) public struct _Atomic16BitStorage {
  public var _storage: Builtin.Int16
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public init(_ _builtin: Builtin.Int16) {
    self._storage = _builtin
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic16BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func load(ordering: Synchronization.AtomicLoadOrdering) -> Value {
    let result = switch ordering {
 
    case .relaxed:
      Builtin.atomicload_monotonic_Int16(_rawAddress)
 
    case .acquiring:
      Builtin.atomicload_acquire_Int16(_rawAddress)
 
    case .sequentiallyConsistent:
      Builtin.atomicload_seqcst_Int16(_rawAddress)
 

    default:
      Builtin.unreachable()
    }

    return Value.decodeAtomicRepresentation(Value.AtomicRepresentation(result))
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic16BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func store(_ desired: consuming Value, ordering: Synchronization.AtomicStoreOrdering) {
    switch ordering {
 
    case .relaxed:
      Builtin.atomicstore_monotonic_Int16(
        _rawAddress,
        Value.encodeAtomicRepresentation(desired)._storage
      )
 
    case .releasing:
      Builtin.atomicstore_release_Int16(
        _rawAddress,
        Value.encodeAtomicRepresentation(desired)._storage
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicstore_seqcst_Int16(
        _rawAddress,
        Value.encodeAtomicRepresentation(desired)._storage
      )
 

    default:
      Builtin.unreachable()
    }
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic16BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func exchange(_ desired: consuming Value, ordering: Synchronization.AtomicUpdateOrdering) -> Value {
    let desired = Value.encodeAtomicRepresentation(desired)._storage

    let result = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_xchg_monotonic_Int16(_rawAddress, desired)
 
    case .acquiring:
      Builtin.atomicrmw_xchg_acquire_Int16(_rawAddress, desired)
 
    case .releasing:
      Builtin.atomicrmw_xchg_release_Int16(_rawAddress, desired)
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_xchg_acqrel_Int16(_rawAddress, desired)
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_xchg_seqcst_Int16(_rawAddress, desired)
 

    default:
      Builtin.unreachable()
    }

    let atomicStorage = Value.AtomicRepresentation(result)

    return Value.decodeAtomicRepresentation(atomicStorage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic16BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func compareExchange(expected: consuming Value, desired: consuming Value, ordering: Synchronization.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    compareExchange(
      expected: expected,
      desired: desired,
      successOrdering: ordering,
      failureOrdering: ._failureOrdering(for: ordering)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic16BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func compareExchange(expected: consuming Value, desired: consuming Value, successOrdering: Synchronization.AtomicUpdateOrdering, failureOrdering: Synchronization.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    let expected = Value.encodeAtomicRepresentation(expected)._storage
    let desired = Value.encodeAtomicRepresentation(desired)._storage

    let (ov, won) = switch (successOrdering, failureOrdering) {
 
    case (.relaxed, .relaxed):
      Builtin.cmpxchg_monotonic_monotonic_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .acquiring):
      Builtin.cmpxchg_acquire_acquire_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .relaxed):
      Builtin.cmpxchg_acquire_monotonic_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .acquiring):
      Builtin.cmpxchg_acquire_acquire_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .relaxed):
      Builtin.cmpxchg_release_monotonic_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .relaxed):
      Builtin.cmpxchg_acqrel_monotonic_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .relaxed):
      Builtin.cmpxchg_seqcst_monotonic_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .acquiring):
      Builtin.cmpxchg_seqcst_acquire_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawAddress,
        expected,
        desired
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      exchanged: Bool(won),
      original: Value.decodeAtomicRepresentation(Value.AtomicRepresentation(ov))
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic16BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func weakCompareExchange(expected: consuming Value, desired: consuming Value, ordering: Synchronization.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    weakCompareExchange(
      expected: expected,
      desired: desired,
      successOrdering: ordering,
      failureOrdering: ._failureOrdering(for: ordering)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic16BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func weakCompareExchange(expected: consuming Value, desired: consuming Value, successOrdering: Synchronization.AtomicUpdateOrdering, failureOrdering: Synchronization.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    let expected = Value.encodeAtomicRepresentation(expected)._storage
    let desired = Value.encodeAtomicRepresentation(desired)._storage

    let (ov, won) = switch (successOrdering, failureOrdering) {
 
    case (.relaxed, .relaxed):
      Builtin.cmpxchg_monotonic_monotonic_weak_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .acquiring):
      Builtin.cmpxchg_acquire_acquire_weak_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .relaxed):
      Builtin.cmpxchg_acquire_monotonic_weak_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .acquiring):
      Builtin.cmpxchg_acquire_acquire_weak_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .relaxed):
      Builtin.cmpxchg_release_monotonic_weak_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_weak_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .relaxed):
      Builtin.cmpxchg_acqrel_monotonic_weak_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_weak_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .relaxed):
      Builtin.cmpxchg_seqcst_monotonic_weak_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .acquiring):
      Builtin.cmpxchg_seqcst_acquire_weak_Int16(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int16(
        _rawAddress,
        expected,
        desired
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      exchanged: Bool(won),
      original: Value.decodeAtomicRepresentation(Value.AtomicRepresentation(ov))
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@frozen @_alignment(4) public struct _Atomic32BitStorage {
  public var _storage: Builtin.Int32
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public init(_ _builtin: Builtin.Int32) {
    self._storage = _builtin
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic32BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func load(ordering: Synchronization.AtomicLoadOrdering) -> Value {
    let result = switch ordering {
 
    case .relaxed:
      Builtin.atomicload_monotonic_Int32(_rawAddress)
 
    case .acquiring:
      Builtin.atomicload_acquire_Int32(_rawAddress)
 
    case .sequentiallyConsistent:
      Builtin.atomicload_seqcst_Int32(_rawAddress)
 

    default:
      Builtin.unreachable()
    }

    return Value.decodeAtomicRepresentation(Value.AtomicRepresentation(result))
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic32BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func store(_ desired: consuming Value, ordering: Synchronization.AtomicStoreOrdering) {
    switch ordering {
 
    case .relaxed:
      Builtin.atomicstore_monotonic_Int32(
        _rawAddress,
        Value.encodeAtomicRepresentation(desired)._storage
      )
 
    case .releasing:
      Builtin.atomicstore_release_Int32(
        _rawAddress,
        Value.encodeAtomicRepresentation(desired)._storage
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicstore_seqcst_Int32(
        _rawAddress,
        Value.encodeAtomicRepresentation(desired)._storage
      )
 

    default:
      Builtin.unreachable()
    }
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic32BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func exchange(_ desired: consuming Value, ordering: Synchronization.AtomicUpdateOrdering) -> Value {
    let desired = Value.encodeAtomicRepresentation(desired)._storage

    let result = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_xchg_monotonic_Int32(_rawAddress, desired)
 
    case .acquiring:
      Builtin.atomicrmw_xchg_acquire_Int32(_rawAddress, desired)
 
    case .releasing:
      Builtin.atomicrmw_xchg_release_Int32(_rawAddress, desired)
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_xchg_acqrel_Int32(_rawAddress, desired)
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_xchg_seqcst_Int32(_rawAddress, desired)
 

    default:
      Builtin.unreachable()
    }

    let atomicStorage = Value.AtomicRepresentation(result)

    return Value.decodeAtomicRepresentation(atomicStorage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic32BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func compareExchange(expected: consuming Value, desired: consuming Value, ordering: Synchronization.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    compareExchange(
      expected: expected,
      desired: desired,
      successOrdering: ordering,
      failureOrdering: ._failureOrdering(for: ordering)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic32BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func compareExchange(expected: consuming Value, desired: consuming Value, successOrdering: Synchronization.AtomicUpdateOrdering, failureOrdering: Synchronization.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    let expected = Value.encodeAtomicRepresentation(expected)._storage
    let desired = Value.encodeAtomicRepresentation(desired)._storage

    let (ov, won) = switch (successOrdering, failureOrdering) {
 
    case (.relaxed, .relaxed):
      Builtin.cmpxchg_monotonic_monotonic_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .acquiring):
      Builtin.cmpxchg_acquire_acquire_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .relaxed):
      Builtin.cmpxchg_acquire_monotonic_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .acquiring):
      Builtin.cmpxchg_acquire_acquire_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .relaxed):
      Builtin.cmpxchg_release_monotonic_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .relaxed):
      Builtin.cmpxchg_acqrel_monotonic_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .relaxed):
      Builtin.cmpxchg_seqcst_monotonic_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .acquiring):
      Builtin.cmpxchg_seqcst_acquire_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawAddress,
        expected,
        desired
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      exchanged: Bool(won),
      original: Value.decodeAtomicRepresentation(Value.AtomicRepresentation(ov))
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic32BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func weakCompareExchange(expected: consuming Value, desired: consuming Value, ordering: Synchronization.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    weakCompareExchange(
      expected: expected,
      desired: desired,
      successOrdering: ordering,
      failureOrdering: ._failureOrdering(for: ordering)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic32BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func weakCompareExchange(expected: consuming Value, desired: consuming Value, successOrdering: Synchronization.AtomicUpdateOrdering, failureOrdering: Synchronization.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    let expected = Value.encodeAtomicRepresentation(expected)._storage
    let desired = Value.encodeAtomicRepresentation(desired)._storage

    let (ov, won) = switch (successOrdering, failureOrdering) {
 
    case (.relaxed, .relaxed):
      Builtin.cmpxchg_monotonic_monotonic_weak_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .acquiring):
      Builtin.cmpxchg_acquire_acquire_weak_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .relaxed):
      Builtin.cmpxchg_acquire_monotonic_weak_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .acquiring):
      Builtin.cmpxchg_acquire_acquire_weak_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .relaxed):
      Builtin.cmpxchg_release_monotonic_weak_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_weak_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .relaxed):
      Builtin.cmpxchg_acqrel_monotonic_weak_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_weak_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .relaxed):
      Builtin.cmpxchg_seqcst_monotonic_weak_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .acquiring):
      Builtin.cmpxchg_seqcst_acquire_weak_Int32(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int32(
        _rawAddress,
        expected,
        desired
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      exchanged: Bool(won),
      original: Value.decodeAtomicRepresentation(Value.AtomicRepresentation(ov))
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@frozen @_alignment(8) public struct _Atomic64BitStorage {
  public var _storage: Builtin.Int64
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public init(_ _builtin: Builtin.Int64) {
    self._storage = _builtin
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic64BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func load(ordering: Synchronization.AtomicLoadOrdering) -> Value {
    let result = switch ordering {
 
    case .relaxed:
      Builtin.atomicload_monotonic_Int64(_rawAddress)
 
    case .acquiring:
      Builtin.atomicload_acquire_Int64(_rawAddress)
 
    case .sequentiallyConsistent:
      Builtin.atomicload_seqcst_Int64(_rawAddress)
 

    default:
      Builtin.unreachable()
    }

    return Value.decodeAtomicRepresentation(Value.AtomicRepresentation(result))
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic64BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func store(_ desired: consuming Value, ordering: Synchronization.AtomicStoreOrdering) {
    switch ordering {
 
    case .relaxed:
      Builtin.atomicstore_monotonic_Int64(
        _rawAddress,
        Value.encodeAtomicRepresentation(desired)._storage
      )
 
    case .releasing:
      Builtin.atomicstore_release_Int64(
        _rawAddress,
        Value.encodeAtomicRepresentation(desired)._storage
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicstore_seqcst_Int64(
        _rawAddress,
        Value.encodeAtomicRepresentation(desired)._storage
      )
 

    default:
      Builtin.unreachable()
    }
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic64BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func exchange(_ desired: consuming Value, ordering: Synchronization.AtomicUpdateOrdering) -> Value {
    let desired = Value.encodeAtomicRepresentation(desired)._storage

    let result = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_xchg_monotonic_Int64(_rawAddress, desired)
 
    case .acquiring:
      Builtin.atomicrmw_xchg_acquire_Int64(_rawAddress, desired)
 
    case .releasing:
      Builtin.atomicrmw_xchg_release_Int64(_rawAddress, desired)
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_xchg_acqrel_Int64(_rawAddress, desired)
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_xchg_seqcst_Int64(_rawAddress, desired)
 

    default:
      Builtin.unreachable()
    }

    let atomicStorage = Value.AtomicRepresentation(result)

    return Value.decodeAtomicRepresentation(atomicStorage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic64BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func compareExchange(expected: consuming Value, desired: consuming Value, ordering: Synchronization.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    compareExchange(
      expected: expected,
      desired: desired,
      successOrdering: ordering,
      failureOrdering: ._failureOrdering(for: ordering)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic64BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func compareExchange(expected: consuming Value, desired: consuming Value, successOrdering: Synchronization.AtomicUpdateOrdering, failureOrdering: Synchronization.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    let expected = Value.encodeAtomicRepresentation(expected)._storage
    let desired = Value.encodeAtomicRepresentation(desired)._storage

    let (ov, won) = switch (successOrdering, failureOrdering) {
 
    case (.relaxed, .relaxed):
      Builtin.cmpxchg_monotonic_monotonic_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .acquiring):
      Builtin.cmpxchg_acquire_acquire_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .relaxed):
      Builtin.cmpxchg_acquire_monotonic_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .acquiring):
      Builtin.cmpxchg_acquire_acquire_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .relaxed):
      Builtin.cmpxchg_release_monotonic_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .relaxed):
      Builtin.cmpxchg_acqrel_monotonic_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .relaxed):
      Builtin.cmpxchg_seqcst_monotonic_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .acquiring):
      Builtin.cmpxchg_seqcst_acquire_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawAddress,
        expected,
        desired
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      exchanged: Bool(won),
      original: Value.decodeAtomicRepresentation(Value.AtomicRepresentation(ov))
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic64BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func weakCompareExchange(expected: consuming Value, desired: consuming Value, ordering: Synchronization.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    weakCompareExchange(
      expected: expected,
      desired: desired,
      successOrdering: ordering,
      failureOrdering: ._failureOrdering(for: ordering)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic64BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func weakCompareExchange(expected: consuming Value, desired: consuming Value, successOrdering: Synchronization.AtomicUpdateOrdering, failureOrdering: Synchronization.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    let expected = Value.encodeAtomicRepresentation(expected)._storage
    let desired = Value.encodeAtomicRepresentation(desired)._storage

    let (ov, won) = switch (successOrdering, failureOrdering) {
 
    case (.relaxed, .relaxed):
      Builtin.cmpxchg_monotonic_monotonic_weak_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .acquiring):
      Builtin.cmpxchg_acquire_acquire_weak_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .relaxed):
      Builtin.cmpxchg_acquire_monotonic_weak_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .acquiring):
      Builtin.cmpxchg_acquire_acquire_weak_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .relaxed):
      Builtin.cmpxchg_release_monotonic_weak_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_weak_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .relaxed):
      Builtin.cmpxchg_acqrel_monotonic_weak_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_weak_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .relaxed):
      Builtin.cmpxchg_seqcst_monotonic_weak_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .acquiring):
      Builtin.cmpxchg_seqcst_acquire_weak_Int64(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int64(
        _rawAddress,
        expected,
        desired
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      exchanged: Bool(won),
      original: Value.decodeAtomicRepresentation(Value.AtomicRepresentation(ov))
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
@frozen @_alignment(16) public struct _Atomic128BitStorage {
  public var _storage: Builtin.Int128
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_alwaysEmitIntoClient @_transparent public init(_ _builtin: Builtin.Int128) {
    self._storage = _builtin
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic128BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func load(ordering: Synchronization.AtomicLoadOrdering) -> Value {
    let result = switch ordering {
 
    case .relaxed:
      Builtin.atomicload_monotonic_Int128(_rawAddress)
 
    case .acquiring:
      Builtin.atomicload_acquire_Int128(_rawAddress)
 
    case .sequentiallyConsistent:
      Builtin.atomicload_seqcst_Int128(_rawAddress)
 

    default:
      Builtin.unreachable()
    }

    return Value.decodeAtomicRepresentation(Value.AtomicRepresentation(result))
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic128BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func store(_ desired: consuming Value, ordering: Synchronization.AtomicStoreOrdering) {
    switch ordering {
 
    case .relaxed:
      Builtin.atomicstore_monotonic_Int128(
        _rawAddress,
        Value.encodeAtomicRepresentation(desired)._storage
      )
 
    case .releasing:
      Builtin.atomicstore_release_Int128(
        _rawAddress,
        Value.encodeAtomicRepresentation(desired)._storage
      )
 
    case .sequentiallyConsistent:
      Builtin.atomicstore_seqcst_Int128(
        _rawAddress,
        Value.encodeAtomicRepresentation(desired)._storage
      )
 

    default:
      Builtin.unreachable()
    }
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic128BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func exchange(_ desired: consuming Value, ordering: Synchronization.AtomicUpdateOrdering) -> Value {
    let desired = Value.encodeAtomicRepresentation(desired)._storage

    let result = switch ordering {
 
    case .relaxed:
      Builtin.atomicrmw_xchg_monotonic_Int128(_rawAddress, desired)
 
    case .acquiring:
      Builtin.atomicrmw_xchg_acquire_Int128(_rawAddress, desired)
 
    case .releasing:
      Builtin.atomicrmw_xchg_release_Int128(_rawAddress, desired)
 
    case .acquiringAndReleasing:
      Builtin.atomicrmw_xchg_acqrel_Int128(_rawAddress, desired)
 
    case .sequentiallyConsistent:
      Builtin.atomicrmw_xchg_seqcst_Int128(_rawAddress, desired)
 

    default:
      Builtin.unreachable()
    }

    let atomicStorage = Value.AtomicRepresentation(result)

    return Value.decodeAtomicRepresentation(atomicStorage)
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic128BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func compareExchange(expected: consuming Value, desired: consuming Value, ordering: Synchronization.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    compareExchange(
      expected: expected,
      desired: desired,
      successOrdering: ordering,
      failureOrdering: ._failureOrdering(for: ordering)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic128BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func compareExchange(expected: consuming Value, desired: consuming Value, successOrdering: Synchronization.AtomicUpdateOrdering, failureOrdering: Synchronization.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    let expected = Value.encodeAtomicRepresentation(expected)._storage
    let desired = Value.encodeAtomicRepresentation(desired)._storage

    let (ov, won) = switch (successOrdering, failureOrdering) {
 
    case (.relaxed, .relaxed):
      Builtin.cmpxchg_monotonic_monotonic_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .acquiring):
      Builtin.cmpxchg_acquire_acquire_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .relaxed):
      Builtin.cmpxchg_acquire_monotonic_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .acquiring):
      Builtin.cmpxchg_acquire_acquire_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .relaxed):
      Builtin.cmpxchg_release_monotonic_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .relaxed):
      Builtin.cmpxchg_acqrel_monotonic_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .relaxed):
      Builtin.cmpxchg_seqcst_monotonic_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .acquiring):
      Builtin.cmpxchg_seqcst_acquire_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawAddress,
        expected,
        desired
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      exchanged: Bool(won),
      original: Value.decodeAtomicRepresentation(Value.AtomicRepresentation(ov))
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic128BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func weakCompareExchange(expected: consuming Value, desired: consuming Value, ordering: Synchronization.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    weakCompareExchange(
      expected: expected,
      desired: desired,
      successOrdering: ordering,
      failureOrdering: ._failureOrdering(for: ordering)
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.Atomic where Value.AtomicRepresentation == Synchronization._Atomic128BitStorage {
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent public func weakCompareExchange(expected: consuming Value, desired: consuming Value, successOrdering: Synchronization.AtomicUpdateOrdering, failureOrdering: Synchronization.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    let expected = Value.encodeAtomicRepresentation(expected)._storage
    let desired = Value.encodeAtomicRepresentation(desired)._storage

    let (ov, won) = switch (successOrdering, failureOrdering) {
 
    case (.relaxed, .relaxed):
      Builtin.cmpxchg_monotonic_monotonic_weak_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .acquiring):
      Builtin.cmpxchg_acquire_acquire_weak_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.relaxed, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .relaxed):
      Builtin.cmpxchg_acquire_monotonic_weak_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .acquiring):
      Builtin.cmpxchg_acquire_acquire_weak_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiring, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .relaxed):
      Builtin.cmpxchg_release_monotonic_weak_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_weak_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.releasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .relaxed):
      Builtin.cmpxchg_acqrel_monotonic_weak_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .acquiring):
      Builtin.cmpxchg_acqrel_acquire_weak_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .relaxed):
      Builtin.cmpxchg_seqcst_monotonic_weak_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .acquiring):
      Builtin.cmpxchg_seqcst_acquire_weak_Int128(
        _rawAddress,
        expected,
        desired
      )
 
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      Builtin.cmpxchg_seqcst_seqcst_weak_Int128(
        _rawAddress,
        expected,
        desired
      )
 

    default:
      Builtin.unreachable()
    }

    return (
      exchanged: Bool(won),
      original: Value.decodeAtomicRepresentation(Value.AtomicRepresentation(ov))
    )
  }
}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicLoadOrdering : Swift.Sendable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicLoadOrdering : Swift.BitwiseCopyable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicStoreOrdering : Swift.Sendable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicStoreOrdering : Swift.BitwiseCopyable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicUpdateOrdering : Swift.Sendable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.AtomicUpdateOrdering : Swift.BitwiseCopyable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization.WordPair : Swift.BitwiseCopyable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization._Atomic8BitStorage : Swift.BitwiseCopyable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization._Atomic8BitStorage : Swift.Sendable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization._Atomic16BitStorage : Swift.BitwiseCopyable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization._Atomic16BitStorage : Swift.Sendable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization._Atomic32BitStorage : Swift.BitwiseCopyable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization._Atomic32BitStorage : Swift.Sendable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization._Atomic64BitStorage : Swift.BitwiseCopyable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization._Atomic64BitStorage : Swift.Sendable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization._Atomic128BitStorage : Swift.BitwiseCopyable {}
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Synchronization._Atomic128BitStorage : Swift.Sendable {}
